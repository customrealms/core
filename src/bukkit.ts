export {};

import './java';

type Modify<T, R> = Omit<T, keyof R> & R;

declare global {
	namespace org.bukkit.entity {
		interface AbstractArrow extends Modify<org.bukkit.entity.Projectile, {
			/**
			 * Gets the knockback strength for an arrow, which is the
			 * KnockBack level
			 * of the bow that shot it.
			 */
			getKnockbackStrength(): number;

			/**
			 * Sets the knockback strength for an arrow.
			 */
			setKnockbackStrength(knockbackStrength: number): void;

			/**
			 * Gets the base amount of damage this arrow will do.
			 * Defaults to 2.0 for a normal arrow with
			 * 0.5 * (1 + power level) added for arrows fired from
			 * enchanted bows.
			 */
			getDamage(): number;

			/**
			 * Sets the base amount of damage this arrow will do.
			 */
			setDamage(damage: number): void;

			/**
			 * Gets the number of times this arrow can pierce through an entity.
			 */
			getPierceLevel(): number;

			/**
			 * Sets the number of times this arrow can pierce through an entity.
			 * Must be between 0 and 127 times.
			 */
			setPierceLevel(pierceLevel: number): void;

			/**
			 * Gets whether this arrow is critical.
			 * 
			 * Critical arrows have increased damage and cause particle effects.
			 * 
			 * Critical arrows generally occur when a player fully draws a bow before
			 * firing.
			 */
			isCritical(): boolean;

			/**
			 * Sets whether or not this arrow should be critical.
			 */
			setCritical(critical: boolean): void;

			/**
			 * Gets whether this arrow is in a block or not.
			 * 
			 * Arrows in a block are motionless and may be picked up by players.
			 */
			isInBlock(): boolean;

			/**
			 * Gets the block to which this arrow is attached.
			 */
			getAttachedBlock(): (org.bukkit.block.Block | null);

			/**
			 * Gets the current pickup status of this arrow.
			 */
			getPickupStatus(): org.bukkit.entity.AbstractArrow.PickupStatus;

			/**
			 * Sets the current pickup status of this arrow.
			 */
			setPickupStatus(status: org.bukkit.entity.AbstractArrow.PickupStatus): void;

			/**
			 * Gets if this arrow was shot from a crossbow.
			 */
			isShotFromCrossbow(): boolean;

			/**
			 * Sets if this arrow was shot from a crossbow.
			 */
			setShotFromCrossbow(shotFromCrossbow: boolean): void;

			/**
			 * Gets the ItemStack which will be picked up from this arrow.
			 */
			getItem(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the ItemStack which will be picked up from this arrow.
			 */
			setItem(item: org.bukkit.inventory.ItemStack): void;

			/**
			 * Gets the ItemStack which fired this arrow.
			 */
			getWeapon(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the ItemStack which fired this arrow.
			 */
			setWeapon(item: org.bukkit.inventory.ItemStack): void;

		}> {}
		namespace AbstractArrow {
			interface PickupStatus {}
			namespace PickupStatus {
				/**
				 * The arrow cannot be picked up.
				 */
				const DISALLOWED: org.bukkit.entity.AbstractArrow.PickupStatus;

				/**
				 * The arrow can be picked up.
				 */
				const ALLOWED: org.bukkit.entity.AbstractArrow.PickupStatus;

				/**
				 * The arrow can only be picked up by players in creative mode.
				 */
				const CREATIVE_ONLY: org.bukkit.entity.AbstractArrow.PickupStatus;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.AbstractArrow.PickupStatus;

			}
		}
		interface AbstractHorse extends Modify<org.bukkit.entity.Vehicle & org.bukkit.inventory.InventoryHolder & org.bukkit.entity.Tameable, {
			/**
			 * Gets the horse's variant.
			 * 
			 * A horse's variant defines its physical appearance and capabilities.
			 * Whether a horse is a regular horse, donkey, mule, or other kind of horse
			 * is determined using the variant.
			 */
			getVariant(): org.bukkit.entity.Horse.Variant;

			setVariant(variant: org.bukkit.entity.Horse.Variant): void;

			/**
			 * Gets the domestication level of this horse.
			 * 
			 * A higher domestication level indicates that the horse is closer to
			 * becoming tame. As the domestication level gets closer to the max
			 * domestication level, the chance of the horse becoming tame increases.
			 */
			getDomestication(): number;

			/**
			 * Sets the domestication level of this horse.
			 * 
			 * Setting the domestication level to a high value will increase the
			 * horse's chances of becoming tame.
			 * 
			 * Domestication level must be greater than zero and no greater than
			 * the max domestication level of the horse, determined with
			 * getMaxDomestication()
			 */
			setDomestication(level: number): void;

			/**
			 * Gets the maximum domestication level of this horse.
			 * 
			 * The higher this level is, the longer it will likely take
			 * for the horse to be tamed.
			 */
			getMaxDomestication(): number;

			/**
			 * Sets the maximum domestication level of this horse.
			 * 
			 * Setting a higher max domestication will increase the amount of
			 * domesticating (feeding, riding, etc.) necessary in order to tame it,
			 * while setting a lower max value will have the opposite effect.
			 * 
			 * Maximum domestication must be greater than zero.
			 */
			setMaxDomestication(level: number): void;

			/**
			 * Gets the jump strength of this horse.
			 * 
			 * Jump strength defines how high the horse can jump. A higher jump strength
			 * increases how high a jump will go.
			 */
			getJumpStrength(): number;

			/**
			 * Sets the jump strength of this horse.
			 * 
			 * A higher jump strength increases how high a jump will go.
			 * Setting a jump strength to 0 will result in no jump.
			 * You cannot set a jump strength to a value below 0 or
			 * above 2.
			 */
			setJumpStrength(strength: number): void;

			/**
			 * Gets whether the horse is currently grazing hay.
			 */
			isEatingHaystack(): boolean;

			/**
			 * Sets whether the horse is grazing hay.
			 */
			setEatingHaystack(eatingHaystack: boolean): void;

			/**
			 * Description copied from interface:Â InventoryHolder
			 */
			getInventory(): org.bukkit.inventory.AbstractHorseInventory;

		}> {}
		interface AbstractSkeleton extends Modify<org.bukkit.entity.Monster, {
			/**
			 * Gets the current type of this skeleton.
			 */
			getSkeletonType(): org.bukkit.entity.Skeleton.SkeletonType;

			setSkeletonType(type: org.bukkit.entity.Skeleton.SkeletonType): void;

		}> {}
		interface AbstractVillager extends Modify<org.bukkit.entity.Breedable & org.bukkit.entity.NPC & org.bukkit.inventory.InventoryHolder & org.bukkit.inventory.Merchant, {
			/**
			 * Gets this villager's inventory.
			 * 
			 * Note that this inventory is not the Merchant inventory, rather, it is the
			 * items that a villager might have collected (from harvesting crops, etc.)
			 * Get the object's inventory.
			 */
			getInventory(): org.bukkit.inventory.Inventory;

		}> {}
		interface AbstractWindCharge extends Modify<org.bukkit.entity.Fireball, {
			/**
			 * Immediately explode this WindCharge.
			 */
			explode(): void;

		}> {}
		interface Ageable extends Modify<org.bukkit.entity.Creature, {
			/**
			 * Gets the age of this mob.
			 */
			getAge(): number;

			/**
			 * Sets the age of this mob.
			 */
			setAge(age: number): void;

			/**
			 * Lock the age of the animal, setting this will prevent the animal from
			 * maturing or getting ready for mating.
			 */
			setAgeLock(lock: boolean): void;

			/**
			 * Gets the current agelock.
			 */
			getAgeLock(): boolean;

			/**
			 * Sets the age of the mob to a baby
			 */
			setBaby(): void;

			/**
			 * Sets the age of the mob to an adult
			 */
			setAdult(): void;

			/**
			 * Returns true if the mob is an adult.
			 */
			isAdult(): boolean;

			/**
			 * Return the ability to breed of the animal.
			 */
			canBreed(): boolean;

			/**
			 * Set breedability of the animal, if the animal is a baby and set to
			 * breed it will instantly grow up.
			 */
			setBreed(breed: boolean): void;

		}> {}
		interface Allay extends Modify<org.bukkit.entity.Creature & org.bukkit.inventory.InventoryHolder, {
			/**
			 * Gets if the allay can duplicate.
			 * 
			 * Note: Duplication is based when the
			 * getDuplicationCooldown() its lower than zero.
			 */
			canDuplicate(): boolean;

			/**
			 * Sets if the allay can duplicate.
			 * 
			 * Note: this value can be overridden later by
			 * getDuplicationCooldown() if is lower than zero. You can also use
			 * setDuplicationCooldown(long) to allow the allay to duplicate
			 */
			setCanDuplicate(canDuplicate: boolean): void;

			/**
			 * Gets the cooldown for duplicating the allay.
			 */
			getDuplicationCooldown(): number;

			/**
			 * Sets the cooldown before the allay can duplicate again.
			 */
			setDuplicationCooldown(cooldown: number): void;

			/**
			 * Reset the cooldown for duplication.
			 * This will set the cooldown ticks to the same value as is set after an
			 * Allay has duplicated.
			 */
			resetDuplicationCooldown(): void;

			/**
			 * Gets if the allay is dancing.
			 */
			isDancing(): boolean;

			/**
			 * Causes the allay to start dancing because of the provided jukebox
			 * location.
			 */
			startDancing(location: org.bukkit.Location): void;

			/**
			 * Force sets the dancing status of the allay.
			 * 
			 * Note: This method forces the allay to dance, ignoring any nearby
			 * jukebox being required.
			 */
			startDancing(): void;

			/**
			 * Makes the allay stop dancing.
			 */
			stopDancing(): void;

			/**
			 * This make the current allay duplicate itself without dance or item
			 * necessary.
			 * Note: this will fire a CreatureSpawnEvent
			 */
			duplicateAllay(): (org.bukkit.entity.Allay | null);

			/**
			 * Gets the jukebox the allay is set to dance to.
			 */
			getJukebox(): (org.bukkit.Location | null);

		}> {}
		interface Ambient extends Modify<org.bukkit.entity.Mob, {}> {}
		interface AnimalTamer {
			/**
			 * This is the name of the specified AnimalTamer.
			 */
			getName(): (string | null);

			/**
			 * This is the UUID of the specified AnimalTamer.
			 */
			getUniqueId(): globalThis.java.util.UUID;

		}
		interface Animals extends Modify<org.bukkit.entity.Breedable, {
			/**
			 * Get the UUID of the entity that caused this entity to enter the
			 * Breedable.canBreed() state.
			 */
			getBreedCause(): (globalThis.java.util.UUID | null);

			/**
			 * Set the UUID of the entity that caused this entity to enter the
			 * Breedable.canBreed() state.
			 */
			setBreedCause(uuid: (globalThis.java.util.UUID | null)): void;

			/**
			 * Get whether or not this entity is in love mode and will produce
			 * offspring with another entity in love mode. Will return true if
			 * and only if getLoveModeTicks() is greater than 0.
			 */
			isLoveMode(): boolean;

			/**
			 * Get the amount of ticks remaining for this entity in love mode.
			 * If the entity is not in love mode, 0 will be returned.
			 */
			getLoveModeTicks(): number;

			/**
			 * Set the amount of ticks for which this entity should be in love mode.
			 * Setting the love mode ticks to 600 is the equivalent of a player
			 * feeding the entity their breeding item of choice.
			 */
			setLoveModeTicks(ticks: number): void;

			/**
			 * Check if the provided ItemStack is the correct item used for breeding
			 * this entity.
			 */
			isBreedItem(stack: org.bukkit.inventory.ItemStack): boolean;

			/**
			 * Check if the provided ItemStack is the correct item used for breeding
			 * this entity..
			 */
			isBreedItem(material: org.bukkit.Material): boolean;

		}> {}
		interface AreaEffectCloud extends Modify<org.bukkit.entity.Entity, {
			/**
			 * Gets the duration which this cloud will exist for (in ticks).
			 */
			getDuration(): number;

			/**
			 * Sets the duration which this cloud will exist for (in ticks).
			 */
			setDuration(duration: number): void;

			/**
			 * Gets the time which an entity has to be exposed to the cloud before the
			 * effect is applied.
			 */
			getWaitTime(): number;

			/**
			 * Sets the time which an entity has to be exposed to the cloud before the
			 * effect is applied.
			 */
			setWaitTime(waitTime: number): void;

			/**
			 * Gets the time that an entity will be immune from subsequent exposure.
			 */
			getReapplicationDelay(): number;

			/**
			 * Sets the time that an entity will be immune from subsequent exposure.
			 */
			setReapplicationDelay(delay: number): void;

			/**
			 * Gets the amount that the duration of this cloud will decrease by when it
			 * applies an effect to an entity.
			 */
			getDurationOnUse(): number;

			/**
			 * Sets the amount that the duration of this cloud will decrease by when it
			 * applies an effect to an entity.
			 */
			setDurationOnUse(duration: number): void;

			/**
			 * Gets the initial radius of the cloud.
			 */
			getRadius(): number;

			/**
			 * Sets the initial radius of the cloud.
			 */
			setRadius(radius: number): void;

			/**
			 * Gets the amount that the radius of this cloud will decrease by when it
			 * applies an effect to an entity.
			 */
			getRadiusOnUse(): number;

			/**
			 * Sets the amount that the radius of this cloud will decrease by when it
			 * applies an effect to an entity.
			 */
			setRadiusOnUse(radius: number): void;

			/**
			 * Gets the amount that the radius of this cloud will decrease by each tick.
			 */
			getRadiusPerTick(): number;

			/**
			 * Gets the amount that the radius of this cloud will decrease by each tick.
			 */
			setRadiusPerTick(radius: number): void;

			/**
			 * Gets the particle which this cloud will be composed of
			 */
			getParticle(): org.bukkit.Particle;

			/**
			 * Sets the particle which this cloud will be composed of
			 */
			setParticle(particle: org.bukkit.Particle): void;

			/**
			 * Sets the particle which this cloud will be composed of
			 */
			setParticle<T = any>(particle: org.bukkit.Particle, data: (T | null)): void;

			/**
			 * Sets the underlying potion data
			 */
			setBasePotionData(data: (org.bukkit.potion.PotionData | null)): void;

			/**
			 * Returns the potion data about the base potion
			 */
			getBasePotionData(): (org.bukkit.potion.PotionData | null);

			/**
			 * Sets the underlying potion type
			 */
			setBasePotionType(type: (org.bukkit.potion.PotionType | null)): void;

			/**
			 * Returns the potion type about the base potion
			 */
			getBasePotionType(): (org.bukkit.potion.PotionType | null);

			/**
			 * Checks for the presence of custom potion effects.
			 */
			hasCustomEffects(): boolean;

			/**
			 * Gets an immutable list containing all custom potion effects applied to
			 * this cloud.
			 * 
			 * Plugins should check that hasCustomEffects() returns true before calling
			 * this method.
			 */
			getCustomEffects(): globalThis.java.util.List<org.bukkit.potion.PotionEffect>;

			/**
			 * Adds a custom potion effect to this cloud.
			 */
			addCustomEffect(effect: org.bukkit.potion.PotionEffect, overwrite: boolean): boolean;

			/**
			 * Removes a custom potion effect from this cloud.
			 */
			removeCustomEffect(type: org.bukkit.potion.PotionEffectType): boolean;

			/**
			 * Checks for a specific custom potion effect type on this cloud.
			 */
			hasCustomEffect(type: (org.bukkit.potion.PotionEffectType | null)): boolean;

			/**
			 * Removes all custom potion effects from this cloud.
			 */
			clearCustomEffects(): void;

			/**
			 * Gets the color of this cloud. Will be applied as a tint to its particles.
			 */
			getColor(): org.bukkit.Color;

			/**
			 * Sets the color of this cloud. Will be applied as a tint to its particles.
			 */
			setColor(color: org.bukkit.Color): void;

			/**
			 * Retrieve the original source of this cloud.
			 */
			getSource(): (org.bukkit.projectiles.ProjectileSource | null);

			/**
			 * Set the original source of this cloud.
			 */
			setSource(source: (org.bukkit.projectiles.ProjectileSource | null)): void;

		}> {}
		interface Armadillo extends Modify<org.bukkit.entity.Animals, {}> {}
		interface ArmorStand extends Modify<org.bukkit.entity.LivingEntity, {
			/**
			 * Returns the item the armor stand is currently holding.
			 */
			getItemInHand(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the item the armor stand is currently holding.
			 */
			setItemInHand(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Returns the item currently being worn by the armor stand on its feet.
			 */
			getBoots(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the item currently being worn by the armor stand on its feet.
			 */
			setBoots(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Returns the item currently being worn by the armor stand on its legs.
			 */
			getLeggings(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the item currently being worn by the armor stand on its legs.
			 */
			setLeggings(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Returns the item currently being worn by the armor stand on its chest.
			 */
			getChestplate(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the item currently being worn by the armor stand on its chest.
			 */
			setChestplate(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Returns the item currently being worn by the armor stand on its head.
			 */
			getHelmet(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the item currently being worn by the armor stand on its head.
			 */
			setHelmet(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Returns the armor stand's body's current pose as a
			 * EulerAngle.
			 */
			getBodyPose(): org.bukkit.util.EulerAngle;

			/**
			 * Sets the armor stand's body's current pose as a
			 * EulerAngle.
			 */
			setBodyPose(pose: org.bukkit.util.EulerAngle): void;

			/**
			 * Returns the armor stand's left arm's current pose as a
			 * EulerAngle.
			 */
			getLeftArmPose(): org.bukkit.util.EulerAngle;

			/**
			 * Sets the armor stand's left arm's current pose as a
			 * EulerAngle.
			 */
			setLeftArmPose(pose: org.bukkit.util.EulerAngle): void;

			/**
			 * Returns the armor stand's right arm's current pose as a
			 * EulerAngle.
			 */
			getRightArmPose(): org.bukkit.util.EulerAngle;

			/**
			 * Sets the armor stand's right arm's current pose as a
			 * EulerAngle.
			 */
			setRightArmPose(pose: org.bukkit.util.EulerAngle): void;

			/**
			 * Returns the armor stand's left leg's current pose as a
			 * EulerAngle.
			 */
			getLeftLegPose(): org.bukkit.util.EulerAngle;

			/**
			 * Sets the armor stand's left leg's current pose as a
			 * EulerAngle.
			 */
			setLeftLegPose(pose: org.bukkit.util.EulerAngle): void;

			/**
			 * Returns the armor stand's right leg's current pose as a
			 * EulerAngle.
			 */
			getRightLegPose(): org.bukkit.util.EulerAngle;

			/**
			 * Sets the armor stand's right leg's current pose as a
			 * EulerAngle.
			 */
			setRightLegPose(pose: org.bukkit.util.EulerAngle): void;

			/**
			 * Returns the armor stand's head's current pose as a
			 * EulerAngle.
			 */
			getHeadPose(): org.bukkit.util.EulerAngle;

			/**
			 * Sets the armor stand's head's current pose as a
			 * EulerAngle.
			 */
			setHeadPose(pose: org.bukkit.util.EulerAngle): void;

			/**
			 * Returns whether the armor stand has a base plate.
			 */
			hasBasePlate(): boolean;

			/**
			 * Sets whether the armor stand has a base plate.
			 */
			setBasePlate(basePlate: boolean): void;

			/**
			 * Returns whether the armor stand should be visible or not.
			 */
			isVisible(): boolean;

			/**
			 * Sets whether the armor stand should be visible or not.
			 */
			setVisible(visible: boolean): void;

			/**
			 * Returns whether this armor stand has arms.
			 */
			hasArms(): boolean;

			/**
			 * Sets whether this armor stand has arms.
			 */
			setArms(arms: boolean): void;

			/**
			 * Returns whether this armor stand is scaled down.
			 */
			isSmall(): boolean;

			/**
			 * Sets whether this armor stand is scaled down.
			 */
			setSmall(small: boolean): void;

			/**
			 * Returns whether this armor stand is a marker, meaning it has a very small
			 * collision box.
			 */
			isMarker(): boolean;

			/**
			 * Sets whether this armor stand is a marker, meaning it has a very small
			 * collision box.
			 */
			setMarker(marker: boolean): void;

			/**
			 * Locks the equipment slot with the specified
			 * locking mechanism.
			 */
			addEquipmentLock(slot: org.bukkit.inventory.EquipmentSlot, lockType: org.bukkit.entity.ArmorStand.LockType): void;

			/**
			 * Remove a locking mechanism.
			 */
			removeEquipmentLock(slot: org.bukkit.inventory.EquipmentSlot, lockType: org.bukkit.entity.ArmorStand.LockType): void;

			/**
			 * Returns if the ArmorStand has the specified
			 * locking mechanism.
			 */
			hasEquipmentLock(slot: org.bukkit.inventory.EquipmentSlot, lockType: org.bukkit.entity.ArmorStand.LockType): boolean;

		}> {}
		namespace ArmorStand {
			interface LockType {}
			namespace LockType {
				/**
				 * Prevents adding or changing the respective equipment - players cannot
				 * replace the empty slot with a new item or swap the items between
				 * themselves and the ArmorStand.
				 */
				const ADDING_OR_CHANGING: org.bukkit.entity.ArmorStand.LockType;

				/**
				 * Prevents removing or changing the respective equipment - players
				 * cannot take an item from the slot or swap the items between
				 * themselves and the ArmorStand.
				 */
				const REMOVING_OR_CHANGING: org.bukkit.entity.ArmorStand.LockType;

				/**
				 * Prevents adding the respective equipment - players cannot replace the
				 * empty slot with a new item, but can swap items between themselves and
				 * the ArmorStand.
				 */
				const ADDING: org.bukkit.entity.ArmorStand.LockType;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.ArmorStand.LockType;

			}
		}
		interface Arrow extends Modify<org.bukkit.entity.AbstractArrow, {
			/**
			 * Sets the underlying potion data
			 */
			setBasePotionData(data: (org.bukkit.potion.PotionData | null)): void;

			/**
			 * Returns the potion data about the base potion
			 */
			getBasePotionData(): (org.bukkit.potion.PotionData | null);

			/**
			 * Sets the underlying potion type
			 */
			setBasePotionType(type: (org.bukkit.potion.PotionType | null)): void;

			/**
			 * Returns the potion type about the base potion
			 */
			getBasePotionType(): (org.bukkit.potion.PotionType | null);

			/**
			 * Gets the color of this arrow.
			 */
			getColor(): (org.bukkit.Color | null);

			/**
			 * Sets the color of this arrow. Will be applied as a tint to its particles.
			 */
			setColor(color: (org.bukkit.Color | null)): void;

			/**
			 * Checks for the presence of custom potion effects.
			 */
			hasCustomEffects(): boolean;

			/**
			 * Gets an immutable list containing all custom potion effects applied to
			 * this arrow.
			 * 
			 * Plugins should check that hasCustomEffects() returns true before calling
			 * this method.
			 */
			getCustomEffects(): globalThis.java.util.List<org.bukkit.potion.PotionEffect>;

			/**
			 * Adds a custom potion effect to this arrow.
			 */
			addCustomEffect(effect: org.bukkit.potion.PotionEffect, overwrite: boolean): boolean;

			/**
			 * Removes a custom potion effect from this arrow.
			 */
			removeCustomEffect(type: org.bukkit.potion.PotionEffectType): boolean;

			/**
			 * Checks for a specific custom potion effect type on this arrow.
			 */
			hasCustomEffect(type: (org.bukkit.potion.PotionEffectType | null)): boolean;

			/**
			 * Removes all custom potion effects from this arrow.
			 */
			clearCustomEffects(): void;

		}> {}
		interface Axolotl extends Modify<org.bukkit.entity.Animals, {
			/**
			 * Gets if this axolotl is playing dead.
			 * An axolotl may play dead when it is damaged underwater.
			 */
			isPlayingDead(): boolean;

			/**
			 * Sets if this axolotl is playing dead.
			 * An axolotl may play dead when it is damaged underwater.
			 */
			setPlayingDead(playingDead: boolean): void;

			/**
			 * Get the variant of this axolotl.
			 */
			getVariant(): org.bukkit.entity.Axolotl.Variant;

			/**
			 * Set the variant of this axolotl.
			 */
			setVariant(variant: org.bukkit.entity.Axolotl.Variant): void;

		}> {}
		namespace Axolotl {
			interface Variant {}
			namespace Variant {
				/**
				 * Leucistic (pink) axolotl.
				 */
				const LUCY: org.bukkit.entity.Axolotl.Variant;

				/**
				 * Brown axolotl.
				 */
				const WILD: org.bukkit.entity.Axolotl.Variant;

				/**
				 * Gold axolotl.
				 */
				const GOLD: org.bukkit.entity.Axolotl.Variant;

				/**
				 * Cyan axolotl.
				 */
				const CYAN: org.bukkit.entity.Axolotl.Variant;

				/**
				 * Blue axolotl.
				 */
				const BLUE: org.bukkit.entity.Axolotl.Variant;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Axolotl.Variant;

			}
		}
		interface Bat extends Modify<org.bukkit.entity.Ambient, {
			/**
			 * Checks the current waking state of this bat.
			 * 
			 * This does not imply any persistence of state past the method call.
			 */
			isAwake(): boolean;

			/**
			 * This method modifies the current waking state of this bat.
			 * 
			 * This does not prevent a bat from spontaneously awaking itself, or from
			 * reattaching itself to a block.
			 */
			setAwake(state: boolean): void;

		}> {}
		interface Bee extends Modify<org.bukkit.entity.Animals, {
			/**
			 * Get the bee's hive location.
			 */
			getHive(): (org.bukkit.Location | null);

			/**
			 * Set the bee's hive location.
			 */
			setHive(location: (org.bukkit.Location | null)): void;

			/**
			 * Get the bee's flower location.
			 */
			getFlower(): (org.bukkit.Location | null);

			/**
			 * Set the bee's flower location.
			 */
			setFlower(location: (org.bukkit.Location | null)): void;

			/**
			 * Get if the bee has nectar.
			 */
			hasNectar(): boolean;

			/**
			 * Set if the bee has nectar.
			 */
			setHasNectar(nectar: boolean): void;

			/**
			 * Get if the bee has stung.
			 */
			hasStung(): boolean;

			/**
			 * Set if the bee has stung.
			 */
			setHasStung(stung: boolean): void;

			/**
			 * Get the bee's anger level.
			 */
			getAnger(): number;

			/**
			 * Set the bee's new anger level.
			 */
			setAnger(anger: number): void;

			/**
			 * Get the amount of ticks the bee cannot enter the hive for.
			 */
			getCannotEnterHiveTicks(): number;

			/**
			 * Set the amount of ticks the bee cannot enter a hive for.
			 */
			setCannotEnterHiveTicks(ticks: number): void;

		}> {}
		interface Blaze extends Modify<org.bukkit.entity.Monster, {}> {}
		interface BlockDisplay extends Modify<org.bukkit.entity.Display, {
			/**
			 * Gets the displayed block.
			 */
			getBlock(): org.bukkit.block.data.BlockData;

			/**
			 * Sets the displayed block.
			 */
			setBlock(block: org.bukkit.block.data.BlockData): void;

		}> {}
		interface Boat extends Modify<org.bukkit.entity.Vehicle, {
			/**
			 * Gets the wood type of the boat.
			 */
			getWoodType(): org.bukkit.TreeSpecies;

			/**
			 * Sets the wood type of the boat.
			 */
			setWoodType(species: org.bukkit.TreeSpecies): void;

			/**
			 * Gets the type of the boat.
			 */
			getBoatType(): org.bukkit.entity.Boat.Type;

			/**
			 * Sets the type of the boat.
			 */
			setBoatType(type: org.bukkit.entity.Boat.Type): void;

			/**
			 * Gets the maximum speed of a boat. The speed is unrelated to the
			 * velocity.
			 */
			getMaxSpeed(): number;

			/**
			 * Sets the maximum speed of a boat. Must be nonnegative. Default is 0.4D.
			 */
			setMaxSpeed(speed: number): void;

			/**
			 * Gets the deceleration rate (newSpeed = curSpeed * rate) of occupied
			 * boats. The default is 0.2.
			 */
			getOccupiedDeceleration(): number;

			/**
			 * Sets the deceleration rate (newSpeed = curSpeed * rate) of occupied
			 * boats. Setting this to a higher value allows for quicker acceleration.
			 * The default is 0.2.
			 */
			setOccupiedDeceleration(rate: number): void;

			/**
			 * Gets the deceleration rate (newSpeed = curSpeed * rate) of unoccupied
			 * boats. The default is -1. Values below 0 indicate that no additional
			 * deceleration is imposed.
			 */
			getUnoccupiedDeceleration(): number;

			/**
			 * Sets the deceleration rate (newSpeed = curSpeed * rate) of unoccupied
			 * boats. Setting this to a higher value allows for quicker deceleration
			 * of boats when a player disembarks. The default is -1. Values below 0
			 * indicate that no additional deceleration is imposed.
			 */
			setUnoccupiedDeceleration(rate: number): void;

			/**
			 * Get whether boats can work on land.
			 */
			getWorkOnLand(): boolean;

			/**
			 * Set whether boats can work on land.
			 */
			setWorkOnLand(workOnLand: boolean): void;

			/**
			 * Gets the status of the boat.
			 */
			getStatus(): org.bukkit.entity.Boat.Status;

		}> {}
		namespace Boat {
			interface Status {}
			namespace Status {
				const IN_WATER: org.bukkit.entity.Boat.Status;

				const UNDER_WATER: org.bukkit.entity.Boat.Status;

				const UNDER_FLOWING_WATER: org.bukkit.entity.Boat.Status;

				const ON_LAND: org.bukkit.entity.Boat.Status;

				const IN_AIR: org.bukkit.entity.Boat.Status;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Boat.Status;

			}
		}
		namespace Boat {
			interface Type {
				/**
				 * Gets the material of the boat type.
				 */
				getMaterial(): org.bukkit.Material;

			}
			namespace Type {
				const OAK: org.bukkit.entity.Boat.Type;

				const SPRUCE: org.bukkit.entity.Boat.Type;

				const BIRCH: org.bukkit.entity.Boat.Type;

				const JUNGLE: org.bukkit.entity.Boat.Type;

				const ACACIA: org.bukkit.entity.Boat.Type;

				const CHERRY: org.bukkit.entity.Boat.Type;

				const DARK_OAK: org.bukkit.entity.Boat.Type;

				const MANGROVE: org.bukkit.entity.Boat.Type;

				const BAMBOO: org.bukkit.entity.Boat.Type;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Boat.Type;

			}
		}
		interface Bogged extends Modify<org.bukkit.entity.AbstractSkeleton, {}> {}
		interface Boss extends Modify<org.bukkit.entity.Entity, {
			/**
			 * Returns the BossBar of the Boss
			 */
			getBossBar(): (org.bukkit.boss.BossBar | null);

		}> {}
		interface Breedable extends Modify<org.bukkit.entity.Ageable, {
			/**
			 * Lock the age of the animal, setting this will prevent the animal from
			 * maturing or getting ready for mating.
			 */
			setAgeLock(lock: boolean): void;

			/**
			 * Gets the current agelock.
			 */
			getAgeLock(): boolean;

			/**
			 * Return the ability to breed of the animal.
			 */
			canBreed(): boolean;

			/**
			 * Set breedability of the animal, if the animal is a baby and set to
			 * breed it will instantly grow up.
			 */
			setBreed(breed: boolean): void;

		}> {}
		interface Breeze extends Modify<org.bukkit.entity.Monster, {}> {}
		interface BreezeWindCharge extends Modify<org.bukkit.entity.AbstractWindCharge, {}> {}
		interface Camel extends Modify<org.bukkit.entity.AbstractHorse & org.bukkit.entity.Sittable, {
			/**
			 * Gets whether this camel is dashing (sprinting).
			 */
			isDashing(): boolean;

			/**
			 * Sets whether this camel is dashing (sprinting).
			 */
			setDashing(dashing: boolean): void;

		}> {}
		interface Cat extends Modify<org.bukkit.entity.Tameable & org.bukkit.entity.Sittable, {
			/**
			 * Gets the current type of this cat.
			 */
			getCatType(): org.bukkit.entity.Cat.Type;

			/**
			 * Sets the current type of this cat.
			 */
			setCatType(type: org.bukkit.entity.Cat.Type): void;

			/**
			 * Get the collar color of this cat
			 */
			getCollarColor(): org.bukkit.DyeColor;

			/**
			 * Set the collar color of this cat
			 */
			setCollarColor(color: org.bukkit.DyeColor): void;

		}> {}
		namespace Cat {
			interface Type {
				/**
				 * Description copied from interface:Â Keyed
				 */
				getKey(): org.bukkit.NamespacedKey;

			}
			namespace Type {
				const TABBY: org.bukkit.entity.Cat.Type;

				const BLACK: org.bukkit.entity.Cat.Type;

				const RED: org.bukkit.entity.Cat.Type;

				const SIAMESE: org.bukkit.entity.Cat.Type;

				const BRITISH_SHORTHAIR: org.bukkit.entity.Cat.Type;

				const CALICO: org.bukkit.entity.Cat.Type;

				const PERSIAN: org.bukkit.entity.Cat.Type;

				const RAGDOLL: org.bukkit.entity.Cat.Type;

				const WHITE: org.bukkit.entity.Cat.Type;

				const JELLIE: org.bukkit.entity.Cat.Type;

				const ALL_BLACK: org.bukkit.entity.Cat.Type;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Cat.Type;

			}
		}
		interface CaveSpider extends Modify<org.bukkit.entity.Spider, {}> {}
		interface ChestBoat extends Modify<org.bukkit.entity.Boat & org.bukkit.inventory.InventoryHolder & org.bukkit.loot.Lootable, {}> {}
		interface ChestedHorse extends Modify<org.bukkit.entity.AbstractHorse, {
			/**
			 * Gets whether the horse has a chest equipped.
			 */
			isCarryingChest(): boolean;

			/**
			 * Sets whether the horse has a chest equipped. Removing a chest will also
			 * clear the chest's inventory.
			 */
			setCarryingChest(chest: boolean): void;

		}> {}
		interface Chicken extends Modify<org.bukkit.entity.Animals, {}> {}
		interface Cod extends Modify<org.bukkit.entity.Fish, {}> {}
		interface ComplexEntityPart extends Modify<org.bukkit.entity.Entity, {
			/**
			 * Gets the parent ComplexLivingEntity of this part.
			 */
			getParent(): org.bukkit.entity.ComplexLivingEntity;

		}> {}
		interface ComplexLivingEntity extends Modify<org.bukkit.entity.LivingEntity, {
			/**
			 * Gets a list of parts that belong to this complex entity
			 */
			getParts(): globalThis.java.util.Set<org.bukkit.entity.ComplexEntityPart>;

		}> {}
		interface Cow extends Modify<org.bukkit.entity.Animals, {}> {}
		interface Creature extends Modify<org.bukkit.entity.Mob, {}> {}
		interface Creeper extends Modify<org.bukkit.entity.Monster, {
			/**
			 * Checks if this Creeper is powered (Electrocuted)
			 */
			isPowered(): boolean;

			/**
			 * Sets the Powered status of this Creeper
			 */
			setPowered(value: boolean): void;

			/**
			 * Set the maximum fuse ticks for this Creeper, where the maximum ticks
			 * is the amount of time in which a creeper is allowed to be in the
			 * primed state before exploding.
			 */
			setMaxFuseTicks(ticks: number): void;

			/**
			 * Get the maximum fuse ticks for this Creeper, where the maximum ticks
			 * is the amount of time in which a creeper is allowed to be in the
			 * primed state before exploding.
			 */
			getMaxFuseTicks(): number;

			/**
			 * Set the fuse ticks for this Creeper, where the ticks is the amount of
			 * time in which a creeper has been in the primed state.
			 */
			setFuseTicks(ticks: number): void;

			/**
			 * Get the maximum fuse ticks for this Creeper, where the ticks is the
			 * amount of time in which a creeper has been in the primed state.
			 */
			getFuseTicks(): number;

			/**
			 * Set the explosion radius in which this Creeper's explosion will affect.
			 */
			setExplosionRadius(radius: number): void;

			/**
			 * Get the explosion radius in which this Creeper's explosion will affect.
			 */
			getExplosionRadius(): number;

			/**
			 * Makes this Creeper explode instantly.
			 * 
			 * The resulting explosion can be cancelled by an
			 * ExplosionPrimeEvent and obeys the mob
			 * griefing gamerule.
			 */
			explode(): void;

			/**
			 * Ignites this Creeper, beginning its fuse.
			 * 
			 * The amount of time the Creeper takes to explode will depend on what
			 * setMaxFuseTicks(int) is set as.
			 * 
			 * The resulting explosion can be cancelled by an
			 * ExplosionPrimeEvent and obeys the mob
			 * griefing gamerule.
			 */
			ignite(entity: org.bukkit.entity.Entity): void;

			/**
			 * Ignites this Creeper, beginning its fuse.
			 * 
			 * The amount of time the Creeper takes to explode will depend on what
			 * setMaxFuseTicks(int) is set as.
			 * 
			 * The resulting explosion can be cancelled by an
			 * ExplosionPrimeEvent and obeys the mob
			 * griefing gamerule.
			 */
			ignite(): void;

			/**
			 * Gets the entity which ignited the creeper, if available.
			 */
			getIgniter(): (org.bukkit.entity.Entity | null);

		}> {}
		interface Damageable extends Modify<org.bukkit.entity.Entity, {
			/**
			 * Deals the given amount of damage to this entity.
			 */
			damage(amount: number): void;

			/**
			 * Deals the given amount of damage to this entity from a specified
			 * Entity.
			 */
			damage(amount: number, source: (org.bukkit.entity.Entity | null)): void;

			/**
			 * Deals the given amount of damage to this entity from a specified
			 * DamageSource.
			 */
			damage(amount: number, damageSource: org.bukkit.damage.DamageSource): void;

			/**
			 * Gets the entity's health from 0 to getMaxHealth(), where 0 is dead.
			 */
			getHealth(): number;

			/**
			 * Sets the entity's health from 0 to getMaxHealth(), where 0 is
			 * dead.
			 */
			setHealth(health: number): void;

			/**
			 * Gets the entity's absorption amount.
			 */
			getAbsorptionAmount(): number;

			/**
			 * Sets the entity's absorption amount.
			 * 
			 * Note: The amount is capped to the value of
			 * Attribute.GENERIC_MAX_ABSORPTION. The effect of this method on
			 * that attribute is currently unspecified and subject to change.
			 */
			setAbsorptionAmount(amount: number): void;

			/**
			 * Gets the maximum health this entity has.
			 */
			getMaxHealth(): number;

			/**
			 * Sets the maximum health this entity can have.
			 * 
			 * If the health of the entity is above the value provided it will be set
			 * to that value.
			 * 
			 * Note: An entity with a health bar (Player, EnderDragon,
			 * Wither, etc...} will have their bar scaled accordingly.
			 */
			setMaxHealth(health: number): void;

			/**
			 * Resets the max health to the original amount.
			 */
			resetMaxHealth(): void;

		}> {}
		interface Display extends Modify<org.bukkit.entity.Entity, {
			/**
			 * Gets the transformation applied to this display.
			 */
			getTransformation(): org.bukkit.util.Transformation;

			/**
			 * Sets the transformation applied to this display
			 */
			setTransformation(transformation: org.bukkit.util.Transformation): void;

			/**
			 * Sets the raw transformation matrix applied to this display
			 */
			setTransformationMatrix(transformationMatrix: any /* org.joml.Matrix4f */): void;

			/**
			 * Gets the interpolation duration of this display.
			 */
			getInterpolationDuration(): number;

			/**
			 * Sets the interpolation duration of this display.
			 */
			setInterpolationDuration(duration: number): void;

			/**
			 * Gets the teleport duration of this display.
			 * 
			 * 0 means that updates are applied immediately.
			 * 1 means that the display entity will move from current position to the updated one over one tick.
			 * Higher values spread the movement over multiple ticks.
			 * 
			 */
			getTeleportDuration(): number;

			/**
			 * Sets the teleport duration of this display.
			 */
			setTeleportDuration(duration: number): void;

			/**
			 * Gets the view distance/range of this display.
			 */
			getViewRange(): number;

			/**
			 * Sets the view distance/range of this display.
			 */
			setViewRange(range: number): void;

			/**
			 * Gets the shadow radius of this display.
			 */
			getShadowRadius(): number;

			/**
			 * Sets the shadow radius of this display.
			 */
			setShadowRadius(radius: number): void;

			/**
			 * Gets the shadow strength of this display.
			 */
			getShadowStrength(): number;

			/**
			 * Sets the shadow strength of this display.
			 */
			setShadowStrength(strength: number): void;

			/**
			 * Gets the width of this display.
			 */
			getDisplayWidth(): number;

			/**
			 * Sets the width of this display.
			 */
			setDisplayWidth(width: number): void;

			/**
			 * Gets the height of this display.
			 */
			getDisplayHeight(): number;

			/**
			 * Sets the height if this display.
			 */
			setDisplayHeight(height: number): void;

			/**
			 * Gets the amount of ticks before client-side interpolation will commence.
			 */
			getInterpolationDelay(): number;

			/**
			 * Sets the amount of ticks before client-side interpolation will commence.
			 */
			setInterpolationDelay(ticks: number): void;

			/**
			 * Gets the billboard setting of this entity.
			 * The billboard setting controls the automatic rotation of the entity to
			 * face the player.
			 */
			getBillboard(): org.bukkit.entity.Display.Billboard;

			/**
			 * Sets the billboard setting of this entity.
			 * The billboard setting controls the automatic rotation of the entity to
			 * face the player.
			 */
			setBillboard(billboard: org.bukkit.entity.Display.Billboard): void;

			/**
			 * Gets the scoreboard team overridden glow color of this display.
			 */
			getGlowColorOverride(): (org.bukkit.Color | null);

			/**
			 * Sets the scoreboard team overridden glow color of this display.
			 */
			setGlowColorOverride(color: (org.bukkit.Color | null)): void;

			/**
			 * Gets the brightness override of the entity.
			 */
			getBrightness(): (org.bukkit.entity.Display.Brightness | null);

			/**
			 * Sets the brightness override of the entity.
			 */
			setBrightness(brightness: (org.bukkit.entity.Display.Brightness | null)): void;

		}> {}
		namespace Display {
			interface Billboard {}
			namespace Billboard {
				/**
				 * No rotation (default).
				 */
				const FIXED: org.bukkit.entity.Display.Billboard;

				/**
				 * Can pivot around vertical axis.
				 */
				const VERTICAL: org.bukkit.entity.Display.Billboard;

				/**
				 * Can pivot around horizontal axis.
				 */
				const HORIZONTAL: org.bukkit.entity.Display.Billboard;

				/**
				 * Can pivot around center point.
				 */
				const CENTER: org.bukkit.entity.Display.Billboard;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Display.Billboard;

			}
		}
		namespace Display {
			interface Brightness {
				/**
				 * Gets the block lighting component of this brightness.
				 */
				getBlockLight(): number;

				/**
				 * Gets the sky lighting component of this brightness.
				 */
				getSkyLight(): number;

				hashCode(): number;

				equals(obj: any): boolean;

				toString(): string;

			}
			class Brightness {
				constructor(blockLight: number, skyLight: number);

			}
		}
		interface Dolphin extends Modify<org.bukkit.entity.WaterMob, {}> {}
		interface Donkey extends Modify<org.bukkit.entity.ChestedHorse, {}> {}
		interface DragonFireball extends Modify<org.bukkit.entity.Fireball, {}> {}
		interface Drowned extends Modify<org.bukkit.entity.Zombie, {}> {}
		interface Egg extends Modify<org.bukkit.entity.ThrowableProjectile, {}> {}
		interface ElderGuardian extends Modify<org.bukkit.entity.Guardian, {}> {}
		interface EnderCrystal extends Modify<org.bukkit.entity.Entity, {
			/**
			 * Return whether or not this end crystal is showing the
			 * bedrock slate underneath it.
			 */
			isShowingBottom(): boolean;

			/**
			 * Sets whether or not this end crystal is showing the
			 * bedrock slate underneath it.
			 */
			setShowingBottom(showing: boolean): void;

			/**
			 * Gets the location that this end crystal is pointing its beam to.
			 */
			getBeamTarget(): (org.bukkit.Location | null);

			/**
			 * Sets the location that this end crystal is pointing to. Passing a null
			 * value will remove the current beam.
			 */
			setBeamTarget(location: (org.bukkit.Location | null)): void;

		}> {}
		interface EnderDragon extends Modify<org.bukkit.entity.ComplexLivingEntity & org.bukkit.entity.Boss & org.bukkit.entity.Mob & org.bukkit.entity.Enemy, {
			/**
			 * Gets the current phase that the dragon is performing.
			 */
			getPhase(): org.bukkit.entity.EnderDragon.Phase;

			/**
			 * Sets the next phase for the dragon to perform.
			 */
			setPhase(phase: org.bukkit.entity.EnderDragon.Phase): void;

			/**
			 * Get the DragonBattle associated with this EnderDragon.
			 * 
			 * This will return null for the following reasons:
			 * 
			 * The EnderDragon is not in the End dimension
			 * The EnderDragon was summoned by command/API
			 * 
			 */
			getDragonBattle(): (org.bukkit.boss.DragonBattle | null);

			/**
			 * Get the current time in ticks relative to the start of this dragon's
			 * death animation.
			 * If this dragon is alive, 0 will be returned. This value will never exceed
			 * 200 (the length of the animation).
			 */
			getDeathAnimationTicks(): number;

		}> {}
		namespace EnderDragon {
			interface Phase {}
			namespace Phase {
				/**
				 * The dragon will circle outside the ring of pillars if ender
				 * crystals remain or inside the ring if not.
				 */
				const CIRCLING: org.bukkit.entity.EnderDragon.Phase;

				/**
				 * The dragon will fly towards a targeted player and shoot a
				 * fireball when within 64 blocks.
				 */
				const STRAFING: org.bukkit.entity.EnderDragon.Phase;

				/**
				 * The dragon will fly towards the empty portal (approaching
				 * from the other side, if applicable).
				 */
				const FLY_TO_PORTAL: org.bukkit.entity.EnderDragon.Phase;

				/**
				 * The dragon will land on on the portal. If the dragon is not near
				 * the portal, it will fly to it before mounting.
				 */
				const LAND_ON_PORTAL: org.bukkit.entity.EnderDragon.Phase;

				/**
				 * The dragon will leave the portal.
				 */
				const LEAVE_PORTAL: org.bukkit.entity.EnderDragon.Phase;

				/**
				 * The dragon will attack with dragon breath at its current location.
				 */
				const BREATH_ATTACK: org.bukkit.entity.EnderDragon.Phase;

				/**
				 * The dragon will search for a player to attack with dragon breath.
				 * If no player is close enough to the dragon for 5 seconds, the
				 * dragon will charge at a player within 150 blocks or will take off
				 * and begin circling if no player is found.
				 */
				const SEARCH_FOR_BREATH_ATTACK_TARGET: org.bukkit.entity.EnderDragon.Phase;

				/**
				 * The dragon will roar before performing a breath attack.
				 */
				const ROAR_BEFORE_ATTACK: org.bukkit.entity.EnderDragon.Phase;

				/**
				 * The dragon will charge a player.
				 */
				const CHARGE_PLAYER: org.bukkit.entity.EnderDragon.Phase;

				/**
				 * The dragon will fly to the vicinity of the portal and die.
				 */
				const DYING: org.bukkit.entity.EnderDragon.Phase;

				/**
				 * The dragon will hover at its current location, not performing any actions.
				 */
				const HOVER: org.bukkit.entity.EnderDragon.Phase;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.EnderDragon.Phase;

			}
		}
		interface EnderDragonPart extends Modify<org.bukkit.entity.ComplexEntityPart & org.bukkit.entity.Damageable, {
			/**
			 * Description copied from interface:Â ComplexEntityPart
			 */
			getParent(): org.bukkit.entity.EnderDragon;

		}> {}
		interface EnderPearl extends Modify<org.bukkit.entity.ThrowableProjectile, {}> {}
		interface EnderSignal extends Modify<org.bukkit.entity.Entity, {
			/**
			 * Get the location this EnderSignal is moving towards.
			 */
			getTargetLocation(): org.bukkit.Location;

			/**
			 * Set the Location this EnderSignal is moving towards.
			 * 
			 * When setting a new target location, the getDropItem() resets to
			 * a random value and the despawn timer gets set back to 0.
			 */
			setTargetLocation(location: org.bukkit.Location): void;

			/**
			 * Gets if the EnderSignal should drop an item on death.
			 * If true, it will drop an item. If false, it will shatter.
			 */
			getDropItem(): boolean;

			/**
			 * Sets if the EnderSignal should drop an item on death; or if it should
			 * shatter.
			 */
			setDropItem(drop: boolean): void;

			/**
			 * Get the ItemStack to be displayed while in the air and to be
			 * dropped on death.
			 */
			getItem(): org.bukkit.inventory.ItemStack;

			/**
			 * Set the ItemStack to be displayed while in the air and to be
			 * dropped on death.
			 */
			setItem(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Gets the amount of time this entity has been alive (in ticks).
			 * 
			 * When this number is greater than 80, it will despawn on the next tick.
			 */
			getDespawnTimer(): number;

			/**
			 * Set how long this entity has been alive (in ticks).
			 * 
			 * When this number is greater than 80, it will despawn on the next tick.
			 */
			setDespawnTimer(timer: number): void;

		}> {}
		interface Enderman extends Modify<org.bukkit.entity.Monster, {
			/**
			 * Gets the id and data of the block that the Enderman is carrying.
			 */
			getCarriedMaterial(): org.bukkit.material.MaterialData;

			/**
			 * Sets the id and data of the block that the Enderman is carrying.
			 */
			setCarriedMaterial(material: org.bukkit.material.MaterialData): void;

			/**
			 * Gets the data of the block that the Enderman is carrying.
			 */
			getCarriedBlock(): (org.bukkit.block.data.BlockData | null);

			/**
			 * Sets the data of the block that the Enderman is carrying.
			 */
			setCarriedBlock(blockData: (org.bukkit.block.data.BlockData | null)): void;

			/**
			 * Randomly teleports the Enderman in a 64x64x64 block cuboid region.
			 * 
			 * If the randomly selected point is in the ground, the point is moved 1 block
			 * down until air is found or until it goes under
			 * WorldInfo.getMinHeight().
			 * 
			 * This method will return false if this Enderman is not alive, or if the
			 * teleport location was obstructed, or if the teleport location is in water.
			 */
			teleport(): boolean;

			/**
			 * Randomly teleports the Enderman towards the given entity.
			 * 
			 * The point is selected by drawing a vector between this enderman and the
			 * given entity. That vector's length is set to 16 blocks.
			 * That point is then moved within a 8x8x8 cuboid region. If the randomly
			 * selected point is in the ground, the point is moved 1 block down until
			 * air is found or until it goes under
			 * WorldInfo.getMinHeight().
			 * 
			 * This method will return false if this Enderman is not alive, or if the
			 * teleport location was obstructed, or if the teleport location is in water.
			 */
			teleportTowards(entity: org.bukkit.entity.Entity): boolean;

		}> {}
		interface Endermite extends Modify<org.bukkit.entity.Monster, {
			/**
			 * Gets whether this Endermite was spawned by a player.
			 * An Endermite spawned by a player will be attacked by nearby Enderman.
			 */
			isPlayerSpawned(): boolean;

			/**
			 * Sets whether this Endermite was spawned by a player.
			 * An Endermite spawned by a player will be attacked by nearby Enderman.
			 */
			setPlayerSpawned(playerSpawned: boolean): void;

		}> {}
		interface Enemy extends Modify<org.bukkit.entity.LivingEntity, {}> {}
		interface Entity extends Modify<org.bukkit.metadata.Metadatable & org.bukkit.command.CommandSender & org.bukkit.Nameable & org.bukkit.persistence.PersistentDataHolder, {
			/**
			 * Gets the entity's current position
			 */
			getLocation(): org.bukkit.Location;

			/**
			 * Stores the entity's current position in the provided Location object.
			 * 
			 * If the provided Location is null this method does nothing and returns
			 * null.
			 */
			getLocation(loc: (org.bukkit.Location | null)): (org.bukkit.Location | null);

			/**
			 * Sets this entity's velocity in meters per tick
			 */
			setVelocity(velocity: org.bukkit.util.Vector): void;

			/**
			 * Gets this entity's current velocity
			 */
			getVelocity(): org.bukkit.util.Vector;

			/**
			 * Gets the entity's height
			 */
			getHeight(): number;

			/**
			 * Gets the entity's width
			 */
			getWidth(): number;

			/**
			 * Gets the entity's current bounding box.
			 * 
			 * The returned bounding box reflects the entity's current location and
			 * size.
			 */
			getBoundingBox(): org.bukkit.util.BoundingBox;

			/**
			 * Returns true if the entity is supported by a block. This value is a
			 * state updated by the server and is not recalculated unless the entity
			 * moves.
			 */
			isOnGround(): boolean;

			/**
			 * Returns true if the entity is in water.
			 */
			isInWater(): boolean;

			/**
			 * Gets the current world this entity resides in
			 */
			getWorld(): org.bukkit.World;

			/**
			 * Sets the entity's rotation.
			 * 
			 * Note that if the entity is affected by AI, it may override this rotation.
			 */
			setRotation(yaw: number, pitch: number): void;

			/**
			 * Teleports this entity to the given location. If this entity is riding a
			 * vehicle, it will be dismounted prior to teleportation.
			 */
			teleport(location: org.bukkit.Location): boolean;

			/**
			 * Teleports this entity to the given location. If this entity is riding a
			 * vehicle, it will be dismounted prior to teleportation.
			 */
			teleport(location: org.bukkit.Location, cause: org.bukkit.event.player.PlayerTeleportEvent.TeleportCause): boolean;

			/**
			 * Teleports this entity to the target Entity. If this entity is riding a
			 * vehicle, it will be dismounted prior to teleportation.
			 */
			teleport(destination: org.bukkit.entity.Entity): boolean;

			/**
			 * Teleports this entity to the target Entity. If this entity is riding a
			 * vehicle, it will be dismounted prior to teleportation.
			 */
			teleport(destination: org.bukkit.entity.Entity, cause: org.bukkit.event.player.PlayerTeleportEvent.TeleportCause): boolean;

			/**
			 * Returns a list of entities within a bounding box centered around this
			 * entity
			 */
			getNearbyEntities(x: number, y: number, z: number): globalThis.java.util.List<org.bukkit.entity.Entity>;

			/**
			 * Returns a unique id for this entity
			 */
			getEntityId(): number;

			/**
			 * Returns the entity's current fire ticks (ticks before the entity stops
			 * being on fire).
			 */
			getFireTicks(): number;

			/**
			 * Returns the entity's maximum fire ticks.
			 */
			getMaxFireTicks(): number;

			/**
			 * Sets the entity's current fire ticks (ticks before the entity stops
			 * being on fire).
			 */
			setFireTicks(ticks: number): void;

			/**
			 * Sets if the entity has visual fire (it will always appear to be on fire).
			 */
			setVisualFire(fire: boolean): void;

			/**
			 * Gets if the entity has visual fire (it will always appear to be on fire).
			 */
			isVisualFire(): boolean;

			/**
			 * Returns the entity's current freeze ticks (amount of ticks the entity has
			 * been in powdered snow).
			 */
			getFreezeTicks(): number;

			/**
			 * Returns the entity's maximum freeze ticks (amount of ticks before it will
			 * be fully frozen)
			 */
			getMaxFreezeTicks(): number;

			/**
			 * Sets the entity's current freeze ticks (amount of ticks the entity has
			 * been in powdered snow).
			 */
			setFreezeTicks(ticks: number): void;

			/**
			 * Gets if the entity is fully frozen (it has been in powdered snow for max
			 * freeze ticks).
			 */
			isFrozen(): boolean;

			/**
			 * Mark the entity's removal.
			 */
			remove(): void;

			/**
			 * Returns true if this entity has been marked for removal.
			 */
			isDead(): boolean;

			/**
			 * Returns false if the entity has died, been despawned for some other
			 * reason, or has not been added to the world.
			 */
			isValid(): boolean;

			/**
			 * Gets the Server that contains this Entity
			 */
			getServer(): org.bukkit.Server;

			/**
			 * Returns true if the entity gets persisted.
			 * 
			 * By default all entities are persistent. An entity will also not get
			 * persisted, if it is riding an entity that is not persistent.
			 * 
			 * The persistent flag on players controls whether or not to save their
			 * playerdata file when they quit. If a player is directly or indirectly
			 * riding a non-persistent entity, the vehicle at the root and all its
			 * passengers won't get persisted.
			 * 
			 * This should not be confused with
			 * LivingEntity.setRemoveWhenFarAway(boolean) which controls
			 * despawning of living entities.
			 */
			isPersistent(): boolean;

			/**
			 * Sets whether or not the entity gets persisted.
			 */
			setPersistent(persistent: boolean): void;

			/**
			 * Gets the primary passenger of a vehicle. For vehicles that could have
			 * multiple passengers, this will only return the primary passenger.
			 */
			getPassenger(): (org.bukkit.entity.Entity | null);

			/**
			 * Set the passenger of a vehicle.
			 */
			setPassenger(passenger: org.bukkit.entity.Entity): boolean;

			/**
			 * Gets a list of passengers of this vehicle.
			 * 
			 * The returned list will not be directly linked to the entity's current
			 * passengers, and no guarantees are made as to its mutability.
			 */
			getPassengers(): globalThis.java.util.List<org.bukkit.entity.Entity>;

			/**
			 * Add a passenger to the vehicle.
			 */
			addPassenger(passenger: org.bukkit.entity.Entity): boolean;

			/**
			 * Remove a passenger from the vehicle.
			 */
			removePassenger(passenger: org.bukkit.entity.Entity): boolean;

			/**
			 * Check if a vehicle has passengers.
			 */
			isEmpty(): boolean;

			/**
			 * Eject any passenger.
			 */
			eject(): boolean;

			/**
			 * Returns the distance this entity has fallen
			 */
			getFallDistance(): number;

			/**
			 * Sets the fall distance for this entity
			 */
			setFallDistance(distance: number): void;

			/**
			 * Record the last EntityDamageEvent inflicted on this entity
			 */
			setLastDamageCause(event: (org.bukkit.event.entity.EntityDamageEvent | null)): void;

			/**
			 * Retrieve the last EntityDamageEvent inflicted on this entity.
			 * This event may have been cancelled.
			 */
			getLastDamageCause(): (org.bukkit.event.entity.EntityDamageEvent | null);

			/**
			 * Returns a unique and persistent id for this entity
			 */
			getUniqueId(): globalThis.java.util.UUID;

			/**
			 * Gets the amount of ticks this entity has lived for.
			 * 
			 * This is the equivalent to "age" in entities.
			 */
			getTicksLived(): number;

			/**
			 * Sets the amount of ticks this entity has lived for.
			 * 
			 * This is the equivalent to "age" in entities. May not be less than one
			 * tick.
			 */
			setTicksLived(value: number): void;

			/**
			 * Performs the specified EntityEffect for this entity.
			 * 
			 * This will be viewable to all players near the entity.
			 * 
			 * If the effect is not applicable to this class of entity, it will not play.
			 */
			playEffect(type: org.bukkit.EntityEffect): void;

			/**
			 * Get the type of the entity.
			 */
			getType(): org.bukkit.entity.EntityType;

			/**
			 * Get the Sound this entity makes while swimming.
			 */
			getSwimSound(): org.bukkit.Sound;

			/**
			 * Get the Sound this entity makes when splashing in water. For most
			 * entities, this is just Sound.ENTITY_GENERIC_SPLASH.
			 */
			getSwimSplashSound(): org.bukkit.Sound;

			/**
			 * Get the Sound this entity makes when splashing in water at high
			 * speeds. For most entities, this is just Sound.ENTITY_GENERIC_SPLASH.
			 */
			getSwimHighSpeedSplashSound(): org.bukkit.Sound;

			/**
			 * Returns whether this entity is inside a vehicle.
			 */
			isInsideVehicle(): boolean;

			/**
			 * Leave the current vehicle. If the entity is currently in a vehicle (and
			 * is removed from it), true will be returned, otherwise false will be
			 * returned.
			 */
			leaveVehicle(): boolean;

			/**
			 * Get the vehicle that this entity is inside. If there is no vehicle,
			 * null will be returned.
			 */
			getVehicle(): (org.bukkit.entity.Entity | null);

			/**
			 * Sets whether or not to display the mob's custom name client side. The
			 * name will be displayed above the mob similarly to a player.
			 * 
			 * This value has no effect on players, they will always display their
			 * name.
			 */
			setCustomNameVisible(flag: boolean): void;

			/**
			 * Gets whether or not the mob's custom name is displayed client side.
			 * 
			 * This value has no effect on players, they will always display their
			 * name.
			 */
			isCustomNameVisible(): boolean;

			/**
			 * Sets whether or not this entity is visible by default.
			 * If this entity is not visible by default, then
			 * Player.showEntity(org.bukkit.plugin.Plugin, org.bukkit.entity.Entity)
			 * will need to be called before the entity is visible to a given player.
			 */
			setVisibleByDefault(visible: boolean): void;

			/**
			 * Gets whether or not this entity is visible by default.
			 * If this entity is not visible by default, then
			 * Player.showEntity(org.bukkit.plugin.Plugin, org.bukkit.entity.Entity)
			 * will need to be called before the entity is visible to a given player.
			 */
			isVisibleByDefault(): boolean;

			/**
			 * Get all players that are currently tracking this entity.
			 * 
			 * 'Tracking' means that this entity has been sent to the player and that
			 * they are receiving updates on its state. Note that the client's
			 * 'Entity Distance' setting does not affect the range at which entities
			 * are tracked.
			 */
			getTrackedBy(): globalThis.java.util.Set<org.bukkit.entity.Player>;

			/**
			 * Sets whether the entity has a team colored (default: white) glow.
			 * nb: this refers to the 'Glowing' entity property, not whether a
			 * glowing potion effect is applied
			 */
			setGlowing(flag: boolean): void;

			/**
			 * Gets whether the entity is glowing or not.
			 * nb: this refers to the 'Glowing' entity property, not whether a
			 * glowing potion effect is applied
			 */
			isGlowing(): boolean;

			/**
			 * Sets whether the entity is invulnerable or not.
			 * 
			 * When an entity is invulnerable it can only be damaged by players in
			 * creative mode.
			 */
			setInvulnerable(flag: boolean): void;

			/**
			 * Gets whether the entity is invulnerable or not.
			 */
			isInvulnerable(): boolean;

			/**
			 * Gets whether the entity is silent or not.
			 */
			isSilent(): boolean;

			/**
			 * Sets whether the entity is silent or not.
			 * 
			 * When an entity is silent it will not produce any sound.
			 */
			setSilent(flag: boolean): void;

			/**
			 * Returns whether gravity applies to this entity.
			 */
			hasGravity(): boolean;

			/**
			 * Sets whether gravity applies to this entity.
			 */
			setGravity(gravity: boolean): void;

			/**
			 * Gets the period of time (in ticks) before this entity can use a portal.
			 */
			getPortalCooldown(): number;

			/**
			 * Sets the period of time (in ticks) before this entity can use a portal.
			 */
			setPortalCooldown(cooldown: number): void;

			/**
			 * Returns a set of tags for this entity.
			 * 
			 * Entities can have no more than 1024 tags.
			 */
			getScoreboardTags(): globalThis.java.util.Set<string>;

			/**
			 * Add a tag to this entity.
			 * 
			 * Entities can have no more than 1024 tags.
			 */
			addScoreboardTag(tag: string): boolean;

			/**
			 * Removes a given tag from this entity.
			 */
			removeScoreboardTag(tag: string): boolean;

			/**
			 * Returns the reaction of the entity when moved by a piston.
			 */
			getPistonMoveReaction(): org.bukkit.block.PistonMoveReaction;

			/**
			 * Get the closest cardinal BlockFace direction an entity is
			 * currently facing.
			 * 
			 * This will not return any non-cardinal directions such as
			 * BlockFace.UP or BlockFace.DOWN.
			 * 
			 * Hanging entities will override this call and thus their behavior
			 * may be different.
			 */
			getFacing(): org.bukkit.block.BlockFace;

			/**
			 * Gets the entity's current pose.
			 * Note that the pose is only updated at the end of a tick, so may be
			 * inconsistent with other methods. eg Player.isSneaking() being
			 * true does not imply the current pose will be Pose.SNEAKING
			 */
			getPose(): org.bukkit.entity.Pose;

			/**
			 * Get the category of spawn to which this entity belongs.
			 */
			getSpawnCategory(): org.bukkit.entity.SpawnCategory;

			/**
			 * Checks if this entity has been spawned in a world.
			 * Entities not spawned in a world will not tick, be sent to players, or be
			 * saved to the server files.
			 */
			isInWorld(): boolean;

			/**
			 * Get this entity as an NBT string.
			 * 
			 * This string should not be relied upon as a serializable value.
			 */
			getAsString(): (string | null);

			/**
			 * Crates an EntitySnapshot representing the current state of this entity.
			 */
			createSnapshot(): (org.bukkit.entity.EntitySnapshot | null);

			/**
			 * Creates a copy of this entity and all its data. Does not spawn the copy in
			 * the world.
			 * Note: Players cannot be copied.
			 */
			copy(): org.bukkit.entity.Entity;

			/**
			 * Creates a copy of this entity and all its data. Spawns the copy at the given location.
			 * Note: Players cannot be copied.
			 */
			copy(to: org.bukkit.Location): org.bukkit.entity.Entity;

		}> {}
		interface EntityCategory {}
		namespace EntityCategory {
			/**
			 * Any uncategorized entity. No additional effects are applied to these
			 * entities relating to a categorization.
			 */
			const NONE: org.bukkit.entity.EntityCategory;

			/**
			 * Undead creatures. These creatures:
			 * 
			 * Are damaged by potions of healing.
			 * Are healed by potions of harming.
			 * Are immune to drowning and poison.
			 * Are subject to burning in daylight (though not all).
			 * Sink in water (except Drowned, Phantoms
			 * and Withers).
			 * Take additional damage from Enchantment.SMITE.
			 * Are ignored by Withers.
			 * 
			 */
			const UNDEAD: org.bukkit.entity.EntityCategory;

			/**
			 * Entities of the arthropod family. These creatures:
			 * 
			 * Take additional damage and receive PotionEffectType.SLOWNESS
			 * from Enchantment.BANE_OF_ARTHROPODS.
			 * Are immune to PotionEffectType.POISON if they are spiders.
			 * 
			 */
			const ARTHROPOD: org.bukkit.entity.EntityCategory;

			/**
			 * Entities that participate in raids. These creatures:
			 * 
			 * Are immune to damage from EvokerFangs.
			 * Are ignored by vindicators named "Johnny".
			 * Are hostile to villagers,
			 * wandering traders, iron golems
			 * and players.
			 * 
			 */
			const ILLAGER: org.bukkit.entity.EntityCategory;

			/**
			 * Entities that reside primarily underwater (excluding Drowned).
			 * These creatures:
			 * 
			 * Take additional damage from Enchantment.IMPALING.
			 * Are immune to drowning (excluding dolphins).
			 * Take suffocation damage when out of water for extended periods of
			 * time (excluding guardians and turtles).
			 * Are capable of swimming in water rather than floating or sinking.
			 * 
			 */
			const WATER: org.bukkit.entity.EntityCategory;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.entity.EntityCategory;

		}
		interface EntityFactory {
			/**
			 * Create a new EntitySnapshot with the supplied input.
			 * Accepts strings in the format output by EntitySnapshot.getAsString().
			 */
			createEntitySnapshot(input: string): org.bukkit.entity.EntitySnapshot;

		}
		interface EntitySnapshot {
			/**
			 * Creates an entity using this template. Does not spawn the copy in the world.
			 * 
			 */
			createEntity(world: org.bukkit.World): org.bukkit.entity.Entity;

			/**
			 * Creates an entity using this template and spawns it at the provided location.
			 */
			createEntity(to: org.bukkit.Location): org.bukkit.entity.Entity;

			/**
			 * Gets the type of entity this template holds.
			 */
			getEntityType(): org.bukkit.entity.EntityType;

			/**
			 * Get this EntitySnapshot as an NBT string.
			 * 
			 * This string should not be relied upon as a serializable value.
			 */
			getAsString(): string;

		}
		interface EntityType {
			/**
			 * Gets the entity type name.
			 */
			getName(): (string | null);

			/**
			 * Description copied from interface:Â Keyed
			 */
			getKey(): org.bukkit.NamespacedKey;

			getEntityClass(): (globalThis.java.lang.Class<org.bukkit.entity.Entity> | null);

			/**
			 * Gets the entity type id.
			 */
			getTypeId(): number;

			/**
			 * Some entities cannot be spawned using RegionAccessor.spawnEntity(Location, EntityType) or RegionAccessor.spawn(Location, Class), usually because they require additional
			 * information in order to spawn.
			 */
			isSpawnable(): boolean;

			isAlive(): boolean;

			/**
			 * Description copied from interface:Â Translatable
			 */
			getTranslationKey(): string;

			/**
			 * Gets if this EntityType is enabled by feature in a world.
			 */
			isEnabledByFeature(world: org.bukkit.World): boolean;

		}
		namespace EntityType {
			/**
			 * An item resting on the ground.
			 * 
			 * Spawn with World.dropItem(Location, ItemStack) or World.dropItemNaturally(Location, ItemStack)
			 */
			const ITEM: org.bukkit.entity.EntityType;

			/**
			 * An experience orb.
			 */
			const EXPERIENCE_ORB: org.bukkit.entity.EntityType;

			const AREA_EFFECT_CLOUD: org.bukkit.entity.EntityType;

			const ELDER_GUARDIAN: org.bukkit.entity.EntityType;

			const WITHER_SKELETON: org.bukkit.entity.EntityType;

			const STRAY: org.bukkit.entity.EntityType;

			/**
			 * A flying chicken egg.
			 */
			const EGG: org.bukkit.entity.EntityType;

			/**
			 * A leash attached to a fencepost.
			 */
			const LEASH_KNOT: org.bukkit.entity.EntityType;

			/**
			 * A painting on a wall.
			 */
			const PAINTING: org.bukkit.entity.EntityType;

			/**
			 * An arrow projectile; may get stuck in the ground.
			 */
			const ARROW: org.bukkit.entity.EntityType;

			/**
			 * A flying snowball.
			 */
			const SNOWBALL: org.bukkit.entity.EntityType;

			/**
			 * A flying large fireball, as thrown by a Ghast for example.
			 */
			const FIREBALL: org.bukkit.entity.EntityType;

			/**
			 * A flying small fireball, such as thrown by a Blaze or player.
			 */
			const SMALL_FIREBALL: org.bukkit.entity.EntityType;

			/**
			 * A flying ender pearl.
			 */
			const ENDER_PEARL: org.bukkit.entity.EntityType;

			/**
			 * An ender eye signal.
			 */
			const EYE_OF_ENDER: org.bukkit.entity.EntityType;

			/**
			 * A flying splash potion.
			 */
			const POTION: org.bukkit.entity.EntityType;

			/**
			 * A flying experience bottle.
			 */
			const EXPERIENCE_BOTTLE: org.bukkit.entity.EntityType;

			/**
			 * An item frame on a wall.
			 */
			const ITEM_FRAME: org.bukkit.entity.EntityType;

			/**
			 * A flying wither skull projectile.
			 */
			const WITHER_SKULL: org.bukkit.entity.EntityType;

			/**
			 * Primed TNT that is about to explode.
			 */
			const TNT: org.bukkit.entity.EntityType;

			/**
			 * A block that is going to or is about to fall.
			 */
			const FALLING_BLOCK: org.bukkit.entity.EntityType;

			/**
			 * Internal representation of a Firework once it has been launched.
			 */
			const FIREWORK_ROCKET: org.bukkit.entity.EntityType;

			const HUSK: org.bukkit.entity.EntityType;

			/**
			 * Like ARROW but causes the PotionEffectType.GLOWING effect on all team members.
			 */
			const SPECTRAL_ARROW: org.bukkit.entity.EntityType;

			/**
			 * Bullet fired by SHULKER.
			 */
			const SHULKER_BULLET: org.bukkit.entity.EntityType;

			/**
			 * Like FIREBALL but with added effects.
			 */
			const DRAGON_FIREBALL: org.bukkit.entity.EntityType;

			const ZOMBIE_VILLAGER: org.bukkit.entity.EntityType;

			const SKELETON_HORSE: org.bukkit.entity.EntityType;

			const ZOMBIE_HORSE: org.bukkit.entity.EntityType;

			/**
			 * Mechanical entity with an inventory for placing weapons / armor into.
			 */
			const ARMOR_STAND: org.bukkit.entity.EntityType;

			const DONKEY: org.bukkit.entity.EntityType;

			const MULE: org.bukkit.entity.EntityType;

			const EVOKER_FANGS: org.bukkit.entity.EntityType;

			const EVOKER: org.bukkit.entity.EntityType;

			const VEX: org.bukkit.entity.EntityType;

			const VINDICATOR: org.bukkit.entity.EntityType;

			const ILLUSIONER: org.bukkit.entity.EntityType;

			const COMMAND_BLOCK_MINECART: org.bukkit.entity.EntityType;

			/**
			 * A placed boat.
			 */
			const BOAT: org.bukkit.entity.EntityType;

			const MINECART: org.bukkit.entity.EntityType;

			const CHEST_MINECART: org.bukkit.entity.EntityType;

			const FURNACE_MINECART: org.bukkit.entity.EntityType;

			const TNT_MINECART: org.bukkit.entity.EntityType;

			const HOPPER_MINECART: org.bukkit.entity.EntityType;

			const SPAWNER_MINECART: org.bukkit.entity.EntityType;

			const CREEPER: org.bukkit.entity.EntityType;

			const SKELETON: org.bukkit.entity.EntityType;

			const SPIDER: org.bukkit.entity.EntityType;

			const GIANT: org.bukkit.entity.EntityType;

			const ZOMBIE: org.bukkit.entity.EntityType;

			const SLIME: org.bukkit.entity.EntityType;

			const GHAST: org.bukkit.entity.EntityType;

			const ZOMBIFIED_PIGLIN: org.bukkit.entity.EntityType;

			const ENDERMAN: org.bukkit.entity.EntityType;

			const CAVE_SPIDER: org.bukkit.entity.EntityType;

			const SILVERFISH: org.bukkit.entity.EntityType;

			const BLAZE: org.bukkit.entity.EntityType;

			const MAGMA_CUBE: org.bukkit.entity.EntityType;

			const ENDER_DRAGON: org.bukkit.entity.EntityType;

			const WITHER: org.bukkit.entity.EntityType;

			const BAT: org.bukkit.entity.EntityType;

			const WITCH: org.bukkit.entity.EntityType;

			const ENDERMITE: org.bukkit.entity.EntityType;

			const GUARDIAN: org.bukkit.entity.EntityType;

			const SHULKER: org.bukkit.entity.EntityType;

			const PIG: org.bukkit.entity.EntityType;

			const SHEEP: org.bukkit.entity.EntityType;

			const COW: org.bukkit.entity.EntityType;

			const CHICKEN: org.bukkit.entity.EntityType;

			const SQUID: org.bukkit.entity.EntityType;

			const WOLF: org.bukkit.entity.EntityType;

			const MOOSHROOM: org.bukkit.entity.EntityType;

			const SNOW_GOLEM: org.bukkit.entity.EntityType;

			const OCELOT: org.bukkit.entity.EntityType;

			const IRON_GOLEM: org.bukkit.entity.EntityType;

			const HORSE: org.bukkit.entity.EntityType;

			const RABBIT: org.bukkit.entity.EntityType;

			const POLAR_BEAR: org.bukkit.entity.EntityType;

			const LLAMA: org.bukkit.entity.EntityType;

			const LLAMA_SPIT: org.bukkit.entity.EntityType;

			const PARROT: org.bukkit.entity.EntityType;

			const VILLAGER: org.bukkit.entity.EntityType;

			const END_CRYSTAL: org.bukkit.entity.EntityType;

			const TURTLE: org.bukkit.entity.EntityType;

			const PHANTOM: org.bukkit.entity.EntityType;

			const TRIDENT: org.bukkit.entity.EntityType;

			const COD: org.bukkit.entity.EntityType;

			const SALMON: org.bukkit.entity.EntityType;

			const PUFFERFISH: org.bukkit.entity.EntityType;

			const TROPICAL_FISH: org.bukkit.entity.EntityType;

			const DROWNED: org.bukkit.entity.EntityType;

			const DOLPHIN: org.bukkit.entity.EntityType;

			const CAT: org.bukkit.entity.EntityType;

			const PANDA: org.bukkit.entity.EntityType;

			const PILLAGER: org.bukkit.entity.EntityType;

			const RAVAGER: org.bukkit.entity.EntityType;

			const TRADER_LLAMA: org.bukkit.entity.EntityType;

			const WANDERING_TRADER: org.bukkit.entity.EntityType;

			const FOX: org.bukkit.entity.EntityType;

			const BEE: org.bukkit.entity.EntityType;

			const HOGLIN: org.bukkit.entity.EntityType;

			const PIGLIN: org.bukkit.entity.EntityType;

			const STRIDER: org.bukkit.entity.EntityType;

			const ZOGLIN: org.bukkit.entity.EntityType;

			const PIGLIN_BRUTE: org.bukkit.entity.EntityType;

			const AXOLOTL: org.bukkit.entity.EntityType;

			const GLOW_ITEM_FRAME: org.bukkit.entity.EntityType;

			const GLOW_SQUID: org.bukkit.entity.EntityType;

			const GOAT: org.bukkit.entity.EntityType;

			const MARKER: org.bukkit.entity.EntityType;

			const ALLAY: org.bukkit.entity.EntityType;

			const CHEST_BOAT: org.bukkit.entity.EntityType;

			const FROG: org.bukkit.entity.EntityType;

			const TADPOLE: org.bukkit.entity.EntityType;

			const WARDEN: org.bukkit.entity.EntityType;

			const CAMEL: org.bukkit.entity.EntityType;

			const BLOCK_DISPLAY: org.bukkit.entity.EntityType;

			const INTERACTION: org.bukkit.entity.EntityType;

			const ITEM_DISPLAY: org.bukkit.entity.EntityType;

			const SNIFFER: org.bukkit.entity.EntityType;

			const TEXT_DISPLAY: org.bukkit.entity.EntityType;

			const BREEZE: org.bukkit.entity.EntityType;

			const WIND_CHARGE: org.bukkit.entity.EntityType;

			const BREEZE_WIND_CHARGE: org.bukkit.entity.EntityType;

			const ARMADILLO: org.bukkit.entity.EntityType;

			const BOGGED: org.bukkit.entity.EntityType;

			const OMINOUS_ITEM_SPAWNER: org.bukkit.entity.EntityType;

			/**
			 * A fishing line and bobber.
			 */
			const FISHING_BOBBER: org.bukkit.entity.EntityType;

			/**
			 * A bolt of lightning.
			 * 
			 * Spawn with World.strikeLightning(Location).
			 */
			const LIGHTNING_BOLT: org.bukkit.entity.EntityType;

			const PLAYER: org.bukkit.entity.EntityType;

			/**
			 * An unknown entity without an Entity Class
			 */
			const UNKNOWN: org.bukkit.entity.EntityType;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.entity.EntityType;

			/**
			 * Gets an entity type from its name.
			 */
			function fromName(name: (string | null)): (org.bukkit.entity.EntityType | null);

			/**
			 * Gets an entity from its id.
			 */
			function fromId(id: number): (org.bukkit.entity.EntityType | null);

		}
		interface Evoker extends Modify<org.bukkit.entity.Spellcaster, {
			/**
			 * Gets the Evoker.Spell the Evoker is currently using.
			 */
			getCurrentSpell(): org.bukkit.entity.Evoker.Spell;

			/**
			 * Sets the Evoker.Spell the Evoker is currently using.
			 */
			setCurrentSpell(spell: (org.bukkit.entity.Evoker.Spell | null)): void;

		}> {}
		namespace Evoker {
			interface Spell {}
			namespace Spell {
				/**
				 * No spell is being evoked.
				 */
				const NONE: org.bukkit.entity.Evoker.Spell;

				/**
				 * The spell that summons Vexes.
				 */
				const SUMMON: org.bukkit.entity.Evoker.Spell;

				/**
				 * The spell that summons Fangs.
				 */
				const FANGS: org.bukkit.entity.Evoker.Spell;

				/**
				 * The "wololo" spell.
				 */
				const WOLOLO: org.bukkit.entity.Evoker.Spell;

				/**
				 * The spell that makes the casting entity invisible.
				 */
				const DISAPPEAR: org.bukkit.entity.Evoker.Spell;

				/**
				 * The spell that makes the target blind.
				 */
				const BLINDNESS: org.bukkit.entity.Evoker.Spell;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Evoker.Spell;

			}
		}
		interface EvokerFangs extends Modify<org.bukkit.entity.Entity, {
			/**
			 * Gets the LivingEntity which summoned the fangs.
			 */
			getOwner(): (org.bukkit.entity.LivingEntity | null);

			/**
			 * Sets the LivingEntity which summoned the fangs.
			 */
			setOwner(owner: (org.bukkit.entity.LivingEntity | null)): void;

			/**
			 * Get the delay in ticks until the fang attacks.
			 */
			getAttackDelay(): number;

			/**
			 * Set the delay in ticks until the fang attacks.
			 */
			setAttackDelay(delay: number): void;

		}> {}
		interface ExperienceOrb extends Modify<org.bukkit.entity.Entity, {
			/**
			 * Gets how much experience is contained within this orb
			 */
			getExperience(): number;

			/**
			 * Sets how much experience is contained within this orb
			 */
			setExperience(value: number): void;

		}> {}
		interface Explosive extends Modify<org.bukkit.entity.Entity, {
			/**
			 * Set the radius affected by this explosive's explosion
			 */
			setYield(yield: number): void;

			/**
			 * Return the radius or yield of this explosive's explosion
			 */
			getYield(): number;

			/**
			 * Set whether or not this explosive's explosion causes fire
			 */
			setIsIncendiary(isIncendiary: boolean): void;

			/**
			 * Return whether or not this explosive creates a fire when exploding
			 */
			isIncendiary(): boolean;

		}> {}
		interface FallingBlock extends Modify<org.bukkit.entity.Entity, {
			/**
			 * Get the Material of the falling block
			 */
			getMaterial(): org.bukkit.Material;

			/**
			 * Get the data for the falling block
			 */
			getBlockData(): org.bukkit.block.data.BlockData;

			/**
			 * Get if the falling block will break into an item if it cannot be placed.
			 * 
			 * Note that if getCancelDrop() is true, the falling block
			 * will not drop an item regardless of whether or not the returned value is
			 * true.
			 */
			getDropItem(): boolean;

			/**
			 * Set if the falling block will break into an item if it cannot be placed.
			 * 
			 * Note that if getCancelDrop() is true, the falling block
			 * will not drop an item regardless of whether or not the value is set to
			 * true.
			 */
			setDropItem(drop: boolean): void;

			/**
			 * Get if the falling block will not become a block upon landing and not drop
			 * an item.
			 * 
			 * Unlike getDropItem(), this property will prevent the block from
			 * forming into a block when it lands, causing it to disappear. If this property
			 * is true and getDropItem() is true, an item will NOT
			 * be dropped.
			 */
			getCancelDrop(): boolean;

			/**
			 * Get if the falling block will not become a block upon landing and not drop
			 * an item.
			 * 
			 * Unlike setDropItem(boolean), this property will prevent the block
			 * from forming into a block when it lands, causing it to disappear. If this
			 * property is true and getDropItem() is true, an item will
			 * NOT be dropped.
			 */
			setCancelDrop(cancelDrop: boolean): void;

			/**
			 * Get the HurtEntities state of this block.
			 */
			canHurtEntities(): boolean;

			/**
			 * Set the HurtEntities state of this block.
			 */
			setHurtEntities(hurtEntities: boolean): void;

			/**
			 * Get the amount of damage inflicted upon entities multiplied by the distance
			 * that the block had fallen when this falling block lands on them.
			 */
			getDamagePerBlock(): number;

			/**
			 * Set the amount of damage inflicted upon entities multiplied by the distance
			 * that the block had fallen when this falling block lands on them.
			 * 
			 * If damage is non-zero, this method will automatically call
			 * setHurtEntities(true).
			 */
			setDamagePerBlock(damage: number): void;

			/**
			 * Get the maximum amount of damage that can be inflicted upon entities when
			 * this falling block lands on them.
			 */
			getMaxDamage(): number;

			/**
			 * Set the maximum amount of damage that can be inflicted upon entities when
			 * this falling block lands on them.
			 * 
			 * If damage is non-zero, this method will automatically call
			 * setHurtEntities(true).
			 */
			setMaxDamage(damage: number): void;

		}> {}
		interface Fireball extends Modify<org.bukkit.entity.Projectile & org.bukkit.entity.Explosive, {
			/**
			 * Sets the direction the fireball should be flying towards.
			 * 
			 * This is a convenience method, it will change the velocity direction and
			 * acceleration direction, while keeping the power the same.
			 * 
			 * Note: This method only uses the direction of the vector and will
			 * normalize (a copy of) it.
			 * 
			 * Special Case: When the given direction is
			 * zero, the velocity and acceleration will also be
			 * set to zero without keeping the power.
			 */
			setDirection(direction: org.bukkit.util.Vector): void;

			/**
			 * Retrieve the direction this fireball is heading toward.
			 * The returned vector is not normalized.
			 */
			getDirection(): org.bukkit.util.Vector;

			/**
			 * Sets the acceleration of the fireball.
			 * The acceleration gets applied to the velocity every tick, depending on
			 * the specific type of the fireball a damping / drag factor is applied so
			 * that the velocity does not grow into infinity.
			 * 
			 * Note: that the client may not respect non-default acceleration
			 * power and will therefore mispredict the location of the fireball, causing
			 * visual stutter.
			 */
			setAcceleration(acceleration: org.bukkit.util.Vector): void;

			/**
			 * Retrieve the acceleration of this fireball.
			 */
			getAcceleration(): org.bukkit.util.Vector;

		}> {}
		interface Firework extends Modify<org.bukkit.entity.Projectile, {
			/**
			 * Get a copy of the fireworks meta
			 */
			getFireworkMeta(): org.bukkit.inventory.meta.FireworkMeta;

			/**
			 * Apply the provided meta to the fireworks
			 */
			setFireworkMeta(meta: org.bukkit.inventory.meta.FireworkMeta): void;

			/**
			 * Set the LivingEntity to which this firework is attached.
			 * 
			 * When attached to an entity, the firework effect will act as normal but
			 * remain positioned on the entity. If the entity LivingEntity#isGliding()
			 * is gliding, then the entity will receive a boost in the direction that
			 * they are looking.
			 */
			setAttachedTo(entity: (org.bukkit.entity.LivingEntity | null)): boolean;

			/**
			 * Get the LivingEntity to which this firework is attached.
			 * 
			 * When attached to an entity, the firework effect will act as normal but
			 * remain positioned on the entity. If the entity LivingEntity#isGliding()
			 * is gliding, then the entity will receive a boost in the direction that
			 * they are looking.
			 */
			getAttachedTo(): (org.bukkit.entity.LivingEntity | null);

			/**
			 * Set the ticks that this firework has been alive. If this value exceeds
			 * getMaxLife(), the firework will detonate.
			 */
			setLife(ticks: number): boolean;

			/**
			 * Get the ticks that this firework has been alive. When this value reaches
			 * getMaxLife(), the firework will detonate.
			 */
			getLife(): number;

			/**
			 * Set the time in ticks this firework will exist until it is detonated.
			 */
			setMaxLife(ticks: number): boolean;

			/**
			 * Get the time in ticks this firework will exist until it is detonated.
			 */
			getMaxLife(): number;

			/**
			 * Cause this firework to explode at earliest opportunity, as if it has no
			 * remaining fuse.
			 */
			detonate(): void;

			/**
			 * Check whether or not this firework has detonated.
			 */
			isDetonated(): boolean;

			/**
			 * Gets if the firework was shot at an angle (i.e. from a crossbow).
			 * A firework which was not shot at an angle will fly straight upwards.
			 */
			isShotAtAngle(): boolean;

			/**
			 * Sets if the firework was shot at an angle (i.e. from a crossbow).
			 * A firework which was not shot at an angle will fly straight upwards.
			 */
			setShotAtAngle(shotAtAngle: boolean): void;

		}> {}
		interface Fish extends Modify<org.bukkit.entity.WaterMob, {}> {}
		interface FishHook extends Modify<org.bukkit.entity.Projectile, {
			/**
			 * Get the minimum number of ticks one has to wait for a fish appearing.
			 * 
			 * The default is 100 ticks (5 seconds).
			 * Note that this is before applying lure.
			 */
			getMinWaitTime(): number;

			/**
			 * Set the minimum number of ticks one has to wait for a fish appearing.
			 * 
			 * The default is 100 ticks (5 seconds).
			 * Note that this is before applying lure.
			 */
			setMinWaitTime(minWaitTime: number): void;

			/**
			 * Get the maximum number of ticks one has to wait for a fish appearing.
			 * 
			 * The default is 600 ticks (30 seconds).
			 * Note that this is before applying lure.
			 */
			getMaxWaitTime(): number;

			/**
			 * Set the maximum number of ticks one has to wait for a fish appearing.
			 * 
			 * The default is 600 ticks (30 seconds).
			 * Note that this is before applying lure.
			 */
			setMaxWaitTime(maxWaitTime: number): void;

			/**
			 * Set both the minimum (default 100) and maximum (default 600) amount
			 * of ticks one has to wait for a fish appearing.
			 */
			setWaitTime(min: number, max: number): void;

			/**
			 * Get the minimum number of ticks one has to wait for a fish to bite
			 * after appearing.
			 * 
			 * The default is 20 ticks (1 second).
			 * Lure does not affect this value.
			 * This will also effect the radius (0.1 * lureTime) of where
			 * the fish will appear.
			 */
			getMinLureTime(): number;

			/**
			 * Set the minimum number of ticks one has to wait for a fish to bite
			 * after appearing.
			 * 
			 * The default is 20 ticks (1 second).
			 * Lure does not affect this value.
			 * This will also effect the radius (0.1 * lureTime) of where
			 * the fish will appear.
			 */
			setMinLureTime(minLureTime: number): void;

			/**
			 * Get the maximum number of ticks one has to wait for a fish to bite
			 * after appearing.
			 * 
			 * The default is 80 ticks (4 second).
			 * Lure does not affect this value.
			 * This will also effect the radius (0.1 * lureTime) of where
			 * the fish will appear.
			 */
			getMaxLureTime(): number;

			/**
			 * Set the maximum number of ticks one has to wait for a fish to bite
			 * after appearing.
			 * 
			 * The default is 80 ticks (4 second).
			 * Lure does not affect this value.
			 * This will also effect the radius (0.1 * lureTime) of where
			 * the fish will appear.
			 */
			setMaxLureTime(maxLureTime: number): void;

			/**
			 * Set both the minimum (default 20) and maximum (default 80) amount
			 * of ticks one has to wait for a fish to bite after appearing.
			 */
			setLureTime(min: number, max: number): void;

			/**
			 * Get the minimum angle (in degrees, 0 being positive Z 90 being negative
			 * X) of where a fish will appear after the wait time.
			 * 
			 * The default is 0 degrees.
			 */
			getMinLureAngle(): number;

			/**
			 * Set the minimum angle (in degrees, 0 being positive Z 90 being negative
			 * X) of where a fish will appear after the wait time.
			 * 
			 * The default is 0 degrees.
			 */
			setMinLureAngle(minLureAngle: number): void;

			/**
			 * Get the maximum angle (in degrees, 0 being positive Z 90 being negative
			 * X) of where a fish will appear after the wait time.
			 * 
			 * The default is 360 degrees.
			 */
			getMaxLureAngle(): number;

			/**
			 * Set the maximum angle (in degrees, 0 being positive Z 90 being negative
			 * X) of where a fish will appear after the wait time.
			 * 
			 * The default is 360 degrees.
			 */
			setMaxLureAngle(maxLureAngle: number): void;

			/**
			 * Set both the minimum (default 0) and maximum (default 360) angle of where
			 * a fish will appear after the wait time.
			 * 0 degrees is positive Z, 90 degrees is negative X.
			 */
			setLureAngle(min: number, max: number): void;

			/**
			 * Get whether the lure enchantment should be applied to reduce the wait
			 * time.
			 * 
			 * The default is true.
			 * Lure reduces the wait time by 100 ticks (5 seconds) for each level of the
			 * enchantment.
			 */
			getApplyLure(): boolean;

			/**
			 * Set whether the lure enchantment should be applied to reduce the wait
			 * time.
			 * 
			 * The default is true.
			 * Lure reduces the wait time by 100 ticks (5 seconds) for each level of the
			 * enchantment.
			 */
			setApplyLure(applyLure: boolean): void;

			/**
			 * Gets the chance of a fish biting.
			 * 
			 * 0.0 = No Chance.
			 * 1.0 = Instant catch.
			 */
			getBiteChance(): number;

			/**
			 * Sets the chance of a fish biting.
			 * 
			 * 0.0 = No Chance.
			 * 1.0 = Instant catch.
			 */
			setBiteChance(chance: number): void;

			/**
			 * Check whether or not this fish hook is in open water.
			 * 
			 * Open water is defined by a 5x4x5 area of water, air and lily pads. If in
			 * open water, treasure items may be caught.
			 */
			isInOpenWater(): boolean;

			/**
			 * Get the entity hooked by this fish hook.
			 */
			getHookedEntity(): (org.bukkit.entity.Entity | null);

			/**
			 * Set the entity hooked by this fish hook.
			 */
			setHookedEntity(entity: (org.bukkit.entity.Entity | null)): void;

			/**
			 * Pull the hooked entity to the caster of this fish hook. If no entity is
			 * hooked, this method has no effect.
			 */
			pullHookedEntity(): boolean;

			/**
			 * Whether or not wait and lure time will be impacted by direct sky access.
			 * True by default, causes a 50% time increase on average.
			 */
			isSkyInfluenced(): boolean;

			/**
			 * Set whether or not wait and lure time will be impacted by direct sky
			 * access.
			 * True by default, causes a 50% time increase on average.
			 */
			setSkyInfluenced(skyInfluenced: boolean): void;

			/**
			 * Whether or not wait and lure time will be impacted by rain.
			 * True by default, causes a 25% time decrease on average.
			 */
			isRainInfluenced(): boolean;

			/**
			 * Set whether or not wait and lure time will be impacted by rain.
			 * True by default, causes a 25% time decrease on average.
			 */
			setRainInfluenced(rainInfluenced: boolean): void;

			/**
			 * Get the current state of this fish hook.
			 */
			getState(): org.bukkit.entity.FishHook.HookState;

		}> {}
		namespace FishHook {
			interface HookState {}
			namespace HookState {
				/**
				 * The fishing hook has been cast and is either in the air or resting
				 * against a block on the ground.
				 */
				const UNHOOKED: org.bukkit.entity.FishHook.HookState;

				/**
				 * The fishing hook has hooked an entity.
				 */
				const HOOKED_ENTITY: org.bukkit.entity.FishHook.HookState;

				/**
				 * The fishing hook is bobbing in the water, waiting for a bite.
				 */
				const BOBBING: org.bukkit.entity.FishHook.HookState;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.FishHook.HookState;

			}
		}
		interface Flying extends Modify<org.bukkit.entity.Mob, {}> {}
		interface Fox extends Modify<org.bukkit.entity.Animals & org.bukkit.entity.Sittable, {
			/**
			 * Gets the current type of this fox.
			 */
			getFoxType(): org.bukkit.entity.Fox.Type;

			/**
			 * Sets the current type of this fox.
			 */
			setFoxType(type: org.bukkit.entity.Fox.Type): void;

			/**
			 * Checks if this animal is crouching
			 */
			isCrouching(): boolean;

			/**
			 * Sets if this animal is crouching.
			 */
			setCrouching(crouching: boolean): void;

			/**
			 * Sets if this animal is sleeping.
			 */
			setSleeping(sleeping: boolean): void;

			/**
			 * Gets the first trusted player.
			 */
			getFirstTrustedPlayer(): (org.bukkit.entity.AnimalTamer | null);

			/**
			 * Set the first trusted player.
			 * 
			 * The first trusted player may only be removed after the second.
			 */
			setFirstTrustedPlayer(player: (org.bukkit.entity.AnimalTamer | null)): void;

			/**
			 * Gets the second trusted player.
			 */
			getSecondTrustedPlayer(): (org.bukkit.entity.AnimalTamer | null);

			/**
			 * Set the second trusted player.
			 * 
			 * The second trusted player may only be added after the first.
			 */
			setSecondTrustedPlayer(player: (org.bukkit.entity.AnimalTamer | null)): void;

			/**
			 * Gets whether the fox is faceplanting the ground
			 */
			isFaceplanted(): boolean;

		}> {}
		namespace Fox {
			interface Type {}
			namespace Type {
				const RED: org.bukkit.entity.Fox.Type;

				const SNOW: org.bukkit.entity.Fox.Type;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Fox.Type;

			}
		}
		interface Frog extends Modify<org.bukkit.entity.Animals, {
			/**
			 * Gets the tongue target of this frog.
			 */
			getTongueTarget(): (org.bukkit.entity.Entity | null);

			/**
			 * Sets the tongue target of this frog.
			 */
			setTongueTarget(target: (org.bukkit.entity.Entity | null)): void;

			/**
			 * Get the variant of this frog.
			 */
			getVariant(): org.bukkit.entity.Frog.Variant;

			/**
			 * Set the variant of this frog.
			 */
			setVariant(variant: org.bukkit.entity.Frog.Variant): void;

		}> {}
		namespace Frog {
			interface Variant {
				/**
				 * Description copied from interface:Â Keyed
				 */
				getKey(): org.bukkit.NamespacedKey;

			}
			namespace Variant {
				/**
				 * Temperate (brown-orange) frog.
				 */
				const TEMPERATE: org.bukkit.entity.Frog.Variant;

				/**
				 * Warm (gray) frog.
				 */
				const WARM: org.bukkit.entity.Frog.Variant;

				/**
				 * Cold (green) frog.
				 */
				const COLD: org.bukkit.entity.Frog.Variant;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Frog.Variant;

			}
		}
		interface Ghast extends Modify<org.bukkit.entity.Flying & org.bukkit.entity.Enemy, {
			/**
			 * Gets whether the Ghast is charging
			 */
			isCharging(): boolean;

			/**
			 * Sets whether the Ghast is charging
			 */
			setCharging(flag: boolean): void;

		}> {}
		interface Giant extends Modify<org.bukkit.entity.Monster, {}> {}
		interface GlowItemFrame extends Modify<org.bukkit.entity.ItemFrame, {}> {}
		interface GlowSquid extends Modify<org.bukkit.entity.Squid, {
			/**
			 * Get the number of dark ticks remaining for this squid.
			 * Bravo Six will go dark for 100 ticks (5 seconds) if damaged.
			 */
			getDarkTicksRemaining(): number;

			/**
			 * Sets the number of dark ticks remaining for this squid.
			 * Bravo Six will go dark for 100 ticks (5 seconds) if damaged.
			 */
			setDarkTicksRemaining(darkTicksRemaining: number): void;

		}> {}
		interface Goat extends Modify<org.bukkit.entity.Animals, {
			/**
			 * Gets if this goat has its left horn.
			 */
			hasLeftHorn(): boolean;

			/**
			 * Sets if this goat has its left horn.
			 */
			setLeftHorn(hasHorn: boolean): void;

			/**
			 * Gets if this goat has its right horn.
			 */
			hasRightHorn(): boolean;

			/**
			 * Sets if this goat has its right horn.
			 */
			setRightHorn(hasHorn: boolean): void;

			/**
			 * Gets if this is a screaming goat.
			 * A screaming goat makes screaming sounds and rams more often. They do not
			 * offer home loans.
			 */
			isScreaming(): boolean;

			/**
			 * Sets if this is a screaming goat.
			 * A screaming goat makes screaming sounds and rams more often. They do not
			 * offer home loans.
			 */
			setScreaming(screaming: boolean): void;

		}> {}
		interface Golem extends Modify<org.bukkit.entity.Creature, {}> {}
		interface Guardian extends Modify<org.bukkit.entity.Monster, {
			/**
			 * Sets whether the guardian laser should show or not.
			 * A target must be present. If no target is present the laser will not show
			 * and the method will return false.
			 */
			setLaser(activated: boolean): boolean;

			/**
			 * Gets whether the guardian laser is active or not.
			 */
			hasLaser(): boolean;

			/**
			 * Get the duration (in ticks) that a laser attack takes.
			 */
			getLaserDuration(): number;

			/**
			 * Set the amount of ticks that have elapsed since this guardian has initiated
			 * a laser attack. If set to getLaserDuration() or greater, the guardian
			 * will inflict damage upon its target and the laser attack will complete.
			 * 
			 * For this value to have any effect, the guardian must have an active target
			 * (see Mob.setTarget(LivingEntity)) and be charging a laser attack (where
			 * hasLaser() is true). The client may display a different animation of
			 * the guardian laser than the set ticks.
			 */
			setLaserTicks(ticks: number): void;

			/**
			 * Get the amount of ticks that have elapsed since this guardian has initiated
			 * a laser attack.
			 * 
			 * This value may or may not be significant depending on whether or not the guardian
			 * has an active target (Mob.getTarget()) and is charging a laser attack
			 * (hasLaser()). This value is not reset after a successful attack nor used
			 * in the next and will be reset to the minimum value when the guardian initiates a
			 * new one.
			 */
			getLaserTicks(): number;

			/**
			 * Check if the Guardian is an elder Guardian
			 */
			isElder(): boolean;

			setElder(shouldBeElder: boolean): void;

			/**
			 * Check whether or not this guardian is moving.
			 * 
			 * While moving, the guardian's spikes are retracted and will not inflict thorns
			 * damage upon entities that attack it. Additionally, a moving guardian cannot
			 * attack another entity. If stationary (i.e. this method returns false),
			 * thorns damage is guaranteed and the guardian may initiate laser attacks.
			 */
			isMoving(): boolean;

		}> {}
		interface Hanging extends Modify<org.bukkit.entity.Entity & org.bukkit.material.Attachable, {
			/**
			 * Sets the direction of the hanging entity, potentially overriding rules
			 * of placement. Note that if the result is not valid the object would
			 * normally drop as an item.
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace, force: boolean): boolean;

		}> {}
		interface Hoglin extends Modify<org.bukkit.entity.Animals & org.bukkit.entity.Enemy, {
			/**
			 * Gets whether the hoglin is immune to zombification.
			 */
			isImmuneToZombification(): boolean;

			/**
			 * Sets whether the hoglin is immune to zombification.
			 */
			setImmuneToZombification(flag: boolean): void;

			/**
			 * Get whether the hoglin is able to be hunted by piglins.
			 */
			isAbleToBeHunted(): boolean;

			/**
			 * Sets whether the hoglin is able to be hunted by piglins.
			 */
			setIsAbleToBeHunted(flag: boolean): void;

			/**
			 * Gets the amount of ticks until this entity will be converted to a Zoglin.
			 * When this reaches 300, the entity will be converted.
			 */
			getConversionTime(): number;

			/**
			 * Sets the amount of ticks until this entity will be converted to a Zoglin.
			 * When this reaches 0, the entity will be converted. A value of less than 0
			 * will stop the current conversion process without converting the current
			 * entity.
			 */
			setConversionTime(time: number): void;

			/**
			 * Get if this entity is in the process of converting to a Zoglin.
			 */
			isConverting(): boolean;

		}> {}
		interface Horse extends Modify<org.bukkit.entity.AbstractHorse, {
			/**
			 * Gets the horse's color.
			 * 
			 * Colors only apply to horses, not to donkeys, mules, skeleton horses
			 * or undead horses.
			 */
			getColor(): org.bukkit.entity.Horse.Color;

			/**
			 * Sets the horse's color.
			 * 
			 * Attempting to set a color for any donkey, mule, skeleton horse or
			 * undead horse will not result in a change.
			 */
			setColor(color: org.bukkit.entity.Horse.Color): void;

			/**
			 * Gets the horse's style.
			 * Styles determine what kind of markings or patterns a horse has.
			 * 
			 * Styles only apply to horses, not to donkeys, mules, skeleton horses
			 * or undead horses.
			 */
			getStyle(): org.bukkit.entity.Horse.Style;

			/**
			 * Sets the style of this horse.
			 * Styles determine what kind of markings or patterns a horse has.
			 * 
			 * Attempting to set a style for any donkey, mule, skeleton horse or
			 * undead horse will not result in a change.
			 */
			setStyle(style: org.bukkit.entity.Horse.Style): void;

			isCarryingChest(): boolean;

			setCarryingChest(chest: boolean): void;

			/**
			 * Description copied from interface:Â InventoryHolder
			 */
			getInventory(): org.bukkit.inventory.HorseInventory;

		}> {}
		namespace Horse {
			interface Color {}
			namespace Color {
				/**
				 * Snow white
				 */
				const WHITE: org.bukkit.entity.Horse.Color;

				/**
				 * Very light brown
				 */
				const CREAMY: org.bukkit.entity.Horse.Color;

				/**
				 * Chestnut
				 */
				const CHESTNUT: org.bukkit.entity.Horse.Color;

				/**
				 * Light brown
				 */
				const BROWN: org.bukkit.entity.Horse.Color;

				/**
				 * Pitch black
				 */
				const BLACK: org.bukkit.entity.Horse.Color;

				/**
				 * Gray
				 */
				const GRAY: org.bukkit.entity.Horse.Color;

				/**
				 * Dark brown
				 */
				const DARK_BROWN: org.bukkit.entity.Horse.Color;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Horse.Color;

			}
		}
		namespace Horse {
			interface Style {}
			namespace Style {
				/**
				 * No markings
				 */
				const NONE: org.bukkit.entity.Horse.Style;

				/**
				 * White socks or stripes
				 */
				const WHITE: org.bukkit.entity.Horse.Style;

				/**
				 * Milky splotches
				 */
				const WHITEFIELD: org.bukkit.entity.Horse.Style;

				/**
				 * Round white dots
				 */
				const WHITE_DOTS: org.bukkit.entity.Horse.Style;

				/**
				 * Small black dots
				 */
				const BLACK_DOTS: org.bukkit.entity.Horse.Style;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Horse.Style;

			}
		}
		namespace Horse {
			interface Variant {}
			namespace Variant {
				/**
				 * A normal horse
				 */
				const HORSE: org.bukkit.entity.Horse.Variant;

				/**
				 * A donkey
				 */
				const DONKEY: org.bukkit.entity.Horse.Variant;

				/**
				 * A mule
				 */
				const MULE: org.bukkit.entity.Horse.Variant;

				/**
				 * An undead horse
				 */
				const UNDEAD_HORSE: org.bukkit.entity.Horse.Variant;

				/**
				 * A skeleton horse
				 */
				const SKELETON_HORSE: org.bukkit.entity.Horse.Variant;

				/**
				 * Not really a horse :)
				 */
				const LLAMA: org.bukkit.entity.Horse.Variant;

				/**
				 * Also not really a horse :)
				 */
				const CAMEL: org.bukkit.entity.Horse.Variant;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Horse.Variant;

			}
		}
		interface HumanEntity extends Modify<org.bukkit.entity.LivingEntity & org.bukkit.entity.AnimalTamer & org.bukkit.inventory.InventoryHolder, {
			/**
			 * Returns the name of this player
			 */
			getName(): string;

			/**
			 * Get the player's inventory.
			 */
			getInventory(): org.bukkit.inventory.PlayerInventory;

			/**
			 * Get the player's EnderChest inventory
			 */
			getEnderChest(): org.bukkit.inventory.Inventory;

			/**
			 * Gets the player's selected main hand
			 */
			getMainHand(): org.bukkit.inventory.MainHand;

			/**
			 * If the player currently has an inventory window open, this method will
			 * set a property of that window, such as the state of a progress bar.
			 */
			setWindowProperty(prop: org.bukkit.inventory.InventoryView.Property, value: number): boolean;

			/**
			 * Gets the player's current enchantment seed.
			 * The Seed is used to generate enchantment options in the enchanting table
			 * for the player.
			 */
			getEnchantmentSeed(): number;

			/**
			 * Sets the player's enchantment seed.
			 * The Seed is used to generate enchantment options in the enchanting table
			 * for the player.
			 */
			setEnchantmentSeed(seed: number): void;

			/**
			 * Gets the inventory view the player is currently viewing. If they do not
			 * have an inventory window open, it returns their internal crafting view.
			 */
			getOpenInventory(): org.bukkit.inventory.InventoryView;

			/**
			 * Opens an inventory window with the specified inventory on the top and
			 * the player's inventory on the bottom.
			 */
			openInventory(inventory: org.bukkit.inventory.Inventory): (org.bukkit.inventory.InventoryView | null);

			/**
			 * Opens an empty workbench inventory window with the player's inventory
			 * on the bottom.
			 */
			openWorkbench(location: (org.bukkit.Location | null), force: boolean): (org.bukkit.inventory.InventoryView | null);

			/**
			 * Opens an empty enchanting inventory window with the player's inventory
			 * on the bottom.
			 */
			openEnchanting(location: (org.bukkit.Location | null), force: boolean): (org.bukkit.inventory.InventoryView | null);

			/**
			 * Opens an inventory window to the specified inventory view.
			 */
			openInventory(inventory: org.bukkit.inventory.InventoryView): void;

			/**
			 * Starts a trade between the player and the villager.
			 * Note that only one player may trade with a villager at once. You must use
			 * the force parameter for this.
			 */
			openMerchant(trader: org.bukkit.entity.Villager, force: boolean): (org.bukkit.inventory.InventoryView | null);

			/**
			 * Starts a trade between the player and the merchant.
			 * Note that only one player may trade with a merchant at once. You must use
			 * the force parameter for this.
			 */
			openMerchant(merchant: org.bukkit.inventory.Merchant, force: boolean): (org.bukkit.inventory.InventoryView | null);

			/**
			 * Force-closes the currently open inventory view for this player, if any.
			 */
			closeInventory(): void;

			/**
			 * Returns the ItemStack currently in your hand, can be empty.
			 */
			getItemInHand(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the item to the given ItemStack, this will replace whatever the
			 * user was holding.
			 */
			setItemInHand(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Returns the ItemStack currently on your cursor, can be empty. Will
			 * always be empty if the player currently has no open window.
			 */
			getItemOnCursor(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the item to the given ItemStack, this will replace whatever the
			 * user was moving. Will always be empty if the player currently has no
			 * open window.
			 */
			setItemOnCursor(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Check whether a cooldown is active on the specified material.
			 */
			hasCooldown(material: org.bukkit.Material): boolean;

			/**
			 * Get the cooldown time in ticks remaining for the specified material.
			 */
			getCooldown(material: org.bukkit.Material): number;

			/**
			 * Set a cooldown on the specified material for a certain amount of ticks.
			 * ticks. 0 ticks will result in the removal of the cooldown.
			 * 
			 * Cooldowns are used by the server for items such as ender pearls and
			 * shields to prevent them from being used repeatedly.
			 * 
			 * Note that cooldowns will not by themselves stop an item from being used
			 * for attacking.
			 */
			setCooldown(material: org.bukkit.Material, ticks: number): void;

			/**
			 * Get the sleep ticks of the player. This value may be capped.
			 */
			getSleepTicks(): number;

			/**
			 * Attempts to make the entity sleep at the given location.
			 * 
			 * The location must be in the current world and have a bed placed at the
			 * location. The game may also enforce other requirements such as proximity
			 * to bed, monsters, and dimension type if force is not set.
			 */
			sleep(location: org.bukkit.Location, force: boolean): boolean;

			/**
			 * Causes the player to wakeup if they are currently sleeping.
			 */
			wakeup(setSpawnLocation: boolean): void;

			/**
			 * Gets the location of the bed the player is currently sleeping in
			 */
			getBedLocation(): org.bukkit.Location;

			/**
			 * Gets this human's current GameMode
			 */
			getGameMode(): org.bukkit.GameMode;

			/**
			 * Sets this human's current GameMode
			 */
			setGameMode(mode: org.bukkit.GameMode): void;

			/**
			 * Check if the player is currently blocking (ie with a shield).
			 */
			isBlocking(): boolean;

			/**
			 * Check if the player currently has their hand raised (ie about to begin
			 * blocking).
			 */
			isHandRaised(): boolean;

			/**
			 * Get the total amount of experience required for the player to level
			 */
			getExpToLevel(): number;

			/**
			 * Gets the current cooldown for a player's attack.
			 * This is used to calculate damage, with 1.0 representing a fully charged
			 * attack and 0.0 representing a non-charged attack
			 */
			getAttackCooldown(): number;

			/**
			 * Discover a recipe for this player such that it has not already been
			 * discovered. This method will add the key's associated recipe to the
			 * player's recipe book.
			 */
			discoverRecipe(recipe: org.bukkit.NamespacedKey): boolean;

			/**
			 * Discover a collection of recipes for this player such that they have not
			 * already been discovered. This method will add the keys' associated
			 * recipes to the player's recipe book. If a recipe in the provided
			 * collection has already been discovered, it will be silently ignored.
			 */
			discoverRecipes(recipes: globalThis.java.util.Collection<org.bukkit.NamespacedKey>): number;

			/**
			 * Undiscover a recipe for this player such that it has already been
			 * discovered. This method will remove the key's associated recipe from the
			 * player's recipe book.
			 */
			undiscoverRecipe(recipe: org.bukkit.NamespacedKey): boolean;

			/**
			 * Undiscover a collection of recipes for this player such that they have
			 * already been discovered. This method will remove the keys' associated
			 * recipes from the player's recipe book. If a recipe in the provided
			 * collection has not yet been discovered, it will be silently ignored.
			 */
			undiscoverRecipes(recipes: globalThis.java.util.Collection<org.bukkit.NamespacedKey>): number;

			/**
			 * Check whether or not this entity has discovered the specified recipe.
			 */
			hasDiscoveredRecipe(recipe: org.bukkit.NamespacedKey): boolean;

			/**
			 * Get an immutable set of recipes this entity has discovered.
			 */
			getDiscoveredRecipes(): globalThis.java.util.Set<org.bukkit.NamespacedKey>;

			/**
			 * Gets the entity currently perched on the left shoulder or null if no
			 * entity.
			 * 
			 * The returned entity will not be spawned within the world, so most
			 * operations are invalid unless the entity is first spawned in.
			 */
			getShoulderEntityLeft(): (org.bukkit.entity.Entity | null);

			/**
			 * Sets the entity currently perched on the left shoulder, or null to
			 * remove. This method will remove the entity from the world.
			 * 
			 * Note that only a copy of the entity will be set to display on the
			 * shoulder.
			 * 
			 * Also note that the client will currently only render Parrot
			 * entities.
			 */
			setShoulderEntityLeft(entity: (org.bukkit.entity.Entity | null)): void;

			/**
			 * Gets the entity currently perched on the right shoulder or null if no
			 * entity.
			 * 
			 * The returned entity will not be spawned within the world, so most
			 * operations are invalid unless the entity is first spawned in.
			 */
			getShoulderEntityRight(): (org.bukkit.entity.Entity | null);

			/**
			 * Sets the entity currently perched on the right shoulder, or null to
			 * remove. This method will remove the entity from the world.
			 * 
			 * Note that only a copy of the entity will be set to display on the
			 * shoulder.
			 * 
			 * Also note that the client will currently only render Parrot
			 * entities.
			 */
			setShoulderEntityRight(entity: (org.bukkit.entity.Entity | null)): void;

			/**
			 * Make the entity drop the item in their hand.
			 * 
			 * This will force the entity to drop the item they are holding with
			 * an option to drop the entire ItemStack or just 1 of the items.
			 */
			dropItem(dropAll: boolean): boolean;

			/**
			 * Gets the players current exhaustion level.
			 * 
			 * Exhaustion controls how fast the food level drops. While you have a
			 * certain amount of exhaustion, your saturation will drop to zero, and
			 * then your food will drop to zero.
			 */
			getExhaustion(): number;

			/**
			 * Sets the players current exhaustion level
			 */
			setExhaustion(value: number): void;

			/**
			 * Gets the players current saturation level.
			 * 
			 * Saturation is a buffer for food level. Your food level will not drop if
			 * you are saturated > 0.
			 */
			getSaturation(): number;

			/**
			 * Sets the players current saturation level
			 */
			setSaturation(value: number): void;

			/**
			 * Gets the players current food level
			 */
			getFoodLevel(): number;

			/**
			 * Sets the players current food level
			 */
			setFoodLevel(value: number): void;

			/**
			 * Get the regeneration rate (1 health per x ticks) of
			 * the HumanEntity when they have saturation and
			 * their food level is >= 20. Default is 10.
			 */
			getSaturatedRegenRate(): number;

			/**
			 * Set the regeneration rate (1 health per x ticks) of
			 * the HumanEntity when they have saturation and
			 * their food level is >= 20. Default is 10.
			 * Not affected if the world's difficulty is peaceful.
			 */
			setSaturatedRegenRate(ticks: number): void;

			/**
			 * Get the regeneration rate (1 health per x ticks) of
			 * the HumanEntity when they have no saturation and
			 * their food level is >= 18. Default is 80.
			 */
			getUnsaturatedRegenRate(): number;

			/**
			 * Get the regeneration rate (1 health per x ticks) of
			 * the HumanEntity when they have no saturation and
			 * their food level is >= 18. Default is 80.
			 * Not affected if the world's difficulty is peaceful.
			 */
			setUnsaturatedRegenRate(ticks: number): void;

			/**
			 * Get the starvation rate (1 health per x ticks) of
			 * the HumanEntity. Default is 80.
			 */
			getStarvationRate(): number;

			/**
			 * Get the starvation rate (1 health per x ticks) of
			 * the HumanEntity. Default is 80.
			 */
			setStarvationRate(ticks: number): void;

			/**
			 * Gets the player's last death location.
			 */
			getLastDeathLocation(): (org.bukkit.Location | null);

			/**
			 * Sets the player's last death location.
			 * 
			 * Note: This data is updated in the player's client only when the
			 * player respawns.
			 */
			setLastDeathLocation(location: (org.bukkit.Location | null)): void;

			/**
			 * Perform a firework boost.
			 * 
			 * This method will only work such that LivingEntity.isGliding() is true and
			 * the entity is actively gliding with an elytra. Additionally, the supplied
			 * fireworkItemStack must be a firework rocket. The power of the boost
			 * will directly correlate to FireworkMeta.getPower().
			 */
			fireworkBoost(fireworkItemStack: org.bukkit.inventory.ItemStack): (org.bukkit.entity.Firework | null);

		}> {}
		interface Husk extends Modify<org.bukkit.entity.Zombie, {
			/**
			 * Get if this entity is in the process of converting to a Zombie as a
			 * result of being underwater.
			 */
			isConverting(): boolean;

			/**
			 * Gets the amount of ticks until this entity will be converted to a Zombie
			 * as a result of being underwater.
			 * When this reaches 0, the entity will be converted.
			 */
			getConversionTime(): number;

			/**
			 * Sets the amount of ticks until this entity will be converted to a Zombie
			 * as a result of being underwater.
			 * When this reaches 0, the entity will be converted. A value of less than 0
			 * will stop the current conversion process without converting the current
			 * entity.
			 */
			setConversionTime(time: number): void;

		}> {}
		interface Illager extends Modify<org.bukkit.entity.Raider, {}> {}
		interface Illusioner extends Modify<org.bukkit.entity.Spellcaster, {}> {}
		interface Interaction extends Modify<org.bukkit.entity.Entity, {
			/**
			 * Gets the width of this interaction entity.
			 */
			getInteractionWidth(): number;

			/**
			 * Sets the width of this interaction entity.
			 */
			setInteractionWidth(width: number): void;

			/**
			 * Gets the height of this interaction entity.
			 */
			getInteractionHeight(): number;

			/**
			 * Sets the height of this interaction entity.
			 */
			setInteractionHeight(height: number): void;

			/**
			 * Gets if this interaction entity should trigger a response when interacted
			 * with.
			 */
			isResponsive(): boolean;

			/**
			 * Sets if this interaction entity should trigger a response when interacted
			 * with.
			 */
			setResponsive(response: boolean): void;

			/**
			 * Gets the last attack on this interaction entity.
			 */
			getLastAttack(): (org.bukkit.entity.Interaction.PreviousInteraction | null);

			/**
			 * Gets the last interaction on this entity.
			 */
			getLastInteraction(): (org.bukkit.entity.Interaction.PreviousInteraction | null);

		}> {}
		namespace Interaction {
			interface PreviousInteraction {
				/**
				 * Get the previous interacting player.
				 */
				getPlayer(): org.bukkit.OfflinePlayer;

				/**
				 * Gets the Unix timestamp at when this interaction occurred.
				 */
				getTimestamp(): number;

			}
		}
		interface IronGolem extends Modify<org.bukkit.entity.Golem, {
			/**
			 * Gets whether this iron golem was built by a player.
			 */
			isPlayerCreated(): boolean;

			/**
			 * Sets whether this iron golem was built by a player or not.
			 */
			setPlayerCreated(playerCreated: boolean): void;

		}> {}
		interface Item extends Modify<org.bukkit.entity.Entity, {
			/**
			 * Gets the item stack associated with this item drop.
			 */
			getItemStack(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the item stack associated with this item drop.
			 */
			setItemStack(stack: org.bukkit.inventory.ItemStack): void;

			/**
			 * Gets the delay before this Item is available to be picked up by players
			 */
			getPickupDelay(): number;

			/**
			 * Sets the delay before this Item is available to be picked up by players
			 */
			setPickupDelay(delay: number): void;

			/**
			 * Sets if this Item should live forever
			 */
			setUnlimitedLifetime(unlimited: boolean): void;

			/**
			 * Gets if this Item lives forever
			 */
			isUnlimitedLifetime(): boolean;

			/**
			 * Sets the owner of this item.
			 * Other entities will not be able to pickup this item when an owner is set.
			 */
			setOwner(owner: (globalThis.java.util.UUID | null)): void;

			/**
			 * Get the owner of this item.
			 */
			getOwner(): (globalThis.java.util.UUID | null);

			/**
			 * Set the thrower of this item.
			 * The thrower is the entity which dropped the item. This affects the
			 * trigger criteria for item pickups, for things such as advancements.
			 */
			setThrower(uuid: (globalThis.java.util.UUID | null)): void;

			/**
			 * Get the thrower of this item.
			 * The thrower is the entity which dropped the item.
			 */
			getThrower(): (globalThis.java.util.UUID | null);

		}> {}
		interface ItemDisplay extends Modify<org.bukkit.entity.Display, {
			/**
			 * Gets the displayed item stack.
			 */
			getItemStack(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Sets the displayed item stack.
			 */
			setItemStack(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Gets the item display transform for this entity.
			 * Defaults to ItemDisplay.ItemDisplayTransform.FIXED.
			 */
			getItemDisplayTransform(): org.bukkit.entity.ItemDisplay.ItemDisplayTransform;

			/**
			 * Sets the item display transform for this entity.
			 * Defaults to ItemDisplay.ItemDisplayTransform.FIXED.
			 */
			setItemDisplayTransform(display: org.bukkit.entity.ItemDisplay.ItemDisplayTransform): void;

		}> {}
		namespace ItemDisplay {
			interface ItemDisplayTransform {}
			namespace ItemDisplayTransform {
				const NONE: org.bukkit.entity.ItemDisplay.ItemDisplayTransform;

				const THIRDPERSON_LEFTHAND: org.bukkit.entity.ItemDisplay.ItemDisplayTransform;

				const THIRDPERSON_RIGHTHAND: org.bukkit.entity.ItemDisplay.ItemDisplayTransform;

				const FIRSTPERSON_LEFTHAND: org.bukkit.entity.ItemDisplay.ItemDisplayTransform;

				const FIRSTPERSON_RIGHTHAND: org.bukkit.entity.ItemDisplay.ItemDisplayTransform;

				const HEAD: org.bukkit.entity.ItemDisplay.ItemDisplayTransform;

				const GUI: org.bukkit.entity.ItemDisplay.ItemDisplayTransform;

				const GROUND: org.bukkit.entity.ItemDisplay.ItemDisplayTransform;

				const FIXED: org.bukkit.entity.ItemDisplay.ItemDisplayTransform;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.ItemDisplay.ItemDisplayTransform;

			}
		}
		interface ItemFrame extends Modify<org.bukkit.entity.Hanging, {
			/**
			 * Get the item in this frame
			 */
			getItem(): org.bukkit.inventory.ItemStack;

			/**
			 * Set the item in this frame
			 */
			setItem(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Set the item in this frame
			 */
			setItem(item: (org.bukkit.inventory.ItemStack | null), playSound: boolean): void;

			/**
			 * Gets the chance of the item being dropped upon this frame's destruction.
			 * 
			 * A drop chance of 0.0F will never drop
			 * A drop chance of 1.0F will always drop
			 * 
			 */
			getItemDropChance(): number;

			/**
			 * Sets the chance of the off hand item being dropped upon this frame's
			 * destruction.
			 * 
			 * A drop chance of 0.0F will never drop
			 * A drop chance of 1.0F will always drop
			 * 
			 */
			setItemDropChance(chance: number): void;

			/**
			 * Get the rotation of the frame's item
			 */
			getRotation(): org.bukkit.Rotation;

			/**
			 * Set the rotation of the frame's item
			 */
			setRotation(rotation: org.bukkit.Rotation): void;

			/**
			 * Returns whether the item frame is be visible or not.
			 */
			isVisible(): boolean;

			/**
			 * Sets whether the item frame should be visible or not.
			 */
			setVisible(visible: boolean): void;

			/**
			 * Returns whether the item frame is "fixed" or not.
			 * When true it's not possible to destroy/move the frame (e.g. by damage,
			 * interaction, pistons, or missing supporting blocks), rotate the item or
			 * place/remove items.
			 */
			isFixed(): boolean;

			/**
			 * Sets whether the item frame should be fixed or not.
			 * When set to true it's not possible to destroy/move the frame (e.g. by
			 * damage, interaction, pistons, or missing supporting blocks), rotate the
			 * item or place/remove items.
			 */
			setFixed(fixed: boolean): void;

		}> {}
		interface LargeFireball extends Modify<org.bukkit.entity.SizedFireball, {}> {}
		interface LeashHitch extends Modify<org.bukkit.entity.Hanging, {}> {}
		interface LightningStrike extends Modify<org.bukkit.entity.Entity, {
			/**
			 * Returns whether the strike is an effect that does no damage.
			 */
			isEffect(): boolean;

			/**
			 * Get the amount of flashes that will occur before the lightning is
			 * removed. By default this value is between 1 and 3.
			 */
			getFlashes(): number;

			/**
			 * Set the amount of flashes that will occur before the lightning is
			 * removed. One flash will occur after this lightning strike's life
			 * has reduced below 0.
			 */
			setFlashes(flashes: number): void;

			/**
			 * Get the amount of ticks this lightning strike will inflict damage
			 * upon its hit entities.
			 * 
			 * When life ticks are negative, there is a random chance that another
			 * flash will be initiated and life ticks reset to 1.
			 */
			getLifeTicks(): number;

			/**
			 * Get the amount of ticks this lightning strike will inflict damage
			 * upon its hit entities.
			 * 
			 * When life ticks are negative, there is a random chance that another
			 * flash will be initiated and life ticks reset to 1. Additionally, if
			 * life ticks are set to 2 (the default value when a lightning strike
			 * has been spawned), a list of events will occur:
			 * 
			 * Impact sound effects will be played
			 * Fire will be spawned (dependent on difficulty)
			 * Lightning rods will be powered (if hit)
			 * Copper will be stripped (if hit)
			 * GameEvent.LIGHTNING_STRIKE will be dispatched
			 * 
			 */
			setLifeTicks(ticks: number): void;

			/**
			 * Get the Player that caused this lightning to strike. This
			 * will occur naturally if a trident enchanted with
			 * Channeling were thrown at an entity
			 * during a storm.
			 */
			getCausingPlayer(): (org.bukkit.entity.Player | null);

			/**
			 * Set the Player that caused this lightning to strike.
			 */
			setCausingPlayer(player: (org.bukkit.entity.Player | null)): void;

		}> {}
		interface LingeringPotion extends Modify<org.bukkit.entity.ThrownPotion, {}> {}
		interface LivingEntity extends Modify<org.bukkit.attribute.Attributable & org.bukkit.entity.Damageable & org.bukkit.projectiles.ProjectileSource, {
			/**
			 * Gets the height of the living entity's eyes above its Location.
			 */
			getEyeHeight(): number;

			/**
			 * Gets the height of the living entity's eyes above its Location.
			 */
			getEyeHeight(ignorePose: boolean): number;

			/**
			 * Get a Location detailing the current eye position of the living entity.
			 */
			getEyeLocation(): org.bukkit.Location;

			/**
			 * Gets all blocks along the living entity's line of sight.
			 * 
			 * This list contains all blocks from the living entity's eye position to
			 * target inclusive. This method considers all blocks as 1x1x1 in size.
			 */
			getLineOfSight(transparent: (globalThis.java.util.Set<org.bukkit.Material> | null), maxDistance: number): globalThis.java.util.List<org.bukkit.block.Block>;

			/**
			 * Gets the block that the living entity has targeted.
			 * 
			 * This method considers all blocks as 1x1x1 in size. To take exact block
			 * collision shapes into account, see getTargetBlockExact(int, FluidCollisionMode).
			 */
			getTargetBlock(transparent: (globalThis.java.util.Set<org.bukkit.Material> | null), maxDistance: number): org.bukkit.block.Block;

			/**
			 * Gets the last two blocks along the living entity's line of sight.
			 * 
			 * The target block will be the last block in the list. This method
			 * considers all blocks as 1x1x1 in size.
			 */
			getLastTwoTargetBlocks(transparent: (globalThis.java.util.Set<org.bukkit.Material> | null), maxDistance: number): globalThis.java.util.List<org.bukkit.block.Block>;

			/**
			 * Gets the block that the living entity has targeted.
			 * 
			 * This takes the blocks' precise collision shapes into account. Fluids are
			 * ignored.
			 * 
			 * This may cause loading of chunks! Some implementations may impose
			 * artificial restrictions on the maximum distance.
			 */
			getTargetBlockExact(maxDistance: number): (org.bukkit.block.Block | null);

			/**
			 * Gets the block that the living entity has targeted.
			 * 
			 * This takes the blocks' precise collision shapes into account.
			 * 
			 * This may cause loading of chunks! Some implementations may impose
			 * artificial restrictions on the maximum distance.
			 */
			getTargetBlockExact(maxDistance: number, fluidCollisionMode: org.bukkit.FluidCollisionMode): (org.bukkit.block.Block | null);

			/**
			 * Performs a ray trace that provides information on the targeted block.
			 * 
			 * This takes the blocks' precise collision shapes into account. Fluids are
			 * ignored.
			 * 
			 * This may cause loading of chunks! Some implementations may impose
			 * artificial restrictions on the maximum distance.
			 */
			rayTraceBlocks(maxDistance: number): (org.bukkit.util.RayTraceResult | null);

			/**
			 * Performs a ray trace that provides information on the targeted block.
			 * 
			 * This takes the blocks' precise collision shapes into account.
			 * 
			 * This may cause loading of chunks! Some implementations may impose
			 * artificial restrictions on the maximum distance.
			 */
			rayTraceBlocks(maxDistance: number, fluidCollisionMode: org.bukkit.FluidCollisionMode): (org.bukkit.util.RayTraceResult | null);

			/**
			 * Returns the amount of air that the living entity has remaining, in
			 * ticks.
			 */
			getRemainingAir(): number;

			/**
			 * Sets the amount of air that the living entity has remaining, in ticks.
			 */
			setRemainingAir(ticks: number): void;

			/**
			 * Returns the maximum amount of air the living entity can have, in ticks.
			 */
			getMaximumAir(): number;

			/**
			 * Sets the maximum amount of air the living entity can have, in ticks.
			 */
			setMaximumAir(ticks: number): void;

			/**
			 * Gets the item that the player is using (eating food, drawing back a bow,
			 * blocking, etc.)
			 */
			getItemInUse(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Gets the number of ticks remaining for the current item's usage.
			 */
			getItemInUseTicks(): number;

			/**
			 * Sets the number of ticks that remain for the current item's usage.
			 * Applies to items that take time to use, like eating food, drawing a bow,
			 * or throwing a trident.
			 */
			setItemInUseTicks(ticks: number): void;

			/**
			 * Gets the time in ticks until the next arrow leaves the entity's body.
			 */
			getArrowCooldown(): number;

			/**
			 * Sets the time in ticks until the next arrow leaves the entity's body.
			 */
			setArrowCooldown(ticks: number): void;

			/**
			 * Gets the amount of arrows in an entity's body.
			 */
			getArrowsInBody(): number;

			/**
			 * Set the amount of arrows in the entity's body.
			 */
			setArrowsInBody(count: number): void;

			/**
			 * Returns the living entity's current maximum no damage ticks.
			 * 
			 * This is the maximum duration in which the living entity will not take
			 * damage.
			 */
			getMaximumNoDamageTicks(): number;

			/**
			 * Sets the living entity's current maximum no damage ticks.
			 */
			setMaximumNoDamageTicks(ticks: number): void;

			/**
			 * Returns the living entity's last damage taken in the current no damage
			 * ticks time.
			 * 
			 * Only damage higher than this amount will further damage the living
			 * entity.
			 */
			getLastDamage(): number;

			/**
			 * Sets the damage dealt within the current no damage ticks time period.
			 */
			setLastDamage(damage: number): void;

			/**
			 * Returns the living entity's current no damage ticks.
			 */
			getNoDamageTicks(): number;

			/**
			 * Sets the living entity's current no damage ticks.
			 */
			setNoDamageTicks(ticks: number): void;

			/**
			 * Get the ticks that this entity has performed no action.
			 * 
			 * The details of what "no action ticks" entails varies from entity to entity
			 * and cannot be specifically defined. Some examples include squid using this
			 * value to determine when to swim, raiders for when they are to be expelled
			 * from raids, or creatures (such as withers) as a requirement to be despawned.
			 */
			getNoActionTicks(): number;

			/**
			 * Set the ticks that this entity has performed no action.
			 * 
			 * The details of what "no action ticks" entails varies from entity to entity
			 * and cannot be specifically defined. Some examples include squid using this
			 * value to determine when to swim, raiders for when they are to be expelled
			 * from raids, or creatures (such as withers) as a requirement to be despawned.
			 */
			setNoActionTicks(ticks: number): void;

			/**
			 * Gets the player identified as the killer of the living entity.
			 * 
			 * May be null.
			 */
			getKiller(): (org.bukkit.entity.Player | null);

			/**
			 * Adds the given PotionEffect to the living entity.
			 */
			addPotionEffect(effect: org.bukkit.potion.PotionEffect): boolean;

			/**
			 * Adds the given PotionEffect to the living entity.
			 * 
			 * Only one potion effect can be present for a given PotionEffectType.
			 */
			addPotionEffect(effect: org.bukkit.potion.PotionEffect, force: boolean): boolean;

			/**
			 * Attempts to add all of the given PotionEffect to the living
			 * entity.
			 */
			addPotionEffects(effects: globalThis.java.util.Collection<org.bukkit.potion.PotionEffect>): boolean;

			/**
			 * Returns whether the living entity already has an existing effect of
			 * the given PotionEffectType applied to it.
			 */
			hasPotionEffect(type: org.bukkit.potion.PotionEffectType): boolean;

			/**
			 * Returns the active PotionEffect of the specified type.
			 * 
			 * If the effect is not present on the entity then null will be returned.
			 */
			getPotionEffect(type: org.bukkit.potion.PotionEffectType): (org.bukkit.potion.PotionEffect | null);

			/**
			 * Removes any effects present of the given PotionEffectType.
			 */
			removePotionEffect(type: org.bukkit.potion.PotionEffectType): void;

			/**
			 * Returns all currently active PotionEffects on the living
			 * entity.
			 */
			getActivePotionEffects(): globalThis.java.util.Collection<org.bukkit.potion.PotionEffect>;

			/**
			 * Checks whether the living entity has block line of sight to another.
			 * 
			 * This uses the same algorithm that hostile mobs use to find the closest
			 * player.
			 */
			hasLineOfSight(other: org.bukkit.entity.Entity): boolean;

			/**
			 * Returns if the living entity despawns when away from players or not.
			 * 
			 * By default, animals are not removed while other mobs are.
			 */
			getRemoveWhenFarAway(): boolean;

			/**
			 * Sets whether or not the living entity despawns when away from players
			 * or not.
			 */
			setRemoveWhenFarAway(remove: boolean): void;

			/**
			 * Gets the inventory with the equipment worn by the living entity.
			 */
			getEquipment(): (org.bukkit.inventory.EntityEquipment | null);

			/**
			 * Sets whether or not the living entity can pick up items.
			 */
			setCanPickupItems(pickup: boolean): void;

			/**
			 * Gets if the living entity can pick up items.
			 */
			getCanPickupItems(): boolean;

			/**
			 * Returns whether the entity is currently leashed.
			 */
			isLeashed(): boolean;

			/**
			 * Gets the entity that is currently leading this entity.
			 */
			getLeashHolder(): org.bukkit.entity.Entity;

			/**
			 * Sets the leash on this entity to be held by the supplied entity.
			 * 
			 * This method has no effect on EnderDragons, Withers, Players, or Bats.
			 * Non-living entities excluding leashes will not persist as leash
			 * holders.
			 */
			setLeashHolder(holder: (org.bukkit.entity.Entity | null)): boolean;

			/**
			 * Checks to see if an entity is gliding, such as using an Elytra.
			 */
			isGliding(): boolean;

			/**
			 * Makes entity start or stop gliding. This will work even if an Elytra
			 * is not equipped, but will be reverted by the server immediately after
			 * unless an event-cancelling mechanism is put in place.
			 */
			setGliding(gliding: boolean): void;

			/**
			 * Checks to see if an entity is swimming.
			 */
			isSwimming(): boolean;

			/**
			 * Makes entity start or stop swimming.
			 * This may have unexpected results if the entity is not in water.
			 */
			setSwimming(swimming: boolean): void;

			/**
			 * Checks to see if an entity is currently using the Riptide enchantment.
			 */
			isRiptiding(): boolean;

			/**
			 * Returns whether this entity is slumbering.
			 */
			isSleeping(): boolean;

			/**
			 * Gets if the entity is climbing.
			 */
			isClimbing(): boolean;

			/**
			 * Sets whether an entity will have AI.
			 * The entity will be completely unable to move if it has no AI.
			 */
			setAI(ai: boolean): void;

			/**
			 * Checks whether an entity has AI.
			 * The entity will be completely unable to move if it has no AI.
			 */
			hasAI(): boolean;

			/**
			 * Makes this entity attack the given entity with a melee attack.
			 * Attack damage is calculated by the server from the attributes and
			 * equipment of this mob, and knockback is applied to target as
			 * appropriate.
			 */
			attack(target: org.bukkit.entity.Entity): void;

			/**
			 * Makes this entity swing their main hand.
			 * This method does nothing if this entity does not have an animation for
			 * swinging their main hand.
			 */
			swingMainHand(): void;

			/**
			 * Makes this entity swing their off hand.
			 * This method does nothing if this entity does not have an animation for
			 * swinging their off hand.
			 */
			swingOffHand(): void;

			/**
			 * Makes this entity flash red as if they were damaged.
			 */
			playHurtAnimation(yaw: number): void;

			/**
			 * Set if this entity will be subject to collisions with other entities.
			 * 
			 * Exemptions to this rule can be managed with
			 * getCollidableExemptions()
			 * 
			 * Note that the client may predict the collision between itself and another
			 * entity, resulting in this flag not working for player collisions. This
			 * method should therefore only be used to set the collision status of
			 * non-player entities.
			 * 
			 * To control player collisions, use Team.Option.COLLISION_RULE in
			 * combination with a Scoreboard and a Team.
			 */
			setCollidable(collidable: boolean): void;

			/**
			 * Gets if this entity is subject to collisions with other entities.
			 * 
			 * Some entities might be exempted from the collidable rule of this entity.
			 * Use getCollidableExemptions() to get these.
			 * 
			 * Please note that this method returns only the custom collidable state,
			 * not whether the entity is non-collidable for other reasons such as being
			 * dead.
			 * 
			 * Note that the client may predict the collision between itself and another
			 * entity, resulting in this flag not being accurate for player collisions.
			 * This method should therefore only be used to check the collision status
			 * of non-player entities.
			 * 
			 * To check the collision behavior for a player, use
			 * Team.Option.COLLISION_RULE in combination with a
			 * Scoreboard and a Team.
			 */
			isCollidable(): boolean;

			/**
			 * Gets a mutable set of UUIDs of the entities which are exempt from the
			 * entity's collidable rule and which's collision with this entity will
			 * behave the opposite of it.
			 * 
			 * This set can be modified to add or remove exemptions.
			 * 
			 * For example if collidable is true and an entity is in the exemptions set
			 * then it will not collide with it. Similarly if collidable is false and an
			 * entity is in this set then it will still collide with it.
			 * 
			 * Note these exemptions are not (currently) persistent.
			 * 
			 * Note that the client may predict the collision between itself and another
			 * entity, resulting in those exemptions not being accurate for player
			 * collisions. This method should therefore only be used to exempt
			 * non-player entities.
			 * 
			 * To exempt collisions for a player, use Team.Option.COLLISION_RULE
			 * in combination with a Scoreboard and a Team.
			 */
			getCollidableExemptions(): globalThis.java.util.Set<globalThis.java.util.UUID>;

			/**
			 * Returns the value of the memory specified.
			 * 
			 * Note that the value is null when the specific entity does not have that
			 * value by default.
			 */
			getMemory<T = any>(memoryKey: org.bukkit.entity.memory.MemoryKey<T>): (T | null);

			/**
			 * Sets the value of the memory specified.
			 * 
			 * Note that the value will not be persisted when the specific entity does
			 * not have that value by default.
			 */
			setMemory<T = any>(memoryKey: org.bukkit.entity.memory.MemoryKey<T>, memoryValue: (T | null)): void;

			/**
			 * Get the Sound this entity will make when damaged.
			 */
			getHurtSound(): (org.bukkit.Sound | null);

			/**
			 * Get the Sound this entity will make on death.
			 */
			getDeathSound(): (org.bukkit.Sound | null);

			/**
			 * Get the Sound this entity will make when falling from the given
			 * height (in blocks). The sound will often differ between either a small
			 * or a big fall damage sound if the height exceeds 4 blocks.
			 */
			getFallDamageSound(fallHeight: number): org.bukkit.Sound;

			/**
			 * Get the Sound this entity will make when falling from a small
			 * height.
			 */
			getFallDamageSoundSmall(): org.bukkit.Sound;

			/**
			 * Get the Sound this entity will make when falling from a large
			 * height.
			 */
			getFallDamageSoundBig(): org.bukkit.Sound;

			/**
			 * Get the Sound this entity will make when drinking the given
			 * ItemStack.
			 */
			getDrinkingSound(itemStack: org.bukkit.inventory.ItemStack): org.bukkit.Sound;

			/**
			 * Get the Sound this entity will make when eating the given
			 * ItemStack.
			 */
			getEatingSound(itemStack: org.bukkit.inventory.ItemStack): org.bukkit.Sound;

			/**
			 * Returns true if this entity can breathe underwater and will not take
			 * suffocation damage when its air supply reaches zero.
			 */
			canBreatheUnderwater(): boolean;

			/**
			 * Get the category to which this entity belongs.
			 * Categories may subject this entity to additional effects, benefits or
			 * debuffs.
			 */
			getCategory(): org.bukkit.entity.EntityCategory;

			/**
			 * Sets whether the entity is invisible or not.
			 */
			setInvisible(invisible: boolean): void;

			/**
			 * Gets whether the entity is invisible or not.
			 */
			isInvisible(): boolean;

		}> {}
		interface Llama extends Modify<org.bukkit.entity.ChestedHorse, {
			/**
			 * Gets the llama's color.
			 */
			getColor(): org.bukkit.entity.Llama.Color;

			/**
			 * Sets the llama's color.
			 */
			setColor(color: org.bukkit.entity.Llama.Color): void;

			/**
			 * Gets the llama's strength. A higher strength llama will have more
			 * inventory slots and be more threatening to entities.
			 */
			getStrength(): number;

			/**
			 * Sets the llama's strength. A higher strength llama will have more
			 * inventory slots and be more threatening to entities. Inventory slots are
			 * equal to strength * 3.
			 */
			setStrength(strength: number): void;

			/**
			 * Description copied from interface:Â InventoryHolder
			 */
			getInventory(): org.bukkit.inventory.LlamaInventory;

		}> {}
		namespace Llama {
			interface Color {}
			namespace Color {
				/**
				 * A cream-colored llama.
				 */
				const CREAMY: org.bukkit.entity.Llama.Color;

				/**
				 * A white llama.
				 */
				const WHITE: org.bukkit.entity.Llama.Color;

				/**
				 * A brown llama.
				 */
				const BROWN: org.bukkit.entity.Llama.Color;

				/**
				 * A gray llama.
				 */
				const GRAY: org.bukkit.entity.Llama.Color;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Llama.Color;

			}
		}
		interface LlamaSpit extends Modify<org.bukkit.entity.Projectile, {}> {}
		interface MagmaCube extends Modify<org.bukkit.entity.Slime, {}> {}
		interface Marker extends Modify<org.bukkit.entity.Entity, {}> {}
		interface Minecart extends Modify<org.bukkit.entity.Vehicle, {
			/**
			 * Sets a minecart's damage.
			 */
			setDamage(damage: number): void;

			/**
			 * Gets a minecart's damage.
			 */
			getDamage(): number;

			/**
			 * Gets the maximum speed of a minecart. The speed is unrelated to the
			 * velocity.
			 */
			getMaxSpeed(): number;

			/**
			 * Sets the maximum speed of a minecart. Must be nonnegative. Default is
			 * 0.4D.
			 */
			setMaxSpeed(speed: number): void;

			/**
			 * Returns whether this minecart will slow down faster without a passenger
			 * occupying it
			 */
			isSlowWhenEmpty(): boolean;

			/**
			 * Sets whether this minecart will slow down faster without a passenger
			 * occupying it
			 */
			setSlowWhenEmpty(slow: boolean): void;

			/**
			 * Gets the flying velocity modifier. Used for minecarts that are in
			 * mid-air. A flying minecart's velocity is multiplied by this factor each
			 * tick.
			 */
			getFlyingVelocityMod(): org.bukkit.util.Vector;

			/**
			 * Sets the flying velocity modifier. Used for minecarts that are in
			 * mid-air. A flying minecart's velocity is multiplied by this factor each
			 * tick.
			 */
			setFlyingVelocityMod(flying: org.bukkit.util.Vector): void;

			/**
			 * Gets the derailed velocity modifier. Used for minecarts that are on the
			 * ground, but not on rails.
			 * 
			 * A derailed minecart's velocity is multiplied by this factor each tick.
			 */
			getDerailedVelocityMod(): org.bukkit.util.Vector;

			/**
			 * Sets the derailed velocity modifier. Used for minecarts that are on the
			 * ground, but not on rails. A derailed minecart's velocity is multiplied
			 * by this factor each tick.
			 */
			setDerailedVelocityMod(derailed: org.bukkit.util.Vector): void;

			/**
			 * Sets the display block for this minecart.
			 * Passing a null value will set the minecart to have no display block.
			 */
			setDisplayBlock(material: (org.bukkit.material.MaterialData | null)): void;

			/**
			 * Gets the display block for this minecart.
			 * This function will return the type AIR if none is set.
			 */
			getDisplayBlock(): org.bukkit.material.MaterialData;

			/**
			 * Sets the display block for this minecart.
			 * Passing a null value will set the minecart to have no display block.
			 */
			setDisplayBlockData(blockData: (org.bukkit.block.data.BlockData | null)): void;

			/**
			 * Gets the display block for this minecart.
			 * This function will return the type AIR if none is set.
			 */
			getDisplayBlockData(): org.bukkit.block.data.BlockData;

			/**
			 * Sets the offset of the display block.
			 */
			setDisplayBlockOffset(offset: number): void;

			/**
			 * Gets the offset of the display block.
			 */
			getDisplayBlockOffset(): number;

		}> {}
		interface Mob extends Modify<org.bukkit.entity.LivingEntity & org.bukkit.loot.Lootable, {
			/**
			 * Instructs this Mob to set the specified LivingEntity as its target.
			 * 
			 * Hostile creatures may attack their target, and friendly creatures may
			 * follow their target.
			 */
			setTarget(target: (org.bukkit.entity.LivingEntity | null)): void;

			/**
			 * Gets the current target of this Mob
			 */
			getTarget(): (org.bukkit.entity.LivingEntity | null);

			/**
			 * Sets whether this mob is aware of its surroundings.
			 * Unaware mobs will still move if pushed, attacked, etc. but will not move
			 * or perform any actions on their own. Unaware mobs may also have other
			 * unspecified behaviours disabled, such as drowning.
			 */
			setAware(aware: boolean): void;

			/**
			 * Gets whether this mob is aware of its surroundings.
			 * Unaware mobs will still move if pushed, attacked, etc. but will not move
			 * or perform any actions on their own. Unaware mobs may also have other
			 * unspecified behaviours disabled, such as drowning.
			 */
			isAware(): boolean;

			/**
			 * Get the Sound this mob makes while ambiently existing. This sound
			 * may change depending on the current state of the entity, and may also
			 * return null under specific conditions. This sound is not constant.
			 * For instance, villagers will make different passive noises depending
			 * on whether or not they are actively trading with a player, or make no
			 * ambient noise while sleeping.
			 */
			getAmbientSound(): (org.bukkit.Sound | null);

		}> {}
		interface Monster extends Modify<org.bukkit.entity.Creature & org.bukkit.entity.Enemy, {}> {}
		interface Mule extends Modify<org.bukkit.entity.ChestedHorse, {}> {}
		interface MushroomCow extends Modify<org.bukkit.entity.Cow, {
			/**
			 * Checks for the presence of custom potion effects to be applied to the
			 * next suspicious stew received from milking this MushroomCow.
			 */
			hasEffectsForNextStew(): boolean;

			/**
			 * Gets an immutable list containing all custom potion effects applied to
			 * the next suspicious stew received from milking this MushroomCow.
			 * 
			 * Plugins should check that hasCustomEffects() returns true before calling
			 * this method.
			 */
			getEffectsForNextStew(): globalThis.java.util.List<org.bukkit.potion.PotionEffect>;

			/**
			 * Adds a custom potion effect to be applied to the next suspicious stew
			 * received from milking this MushroomCow.
			 */
			addEffectToNextStew(effect: org.bukkit.potion.PotionEffect, overwrite: boolean): boolean;

			/**
			 * Removes a custom potion effect from being applied to the next suspicious
			 * stew received from milking this MushroomCow.
			 */
			removeEffectFromNextStew(type: org.bukkit.potion.PotionEffectType): boolean;

			/**
			 * Checks for a specific custom potion effect type to be applied to the next
			 * suspicious stew received from milking this MushroomCow.
			 */
			hasEffectForNextStew(type: org.bukkit.potion.PotionEffectType): boolean;

			/**
			 * Removes all custom potion effects to be applied to the next suspicious
			 * stew received from milking this MushroomCow.
			 */
			clearEffectsForNextStew(): void;

			/**
			 * Get the variant of this cow.
			 */
			getVariant(): org.bukkit.entity.MushroomCow.Variant;

			/**
			 * Set the variant of this cow.
			 */
			setVariant(variant: org.bukkit.entity.MushroomCow.Variant): void;

		}> {}
		namespace MushroomCow {
			interface Variant {}
			namespace Variant {
				/**
				 * Red mushroom cow.
				 */
				const RED: org.bukkit.entity.MushroomCow.Variant;

				/**
				 * Brown mushroom cow.
				 */
				const BROWN: org.bukkit.entity.MushroomCow.Variant;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.MushroomCow.Variant;

			}
		}
		interface NPC extends Modify<org.bukkit.entity.Creature, {}> {}
		interface Ocelot extends Modify<org.bukkit.entity.Animals, {
			/**
			 * Checks if this ocelot trusts players.
			 */
			isTrusting(): boolean;

			/**
			 * Sets if this ocelot trusts players.
			 */
			setTrusting(trust: boolean): void;

			/**
			 * Gets the current type of this cat.
			 */
			getCatType(): org.bukkit.entity.Ocelot.Type;

			/**
			 * Sets the current type of this cat.
			 */
			setCatType(type: org.bukkit.entity.Ocelot.Type): void;

		}> {}
		namespace Ocelot {
			interface Type {
				/**
				 * Gets the ID of this cat type.
				 */
				getId(): number;

			}
			namespace Type {
				const WILD_OCELOT: org.bukkit.entity.Ocelot.Type;

				const BLACK_CAT: org.bukkit.entity.Ocelot.Type;

				const RED_CAT: org.bukkit.entity.Ocelot.Type;

				const SIAMESE_CAT: org.bukkit.entity.Ocelot.Type;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Ocelot.Type;

				/**
				 * Gets a cat type by its ID.
				 */
				function getType(id: number): (org.bukkit.entity.Ocelot.Type | null);

			}
		}
		interface OminousItemSpawner extends Modify<org.bukkit.entity.Entity, {
			/**
			 * Gets the item which will be spawned by this spawner.
			 */
			getItem(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Sets the item which will be spawned by this spawner.
			 */
			setItem(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Gets the ticks after which this item will be spawned.
			 */
			getSpawnItemAfterTicks(): number;

			/**
			 * Sets the ticks after which this item will be spawned.
			 */
			setSpawnItemAfterTicks(ticks: number): void;

		}> {}
		interface Painting extends Modify<org.bukkit.entity.Hanging, {
			/**
			 * Get the art on this painting
			 */
			getArt(): org.bukkit.Art;

			/**
			 * Set the art on this painting
			 */
			setArt(art: org.bukkit.Art): boolean;

			/**
			 * Set the art on this painting
			 */
			setArt(art: org.bukkit.Art, force: boolean): boolean;

		}> {}
		interface Panda extends Modify<org.bukkit.entity.Animals & org.bukkit.entity.Sittable, {
			/**
			 * Gets this Panda's main gene.
			 */
			getMainGene(): org.bukkit.entity.Panda.Gene;

			/**
			 * Sets this Panda's main gene.
			 */
			setMainGene(gene: org.bukkit.entity.Panda.Gene): void;

			/**
			 * Gets this Panda's hidden gene.
			 */
			getHiddenGene(): org.bukkit.entity.Panda.Gene;

			/**
			 * Sets this Panda's hidden gene.
			 */
			setHiddenGene(gene: org.bukkit.entity.Panda.Gene): void;

			/**
			 * Gets whether the Panda is rolling
			 */
			isRolling(): boolean;

			/**
			 * Sets whether the Panda is rolling
			 */
			setRolling(flag: boolean): void;

			/**
			 * Gets whether the Panda is sneezing
			 */
			isSneezing(): boolean;

			/**
			 * Sets whether the Panda is sneezing
			 */
			setSneezing(flag: boolean): void;

			/**
			 * Gets whether the Panda is on its back
			 */
			isOnBack(): boolean;

			/**
			 * Sets whether the Panda is on its back
			 */
			setOnBack(flag: boolean): void;

			/**
			 * Gets whether the Panda is eating
			 */
			isEating(): boolean;

			/**
			 * Sets the Panda's eating status. The panda must be holding food for this to work
			 */
			setEating(flag: boolean): void;

			/**
			 * Gets whether the Panda is scared
			 */
			isScared(): boolean;

			/**
			 * Gets how many ticks the panda will be unhappy for
			 */
			getUnhappyTicks(): number;

		}> {}
		namespace Panda {
			interface Gene {
				/**
				 * Gets whether this gene is recessive, i.e. required in both parents to
				 * propagate to children.
				 */
				isRecessive(): boolean;

			}
			namespace Gene {
				const NORMAL: org.bukkit.entity.Panda.Gene;

				const LAZY: org.bukkit.entity.Panda.Gene;

				const WORRIED: org.bukkit.entity.Panda.Gene;

				const PLAYFUL: org.bukkit.entity.Panda.Gene;

				const BROWN: org.bukkit.entity.Panda.Gene;

				const WEAK: org.bukkit.entity.Panda.Gene;

				const AGGRESSIVE: org.bukkit.entity.Panda.Gene;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Panda.Gene;

			}
		}
		interface Parrot extends Modify<org.bukkit.entity.Tameable & org.bukkit.entity.Sittable, {
			/**
			 * Get the variant of this parrot.
			 */
			getVariant(): org.bukkit.entity.Parrot.Variant;

			/**
			 * Set the variant of this parrot.
			 */
			setVariant(variant: org.bukkit.entity.Parrot.Variant): void;

			/**
			 * Gets whether a parrot is dancing
			 */
			isDancing(): boolean;

		}> {}
		namespace Parrot {
			interface Variant {}
			namespace Variant {
				/**
				 * Classic parrot - red with colored wingtips.
				 */
				const RED: org.bukkit.entity.Parrot.Variant;

				/**
				 * Royal blue colored parrot.
				 */
				const BLUE: org.bukkit.entity.Parrot.Variant;

				/**
				 * Green colored parrot.
				 */
				const GREEN: org.bukkit.entity.Parrot.Variant;

				/**
				 * Cyan colored parrot.
				 */
				const CYAN: org.bukkit.entity.Parrot.Variant;

				/**
				 * Gray colored parrot.
				 */
				const GRAY: org.bukkit.entity.Parrot.Variant;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Parrot.Variant;

			}
		}
		interface Phantom extends Modify<org.bukkit.entity.Flying & org.bukkit.entity.Enemy, {
			getSize(): number;

			setSize(sz: number): void;

		}> {}
		interface Pig extends Modify<org.bukkit.entity.Steerable & org.bukkit.entity.Vehicle, {}> {}
		interface PigZombie extends Modify<org.bukkit.entity.Zombie, {
			/**
			 * Get the pig zombie's current anger level.
			 */
			getAnger(): number;

			/**
			 * Set the pig zombie's current anger level.
			 */
			setAnger(level: number): void;

			/**
			 * Shorthand; sets to either 0 or the default level.
			 */
			setAngry(angry: boolean): void;

			/**
			 * Shorthand; gets whether the zombie is angry.
			 */
			isAngry(): boolean;

			/**
			 * Not applicable to this entity
			 */
			isConverting(): boolean;

			/**
			 * Not applicable to this entity
			 */
			getConversionTime(): number;

			/**
			 * Not applicable to this entity
			 */
			setConversionTime(time: number): void;

		}> {}
		interface Piglin extends Modify<org.bukkit.entity.PiglinAbstract & org.bukkit.inventory.InventoryHolder, {
			/**
			 * Get whether the piglin is able to hunt hoglins.
			 */
			isAbleToHunt(): boolean;

			/**
			 * Sets whether the piglin is able to hunt hoglins.
			 */
			setIsAbleToHunt(flag: boolean): void;

			/**
			 * Adds a material to the allowed list of materials to barter with.
			 */
			addBarterMaterial(material: org.bukkit.Material): boolean;

			/**
			 * Removes a material from the allowed list of materials to barter with.
			 * Note: It's not possible to override the default
			 * bartering item gold_ingots as payment. To block gold_ingots see
			 * PiglinBarterEvent.
			 */
			removeBarterMaterial(material: org.bukkit.Material): boolean;

			/**
			 * Adds a material the piglin will pickup and store in his inventory.
			 */
			addMaterialOfInterest(material: org.bukkit.Material): boolean;

			/**
			 * Removes a material from the list of materials the piglin will pickup.
			 * Note: It's not possible to override the default list of
			 * item the piglin will pickup. To cancel pickup see
			 * EntityPickupItemEvent.
			 */
			removeMaterialOfInterest(material: org.bukkit.Material): boolean;

			/**
			 * Returns a immutable set of materials the piglins will pickup.
			 * 
			 * Note: This set will not include the items that are set
			 * by default. To interact with those items see
			 * EntityPickupItemEvent.
			 */
			getInterestList(): globalThis.java.util.Set<org.bukkit.Material>;

			/**
			 * Returns a immutable set of materials the piglins will barter with.
			 * Note: This set will not include the items that are set
			 * by default. To interact with those items see
			 * PiglinBarterEvent.
			 */
			getBarterList(): globalThis.java.util.Set<org.bukkit.Material>;

		}> {}
		interface PiglinAbstract extends Modify<org.bukkit.entity.Monster & org.bukkit.entity.Ageable, {
			/**
			 * Gets whether the piglin is immune to zombification.
			 */
			isImmuneToZombification(): boolean;

			/**
			 * Sets whether the piglin is immune to zombification.
			 */
			setImmuneToZombification(flag: boolean): void;

			/**
			 * Gets the amount of ticks until this entity will be converted to a
			 * Zombified Piglin.
			 * When this reaches 300, the entity will be converted.
			 */
			getConversionTime(): number;

			/**
			 * Sets the amount of ticks until this entity will be converted to a
			 * Zombified Piglin.
			 * When this reaches 0, the entity will be converted. A value of less than 0
			 * will stop the current conversion process without converting the current
			 * entity.
			 */
			setConversionTime(time: number): void;

			/**
			 * Get if this entity is in the process of converting to a Zombified Piglin.
			 */
			isConverting(): boolean;

			/**
			 * Gets whether the piglin is a baby
			 */
			isBaby(): boolean;

			/**
			 * Sets whether the piglin is a baby
			 */
			setBaby(flag: boolean): void;

		}> {}
		interface PiglinBrute extends Modify<org.bukkit.entity.PiglinAbstract, {}> {}
		interface Pillager extends Modify<org.bukkit.entity.Illager & org.bukkit.inventory.InventoryHolder, {}> {}
		interface Player extends Modify<org.bukkit.entity.HumanEntity & org.bukkit.conversations.Conversable & org.bukkit.OfflinePlayer & org.bukkit.plugin.messaging.PluginMessageRecipient, {
			/**
			 * Returns the name of this player
			 */
			getName(): string;

			/**
			 * Gets the "friendly" name to display of this player. This may include
			 * color.
			 * 
			 * Note that this name will not be displayed in game, only in chat and
			 * places defined by plugins.
			 */
			getDisplayName(): string;

			/**
			 * Sets the "friendly" name to display of this player. This may include
			 * color.
			 * 
			 * Note that this name will not be displayed in game, only in chat and
			 * places defined by plugins.
			 */
			setDisplayName(name: (string | null)): void;

			/**
			 * Gets the name that is shown on the player list.
			 */
			getPlayerListName(): string;

			/**
			 * Sets the name that is shown on the in-game player list.
			 * 
			 * If the value is null, the name will be identical to getName().
			 */
			setPlayerListName(name: (string | null)): void;

			/**
			 * Gets the currently displayed player list header for this player.
			 */
			getPlayerListHeader(): (string | null);

			/**
			 * Gets the currently displayed player list footer for this player.
			 */
			getPlayerListFooter(): (string | null);

			/**
			 * Sets the currently displayed player list header for this player.
			 */
			setPlayerListHeader(header: (string | null)): void;

			/**
			 * Sets the currently displayed player list footer for this player.
			 */
			setPlayerListFooter(footer: (string | null)): void;

			/**
			 * Sets the currently displayed player list header and footer for this
			 * player.
			 */
			setPlayerListHeaderFooter(header: (string | null), footer: (string | null)): void;

			/**
			 * Set the target of the player's compass.
			 */
			setCompassTarget(loc: org.bukkit.Location): void;

			/**
			 * Get the previously set compass target.
			 */
			getCompassTarget(): org.bukkit.Location;

			/**
			 * Gets the socket address of this player
			 */
			getAddress(): (any /* java.net.InetSocketAddress */ | null);

			/**
			 * Gets if this connection has been transferred from another server.
			 */
			isTransferred(): boolean;

			/**
			 * Retrieves a cookie from this player.
			 */
			retrieveCookie(key: org.bukkit.NamespacedKey): globalThis.java.util.concurrent.CompletableFuture;

			/**
			 * Stores a cookie in this player's client.
			 */
			storeCookie(key: org.bukkit.NamespacedKey, value: any /* byte */[]): void;

			/**
			 * Requests this player to connect to a different server specified by host
			 * and port.
			 */
			transfer(host: string, port: number): void;

			/**
			 * Sends this sender a message raw
			 */
			sendRawMessage(message: string): void;

			/**
			 * Kicks player with custom kick message.
			 */
			kickPlayer(message: (string | null)): void;

			/**
			 * Adds this user to the ProfileBanList. If a previous ban exists, this will
			 * update the entry.
			 */
			ban(reason: (string | null), expires: (globalThis.java.util.Date | null), source: (string | null), kickPlayer: boolean): (org.bukkit.BanEntry<org.bukkit.profile.PlayerProfile> | null);

			/**
			 * Adds this user to the ProfileBanList. If a previous ban exists, this will
			 * update the entry.
			 */
			ban(reason: (string | null), expires: (any /* java.time.Instant */ | null), source: (string | null), kickPlayer: boolean): (org.bukkit.BanEntry<org.bukkit.profile.PlayerProfile> | null);

			/**
			 * Adds this user to the ProfileBanList. If a previous ban exists, this will
			 * update the entry.
			 */
			ban(reason: (string | null), duration: (any /* java.time.Duration */ | null), source: (string | null), kickPlayer: boolean): (org.bukkit.BanEntry<org.bukkit.profile.PlayerProfile> | null);

			/**
			 * Adds this user's current IP address to the IpBanList. If a previous ban exists, this will
			 * update the entry. If getAddress() is null this method will throw an exception.
			 */
			banIp(reason: (string | null), expires: (globalThis.java.util.Date | null), source: (string | null), kickPlayer: boolean): (org.bukkit.BanEntry<any /* java.net.InetAddress */> | null);

			/**
			 * Adds this user's current IP address to the IpBanList. If a previous ban exists, this will
			 * update the entry. If getAddress() is null this method will throw an exception.
			 */
			banIp(reason: (string | null), expires: (any /* java.time.Instant */ | null), source: (string | null), kickPlayer: boolean): (org.bukkit.BanEntry<any /* java.net.InetAddress */> | null);

			/**
			 * Adds this user's current IP address to the IpBanList. If a previous ban exists, this will
			 * update the entry. If getAddress() is null this method will throw an exception.
			 */
			banIp(reason: (string | null), duration: (any /* java.time.Duration */ | null), source: (string | null), kickPlayer: boolean): (org.bukkit.BanEntry<any /* java.net.InetAddress */> | null);

			/**
			 * Says a message (or runs a command).
			 */
			chat(msg: string): void;

			/**
			 * Makes the player perform the given command
			 */
			performCommand(command: string): boolean;

			/**
			 * Returns true if the entity is supported by a block.
			 * This value is a state updated by the client after each movement.
			 */
			isOnGround(): boolean;

			/**
			 * Returns if the player is in sneak mode
			 */
			isSneaking(): boolean;

			/**
			 * Sets the sneak mode the player
			 */
			setSneaking(sneak: boolean): void;

			/**
			 * Gets whether the player is sprinting or not.
			 */
			isSprinting(): boolean;

			/**
			 * Sets whether the player is sprinting or not.
			 */
			setSprinting(sprinting: boolean): void;

			/**
			 * Saves the players current location, health, inventory, motion, and
			 * other information into the username.dat file, in the world/player
			 * folder
			 */
			saveData(): void;

			/**
			 * Loads the players current location, health, inventory, motion, and
			 * other information from the username.dat file, in the world/player
			 * folder.
			 * 
			 * Note: This will overwrite the players current inventory, health,
			 * motion, etc, with the state from the saved dat file.
			 */
			loadData(): void;

			/**
			 * Sets whether the player is ignored as not sleeping. If everyone is
			 * either sleeping or has this flag set, then time will advance to the
			 * next day. If everyone has this flag set but no one is actually in bed,
			 * then nothing will happen.
			 */
			setSleepingIgnored(isSleeping: boolean): void;

			/**
			 * Returns whether the player is sleeping ignored.
			 */
			isSleepingIgnored(): boolean;

			/**
			 * Gets the Location where the player will spawn at their bed, null if
			 * they have not slept in one or their current bed spawn is invalid.
			 */
			getBedSpawnLocation(): (org.bukkit.Location | null);

			/**
			 * Gets the Location where the player will spawn at, null if they
			 * don't have a valid respawn point.
			 */
			getRespawnLocation(): (org.bukkit.Location | null);

			/**
			 * Sets the Location where the player will spawn at their bed.
			 */
			setBedSpawnLocation(location: (org.bukkit.Location | null)): void;

			/**
			 * Sets the Location where the player will respawn.
			 */
			setRespawnLocation(location: (org.bukkit.Location | null)): void;

			/**
			 * Sets the Location where the player will spawn at their bed.
			 */
			setBedSpawnLocation(location: (org.bukkit.Location | null), force: boolean): void;

			/**
			 * Sets the Location where the player will respawn.
			 */
			setRespawnLocation(location: (org.bukkit.Location | null), force: boolean): void;

			/**
			 * Play a note for the player at a location.
			 * This will work with cake.
			 */
			playNote(loc: org.bukkit.Location, instrument: any /* byte */, note: any /* byte */): void;

			/**
			 * Play a note for the player at a location.
			 * This will work with cake.
			 * 
			 * This method will fail silently when called with Instrument.CUSTOM_HEAD.
			 */
			playNote(loc: org.bukkit.Location, instrument: org.bukkit.Instrument, note: org.bukkit.Note): void;

			/**
			 * Play a sound for a player at the location.
			 * 
			 * This function will fail silently if Location or Sound are null.
			 */
			playSound(location: org.bukkit.Location, sound: org.bukkit.Sound, volume: number, pitch: number): void;

			/**
			 * Play a sound for a player at the location.
			 * 
			 * This function will fail silently if Location or Sound are null. No
			 * sound will be heard by the player if their client does not have the
			 * respective sound for the value passed.
			 */
			playSound(location: org.bukkit.Location, sound: string, volume: number, pitch: number): void;

			/**
			 * Play a sound for a player at the location.
			 * 
			 * This function will fail silently if Location or Sound are null.
			 */
			playSound(location: org.bukkit.Location, sound: org.bukkit.Sound, category: org.bukkit.SoundCategory, volume: number, pitch: number): void;

			/**
			 * Play a sound for a player at the location.
			 * 
			 * This function will fail silently if Location or Sound are null. No sound
			 * will be heard by the player if their client does not have the respective
			 * sound for the value passed.
			 */
			playSound(location: org.bukkit.Location, sound: string, category: org.bukkit.SoundCategory, volume: number, pitch: number): void;

			/**
			 * Play a sound for a player at the location. For sounds with multiple
			 * variations passing the same seed will always play the same variation.
			 * 
			 * This function will fail silently if Location or Sound are null.
			 */
			playSound(location: org.bukkit.Location, sound: org.bukkit.Sound, category: org.bukkit.SoundCategory, volume: number, pitch: number, seed: number): void;

			/**
			 * Play a sound for a player at the location. For sounds with multiple
			 * variations passing the same seed will always play the same variation.
			 * 
			 * This function will fail silently if Location or Sound are null. No sound
			 * will be heard by the player if their client does not have the respective
			 * sound for the value passed.
			 */
			playSound(location: org.bukkit.Location, sound: string, category: org.bukkit.SoundCategory, volume: number, pitch: number, seed: number): void;

			/**
			 * Play a sound for a player at the location of the entity.
			 * 
			 * This function will fail silently if Entity or Sound are null.
			 */
			playSound(entity: org.bukkit.entity.Entity, sound: org.bukkit.Sound, volume: number, pitch: number): void;

			/**
			 * Play a sound for a player at the location of the entity.
			 * 
			 * This function will fail silently if Entity or Sound are null.
			 */
			playSound(entity: org.bukkit.entity.Entity, sound: string, volume: number, pitch: number): void;

			/**
			 * Play a sound for a player at the location of the entity.
			 * 
			 * This function will fail silently if Entity or Sound are null.
			 */
			playSound(entity: org.bukkit.entity.Entity, sound: org.bukkit.Sound, category: org.bukkit.SoundCategory, volume: number, pitch: number): void;

			/**
			 * Play a sound for a player at the location of the entity.
			 * 
			 * This function will fail silently if Entity or Sound are null.
			 */
			playSound(entity: org.bukkit.entity.Entity, sound: string, category: org.bukkit.SoundCategory, volume: number, pitch: number): void;

			/**
			 * Play a sound for a player at the location of the entity. For sounds with
			 * multiple variations passing the same seed will always play the same variation.
			 * 
			 * This function will fail silently if Entity or Sound are null.
			 */
			playSound(entity: org.bukkit.entity.Entity, sound: org.bukkit.Sound, category: org.bukkit.SoundCategory, volume: number, pitch: number, seed: number): void;

			/**
			 * Play a sound for a player at the location of the entity. For sounds with
			 * multiple variations passing the same seed will always play the same variation.
			 * 
			 * This function will fail silently if Entity or Sound are null.
			 */
			playSound(entity: org.bukkit.entity.Entity, sound: string, category: org.bukkit.SoundCategory, volume: number, pitch: number, seed: number): void;

			/**
			 * Stop the specified sound from playing.
			 */
			stopSound(sound: org.bukkit.Sound): void;

			/**
			 * Stop the specified sound from playing.
			 */
			stopSound(sound: string): void;

			/**
			 * Stop the specified sound from playing.
			 */
			stopSound(sound: org.bukkit.Sound, category: (org.bukkit.SoundCategory | null)): void;

			/**
			 * Stop the specified sound from playing.
			 */
			stopSound(sound: string, category: (org.bukkit.SoundCategory | null)): void;

			/**
			 * Stop the specified sound category from playing.
			 */
			stopSound(category: org.bukkit.SoundCategory): void;

			/**
			 * Stop all sounds from playing.
			 */
			stopAllSounds(): void;

			/**
			 * Plays an effect to just this player.
			 */
			playEffect(loc: org.bukkit.Location, effect: org.bukkit.Effect, data: number): void;

			/**
			 * Plays an effect to just this player.
			 */
			playEffect<T = any>(loc: org.bukkit.Location, effect: org.bukkit.Effect, data: (T | null)): void;

			/**
			 * Force this player to break a Block using the item in their main hand.
			 * This method will respect enchantments, handle item durability (if
			 * applicable) and drop experience and the correct items according to the
			 * tool/item in the player's hand.
			 * 
			 * Note that this method will call a BlockBreakEvent, meaning that
			 * this method may not be successful in breaking the block if the event was
			 * cancelled by a third party plugin. Care should be taken if running this
			 * method in a BlockBreakEvent listener as recursion may be possible if it
			 * is invoked on the same Block being broken in the event.
			 * 
			 * Additionally, a BlockDropItemEvent is called for the items
			 * dropped by this method (if successful).
			 * 
			 * The block must be in the same world as the player.
			 */
			breakBlock(block: org.bukkit.block.Block): boolean;

			/**
			 * Send a block change. This fakes a block change packet for a user at a
			 * certain location. This will not actually change the world in any way.
			 */
			sendBlockChange(loc: org.bukkit.Location, material: org.bukkit.Material, data: any /* byte */): void;

			/**
			 * Send a block change. This fakes a block change packet for a user at a
			 * certain location. This will not actually change the world in any way.
			 */
			sendBlockChange(loc: org.bukkit.Location, block: org.bukkit.block.data.BlockData): void;

			/**
			 * Send a multi-block change. This fakes a block change packet for a user
			 * at multiple locations. This will not actually change the world in any
			 * way.
			 * 
			 * This method may send multiple packets to the client depending on the
			 * blocks in the collection. A packet must be sent for each chunk section
			 * modified, meaning one packet for each 16x16x16 block area. Even if only
			 * one block is changed in two different chunk sections, two packets will
			 * be sent.
			 * 
			 * Additionally, this method cannot guarantee the functionality of changes
			 * being sent to the player in chunks not loaded by the client. It is the
			 * responsibility of the caller to ensure that the client is within range
			 * of the changed blocks or to handle any side effects caused as a result.
			 */
			sendBlockChanges(blocks: globalThis.java.util.Collection<org.bukkit.block.BlockState>): void;

			/**
			 * Send a multi-block change. This fakes a block change packet for a user
			 * at multiple locations. This will not actually change the world in any
			 * way.
			 * 
			 * This method may send multiple packets to the client depending on the
			 * blocks in the collection. A packet must be sent for each chunk section
			 * modified, meaning one packet for each 16x16x16 block area. Even if only
			 * one block is changed in two different chunk sections, two packets will
			 * be sent.
			 * 
			 * Additionally, this method cannot guarantee the functionality of changes
			 * being sent to the player in chunks not loaded by the client. It is the
			 * responsibility of the caller to ensure that the client is within range
			 * of the changed blocks or to handle any side effects caused as a result.
			 */
			sendBlockChanges(blocks: globalThis.java.util.Collection<org.bukkit.block.BlockState>, suppressLightUpdates: boolean): void;

			/**
			 * Send block damage. This fakes block break progress at a certain location
			 * sourced by this player. This will not actually change the block's break
			 * progress in any way.
			 */
			sendBlockDamage(loc: org.bukkit.Location, progress: number): void;

			/**
			 * Send block damage. This fakes block break progress at a certain location
			 * sourced by the provided entity. This will not actually change the block's
			 * break progress in any way.
			 * 
			 * At the same location for each unique damage source sent to the player, a
			 * separate damage overlay will be displayed with the given progress. This allows
			 * for block damage at different progress from multiple entities at once.
			 */
			sendBlockDamage(loc: org.bukkit.Location, progress: number, source: org.bukkit.entity.Entity): void;

			/**
			 * Send block damage. This fakes block break progress at a certain location
			 * sourced by the provided entity id. This will not actually change the block's
			 * break progress in any way.
			 * 
			 * At the same location for each unique damage source sent to the player, a
			 * separate damage overlay will be displayed with the given progress. This allows
			 * for block damage at different progress from multiple entities at once.
			 */
			sendBlockDamage(loc: org.bukkit.Location, progress: number, sourceId: number): void;

			/**
			 * Send an equipment change for the target entity. This will not
			 * actually change the entity's equipment in any way.
			 */
			sendEquipmentChange(entity: org.bukkit.entity.LivingEntity, slot: org.bukkit.inventory.EquipmentSlot, item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Send multiple equipment changes for the target entity. This will not
			 * actually change the entity's equipment in any way.
			 */
			sendEquipmentChange(entity: org.bukkit.entity.LivingEntity, items: globalThis.java.util.Map<org.bukkit.inventory.EquipmentSlot, org.bukkit.inventory.ItemStack>): void;

			/**
			 * Send a sign change. This fakes a sign change packet for a user at
			 * a certain location. This will not actually change the world in any way.
			 * This method will use a sign at the location's block or a faked sign
			 * sent via
			 * sendBlockChange(org.bukkit.Location, org.bukkit.block.data.BlockData).
			 * 
			 * If the client does not have a sign at the given location it will
			 * display an error message to the user.
			 * 
			 * To change all attributes of a sign, including the back Side, use
			 * sendBlockUpdate(org.bukkit.Location, org.bukkit.block.TileState).
			 */
			sendSignChange(loc: org.bukkit.Location, lines: (string | null)[]): void;

			/**
			 * Send a sign change. This fakes a sign change packet for a user at
			 * a certain location. This will not actually change the world in any way.
			 * This method will use a sign at the location's block or a faked sign
			 * sent via
			 * sendBlockChange(org.bukkit.Location, org.bukkit.block.data.BlockData).
			 * 
			 * If the client does not have a sign at the given location it will
			 * display an error message to the user.
			 * 
			 * To change all attributes of a sign, including the back Side, use
			 * sendBlockUpdate(org.bukkit.Location, org.bukkit.block.TileState).
			 */
			sendSignChange(loc: org.bukkit.Location, lines: (string | null)[], dyeColor: org.bukkit.DyeColor): void;

			/**
			 * Send a sign change. This fakes a sign change packet for a user at
			 * a certain location. This will not actually change the world in any way.
			 * This method will use a sign at the location's block or a faked sign
			 * sent via
			 * sendBlockChange(org.bukkit.Location, org.bukkit.block.data.BlockData).
			 * 
			 * If the client does not have a sign at the given location it will
			 * display an error message to the user.
			 * 
			 * To change all attributes of a sign, including the back Side, use
			 * sendBlockUpdate(org.bukkit.Location, org.bukkit.block.TileState).
			 */
			sendSignChange(loc: org.bukkit.Location, lines: (string | null)[], dyeColor: org.bukkit.DyeColor, hasGlowingText: boolean): void;

			/**
			 * Send a TileState change. This fakes a TileState change for a user at
			 * the given location. This will not actually change the world in any way.
			 * This method will use a TileState at the location's block or a faked TileState
			 * sent via
			 * sendBlockChange(org.bukkit.Location, org.bukkit.block.data.BlockData).
			 * 
			 * If the client does not have an appropriate tile at the given location it
			 * may display an error message to the user.
			 * 
			 * BlockData.createBlockState() can be used to create a BlockState.
			 */
			sendBlockUpdate(loc: org.bukkit.Location, tileState: org.bukkit.block.TileState): void;

			/**
			 * Change a potion effect for the target entity. This will not actually
			 * change the entity's potion effects in any way.
			 * 
			 * Note: Sending an effect change to a player for themselves may
			 * cause unexpected behavior on the client. Effects sent this way will also
			 * not be removed when their timer reaches 0, they can be removed with
			 * sendPotionEffectChangeRemove(LivingEntity, PotionEffectType)
			 */
			sendPotionEffectChange(entity: org.bukkit.entity.LivingEntity, effect: org.bukkit.potion.PotionEffect): void;

			/**
			 * Remove a potion effect for the target entity. This will not actually
			 * change the entity's potion effects in any way.
			 * 
			 * Note: Sending an effect change to a player for themselves may
			 * cause unexpected behavior on the client.
			 */
			sendPotionEffectChangeRemove(entity: org.bukkit.entity.LivingEntity, type: org.bukkit.potion.PotionEffectType): void;

			/**
			 * Render a map and send it to the player in its entirety. This may be
			 * used when streaming the map in the normal manner is not desirable.
			 */
			sendMap(map: org.bukkit.map.MapView): void;

			/**
			 * Send a hurt animation. This fakes incoming damage towards the player from
			 * the given yaw relative to the player's direction.
			 */
			sendHurtAnimation(yaw: number): void;

			/**
			 * Sends the given server links to the player.
			 */
			sendLinks(links: org.bukkit.ServerLinks): void;

			/**
			 * Add custom chat completion suggestions shown to the player while typing a
			 * message.
			 */
			addCustomChatCompletions(completions: globalThis.java.util.Collection<string>): void;

			/**
			 * Remove custom chat completion suggestions shown to the player while
			 * typing a message.
			 * Online player names cannot be removed with this method. This will affect
			 * only custom completions added by addCustomChatCompletions(Collection)
			 * or setCustomChatCompletions(Collection).
			 */
			removeCustomChatCompletions(completions: globalThis.java.util.Collection<string>): void;

			/**
			 * Set the list of chat completion suggestions shown to the player while
			 * typing a message.
			 * 
			 * If completions were set previously, this method will remove them all and
			 * replace them with the provided completions.
			 */
			setCustomChatCompletions(completions: globalThis.java.util.Collection<string>): void;

			/**
			 * Forces an update of the player's entire inventory.
			 */
			updateInventory(): void;

			/**
			 * Gets this player's previous GameMode
			 */
			getPreviousGameMode(): (org.bukkit.GameMode | null);

			/**
			 * Sets the current time on the player's client. When relative is true the
			 * player's time will be kept synchronized to its world time with the
			 * specified offset.
			 * 
			 * When using non relative time the player's time will stay fixed at the
			 * specified time parameter. It's up to the caller to continue updating
			 * the player's time. To restore player time to normal use
			 * resetPlayerTime().
			 */
			setPlayerTime(time: number, relative: boolean): void;

			/**
			 * Returns the player's current timestamp.
			 */
			getPlayerTime(): number;

			/**
			 * Returns the player's current time offset relative to server time, or
			 * the current player's fixed time if the player's time is absolute.
			 */
			getPlayerTimeOffset(): number;

			/**
			 * Returns true if the player's time is relative to the server time,
			 * otherwise the player's time is absolute and will not change its current
			 * time unless done so with setPlayerTime().
			 */
			isPlayerTimeRelative(): boolean;

			/**
			 * Restores the normal condition where the player's time is synchronized
			 * with the server time.
			 * 
			 * Equivalent to calling setPlayerTime(0, true).
			 */
			resetPlayerTime(): void;

			/**
			 * Sets the type of weather the player will see. When used, the weather
			 * status of the player is locked until resetPlayerWeather() is
			 * used.
			 */
			setPlayerWeather(type: org.bukkit.WeatherType): void;

			/**
			 * Returns the type of weather the player is currently experiencing.
			 */
			getPlayerWeather(): (org.bukkit.WeatherType | null);

			/**
			 * Restores the normal condition where the player's weather is controlled
			 * by server conditions.
			 */
			resetPlayerWeather(): void;

			/**
			 * Gets the player's cooldown between picking up experience orbs.
			 */
			getExpCooldown(): number;

			/**
			 * Sets the player's cooldown between picking up experience orbs..
			 * Note: Setting this to 0 allows the player to pick up
			 * instantly, but setting this to a negative value will cause the player to
			 * be unable to pick up xp-orbs.
			 * Calling this Method will result in PlayerExpCooldownChangeEvent
			 * being called.
			 */
			setExpCooldown(ticks: number): void;

			/**
			 * Gives the player the amount of experience specified.
			 */
			giveExp(amount: number): void;

			/**
			 * Gives the player the amount of experience levels specified. Levels can
			 * be taken by specifying a negative amount.
			 */
			giveExpLevels(amount: number): void;

			/**
			 * Gets the players current experience points towards the next level.
			 * 
			 * This is a percentage value. 0 is "no progress" and 1 is "next level".
			 */
			getExp(): number;

			/**
			 * Sets the players current experience points towards the next level
			 * 
			 * This is a percentage value. 0 is "no progress" and 1 is "next level".
			 */
			setExp(exp: number): void;

			/**
			 * Gets the players current experience level
			 */
			getLevel(): number;

			/**
			 * Sets the players current experience level
			 */
			setLevel(level: number): void;

			/**
			 * Gets the players total experience points.
			 * 
			 * This refers to the total amount of experience the player has collected
			 * over time and is not currently displayed to the client.
			 */
			getTotalExperience(): number;

			/**
			 * Sets the players current experience points.
			 * 
			 * This refers to the total amount of experience the player has collected
			 * over time and is not currently displayed to the client.
			 */
			setTotalExperience(exp: number): void;

			/**
			 * Send an experience change.
			 * This fakes an experience change packet for a user. This will not actually
			 * change the experience points in any way.
			 */
			sendExperienceChange(progress: number): void;

			/**
			 * Send an experience change.
			 * This fakes an experience change packet for a user. This will not actually
			 * change the experience points in any way.
			 */
			sendExperienceChange(progress: number, level: number): void;

			/**
			 * Determines if the Player is allowed to fly via jump key double-tap like
			 * in creative mode.
			 */
			getAllowFlight(): boolean;

			/**
			 * Sets if the Player is allowed to fly via jump key double-tap like in
			 * creative mode.
			 */
			setAllowFlight(flight: boolean): void;

			/**
			 * Hides a player from this player
			 */
			hidePlayer(player: org.bukkit.entity.Player): void;

			/**
			 * Hides a player from this player
			 */
			hidePlayer(plugin: org.bukkit.plugin.Plugin, player: org.bukkit.entity.Player): void;

			/**
			 * Allows this player to see a player that was previously hidden
			 */
			showPlayer(player: org.bukkit.entity.Player): void;

			/**
			 * Allows this player to see a player that was previously hidden. If
			 * another another plugin had hidden the player too, then the player will
			 * remain hidden until the other plugin calls this method too.
			 */
			showPlayer(plugin: org.bukkit.plugin.Plugin, player: org.bukkit.entity.Player): void;

			/**
			 * Checks to see if a player has been hidden from this player
			 */
			canSee(player: org.bukkit.entity.Player): boolean;

			/**
			 * Visually hides an entity from this player.
			 */
			hideEntity(plugin: org.bukkit.plugin.Plugin, entity: org.bukkit.entity.Entity): void;

			/**
			 * Allows this player to see an entity that was previously hidden. If
			 * another another plugin had hidden the entity too, then the entity will
			 * remain hidden until the other plugin calls this method too.
			 */
			showEntity(plugin: org.bukkit.plugin.Plugin, entity: org.bukkit.entity.Entity): void;

			/**
			 * Checks to see if an entity has been visually hidden from this player.
			 */
			canSee(entity: org.bukkit.entity.Entity): boolean;

			/**
			 * Checks to see if this player is currently flying or not.
			 */
			isFlying(): boolean;

			/**
			 * Makes this player start or stop flying.
			 */
			setFlying(value: boolean): void;

			/**
			 * Sets the speed at which a client will fly. Negative values indicate
			 * reverse directions.
			 */
			setFlySpeed(value: number): void;

			/**
			 * Sets the speed at which a client will walk. Negative values indicate
			 * reverse directions.
			 */
			setWalkSpeed(value: number): void;

			/**
			 * Gets the current allowed speed that a client can fly.
			 */
			getFlySpeed(): number;

			/**
			 * Gets the current allowed speed that a client can walk.
			 */
			getWalkSpeed(): number;

			/**
			 * Request that the player's client download and switch texture packs.
			 * 
			 * The player's client will download the new texture pack asynchronously
			 * in the background, and will automatically switch to it once the
			 * download is complete. If the client has downloaded and cached the same
			 * texture pack in the past, it will perform a file size check against
			 * the response content to determine if the texture pack has changed and
			 * needs to be downloaded again. When this request is sent for the very
			 * first time from a given server, the client will first display a
			 * confirmation GUI to the player before proceeding with the download.
			 * 
			 * Notes:
			 * 
			 * Players can disable server textures on their client, in which
			 * case this method will have no affect on them. Use the
			 * PlayerResourcePackStatusEvent to figure out whether or not
			 * the player loaded the pack!
			 * There is no concept of resetting texture packs back to default
			 * within Minecraft, so players will have to relog to do so or you
			 * have to send an empty pack.
			 * The request is send with "null" as the hash. This might result
			 * in newer versions not loading the pack correctly.
			 * 
			 */
			setTexturePack(url: string): void;

			/**
			 * Request that the player's client download and switch resource packs.
			 * 
			 * The player's client will download the new resource pack asynchronously
			 * in the background, and will automatically switch to it once the
			 * download is complete. If the client has downloaded and cached the same
			 * resource pack in the past, it will perform a file size check against
			 * the response content to determine if the resource pack has changed and
			 * needs to be downloaded again. When this request is sent for the very
			 * first time from a given server, the client will first display a
			 * confirmation GUI to the player before proceeding with the download.
			 * 
			 * Notes:
			 * 
			 * Players can disable server resources on their client, in which
			 * case this method will have no affect on them. Use the
			 * PlayerResourcePackStatusEvent to figure out whether or not
			 * the player loaded the pack!
			 * There is no concept of resetting resource packs back to default
			 * within Minecraft, so players will have to relog to do so or you
			 * have to send an empty pack.
			 * The request is send with empty string as the hash. This might result
			 * in newer versions not loading the pack correctly.
			 * 
			 */
			setResourcePack(url: string): void;

			/**
			 * Request that the player's client download and switch resource packs.
			 * 
			 * The player's client will download the new resource pack asynchronously
			 * in the background, and will automatically switch to it once the
			 * download is complete. If the client has downloaded and cached a
			 * resource pack with the same hash in the past it will not download but
			 * directly apply the cached pack. If the hash is null and the client has
			 * downloaded and cached the same resource pack in the past, it will
			 * perform a file size check against the response content to determine if
			 * the resource pack has changed and needs to be downloaded again. When
			 * this request is sent for the very first time from a given server, the
			 * client will first display a confirmation GUI to the player before
			 * proceeding with the download.
			 * 
			 * Notes:
			 * 
			 * Players can disable server resources on their client, in which
			 * case this method will have no affect on them. Use the
			 * PlayerResourcePackStatusEvent to figure out whether or not
			 * the player loaded the pack!
			 * There is no concept of resetting resource packs back to default
			 * within Minecraft, so players will have to relog to do so or you
			 * have to send an empty pack.
			 * The request is sent with empty string as the hash when the hash is
			 * not provided. This might result in newer versions not loading the
			 * pack correctly.
			 * 
			 */
			setResourcePack(url: string, hash: (any /* byte */ | null)[]): void;

			/**
			 * Request that the player's client download and switch resource packs.
			 * 
			 * The player's client will download the new resource pack asynchronously
			 * in the background, and will automatically switch to it once the
			 * download is complete. If the client has downloaded and cached a
			 * resource pack with the same hash in the past it will not download but
			 * directly apply the cached pack. If the hash is null and the client has
			 * downloaded and cached the same resource pack in the past, it will
			 * perform a file size check against the response content to determine if
			 * the resource pack has changed and needs to be downloaded again. When
			 * this request is sent for the very first time from a given server, the
			 * client will first display a confirmation GUI to the player before
			 * proceeding with the download.
			 * 
			 * Notes:
			 * 
			 * Players can disable server resources on their client, in which
			 * case this method will have no affect on them. Use the
			 * PlayerResourcePackStatusEvent to figure out whether or not
			 * the player loaded the pack!
			 * To remove a resource pack you can use
			 * removeResourcePack(UUID) or removeResourcePacks().
			 * The request is sent with empty string as the hash when the hash is
			 * not provided. This might result in newer versions not loading the
			 * pack correctly.
			 * 
			 */
			setResourcePack(url: string, hash: (any /* byte */ | null)[], prompt: (string | null)): void;

			/**
			 * Request that the player's client download and switch resource packs.
			 * 
			 * The player's client will download the new resource pack asynchronously
			 * in the background, and will automatically switch to it once the
			 * download is complete. If the client has downloaded and cached a
			 * resource pack with the same hash in the past it will not download but
			 * directly apply the cached pack. If the hash is null and the client has
			 * downloaded and cached the same resource pack in the past, it will
			 * perform a file size check against the response content to determine if
			 * the resource pack has changed and needs to be downloaded again. When
			 * this request is sent for the very first time from a given server, the
			 * client will first display a confirmation GUI to the player before
			 * proceeding with the download.
			 * 
			 * Notes:
			 * 
			 * Players can disable server resources on their client, in which
			 * case this method will have no affect on them. Use the
			 * PlayerResourcePackStatusEvent to figure out whether or not
			 * the player loaded the pack!
			 * To remove a resource pack you can use
			 * removeResourcePack(UUID) or removeResourcePacks().
			 * The request is sent with empty string as the hash when the hash is
			 * not provided. This might result in newer versions not loading the
			 * pack correctly.
			 * 
			 */
			setResourcePack(url: string, hash: (any /* byte */ | null)[], force: boolean): void;

			/**
			 * Request that the player's client download and switch resource packs.
			 * 
			 * The player's client will download the new resource pack asynchronously
			 * in the background, and will automatically switch to it once the
			 * download is complete. If the client has downloaded and cached a
			 * resource pack with the same hash in the past it will not download but
			 * directly apply the cached pack. If the hash is null and the client has
			 * downloaded and cached the same resource pack in the past, it will
			 * perform a file size check against the response content to determine if
			 * the resource pack has changed and needs to be downloaded again. When
			 * this request is sent for the very first time from a given server, the
			 * client will first display a confirmation GUI to the player before
			 * proceeding with the download.
			 * 
			 * Notes:
			 * 
			 * Players can disable server resources on their client, in which
			 * case this method will have no affect on them. Use the
			 * PlayerResourcePackStatusEvent to figure out whether or not
			 * the player loaded the pack!
			 * To remove a resource pack you can use
			 * removeResourcePack(UUID) or removeResourcePacks().
			 * The request is sent with empty string as the hash when the hash is
			 * not provided. This might result in newer versions not loading the
			 * pack correctly.
			 * 
			 */
			setResourcePack(url: string, hash: (any /* byte */ | null)[], prompt: (string | null), force: boolean): void;

			/**
			 * Request that the player's client download and switch resource packs.
			 * 
			 * The player's client will download the new resource pack asynchronously
			 * in the background, and will automatically switch to it once the
			 * download is complete. If the client has downloaded and cached a
			 * resource pack with the same hash in the past it will not download but
			 * directly apply the cached pack. If the hash is null and the client has
			 * downloaded and cached the same resource pack in the past, it will
			 * perform a file size check against the response content to determine if
			 * the resource pack has changed and needs to be downloaded again. When
			 * this request is sent for the very first time from a given server, the
			 * client will first display a confirmation GUI to the player before
			 * proceeding with the download.
			 * 
			 * Notes:
			 * 
			 * Players can disable server resources on their client, in which
			 * case this method will have no affect on them. Use the
			 * PlayerResourcePackStatusEvent to figure out whether or not
			 * the player loaded the pack!
			 * To remove a resource pack you can use
			 * removeResourcePack(UUID) or removeResourcePacks().
			 * The request is sent with empty string as the hash when the hash is
			 * not provided. This might result in newer versions not loading the
			 * pack correctly.
			 * 
			 */
			setResourcePack(id: globalThis.java.util.UUID, url: string, hash: (any /* byte */ | null)[], prompt: (string | null), force: boolean): void;

			/**
			 * Request that the player's client download and include another resource pack.
			 * 
			 * The player's client will download the new resource pack asynchronously
			 * in the background, and will automatically add to it once the
			 * download is complete. If the client has downloaded and cached a
			 * resource pack with the same hash in the past it will not download but
			 * directly apply the cached pack. If the hash is null and the client has
			 * downloaded and cached the same resource pack in the past, it will
			 * perform a file size check against the response content to determine if
			 * the resource pack has changed and needs to be downloaded again. When
			 * this request is sent for the very first time from a given server, the
			 * client will first display a confirmation GUI to the player before
			 * proceeding with the download.
			 * 
			 * Notes:
			 * 
			 * Players can disable server resources on their client, in which
			 * case this method will have no affect on them. Use the
			 * PlayerResourcePackStatusEvent to figure out whether or not
			 * the player loaded the pack!
			 * To remove a resource pack you can use
			 * removeResourcePack(UUID) or removeResourcePacks().
			 * The request is sent with empty string as the hash when the hash is
			 * not provided. This might result in newer versions not loading the
			 * pack correctly.
			 * 
			 */
			addResourcePack(id: globalThis.java.util.UUID, url: string, hash: (any /* byte */ | null)[], prompt: (string | null), force: boolean): void;

			/**
			 * Request that the player's client remove a resource pack sent by the
			 * server.
			 */
			removeResourcePack(id: globalThis.java.util.UUID): void;

			/**
			 * Request that the player's client remove all loaded resource pack sent by
			 * the server.
			 */
			removeResourcePacks(): void;

			/**
			 * Gets the Scoreboard displayed to this player
			 */
			getScoreboard(): org.bukkit.scoreboard.Scoreboard;

			/**
			 * Sets the player's visible Scoreboard.
			 */
			setScoreboard(scoreboard: org.bukkit.scoreboard.Scoreboard): void;

			/**
			 * Gets the WorldBorder visible to this Player, or null if viewing
			 * the world's world border.
			 */
			getWorldBorder(): (org.bukkit.WorldBorder | null);

			/**
			 * Sets the WorldBorder visible to this Player.
			 */
			setWorldBorder(border: (org.bukkit.WorldBorder | null)): void;

			/**
			 * Send a health update to the player. This will adjust the health, food, and
			 * saturation on the client and will not affect the player's actual values on
			 * the server. As soon as any of these values change on the server, changes sent
			 * by this method will no longer be visible.
			 */
			sendHealthUpdate(health: number, foodLevel: number, saturation: number): void;

			/**
			 * Send a health update to the player using its known server values. This will
			 * synchronize the health, food, and saturation on the client and therefore may
			 * be useful when changing a player's maximum health attribute.
			 */
			sendHealthUpdate(): void;

			/**
			 * Gets if the client is displayed a 'scaled' health, that is, health on a
			 * scale from 0-getHealthScale().
			 */
			isHealthScaled(): boolean;

			/**
			 * Sets if the client is displayed a 'scaled' health, that is, health on a
			 * scale from 0-getHealthScale().
			 * 
			 * Displayed health follows a simple formula displayedHealth =
			 * getHealth() / getMaxHealth() * getHealthScale().
			 */
			setHealthScaled(scale: boolean): void;

			/**
			 * Sets the number to scale health to for the client; this will also
			 * setHealthScaled(true).
			 * 
			 * Displayed health follows a simple formula displayedHealth =
			 * getHealth() / getMaxHealth() * getHealthScale().
			 */
			setHealthScale(scale: number): void;

			/**
			 * Gets the number that health is scaled to for the client.
			 */
			getHealthScale(): number;

			/**
			 * Gets the entity which is followed by the camera when in
			 * GameMode.SPECTATOR.
			 */
			getSpectatorTarget(): (org.bukkit.entity.Entity | null);

			/**
			 * Sets the entity which is followed by the camera when in
			 * GameMode.SPECTATOR.
			 */
			setSpectatorTarget(entity: (org.bukkit.entity.Entity | null)): void;

			/**
			 * Sends a title and a subtitle message to the player. If either of these
			 * values are null, they will not be sent and the display will remain
			 * unchanged. If they are empty strings, the display will be updated as
			 * such. If the strings contain a new line, only the first line will be
			 * sent. The titles will be displayed with the client's default timings.
			 */
			sendTitle(title: (string | null), subtitle: (string | null)): void;

			/**
			 * Sends a title and a subtitle message to the player. If either of these
			 * values are null, they will not be sent and the display will remain
			 * unchanged. If they are empty strings, the display will be updated as
			 * such. If the strings contain a new line, only the first line will be
			 * sent. All timings values may take a value of -1 to indicate that they
			 * will use the last value sent (or the defaults if no title has been
			 * displayed).
			 */
			sendTitle(title: (string | null), subtitle: (string | null), fadeIn: number, stay: number, fadeOut: number): void;

			/**
			 * Resets the title displayed to the player. This will clear the displayed
			 * title / subtitle and reset timings to their default values.
			 */
			resetTitle(): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location.
			 */
			spawnParticle(particle: org.bukkit.Particle, location: org.bukkit.Location, count: number): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location.
			 */
			spawnParticle(particle: org.bukkit.Particle, x: number, y: number, z: number, count: number): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location.
			 */
			spawnParticle<T = any>(particle: org.bukkit.Particle, location: org.bukkit.Location, count: number, data: (T | null)): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location.
			 */
			spawnParticle<T = any>(particle: org.bukkit.Particle, x: number, y: number, z: number, count: number, data: (T | null)): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location. The position of each particle will be
			 * randomized positively and negatively by the offset parameters
			 * on each axis.
			 */
			spawnParticle(particle: org.bukkit.Particle, location: org.bukkit.Location, count: number, offsetX: number, offsetY: number, offsetZ: number): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location. The position of each particle will be
			 * randomized positively and negatively by the offset parameters
			 * on each axis.
			 */
			spawnParticle(particle: org.bukkit.Particle, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location. The position of each particle will be
			 * randomized positively and negatively by the offset parameters
			 * on each axis.
			 */
			spawnParticle<T = any>(particle: org.bukkit.Particle, location: org.bukkit.Location, count: number, offsetX: number, offsetY: number, offsetZ: number, data: (T | null)): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location. The position of each particle will be
			 * randomized positively and negatively by the offset parameters
			 * on each axis.
			 */
			spawnParticle<T = any>(particle: org.bukkit.Particle, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number, data: (T | null)): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location. The position of each particle will be
			 * randomized positively and negatively by the offset parameters
			 * on each axis.
			 */
			spawnParticle(particle: org.bukkit.Particle, location: org.bukkit.Location, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location. The position of each particle will be
			 * randomized positively and negatively by the offset parameters
			 * on each axis.
			 */
			spawnParticle(particle: org.bukkit.Particle, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location. The position of each particle will be
			 * randomized positively and negatively by the offset parameters
			 * on each axis.
			 */
			spawnParticle<T = any>(particle: org.bukkit.Particle, location: org.bukkit.Location, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number, data: (T | null)): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location. The position of each particle will be
			 * randomized positively and negatively by the offset parameters
			 * on each axis.
			 */
			spawnParticle<T = any>(particle: org.bukkit.Particle, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number, data: (T | null)): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location. The position of each particle will be
			 * randomized positively and negatively by the offset parameters
			 * on each axis.
			 */
			spawnParticle<T = any>(particle: org.bukkit.Particle, location: org.bukkit.Location, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number, data: (T | null), force: boolean): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location. The position of each particle will be
			 * randomized positively and negatively by the offset parameters
			 * on each axis.
			 */
			spawnParticle<T = any>(particle: org.bukkit.Particle, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number, data: (T | null), force: boolean): void;

			/**
			 * Return the player's progression on the specified advancement.
			 */
			getAdvancementProgress(advancement: org.bukkit.advancement.Advancement): org.bukkit.advancement.AdvancementProgress;

			/**
			 * Get the player's current client side view distance.
			 * 
			 * Will default to the server view distance if the client has not yet
			 * communicated this information,
			 */
			getClientViewDistance(): number;

			/**
			 * Gets the player's estimated ping in milliseconds.
			 * In Vanilla this value represents a weighted average of the response time
			 * to application layer ping packets sent. This value does not represent the
			 * network round trip time and as such may have less granularity and be
			 * impacted by other sources. For these reasons it should not be used
			 * for anti-cheat purposes. Its recommended use is only as a
			 * qualitative indicator of connection quality (Vanilla uses it for
			 * this purpose in the tab list).
			 */
			getPing(): number;

			/**
			 * Gets the player's current locale.
			 * The value of the locale String is not defined properly.
			 * 
			 * The vanilla Minecraft client will use lowercase language / country pairs
			 * separated by an underscore, but custom resource packs may use any format
			 * they wish.
			 */
			getLocale(): string;

			/**
			 * Update the list of commands sent to the client.
			 * 
			 * Generally useful to ensure the client has a complete list of commands
			 * after permission changes are done.
			 */
			updateCommands(): void;

			/**
			 * Open a Material.WRITTEN_BOOK for a Player
			 */
			openBook(book: org.bukkit.inventory.ItemStack): void;

			/**
			 * Open a Sign for editing by the Player.
			 * The Sign must be placed in the same world as the player.
			 */
			openSign(sign: org.bukkit.block.Sign): void;

			/**
			 * Open a Sign for editing by the Player.
			 * The Sign must be placed in the same world as the player.
			 */
			openSign(sign: org.bukkit.block.Sign, side: org.bukkit.block.sign.Side): void;

			/**
			 * Shows the demo screen to the player, this screen is normally only seen in
			 * the demo version of the game.
			 * 
			 * Servers can modify the text on this screen using a resource pack.
			 */
			showDemoScreen(): void;

			/**
			 * Gets whether the player has the "Allow Server Listings" setting enabled.
			 */
			isAllowingServerListings(): boolean;

		}> {}
		interface PolarBear extends Modify<org.bukkit.entity.Animals, {}> {}
		interface Pose {}
		namespace Pose {
			/**
			 * Entity is standing normally.
			 */
			const STANDING: org.bukkit.entity.Pose;

			/**
			 * Entity is gliding.
			 */
			const FALL_FLYING: org.bukkit.entity.Pose;

			/**
			 * Entity is sleeping.
			 */
			const SLEEPING: org.bukkit.entity.Pose;

			/**
			 * Entity is swimming.
			 */
			const SWIMMING: org.bukkit.entity.Pose;

			/**
			 * Entity is riptiding with a trident.
			 */
			const SPIN_ATTACK: org.bukkit.entity.Pose;

			/**
			 * Entity is sneaking.
			 */
			const SNEAKING: org.bukkit.entity.Pose;

			/**
			 * Entity is long jumping.
			 */
			const LONG_JUMPING: org.bukkit.entity.Pose;

			/**
			 * Entity is dead.
			 */
			const DYING: org.bukkit.entity.Pose;

			/**
			 * Entity is croaking.
			 */
			const CROAKING: org.bukkit.entity.Pose;

			/**
			 * Entity is using its tongue.
			 */
			const USING_TONGUE: org.bukkit.entity.Pose;

			/**
			 * Entity is sitting.
			 */
			const SITTING: org.bukkit.entity.Pose;

			/**
			 * Entity is roaring.
			 */
			const ROARING: org.bukkit.entity.Pose;

			/**
			 * Entity is sniffing.
			 */
			const SNIFFING: org.bukkit.entity.Pose;

			/**
			 * Entity is emerging.
			 */
			const EMERGING: org.bukkit.entity.Pose;

			/**
			 * Entity is digging.
			 */
			const DIGGING: org.bukkit.entity.Pose;

			/**
			 * Entity is sliding.
			 */
			const SLIDING: org.bukkit.entity.Pose;

			/**
			 * Entity is shooting.
			 */
			const SHOOTING: org.bukkit.entity.Pose;

			/**
			 * Entity is inhaling.
			 */
			const INHALING: org.bukkit.entity.Pose;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.entity.Pose;

		}
		interface Projectile extends Modify<org.bukkit.entity.Entity, {
			/**
			 * Retrieve the shooter of this projectile.
			 */
			getShooter(): (org.bukkit.projectiles.ProjectileSource | null);

			/**
			 * Set the shooter of this projectile.
			 */
			setShooter(source: (org.bukkit.projectiles.ProjectileSource | null)): void;

			/**
			 * Determine if this projectile should bounce or not when it hits.
			 */
			doesBounce(): boolean;

			/**
			 * Set whether or not this projectile should bounce or not when it hits
			 * something.
			 */
			setBounce(doesBounce: boolean): void;

		}> {}
		interface PufferFish extends Modify<org.bukkit.entity.Fish, {
			/**
			 * Returns the current puff state of this fish (i.e. how inflated it is).
			 */
			getPuffState(): number;

			/**
			 * Sets the current puff state of this fish (i.e. how inflated it is).
			 */
			setPuffState(state: number): void;

		}> {}
		interface Rabbit extends Modify<org.bukkit.entity.Animals, {
			getRabbitType(): org.bukkit.entity.Rabbit.Type;

			setRabbitType(type: org.bukkit.entity.Rabbit.Type): void;

		}> {}
		namespace Rabbit {
			interface Type {}
			namespace Type {
				/**
				 * Chocolate colored rabbit.
				 */
				const BROWN: org.bukkit.entity.Rabbit.Type;

				/**
				 * Pure white rabbit.
				 */
				const WHITE: org.bukkit.entity.Rabbit.Type;

				/**
				 * Black rabbit.
				 */
				const BLACK: org.bukkit.entity.Rabbit.Type;

				/**
				 * Black with white patches, or white with black patches?
				 */
				const BLACK_AND_WHITE: org.bukkit.entity.Rabbit.Type;

				/**
				 * Golden bunny.
				 */
				const GOLD: org.bukkit.entity.Rabbit.Type;

				/**
				 * Salt and pepper colored, whatever that means.
				 */
				const SALT_AND_PEPPER: org.bukkit.entity.Rabbit.Type;

				/**
				 * Rabbit with pure white fur, blood red horizontal eyes, and is hostile to players.
				 */
				const THE_KILLER_BUNNY: org.bukkit.entity.Rabbit.Type;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Rabbit.Type;

			}
		}
		interface Raider extends Modify<org.bukkit.entity.Monster, {
			/**
			 * Set the Raid that this raider is participating in.
			 */
			setRaid(raid: (org.bukkit.Raid | null)): void;

			/**
			 * Get the Raid that this raider is participating in, if any.
			 */
			getRaid(): (org.bukkit.Raid | null);

			/**
			 * Get the raid wave that this raider spawned as part of.
			 */
			getWave(): number;

			/**
			 * Set the raid wave that this raider was spawned as part of.
			 */
			setWave(wave: number): void;

			/**
			 * Gets the block the raider is targeting to patrol.
			 */
			getPatrolTarget(): (org.bukkit.block.Block | null);

			/**
			 * Sets the block the raider is targeting to patrol.
			 */
			setPatrolTarget(block: (org.bukkit.block.Block | null)): void;

			/**
			 * Gets whether this entity is a patrol leader.
			 */
			isPatrolLeader(): boolean;

			/**
			 * Sets whether this entity is a patrol leader.
			 */
			setPatrolLeader(leader: boolean): void;

			/**
			 * Gets whether this mob can join an active raid.
			 */
			isCanJoinRaid(): boolean;

			/**
			 * Sets whether this mob can join an active raid.
			 */
			setCanJoinRaid(join: boolean): void;

			/**
			 * Get the amount of ticks that this mob has exited the bounds of a village
			 * as a raid participant.
			 * 
			 * This value is increased only when the mob has had no action for 2,400 ticks
			 * (according to LivingEntity.getNoActionTicks()). Once both the no action ticks have
			 * reached that value and the ticks outside a raid exceeds 30, the mob will be
			 * expelled from the raid.
			 */
			getTicksOutsideRaid(): number;

			/**
			 * Set the amount of ticks that this mob has exited the bounds of a village
			 * as a raid participant.
			 * 
			 * This value is considered only when the mob has had no action for 2,400 ticks
			 * (according to LivingEntity.getNoActionTicks()). Once both the no action ticks have
			 * reached that value and the ticks outside a raid exceeds 30, the mob will be
			 * expelled from the raid.
			 */
			setTicksOutsideRaid(ticks: number): void;

			/**
			 * Check whether or not this raider is celebrating a raid victory.
			 */
			isCelebrating(): boolean;

			/**
			 * Set whether or not this mob is celebrating a raid victory.
			 */
			setCelebrating(celebrating: boolean): void;

			/**
			 * Get the Sound this entity will play when celebrating.
			 */
			getCelebrationSound(): org.bukkit.Sound;

		}> {}
		interface Ravager extends Modify<org.bukkit.entity.Raider, {}> {}
		interface Salmon extends Modify<org.bukkit.entity.Fish, {}> {}
		interface Sheep extends Modify<org.bukkit.entity.Animals & org.bukkit.material.Colorable, {
			isSheared(): boolean;

			setSheared(flag: boolean): void;

		}> {}
		interface Shulker extends Modify<org.bukkit.entity.Golem & org.bukkit.material.Colorable & org.bukkit.entity.Enemy, {
			/**
			 * Gets the peek state of the shulker between 0.0 and 1.0.
			 */
			getPeek(): number;

			/**
			 * Sets the peek state of the shulker, should be in between 0.0 and 1.0.
			 */
			setPeek(value: number): void;

			/**
			 * Gets the face to which the shulker is attached.
			 */
			getAttachedFace(): org.bukkit.block.BlockFace;

			/**
			 * Sets the face to which the shulker is attached.
			 */
			setAttachedFace(face: org.bukkit.block.BlockFace): void;

		}> {}
		interface ShulkerBullet extends Modify<org.bukkit.entity.Projectile, {
			/**
			 * Retrieve the target of this bullet.
			 */
			getTarget(): (org.bukkit.entity.Entity | null);

			/**
			 * Sets the target of this bullet
			 */
			setTarget(target: (org.bukkit.entity.Entity | null)): void;

		}> {}
		interface Silverfish extends Modify<org.bukkit.entity.Monster, {}> {}
		interface Sittable {
			/**
			 * Checks if this animal is sitting
			 */
			isSitting(): boolean;

			/**
			 * Sets if this animal is sitting. Will remove any path that the animal
			 * was following beforehand.
			 */
			setSitting(sitting: boolean): void;

		}
		interface SizedFireball extends Modify<org.bukkit.entity.Fireball, {
			/**
			 * Gets the display ItemStack.
			 */
			getDisplayItem(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the display ItemStack for the fireball.
			 */
			setDisplayItem(item: org.bukkit.inventory.ItemStack): void;

		}> {}
		interface Skeleton extends Modify<org.bukkit.entity.AbstractSkeleton, {
			/**
			 * Computes whether or not this skeleton is currently in the process of
			 * converting to a Stray due to it being frozen by powdered snow.
			 */
			isConverting(): boolean;

			/**
			 * Gets the amount of ticks until this entity will be converted to a stray
			 * as a result of being frozen by a powdered snow block.
			 * 
			 * When this reaches 0, the entity will be converted.
			 */
			getConversionTime(): number;

			/**
			 * Sets the amount of ticks until this entity will be converted to a stray
			 * as a result of being frozen by a powdered snow block.
			 * 
			 * When this reaches 0, the entity will be converted. A value of less than 0
			 * will stop the current conversion process without converting the current
			 * entity.
			 */
			setConversionTime(time: number): void;

		}> {}
		namespace Skeleton {
			interface SkeletonType {}
			namespace SkeletonType {
				/**
				 * Standard skeleton type.
				 */
				const NORMAL: org.bukkit.entity.Skeleton.SkeletonType;

				/**
				 * Wither skeleton. Generally found in Nether fortresses.
				 */
				const WITHER: org.bukkit.entity.Skeleton.SkeletonType;

				/**
				 * Stray skeleton. Generally found in ice biomes. Shoots tipped arrows.
				 */
				const STRAY: org.bukkit.entity.Skeleton.SkeletonType;

				/**
				 * Bogged skeleton.
				 */
				const BOGGED: org.bukkit.entity.Skeleton.SkeletonType;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Skeleton.SkeletonType;

			}
		}
		interface SkeletonHorse extends Modify<org.bukkit.entity.AbstractHorse, {
			/**
			 * Returns whether this skeleton horse is trapped.
			 * 
			 * When a horse is trapped and a player comes within 10 blocks of a trapped
			 * horse, lightning will strike the horse. When struck, the skeleton trap
			 * will activate, turning the horse into a skeleton horseman as well as
			 * spawning three additional horsemen nearby.
			 */
			isTrapped(): boolean;

			/**
			 * Sets if this skeleton horse is trapped.
			 */
			setTrapped(trapped: boolean): void;

			/**
			 * Returns the horse's current trap time in ticks.
			 * Trap time is incremented every tick when isTrapped() is true.
			 * The horse automatically despawns when it reaches 18000 ticks.
			 */
			getTrapTime(): number;

			/**
			 * Sets the trap time for the horse.
			 * Values greater than 18000 will cause the horse to despawn on the next
			 * tick.
			 */
			setTrapTime(trapTime: number): void;

		}> {}
		interface Slime extends Modify<org.bukkit.entity.Mob & org.bukkit.entity.Enemy, {
			getSize(): number;

			setSize(sz: number): void;

		}> {}
		interface SmallFireball extends Modify<org.bukkit.entity.SizedFireball, {}> {}
		interface Sniffer extends Modify<org.bukkit.entity.Animals, {
			/**
			 * Gets the locations explored by the sniffer.
			 * 
			 * Note: the returned locations use sniffer's current world.
			 */
			getExploredLocations(): globalThis.java.util.Collection<org.bukkit.Location>;

			/**
			 * Remove a location of the explored locations.
			 * 
			 * Note: the location must be in the sniffer's current world for this
			 * method to have any effect.
			 */
			removeExploredLocation(location: org.bukkit.Location): void;

			/**
			 * Add a location to the explored locations.
			 * 
			 * Note: the location must be in the sniffer's current world for this
			 * method to have any effect.
			 */
			addExploredLocation(location: org.bukkit.Location): void;

			/**
			 * Get the current state of the sniffer.
			 */
			getState(): org.bukkit.entity.Sniffer.State;

			/**
			 * Set a new state for the sniffer.
			 * 
			 * This will also make the sniffer make the transition to the new state.
			 */
			setState(state: org.bukkit.entity.Sniffer.State): void;

			/**
			 * Try to get a possible location where the sniffer can dig.
			 */
			findPossibleDigLocation(): (org.bukkit.Location | null);

			/**
			 * Gets whether the sniffer can dig in the current Location below
			 * its head.
			 */
			canDig(): boolean;

		}> {}
		namespace Sniffer {
			interface State {}
			namespace State {
				const IDLING: org.bukkit.entity.Sniffer.State;

				const FEELING_HAPPY: org.bukkit.entity.Sniffer.State;

				const SCENTING: org.bukkit.entity.Sniffer.State;

				const SNIFFING: org.bukkit.entity.Sniffer.State;

				const SEARCHING: org.bukkit.entity.Sniffer.State;

				const DIGGING: org.bukkit.entity.Sniffer.State;

				const RISING: org.bukkit.entity.Sniffer.State;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Sniffer.State;

			}
		}
		interface Snowball extends Modify<org.bukkit.entity.ThrowableProjectile, {}> {}
		interface Snowman extends Modify<org.bukkit.entity.Golem, {
			/**
			 * Gets whether this snowman is in "derp mode", meaning it is not wearing a
			 * pumpkin.
			 */
			isDerp(): boolean;

			/**
			 * Sets whether this snowman is in "derp mode", meaning it is not wearing a
			 * pumpkin. NOTE: This value is not persisted to disk and will therefore
			 * reset when the chunk is reloaded.
			 */
			setDerp(derpMode: boolean): void;

		}> {}
		interface SpawnCategory {}
		namespace SpawnCategory {
			/**
			 * Entities related to Monsters, eg: Witch, Zombie, Creeper, etc.
			 */
			const MONSTER: org.bukkit.entity.SpawnCategory;

			/**
			 * Entities related to Animals, eg: Strider, Cow, Turtle, etc.
			 */
			const ANIMAL: org.bukkit.entity.SpawnCategory;

			/**
			 * Entities related to Water Animals, eg: Squid or Dolphin.
			 */
			const WATER_ANIMAL: org.bukkit.entity.SpawnCategory;

			/**
			 * Entities related to Water Ambient, eg: Cod, PufferFish, Tropical Fish,
			 * Salmon, etc.
			 */
			const WATER_AMBIENT: org.bukkit.entity.SpawnCategory;

			/**
			 * Entities related to Water Underground, eg: Glow Squid.
			 */
			const WATER_UNDERGROUND_CREATURE: org.bukkit.entity.SpawnCategory;

			/**
			 * Entities related to Ambient, eg: Bat.
			 */
			const AMBIENT: org.bukkit.entity.SpawnCategory;

			/**
			 * All the Axolotl are represented by this Category.
			 */
			const AXOLOTL: org.bukkit.entity.SpawnCategory;

			/**
			 * Entities not related to a mob, eg: Player, ArmorStand, Boat, etc.
			 */
			const MISC: org.bukkit.entity.SpawnCategory;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.entity.SpawnCategory;

		}
		interface SpectralArrow extends Modify<org.bukkit.entity.AbstractArrow, {
			/**
			 * Returns the amount of time that this arrow will apply
			 * the glowing effect for.
			 */
			getGlowingTicks(): number;

			/**
			 * Sets the amount of time to apply the glowing effect for.
			 */
			setGlowingTicks(duration: number): void;

		}> {}
		interface Spellcaster extends Modify<org.bukkit.entity.Illager, {
			/**
			 * Gets the Spellcaster.Spell the entity is currently using.
			 */
			getSpell(): org.bukkit.entity.Spellcaster.Spell;

			/**
			 * Sets the Spellcaster.Spell the entity is currently using.
			 */
			setSpell(spell: org.bukkit.entity.Spellcaster.Spell): void;

		}> {}
		namespace Spellcaster {
			interface Spell {}
			namespace Spell {
				/**
				 * No spell is being used..
				 */
				const NONE: org.bukkit.entity.Spellcaster.Spell;

				/**
				 * The spell that summons Vexes.
				 */
				const SUMMON_VEX: org.bukkit.entity.Spellcaster.Spell;

				/**
				 * The spell that summons Fangs.
				 */
				const FANGS: org.bukkit.entity.Spellcaster.Spell;

				/**
				 * The "wololo" spell.
				 */
				const WOLOLO: org.bukkit.entity.Spellcaster.Spell;

				/**
				 * The spell that makes the casting entity invisible.
				 */
				const DISAPPEAR: org.bukkit.entity.Spellcaster.Spell;

				/**
				 * The spell that makes the target blind.
				 */
				const BLINDNESS: org.bukkit.entity.Spellcaster.Spell;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Spellcaster.Spell;

			}
		}
		interface Spider extends Modify<org.bukkit.entity.Monster, {}> {}
		interface SplashPotion extends Modify<org.bukkit.entity.ThrownPotion, {}> {}
		interface Squid extends Modify<org.bukkit.entity.WaterMob, {}> {}
		interface Steerable extends Modify<org.bukkit.entity.Animals, {
			/**
			 * Check if the pig has a saddle.
			 */
			hasSaddle(): boolean;

			/**
			 * Sets if the pig has a saddle or not
			 */
			setSaddle(saddled: boolean): void;

			/**
			 * Get the time in ticks this entity's movement is being increased.
			 * Movement speed is often increased as a result of using the
			 * getSteerMaterial().
			 */
			getBoostTicks(): number;

			/**
			 * Set the time in ticks this entity's movement will be increased.
			 * This will reset the current boost ticks to 0
			 * (getCurrentBoostTicks()).
			 */
			setBoostTicks(ticks: number): void;

			/**
			 * Get the time in ticks this entity's movement has been increased as of the
			 * most recent boost.
			 * Current boost ticks will never be > getBoostTicks().
			 */
			getCurrentBoostTicks(): number;

			/**
			 * Set the time in ticks this entity's movement has been increased relative
			 * to the most recent boost.
			 */
			setCurrentBoostTicks(ticks: number): void;

			/**
			 * Get the material used to steer this entity when ridden by a player.
			 */
			getSteerMaterial(): org.bukkit.Material;

		}> {}
		interface Stray extends Modify<org.bukkit.entity.AbstractSkeleton, {}> {}
		interface Strider extends Modify<org.bukkit.entity.Steerable & org.bukkit.entity.Vehicle, {
			/**
			 * Check whether or not this strider is out of warm blocks and shivering.
			 */
			isShivering(): boolean;

			/**
			 * Set whether or not this strider is shivering.
			 * Note that the shivering state is updated frequently on the server,
			 * therefore this method may not affect the entity for long enough to have a
			 * noticeable difference.
			 */
			setShivering(shivering: boolean): void;

		}> {}
		interface TNTPrimed extends Modify<org.bukkit.entity.Explosive, {
			/**
			 * Set the number of ticks until the TNT blows up after being primed.
			 */
			setFuseTicks(fuseTicks: number): void;

			/**
			 * Retrieve the number of ticks until the explosion of this TNTPrimed
			 * entity
			 */
			getFuseTicks(): number;

			/**
			 * Gets the source of this primed TNT. The source is the entity
			 * responsible for the creation of this primed TNT. (I.E. player ignites
			 * TNT with flint and steel.) Take note that this can be null if there is
			 * no suitable source. (created by the RegionAccessor.spawn(Location, Class) method, for example.)
			 * 
			 * The source will become null if the chunk this primed TNT is in is
			 * unloaded then reloaded. The source entity may be invalid if for example
			 * it has since died or been unloaded. Callers should check
			 * Entity.isValid().
			 */
			getSource(): (org.bukkit.entity.Entity | null);

			/**
			 * Sets the source of this primed TNT.
			 * The source is the entity responsible for the creation of this primed TNT.
			 * 
			 * Must be instance of LivingEntity otherwise will
			 * be set to null. The parameter is typed Entity to be consistent with getSource() method.
			 */
			setSource(source: (org.bukkit.entity.Entity | null)): void;

		}> {}
		interface Tadpole extends Modify<org.bukkit.entity.Fish, {
			/**
			 * Gets the age of this mob.
			 */
			getAge(): number;

			/**
			 * Sets the age of this mob.
			 */
			setAge(age: number): void;

		}> {}
		interface Tameable extends Modify<org.bukkit.entity.Animals, {
			/**
			 * Check if this is tamed
			 * 
			 * If something is tamed then a player can not tame it through normal
			 * methods, even if it does not belong to anyone in particular.
			 */
			isTamed(): boolean;

			/**
			 * Sets if this has been tamed. Not necessary if the method setOwner has
			 * been used, as it tames automatically.
			 * 
			 * If something is tamed then a player can not tame it through normal
			 * methods, even if it does not belong to anyone in particular.
			 */
			setTamed(tame: boolean): void;

			/**
			 * Gets the current owning AnimalTamer
			 */
			getOwner(): (org.bukkit.entity.AnimalTamer | null);

			/**
			 * Set this to be owned by given AnimalTamer.
			 * 
			 * If the owner is not null, this will be tamed and will have any current
			 * path it is following removed. If the owner is set to null, this will be
			 * untamed, and the current owner removed.
			 */
			setOwner(tamer: (org.bukkit.entity.AnimalTamer | null)): void;

		}> {}
		interface TextDisplay extends Modify<org.bukkit.entity.Display, {
			/**
			 * Gets the displayed text.
			 */
			getText(): (string | null);

			/**
			 * Sets the displayed text.
			 */
			setText(text: (string | null)): void;

			/**
			 * Gets the maximum line width before wrapping.
			 */
			getLineWidth(): number;

			/**
			 * Sets the maximum line width before wrapping.
			 */
			setLineWidth(width: number): void;

			/**
			 * Gets the text background color.
			 */
			getBackgroundColor(): (org.bukkit.Color | null);

			/**
			 * Sets the text background color.
			 */
			setBackgroundColor(color: (org.bukkit.Color | null)): void;

			/**
			 * Gets the text opacity.
			 */
			getTextOpacity(): any /* byte */;

			/**
			 * Sets the text opacity.
			 */
			setTextOpacity(opacity: any /* byte */): void;

			/**
			 * Gets if the text is shadowed.
			 */
			isShadowed(): boolean;

			/**
			 * Sets if the text is shadowed.
			 */
			setShadowed(shadow: boolean): void;

			/**
			 * Gets if the text is see through.
			 */
			isSeeThrough(): boolean;

			/**
			 * Sets if the text is see through.
			 */
			setSeeThrough(seeThrough: boolean): void;

			/**
			 * Gets if the text has its default background.
			 */
			isDefaultBackground(): boolean;

			/**
			 * Sets if the text has its default background.
			 */
			setDefaultBackground(defaultBackground: boolean): void;

			/**
			 * Gets the text alignment for this display.
			 */
			getAlignment(): org.bukkit.entity.TextDisplay.TextAlignment;

			/**
			 * Sets the text alignment for this display.
			 */
			setAlignment(alignment: org.bukkit.entity.TextDisplay.TextAlignment): void;

		}> {}
		namespace TextDisplay {
			interface TextAlignment {}
			namespace TextAlignment {
				/**
				 * Center aligned text (default).
				 */
				const CENTER: org.bukkit.entity.TextDisplay.TextAlignment;

				/**
				 * Left aligned text.
				 */
				const LEFT: org.bukkit.entity.TextDisplay.TextAlignment;

				/**
				 * Right aligned text.
				 */
				const RIGHT: org.bukkit.entity.TextDisplay.TextAlignment;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.TextDisplay.TextAlignment;

			}
		}
		interface ThrowableProjectile extends Modify<org.bukkit.entity.Projectile, {
			/**
			 * Gets the ItemStack the thrown projectile will display.
			 */
			getItem(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the display ItemStack for the thrown projectile.
			 */
			setItem(item: org.bukkit.inventory.ItemStack): void;

		}> {}
		interface ThrownExpBottle extends Modify<org.bukkit.entity.ThrowableProjectile, {}> {}
		interface ThrownPotion extends Modify<org.bukkit.entity.ThrowableProjectile, {
			/**
			 * Returns the effects that are applied by this potion.
			 */
			getEffects(): globalThis.java.util.Collection<org.bukkit.potion.PotionEffect>;

			/**
			 * Returns a copy of the ItemStack for this thrown potion.
			 * 
			 * Altering this copy will not alter the thrown potion directly. If you want
			 * to alter the thrown potion, you must use the setItemStack method.
			 */
			getItem(): org.bukkit.inventory.ItemStack;

			/**
			 * Set the ItemStack for this thrown potion.
			 * 
			 * The ItemStack must be of type Material.SPLASH_POTION
			 * or Material.LINGERING_POTION, otherwise an exception
			 * is thrown.
			 */
			setItem(item: org.bukkit.inventory.ItemStack): void;

		}> {}
		interface TippedArrow extends Modify<org.bukkit.entity.Arrow, {}> {}
		interface TraderLlama extends Modify<org.bukkit.entity.Llama, {}> {}
		interface Trident extends Modify<org.bukkit.entity.AbstractArrow & org.bukkit.entity.ThrowableProjectile, {}> {}
		interface TropicalFish extends Modify<org.bukkit.entity.Fish, {
			/**
			 * Gets the color of the fish's pattern.
			 */
			getPatternColor(): org.bukkit.DyeColor;

			/**
			 * Sets the color of the fish's pattern
			 */
			setPatternColor(color: org.bukkit.DyeColor): void;

			/**
			 * Gets the color of the fish's body.
			 */
			getBodyColor(): org.bukkit.DyeColor;

			/**
			 * Sets the color of the fish's body
			 */
			setBodyColor(color: org.bukkit.DyeColor): void;

			/**
			 * Gets the fish's pattern.
			 */
			getPattern(): org.bukkit.entity.TropicalFish.Pattern;

			/**
			 * Sets the fish's pattern
			 */
			setPattern(pattern: org.bukkit.entity.TropicalFish.Pattern): void;

		}> {}
		namespace TropicalFish {
			interface Pattern {}
			namespace Pattern {
				const KOB: org.bukkit.entity.TropicalFish.Pattern;

				const SUNSTREAK: org.bukkit.entity.TropicalFish.Pattern;

				const SNOOPER: org.bukkit.entity.TropicalFish.Pattern;

				const DASHER: org.bukkit.entity.TropicalFish.Pattern;

				const BRINELY: org.bukkit.entity.TropicalFish.Pattern;

				const SPOTTY: org.bukkit.entity.TropicalFish.Pattern;

				const FLOPPER: org.bukkit.entity.TropicalFish.Pattern;

				const STRIPEY: org.bukkit.entity.TropicalFish.Pattern;

				const GLITTER: org.bukkit.entity.TropicalFish.Pattern;

				const BLOCKFISH: org.bukkit.entity.TropicalFish.Pattern;

				const BETTY: org.bukkit.entity.TropicalFish.Pattern;

				const CLAYFISH: org.bukkit.entity.TropicalFish.Pattern;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.TropicalFish.Pattern;

			}
		}
		interface Turtle extends Modify<org.bukkit.entity.Animals, {
			/**
			 * Gets whether the turtle has an egg
			 */
			hasEgg(): boolean;

			/**
			 * Gets whether the turtle is laying an egg
			 */
			isLayingEgg(): boolean;

		}> {}
		interface Vehicle extends Modify<org.bukkit.entity.Entity, {
			/**
			 * Gets the vehicle's velocity.
			 */
			getVelocity(): org.bukkit.util.Vector;

			/**
			 * Sets the vehicle's velocity in meters per tick.
			 */
			setVelocity(vel: org.bukkit.util.Vector): void;

		}> {}
		interface Vex extends Modify<org.bukkit.entity.Monster, {
			/**
			 * Gets the charging state of this entity.
			 * When this entity is charging it will having a glowing red texture.
			 */
			isCharging(): boolean;

			/**
			 * Sets the charging state of this entity.
			 * When this entity is charging it will having a glowing red texture.
			 */
			setCharging(charging: boolean): void;

			/**
			 * Gets the bound of this entity.
			 * An idle vex will navigate a 15x11x15 area centered around its bound
			 * location.
			 * When summoned by an Evoker, this location will be set to that of the
			 * summoner.
			 */
			getBound(): (org.bukkit.Location | null);

			/**
			 * Sets the bound of this entity.
			 * An idle vex will navigate a 15x11x15 area centered around its bound
			 * location.
			 * When summoned by an Evoker, this location will be set to that of the
			 * summoner.
			 */
			setBound(location: (org.bukkit.Location | null)): void;

			/**
			 * Gets the remaining lifespan of this entity.
			 */
			getLifeTicks(): number;

			/**
			 * Sets the remaining lifespan of this entity.
			 */
			setLifeTicks(lifeTicks: number): void;

			/**
			 * Gets if the entity has a limited life.
			 */
			hasLimitedLife(): boolean;

		}> {}
		interface Villager extends Modify<org.bukkit.entity.AbstractVillager, {
			/**
			 * Gets the current profession of this villager.
			 */
			getProfession(): org.bukkit.entity.Villager.Profession;

			/**
			 * Sets the new profession of this villager.
			 */
			setProfession(profession: org.bukkit.entity.Villager.Profession): void;

			/**
			 * Gets the current type of this villager.
			 */
			getVillagerType(): org.bukkit.entity.Villager.Type;

			/**
			 * Sets the new type of this villager.
			 */
			setVillagerType(type: org.bukkit.entity.Villager.Type): void;

			/**
			 * Gets the level of this villager.
			 * A villager with a level of 1 and no experience is liable to lose its
			 * profession.
			 */
			getVillagerLevel(): number;

			/**
			 * Sets the level of this villager.
			 * A villager with a level of 1 and no experience is liable to lose its
			 * profession.
			 */
			setVillagerLevel(level: number): void;

			/**
			 * Gets the trading experience of this villager.
			 */
			getVillagerExperience(): number;

			/**
			 * Sets the trading experience of this villager.
			 */
			setVillagerExperience(experience: number): void;

			/**
			 * Attempts to make this villager sleep at the given location.
			 * 
			 * The location must be in the current world and have a bed placed at the
			 * location. The villager will put its head on the specified block while
			 * sleeping.
			 */
			sleep(location: org.bukkit.Location): boolean;

			/**
			 * Causes this villager to wake up if he's currently sleeping.
			 */
			wakeup(): void;

			/**
			 * Causes this villager to shake his head.
			 */
			shakeHead(): void;

			/**
			 * Convert this Villager into a ZombieVillager as if it was killed by a
			 * Zombie.
			 * Note: this will fire a EntityTransformEvent
			 */
			zombify(): (org.bukkit.entity.ZombieVillager | null);

		}> {}
		namespace Villager {
			interface Profession {
				/**
				 * Description copied from interface:Â Keyed
				 */
				getKey(): org.bukkit.NamespacedKey;

			}
			namespace Profession {
				const NONE: org.bukkit.entity.Villager.Profession;

				/**
				 * Armorer profession. Wears a black apron. Armorers primarily trade for
				 * iron armor, chainmail armor, and sometimes diamond armor.
				 */
				const ARMORER: org.bukkit.entity.Villager.Profession;

				/**
				 * Butcher profession. Wears a white apron. Butchers primarily trade for
				 * raw and cooked food.
				 */
				const BUTCHER: org.bukkit.entity.Villager.Profession;

				/**
				 * Cartographer profession. Wears a white robe. Cartographers primarily
				 * trade for explorer maps and some paper.
				 */
				const CARTOGRAPHER: org.bukkit.entity.Villager.Profession;

				/**
				 * Cleric profession. Wears a purple robe. Clerics primarily trade for
				 * rotten flesh, gold ingot, redstone, lapis, ender pearl, glowstone,
				 * and bottle o' enchanting.
				 */
				const CLERIC: org.bukkit.entity.Villager.Profession;

				/**
				 * Farmer profession. Wears a brown robe. Farmers primarily trade for
				 * food-related items.
				 */
				const FARMER: org.bukkit.entity.Villager.Profession;

				/**
				 * Fisherman profession. Wears a brown robe. Fisherman primarily trade
				 * for fish, as well as possibly selling string and/or coal.
				 */
				const FISHERMAN: org.bukkit.entity.Villager.Profession;

				/**
				 * Fletcher profession. Wears a brown robe. Fletchers primarily trade
				 * for string, bows, and arrows.
				 */
				const FLETCHER: org.bukkit.entity.Villager.Profession;

				/**
				 * Leatherworker profession. Wears a white apron. Leatherworkers
				 * primarily trade for leather, and leather armor, as well as saddles.
				 */
				const LEATHERWORKER: org.bukkit.entity.Villager.Profession;

				/**
				 * Librarian profession. Wears a white robe. Librarians primarily trade
				 * for paper, books, and enchanted books.
				 */
				const LIBRARIAN: org.bukkit.entity.Villager.Profession;

				/**
				 * Mason profession.
				 */
				const MASON: org.bukkit.entity.Villager.Profession;

				/**
				 * Nitwit profession. Wears a green apron, cannot trade. Nitwit
				 * villagers do not do anything. They do not have any trades by default.
				 */
				const NITWIT: org.bukkit.entity.Villager.Profession;

				/**
				 * Sheperd profession. Wears a brown robe. Shepherds primarily trade for
				 * wool items, and shears.
				 */
				const SHEPHERD: org.bukkit.entity.Villager.Profession;

				/**
				 * Toolsmith profession. Wears a black apron. Tool smiths primarily
				 * trade for iron and diamond tools.
				 */
				const TOOLSMITH: org.bukkit.entity.Villager.Profession;

				/**
				 * Weaponsmith profession. Wears a black apron. Weapon smiths primarily
				 * trade for iron and diamond weapons, sometimes enchanted.
				 */
				const WEAPONSMITH: org.bukkit.entity.Villager.Profession;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Villager.Profession;

			}
		}
		namespace Villager {
			interface Type {
				/**
				 * Description copied from interface:Â Keyed
				 */
				getKey(): org.bukkit.NamespacedKey;

			}
			namespace Type {
				const DESERT: org.bukkit.entity.Villager.Type;

				const JUNGLE: org.bukkit.entity.Villager.Type;

				const PLAINS: org.bukkit.entity.Villager.Type;

				const SAVANNA: org.bukkit.entity.Villager.Type;

				const SNOW: org.bukkit.entity.Villager.Type;

				const SWAMP: org.bukkit.entity.Villager.Type;

				const TAIGA: org.bukkit.entity.Villager.Type;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Villager.Type;

			}
		}
		interface Vindicator extends Modify<org.bukkit.entity.Illager, {
			/**
			 * Returns whether a vindicator is in "Johnny" mode.
			 * When this mode is active, vindicators will be hostile to all mobs.
			 */
			isJohnny(): boolean;

			/**
			 * Sets the Johnny state of a vindicator.
			 */
			setJohnny(johnny: boolean): void;

		}> {}
		interface WanderingTrader extends Modify<org.bukkit.entity.AbstractVillager, {
			/**
			 * Gets the despawn delay before this WanderingTrader is forcibly
			 * despawned.
			 * If this is less than or equal to 0, then the trader will not be
			 * despawned.
			 */
			getDespawnDelay(): number;

			/**
			 * Sets the despawn delay before this WanderingTrader is forcibly
			 * despawned.
			 * If this is less than or equal to 0, then the trader will not be
			 * despawned.
			 */
			setDespawnDelay(despawnDelay: number): void;

		}> {}
		interface Warden extends Modify<org.bukkit.entity.Monster, {
			/**
			 * Gets the anger level of this warden.
			 * Anger is an integer from 0 to 150. Once a Warden reaches 80 anger at a
			 * target it will actively pursue it.
			 */
			getAnger(): number;

			/**
			 * Gets the anger level of this warden.
			 * Anger is an integer from 0 to 150. Once a Warden reaches 80 anger at a
			 * target it will actively pursue it.
			 */
			getAnger(entity: org.bukkit.entity.Entity): number;

			/**
			 * Increases the anger level of this warden.
			 * Anger is an integer from 0 to 150. Once a Warden reaches 80 anger at a
			 * target it will actively pursue it.
			 */
			increaseAnger(entity: org.bukkit.entity.Entity, increase: number): void;

			/**
			 * Sets the anger level of this warden.
			 * Anger is an integer from 0 to 150. Once a Warden reaches 80 anger at a
			 * target it will actively pursue it.
			 */
			setAnger(entity: org.bukkit.entity.Entity, anger: number): void;

			/**
			 * Clears the anger level of this warden.
			 */
			clearAnger(entity: org.bukkit.entity.Entity): void;

			/**
			 * Gets the LivingEntity at which this warden is most angry.
			 */
			getEntityAngryAt(): (org.bukkit.entity.LivingEntity | null);

			/**
			 * Make the warden sense a disturbance in the force at the location given.
			 */
			setDisturbanceLocation(location: org.bukkit.Location): void;

			/**
			 * Get the level of anger of this warden.
			 */
			getAngerLevel(): org.bukkit.entity.Warden.AngerLevel;

		}> {}
		namespace Warden {
			interface AngerLevel {}
			namespace AngerLevel {
				/**
				 * Anger level 0-39.
				 */
				const CALM: org.bukkit.entity.Warden.AngerLevel;

				/**
				 * Anger level 40-79.
				 */
				const AGITATED: org.bukkit.entity.Warden.AngerLevel;

				/**
				 * Anger level 80 or above.
				 */
				const ANGRY: org.bukkit.entity.Warden.AngerLevel;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Warden.AngerLevel;

			}
		}
		interface WaterMob extends Modify<org.bukkit.entity.Creature, {}> {}
		interface WindCharge extends Modify<org.bukkit.entity.AbstractWindCharge, {}> {}
		interface Witch extends Modify<org.bukkit.entity.Raider, {
			/**
			 * Gets whether the witch is drinking a potion
			 */
			isDrinkingPotion(): boolean;

		}> {}
		interface Wither extends Modify<org.bukkit.entity.Monster & org.bukkit.entity.Boss, {
			/**
			 * Instructs this Mob to set the specified LivingEntity as its target.
			 * 
			 * Hostile creatures may attack their target, and friendly creatures may
			 * follow their target.
			 * 
			 * This method will set the target of the center head of
			 * the wither.
			 */
			setTarget(target: (org.bukkit.entity.LivingEntity | null)): void;

			/**
			 * This method will set the target of individual heads Wither.Head of the
			 * wither.
			 */
			setTarget(head: org.bukkit.entity.Wither.Head, target: (org.bukkit.entity.LivingEntity | null)): void;

			/**
			 * This method will get the target of individual heads Wither.Head of the
			 * wither.
			 */
			getTarget(head: org.bukkit.entity.Wither.Head): (org.bukkit.entity.LivingEntity | null);

			/**
			 * Returns the wither's current invulnerability ticks.
			 */
			getInvulnerabilityTicks(): number;

			/**
			 * Sets the wither's current invulnerability ticks.
			 * When invulnerability ticks reach 0, the wither will trigger an explosion.
			 */
			setInvulnerabilityTicks(ticks: number): void;

		}> {}
		namespace Wither {
			interface Head {}
			namespace Head {
				const CENTER: org.bukkit.entity.Wither.Head;

				const LEFT: org.bukkit.entity.Wither.Head;

				const RIGHT: org.bukkit.entity.Wither.Head;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.entity.Wither.Head;

			}
		}
		interface WitherSkeleton extends Modify<org.bukkit.entity.AbstractSkeleton, {}> {}
		interface WitherSkull extends Modify<org.bukkit.entity.Fireball, {
			/**
			 * Sets the charged status of the wither skull.
			 */
			setCharged(charged: boolean): void;

			/**
			 * Gets whether or not the wither skull is charged.
			 */
			isCharged(): boolean;

		}> {}
		interface Wolf extends Modify<org.bukkit.entity.Tameable & org.bukkit.entity.Sittable, {
			/**
			 * Checks if this wolf is angry
			 */
			isAngry(): boolean;

			/**
			 * Sets the anger of this wolf.
			 * 
			 * An angry wolf can not be fed or tamed.
			 */
			setAngry(angry: boolean): void;

			/**
			 * Get the collar color of this wolf
			 */
			getCollarColor(): org.bukkit.DyeColor;

			/**
			 * Set the collar color of this wolf
			 */
			setCollarColor(color: org.bukkit.DyeColor): void;

			/**
			 * Gets whether the wolf is wet
			 */
			isWet(): boolean;

			/**
			 * Gets the wolf's tail angle in radians
			 */
			getTailAngle(): number;

			/**
			 * Gets if the wolf is interested
			 */
			isInterested(): boolean;

			/**
			 * Set wolf to be interested
			 */
			setInterested(interested: boolean): void;

			/**
			 * Get the variant of this wolf.
			 */
			getVariant(): org.bukkit.entity.Wolf.Variant;

			/**
			 * Set the variant of this wolf.
			 */
			setVariant(variant: org.bukkit.entity.Wolf.Variant): void;

		}> {}
		namespace Wolf {
			interface Variant extends Modify<org.bukkit.Keyed, {}> {}
			namespace Variant {
				const PALE: org.bukkit.entity.Wolf.Variant;

				const SPOTTED: org.bukkit.entity.Wolf.Variant;

				const SNOWY: org.bukkit.entity.Wolf.Variant;

				const BLACK: org.bukkit.entity.Wolf.Variant;

				const ASHEN: org.bukkit.entity.Wolf.Variant;

				const RUSTY: org.bukkit.entity.Wolf.Variant;

				const WOODS: org.bukkit.entity.Wolf.Variant;

				const CHESTNUT: org.bukkit.entity.Wolf.Variant;

				const STRIPED: org.bukkit.entity.Wolf.Variant;

			}
		}
		interface Zoglin extends Modify<org.bukkit.entity.Monster & org.bukkit.entity.Ageable, {
			/**
			 * Gets whether the zoglin is a baby
			 */
			isBaby(): boolean;

			/**
			 * Sets whether the zoglin is a baby
			 */
			setBaby(flag: boolean): void;

		}> {}
		interface Zombie extends Modify<org.bukkit.entity.Monster & org.bukkit.entity.Ageable, {
			/**
			 * Gets whether the zombie is a baby
			 */
			isBaby(): boolean;

			/**
			 * Sets whether the zombie is a baby
			 */
			setBaby(flag: boolean): void;

			/**
			 * Gets whether the zombie is a villager
			 */
			isVillager(): boolean;

			setVillager(flag: boolean): void;

			setVillagerProfession(profession: org.bukkit.entity.Villager.Profession): void;

			getVillagerProfession(): (org.bukkit.entity.Villager.Profession | null);

			/**
			 * Get if this entity is in the process of converting to a Drowned as a
			 * result of being underwater.
			 */
			isConverting(): boolean;

			/**
			 * Gets the amount of ticks until this entity will be converted to a Drowned
			 * as a result of being underwater.
			 * When this reaches 0, the entity will be converted.
			 */
			getConversionTime(): number;

			/**
			 * Sets the amount of ticks until this entity will be converted to a Drowned
			 * as a result of being underwater.
			 * When this reaches 0, the entity will be converted. A value of less than 0
			 * will stop the current conversion process without converting the current
			 * entity.
			 */
			setConversionTime(time: number): void;

			/**
			 * Gets whether this zombie can break doors
			 */
			canBreakDoors(): boolean;

			/**
			 * Sets whether this zombie can break doors
			 * This will be ignored if the entity is a Drowned. Will also stop the action if
			 * the entity is currently breaking a door.
			 */
			setCanBreakDoors(flag: boolean): void;

		}> {}
		interface ZombieHorse extends Modify<org.bukkit.entity.AbstractHorse, {}> {}
		interface ZombieVillager extends Modify<org.bukkit.entity.Zombie, {
			/**
			 * Sets the villager profession of this zombie.
			 */
			setVillagerProfession(profession: (org.bukkit.entity.Villager.Profession | null)): void;

			/**
			 * Returns the villager profession of this zombie.
			 */
			getVillagerProfession(): (org.bukkit.entity.Villager.Profession | null);

			/**
			 * Gets the current type of this villager.
			 */
			getVillagerType(): org.bukkit.entity.Villager.Type;

			/**
			 * Sets the new type of this villager.
			 */
			setVillagerType(type: org.bukkit.entity.Villager.Type): void;

			/**
			 * Get if this entity is in the process of converting to a Villager as a
			 * result of being cured.
			 */
			isConverting(): boolean;

			/**
			 * Gets the amount of ticks until this entity will be converted to a
			 * Villager as a result of being cured.
			 * When this reaches 0, the entity will be converted.
			 */
			getConversionTime(): number;

			/**
			 * Sets the amount of ticks until this entity will be converted to a
			 * Villager as a result of being cured.
			 * When this reaches 0, the entity will be converted. A value of less than 0
			 * will stop the current conversion process without converting the current
			 * entity.
			 */
			setConversionTime(time: number): void;

			/**
			 * Gets the player who initiated the conversion.
			 */
			getConversionPlayer(): (org.bukkit.OfflinePlayer | null);

			/**
			 * Sets the player who initiated the conversion.
			 * 
			 * This has no effect if this entity isn't converting currently.
			 */
			setConversionPlayer(conversionPlayer: (org.bukkit.OfflinePlayer | null)): void;

		}> {}
	}
	namespace org.bukkit.inventory {
		interface AbstractHorseInventory extends Modify<org.bukkit.inventory.Inventory, {
			/**
			 * Gets the item in the horse's saddle slot.
			 */
			getSaddle(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Sets the item in the horse's saddle slot.
			 */
			setSaddle(stack: (org.bukkit.inventory.ItemStack | null)): void;

		}> {}
		interface AnvilInventory extends Modify<org.bukkit.inventory.Inventory, {
			/**
			 * Get the name to be applied to the repaired item. An empty string denotes
			 * the default item name.
			 */
			getRenameText(): (string | null);

			/**
			 * Get the item cost (in amount) to complete the current repair.
			 */
			getRepairCostAmount(): number;

			/**
			 * Set the item cost (in amount) to complete the current repair.
			 */
			setRepairCostAmount(amount: number): void;

			/**
			 * Get the experience cost (in levels) to complete the current repair.
			 */
			getRepairCost(): number;

			/**
			 * Set the experience cost (in levels) to complete the current repair.
			 */
			setRepairCost(levels: number): void;

			/**
			 * Get the maximum experience cost (in levels) to be allowed by the current
			 * repair. If the result of getRepairCost() exceeds the returned
			 * value, the repair result will be air to due being "too expensive".
			 * 
			 * By default, this level is set to 40. Players in creative mode ignore the
			 * maximum repair cost.
			 */
			getMaximumRepairCost(): number;

			/**
			 * Set the maximum experience cost (in levels) to be allowed by the current
			 * repair. The default value set by vanilla Minecraft is 40.
			 */
			setMaximumRepairCost(levels: number): void;

		}> {}
		interface BeaconInventory extends Modify<org.bukkit.inventory.Inventory, {
			/**
			 * Set the item powering the beacon.
			 */
			setItem(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Get the item powering the beacon.
			 */
			getItem(): (org.bukkit.inventory.ItemStack | null);

		}> {}
		interface BlastingRecipe extends Modify<org.bukkit.inventory.CookingRecipe<org.bukkit.inventory.BlastingRecipe>, {
		}> {}
		class BlastingRecipe {
			constructor(key: org.bukkit.NamespacedKey, result: org.bukkit.inventory.ItemStack, source: org.bukkit.Material, experience: number, cookingTime: number);

			constructor(key: org.bukkit.NamespacedKey, result: org.bukkit.inventory.ItemStack, input: org.bukkit.inventory.RecipeChoice, experience: number, cookingTime: number);

		}
		interface BlockInventoryHolder extends Modify<org.bukkit.inventory.InventoryHolder, {
			/**
			 * Gets the block associated with this holder.
			 */
			getBlock(): org.bukkit.block.Block;

		}> {}
		interface BrewerInventory extends Modify<org.bukkit.inventory.Inventory, {
			/**
			 * Get the current ingredient for brewing.
			 */
			getIngredient(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Set the current ingredient for brewing.
			 */
			setIngredient(ingredient: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Get the current fuel for brewing.
			 */
			getFuel(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Set the current fuel for brewing. Generally only
			 * Material.BLAZE_POWDER will be of use.
			 */
			setFuel(fuel: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Description copied from interface:Â Inventory
			 */
			getHolder(): (org.bukkit.block.BrewingStand | null);

		}> {}
		interface CampfireRecipe extends Modify<org.bukkit.inventory.CookingRecipe<org.bukkit.inventory.CampfireRecipe>, {
		}> {}
		class CampfireRecipe {
			constructor(key: org.bukkit.NamespacedKey, result: org.bukkit.inventory.ItemStack, source: org.bukkit.Material, experience: number, cookingTime: number);

			constructor(key: org.bukkit.NamespacedKey, result: org.bukkit.inventory.ItemStack, input: org.bukkit.inventory.RecipeChoice, experience: number, cookingTime: number);

		}
		interface CartographyInventory extends Modify<org.bukkit.inventory.Inventory, {}> {}
		interface ChiseledBookshelfInventory extends Modify<org.bukkit.inventory.Inventory, {
			/**
			 * Description copied from interface:Â Inventory
			 */
			getHolder(): (org.bukkit.block.ChiseledBookshelf | null);

		}> {}
		interface ComplexRecipe extends Modify<org.bukkit.inventory.Recipe & org.bukkit.Keyed, {}> {}
		interface CookingRecipe<T = any> {
			/**
			 * Sets the input of this cooking recipe.
			 */
			setInput(input: org.bukkit.Material): org.bukkit.inventory.CookingRecipe;

			/**
			 * Get the input material.
			 */
			getInput(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the input of this cooking recipe.
			 */
			setInputChoice(input: org.bukkit.inventory.RecipeChoice): T;

			/**
			 * Get the input choice.
			 */
			getInputChoice(): org.bukkit.inventory.RecipeChoice;

			/**
			 * Get the result of this recipe.
			 */
			getResult(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the experience given by this recipe.
			 */
			setExperience(experience: number): void;

			/**
			 * Get the experience given by this recipe.
			 */
			getExperience(): number;

			/**
			 * Set the cooking time for this recipe in ticks.
			 */
			setCookingTime(cookingTime: number): void;

			/**
			 * Get the cooking time for this recipe in ticks.
			 */
			getCookingTime(): number;

			/**
			 * Description copied from interface:Â Keyed
			 */
			getKey(): org.bukkit.NamespacedKey;

			/**
			 * Get the group of this recipe. Recipes with the same group may be grouped
			 * together when displayed in the client.
			 */
			getGroup(): string;

			/**
			 * Set the group of this recipe. Recipes with the same group may be grouped
			 * together when displayed in the client.
			 */
			setGroup(group: string): void;

			/**
			 * Gets the category which this recipe will appear in the recipe book under.
			 * Defaults to CookingBookCategory.MISC if not set.
			 */
			getCategory(): org.bukkit.inventory.recipe.CookingBookCategory;

			/**
			 * Sets the category which this recipe will appear in the recipe book under.
			 * Defaults to CookingBookCategory.MISC if not set.
			 */
			setCategory(category: org.bukkit.inventory.recipe.CookingBookCategory): void;

		}
		class CookingRecipe<T = any> {
			/**
			 * Create a cooking recipe to craft the specified ItemStack.
			 */
			constructor(key: org.bukkit.NamespacedKey, result: org.bukkit.inventory.ItemStack, source: org.bukkit.Material, experience: number, cookingTime: number);

			/**
			 * Create a cooking recipe to craft the specified ItemStack.
			 */
			constructor(key: org.bukkit.NamespacedKey, result: org.bukkit.inventory.ItemStack, input: org.bukkit.inventory.RecipeChoice, experience: number, cookingTime: number);

		}
		interface CrafterInventory extends Modify<org.bukkit.inventory.Inventory, {}> {}
		interface CraftingInventory extends Modify<org.bukkit.inventory.Inventory, {
			/**
			 * Check what item is in the result slot of this crafting inventory.
			 */
			getResult(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Set the item in the result slot of the crafting inventory.
			 */
			setResult(newResult: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Replace the contents of the crafting matrix
			 */
			setMatrix(contents: org.bukkit.inventory.ItemStack[]): void;

			/**
			 * Get the current recipe formed on the crafting inventory, if any.
			 */
			getRecipe(): (org.bukkit.inventory.Recipe | null);

		}> {}
		interface CraftingRecipe {
			/**
			 * Description copied from interface:Â Keyed
			 */
			getKey(): org.bukkit.NamespacedKey;

			/**
			 * Get the result of this recipe.
			 */
			getResult(): org.bukkit.inventory.ItemStack;

			/**
			 * Get the group of this recipe. Recipes with the same group may be grouped
			 * together when displayed in the client.
			 */
			getGroup(): string;

			/**
			 * Set the group of this recipe. Recipes with the same group may be grouped
			 * together when displayed in the client.
			 */
			setGroup(group: string): void;

			/**
			 * Gets the category which this recipe will appear in the recipe book under.
			 * Defaults to CraftingBookCategory.MISC if not set.
			 */
			getCategory(): org.bukkit.inventory.recipe.CraftingBookCategory;

			/**
			 * Sets the category which this recipe will appear in the recipe book under.
			 * Defaults to CraftingBookCategory.MISC if not set.
			 */
			setCategory(category: org.bukkit.inventory.recipe.CraftingBookCategory): void;

		}
		interface CreativeCategory {}
		namespace CreativeCategory {
			/**
			 * An assortment of building blocks including dirt, bricks, planks, ores
			 * slabs, etc.
			 */
			const BUILDING_BLOCKS: org.bukkit.inventory.CreativeCategory;

			/**
			 * Blocks and items typically used for decorative purposes including
			 * candles, saplings, flora, fauna, fences, walls, carpets, etc.
			 */
			const DECORATIONS: org.bukkit.inventory.CreativeCategory;

			/**
			 * Blocks used and associated with redstone contraptions including buttons,
			 * levers, pressure plates, redstone components, pistons, etc.
			 */
			const REDSTONE: org.bukkit.inventory.CreativeCategory;

			/**
			 * Items pertaining to transportation including minecarts, rails, boats,
			 * elytra, etc.
			 */
			const TRANSPORTATION: org.bukkit.inventory.CreativeCategory;

			/**
			 * Miscellaneous items and blocks that do not fit into other categories
			 * including gems, dyes, spawn eggs, discs, banner patterns, etc.
			 */
			const MISC: org.bukkit.inventory.CreativeCategory;

			/**
			 * Food items consumable by the player including meats, berries, edible
			 * drops from creatures, etc.
			 */
			const FOOD: org.bukkit.inventory.CreativeCategory;

			/**
			 * Equipment items meant for general utility including pickaxes, axes, hoes,
			 * flint and steel, and useful enchantment books for said tools.
			 */
			const TOOLS: org.bukkit.inventory.CreativeCategory;

			/**
			 * Equipment items meant for combat including armor, swords, bows, tipped
			 * arrows, and useful enchantment books for said equipment.
			 */
			const COMBAT: org.bukkit.inventory.CreativeCategory;

			/**
			 * All items related to brewing and potions including all types of potions,
			 * their variants, and ingredients to brew them.
			 */
			const BREWING: org.bukkit.inventory.CreativeCategory;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.inventory.CreativeCategory;

		}
		interface DecoratedPotInventory extends Modify<org.bukkit.inventory.Inventory, {
			/**
			 * Set the item stack in the decorated pot.
			 */
			setItem(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Get the item stack in the decorated pot.
			 */
			getItem(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Description copied from interface:Â Inventory
			 */
			getHolder(): (org.bukkit.block.DecoratedPot | null);

		}> {}
		interface DoubleChestInventory extends Modify<org.bukkit.inventory.Inventory, {
			/**
			 * Get the left half of this double chest.
			 */
			getLeftSide(): org.bukkit.inventory.Inventory;

			/**
			 * Get the right side of this double chest.
			 */
			getRightSide(): org.bukkit.inventory.Inventory;

			/**
			 * Description copied from interface:Â Inventory
			 */
			getHolder(): (org.bukkit.block.DoubleChest | null);

		}> {}
		interface EnchantingInventory extends Modify<org.bukkit.inventory.Inventory, {
			/**
			 * Set the item being enchanted.
			 */
			setItem(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Get the item being enchanted.
			 */
			getItem(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Set the secondary item being used for the enchant.
			 */
			setSecondary(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Get the secondary item being used for the enchant.
			 */
			getSecondary(): (org.bukkit.inventory.ItemStack | null);

		}> {}
		interface EntityEquipment {
			/**
			 * Stores the ItemStack at the given equipment slot in the inventory.
			 */
			setItem(slot: org.bukkit.inventory.EquipmentSlot, item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Stores the ItemStack at the given equipment slot in the inventory.
			 */
			setItem(slot: org.bukkit.inventory.EquipmentSlot, item: (org.bukkit.inventory.ItemStack | null), silent: boolean): void;

			/**
			 * Gets the ItemStack at the given equipment slot in the inventory.
			 */
			getItem(slot: org.bukkit.inventory.EquipmentSlot): org.bukkit.inventory.ItemStack;

			/**
			 * Gets a copy of the item the entity is currently holding
			 * in their main hand.
			 */
			getItemInMainHand(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the item the entity is holding in their main hand.
			 */
			setItemInMainHand(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Sets the item the entity is holding in their main hand.
			 */
			setItemInMainHand(item: (org.bukkit.inventory.ItemStack | null), silent: boolean): void;

			/**
			 * Gets a copy of the item the entity is currently holding
			 * in their off hand.
			 */
			getItemInOffHand(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the item the entity is holding in their off hand.
			 */
			setItemInOffHand(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Sets the item the entity is holding in their off hand.
			 */
			setItemInOffHand(item: (org.bukkit.inventory.ItemStack | null), silent: boolean): void;

			/**
			 * Gets a copy of the item the entity is currently holding
			 */
			getItemInHand(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the item the entity is holding
			 */
			setItemInHand(stack: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Gets a copy of the helmet currently being worn by the entity
			 */
			getHelmet(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Sets the helmet worn by the entity
			 */
			setHelmet(helmet: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Sets the helmet worn by the entity
			 */
			setHelmet(helmet: (org.bukkit.inventory.ItemStack | null), silent: boolean): void;

			/**
			 * Gets a copy of the chest plate currently being worn by the entity
			 */
			getChestplate(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Sets the chest plate worn by the entity
			 */
			setChestplate(chestplate: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Sets the chest plate worn by the entity
			 */
			setChestplate(chestplate: (org.bukkit.inventory.ItemStack | null), silent: boolean): void;

			/**
			 * Gets a copy of the leggings currently being worn by the entity
			 */
			getLeggings(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Sets the leggings worn by the entity
			 */
			setLeggings(leggings: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Sets the leggings worn by the entity
			 */
			setLeggings(leggings: (org.bukkit.inventory.ItemStack | null), silent: boolean): void;

			/**
			 * Gets a copy of the boots currently being worn by the entity
			 */
			getBoots(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Sets the boots worn by the entity
			 */
			setBoots(boots: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Sets the boots worn by the entity
			 */
			setBoots(boots: (org.bukkit.inventory.ItemStack | null), silent: boolean): void;

			/**
			 * Sets the entities armor to the provided array of ItemStacks
			 */
			setArmorContents(items: org.bukkit.inventory.ItemStack[]): void;

			/**
			 * Clears the entity of all armor and held items
			 */
			clear(): void;

			getItemInHandDropChance(): number;

			setItemInHandDropChance(chance: number): void;

			/**
			 * Gets the chance of the main hand item being dropped upon this creature's
			 * death.
			 * 
			 * A drop chance of 0.0F will never drop
			 * A drop chance of 1.0F will always drop
			 * 
			 */
			getItemInMainHandDropChance(): number;

			/**
			 * Sets the chance of the item this creature is currently holding in their
			 * main hand being dropped upon this creature's death.
			 * 
			 * A drop chance of 0.0F will never drop
			 * A drop chance of 1.0F will always drop
			 * 
			 */
			setItemInMainHandDropChance(chance: number): void;

			/**
			 * Gets the chance of the off hand item being dropped upon this creature's
			 * death.
			 * 
			 * A drop chance of 0.0F will never drop
			 * A drop chance of 1.0F will always drop
			 * 
			 */
			getItemInOffHandDropChance(): number;

			/**
			 * Sets the chance of the off hand item being dropped upon this creature's
			 * death.
			 * 
			 * A drop chance of 0.0F will never drop
			 * A drop chance of 1.0F will always drop
			 * 
			 */
			setItemInOffHandDropChance(chance: number): void;

			/**
			 * Gets the chance of the helmet being dropped upon this creature's death.
			 * 
			 * A drop chance of 0.0F will never drop
			 * A drop chance of 1.0F will always drop
			 * 
			 */
			getHelmetDropChance(): number;

			/**
			 * Sets the chance of the helmet being dropped upon this creature's death.
			 * 
			 * A drop chance of 0.0F will never drop
			 * A drop chance of 1.0F will always drop
			 * 
			 */
			setHelmetDropChance(chance: number): void;

			/**
			 * Gets the chance of the chest plate being dropped upon this creature's
			 * death.
			 * 
			 * A drop chance of 0.0F will never drop
			 * A drop chance of 1.0F will always drop
			 * 
			 */
			getChestplateDropChance(): number;

			/**
			 * Sets the chance of the chest plate being dropped upon this creature's
			 * death.
			 * 
			 * A drop chance of 0.0F will never drop
			 * A drop chance of 1.0F will always drop
			 * 
			 */
			setChestplateDropChance(chance: number): void;

			/**
			 * Gets the chance of the leggings being dropped upon this creature's
			 * death.
			 * 
			 * A drop chance of 0.0F will never drop
			 * A drop chance of 1.0F will always drop
			 * 
			 */
			getLeggingsDropChance(): number;

			/**
			 * Sets the chance of the leggings being dropped upon this creature's
			 * death.
			 * 
			 * A drop chance of 0.0F will never drop
			 * A drop chance of 1.0F will always drop
			 * 
			 */
			setLeggingsDropChance(chance: number): void;

			/**
			 * Gets the chance of the boots being dropped upon this creature's death.
			 * 
			 * A drop chance of 0.0F will never drop
			 * A drop chance of 1.0F will always drop
			 * 
			 */
			getBootsDropChance(): number;

			/**
			 * Sets the chance of the boots being dropped upon this creature's death.
			 * 
			 * A drop chance of 0.0F will never drop
			 * A drop chance of 1.0F will always drop
			 * 
			 */
			setBootsDropChance(chance: number): void;

			/**
			 * Get the entity this EntityEquipment belongs to
			 */
			getHolder(): (org.bukkit.entity.Entity | null);

		}
		interface EquipmentSlot {
			/**
			 * Gets the EquipmentSlotGroup corresponding to this slot.
			 */
			getGroup(): org.bukkit.inventory.EquipmentSlotGroup;

		}
		namespace EquipmentSlot {
			const HAND: org.bukkit.inventory.EquipmentSlot;

			const OFF_HAND: org.bukkit.inventory.EquipmentSlot;

			const FEET: org.bukkit.inventory.EquipmentSlot;

			const LEGS: org.bukkit.inventory.EquipmentSlot;

			const CHEST: org.bukkit.inventory.EquipmentSlot;

			const HEAD: org.bukkit.inventory.EquipmentSlot;

			/**
			 * Only for certain entities such as horses and wolves.
			 */
			const BODY: org.bukkit.inventory.EquipmentSlot;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.inventory.EquipmentSlot;

		}
		interface EquipmentSlotGroup {
			test(test: org.bukkit.inventory.EquipmentSlot): boolean;

			toString(): string;

			/**
			 * Gets an EquipmentSlot which is an example of a slot in this
			 * group.
			 */
			getExample(): org.bukkit.inventory.EquipmentSlot;

		}
		namespace EquipmentSlotGroup {
			const ANY: org.bukkit.inventory.EquipmentSlotGroup;

			const MAINHAND: org.bukkit.inventory.EquipmentSlotGroup;

			const OFFHAND: org.bukkit.inventory.EquipmentSlotGroup;

			const HAND: org.bukkit.inventory.EquipmentSlotGroup;

			const FEET: org.bukkit.inventory.EquipmentSlotGroup;

			const LEGS: org.bukkit.inventory.EquipmentSlotGroup;

			const CHEST: org.bukkit.inventory.EquipmentSlotGroup;

			const HEAD: org.bukkit.inventory.EquipmentSlotGroup;

			const ARMOR: org.bukkit.inventory.EquipmentSlotGroup;

			/**
			 * Gets the EquipmentSlotGroup corresponding to the given string.
			 */
			function getByName(name: string): (org.bukkit.inventory.EquipmentSlotGroup | null);

		}
		interface FurnaceInventory extends Modify<org.bukkit.inventory.Inventory, {
			/**
			 * Get the current item in the result slot.
			 */
			getResult(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Get the current fuel.
			 */
			getFuel(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Get the item currently smelting.
			 */
			getSmelting(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Set the current fuel.
			 */
			setFuel(stack: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Set the current item in the result slot.
			 */
			setResult(stack: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Set the item currently smelting.
			 */
			setSmelting(stack: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Description copied from interface:Â Inventory
			 */
			getHolder(): (org.bukkit.block.Furnace | null);

		}> {}
		interface FurnaceRecipe extends Modify<org.bukkit.inventory.CookingRecipe<org.bukkit.inventory.FurnaceRecipe>, {
			/**
			 * Sets the input of this furnace recipe.
			 */
			setInput(input: org.bukkit.material.MaterialData): org.bukkit.inventory.FurnaceRecipe;

			/**
			 * Description copied from class:Â CookingRecipe
			 */
			setInput(input: org.bukkit.Material): org.bukkit.inventory.FurnaceRecipe;

			/**
			 * Sets the input of this furnace recipe.
			 */
			setInput(input: org.bukkit.Material, data: number): org.bukkit.inventory.FurnaceRecipe;

			/**
			 * Description copied from class:Â CookingRecipe
			 */
			setInputChoice(input: org.bukkit.inventory.RecipeChoice): org.bukkit.inventory.FurnaceRecipe;

		}> {}
		class FurnaceRecipe {
			constructor(result: org.bukkit.inventory.ItemStack, source: org.bukkit.Material);

			constructor(result: org.bukkit.inventory.ItemStack, source: org.bukkit.material.MaterialData);

			constructor(result: org.bukkit.inventory.ItemStack, source: org.bukkit.material.MaterialData, experience: number);

			constructor(result: org.bukkit.inventory.ItemStack, source: org.bukkit.Material, data: number);

			/**
			 * Create a furnace recipe to craft the specified ItemStack.
			 */
			constructor(key: org.bukkit.NamespacedKey, result: org.bukkit.inventory.ItemStack, source: org.bukkit.Material, experience: number, cookingTime: number);

			constructor(key: org.bukkit.NamespacedKey, result: org.bukkit.inventory.ItemStack, source: org.bukkit.Material, data: number, experience: number, cookingTime: number);

			/**
			 * Create a furnace recipe to craft the specified ItemStack.
			 */
			constructor(key: org.bukkit.NamespacedKey, result: org.bukkit.inventory.ItemStack, input: org.bukkit.inventory.RecipeChoice, experience: number, cookingTime: number);

		}
		interface GrindstoneInventory extends Modify<org.bukkit.inventory.Inventory, {}> {}
		interface HorseInventory extends Modify<org.bukkit.inventory.AbstractHorseInventory, {
			/**
			 * Gets the item in the horse's armor slot.
			 */
			getArmor(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Sets the item in the horse's armor slot.
			 */
			setArmor(stack: (org.bukkit.inventory.ItemStack | null)): void;

		}> {}
		interface Inventory {
			/**
			 * Returns the size of the inventory
			 */
			getSize(): number;

			/**
			 * Returns the maximum stack size for an ItemStack in this inventory.
			 */
			getMaxStackSize(): number;

			/**
			 * This method allows you to change the maximum stack size for an
			 * inventory.
			 * 
			 * Caveats:
			 * 
			 * Not all inventories respect this value.
			 * Stacks larger than 127 may be clipped when the world is saved.
			 * This value is not guaranteed to be preserved; be sure to set it
			 * before every time you want to set a slot over the max stack size.
			 * Stacks larger than the default max size for this type of inventory
			 * may not display correctly in the client.
			 * 
			 */
			setMaxStackSize(size: number): void;

			/**
			 * Returns the ItemStack found in the slot at the given index
			 */
			getItem(index: number): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Stores the ItemStack at the given index of the inventory.
			 */
			setItem(index: number, item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Stores the given ItemStacks in the inventory. This will try to fill
			 * existing stacks and empty slots as well as it can.
			 * 
			 * The returned HashMap contains what it couldn't store, where the key is
			 * the index of the parameter, and the value is the ItemStack at that
			 * index of the varargs parameter. If all items are stored, it will return
			 * an empty HashMap.
			 * 
			 * If you pass in ItemStacks which exceed the maximum stack size for the
			 * Material, first they will be added to partial stacks where
			 * Material.getMaxStackSize() is not exceeded, up to
			 * Material.getMaxStackSize(). When there are no partial stacks left
			 * stacks will be split on Inventory.getMaxStackSize() allowing you to
			 * exceed the maximum stack size for that material.
			 * 
			 * It is known that in some implementations this method will also set
			 * the inputted argument amount to the number of that item not placed in
			 * slots.
			 */
			addItem(...items: org.bukkit.inventory.ItemStack[]): globalThis.java.util.HashMap<number, org.bukkit.inventory.ItemStack>;

			/**
			 * Removes the given ItemStacks from the inventory.
			 * 
			 * It will try to remove 'as much as possible' from the types and amounts
			 * you give as arguments.
			 * 
			 * The returned HashMap contains what it couldn't remove, where the key is
			 * the index of the parameter, and the value is the ItemStack at that
			 * index of the varargs parameter. If all the given ItemStacks are
			 * removed, it will return an empty HashMap.
			 * 
			 * It is known that in some implementations this method will also set the
			 * inputted argument amount to the number of that item not removed from
			 * slots.
			 */
			removeItem(...items: org.bukkit.inventory.ItemStack[]): globalThis.java.util.HashMap<number, org.bukkit.inventory.ItemStack>;

			/**
			 * Completely replaces the inventory's contents. Removes all existing
			 * contents and replaces it with the ItemStacks given in the array.
			 */
			setContents(items: org.bukkit.inventory.ItemStack[]): void;

			/**
			 * Put the given ItemStacks into the storage slots
			 */
			setStorageContents(items: org.bukkit.inventory.ItemStack[]): void;

			/**
			 * Checks if the inventory contains any ItemStacks with the given
			 * material.
			 */
			contains(material: org.bukkit.Material): boolean;

			/**
			 * Checks if the inventory contains any ItemStacks matching the given
			 * ItemStack.
			 * 
			 * This will only return true if both the type and the amount of the stack
			 * match.
			 */
			contains(item: (org.bukkit.inventory.ItemStack | null)): boolean;

			/**
			 * Checks if the inventory contains any ItemStacks with the given
			 * material, adding to at least the minimum amount specified.
			 */
			contains(material: org.bukkit.Material, amount: number): boolean;

			/**
			 * Checks if the inventory contains at least the minimum amount specified
			 * of exactly matching ItemStacks.
			 * 
			 * An ItemStack only counts if both the type and the amount of the stack
			 * match.
			 */
			contains(item: (org.bukkit.inventory.ItemStack | null), amount: number): boolean;

			/**
			 * Checks if the inventory contains ItemStacks matching the given
			 * ItemStack whose amounts sum to at least the minimum amount specified.
			 */
			containsAtLeast(item: (org.bukkit.inventory.ItemStack | null), amount: number): boolean;

			/**
			 * Returns a HashMap with all slots and ItemStacks in the inventory with
			 * the given Material.
			 * 
			 * The HashMap contains entries where, the key is the slot index, and the
			 * value is the ItemStack in that slot. If no matching ItemStack with the
			 * given Material is found, an empty map is returned.
			 */
			all(material: org.bukkit.Material): globalThis.java.util.HashMap<number, org.bukkit.inventory.ItemStack>;

			/**
			 * Finds all slots in the inventory containing any ItemStacks with the
			 * given ItemStack. This will only match slots if both the type and the
			 * amount of the stack match
			 * 
			 * The HashMap contains entries where, the key is the slot index, and the
			 * value is the ItemStack in that slot. If no matching ItemStack with the
			 * given Material is found, an empty map is returned.
			 */
			all(item: (org.bukkit.inventory.ItemStack | null)): globalThis.java.util.HashMap<number, org.bukkit.inventory.ItemStack>;

			/**
			 * Finds the first slot in the inventory containing an ItemStack with the
			 * given material
			 */
			first(material: org.bukkit.Material): number;

			/**
			 * Returns the first slot in the inventory containing an ItemStack with
			 * the given stack. This will only match a slot if both the type and the
			 * amount of the stack match
			 */
			first(item: org.bukkit.inventory.ItemStack): number;

			/**
			 * Returns the first empty Slot.
			 */
			firstEmpty(): number;

			/**
			 * Check whether or not this inventory is empty. An inventory is considered
			 * to be empty if there are no ItemStacks in any slot of this inventory.
			 */
			isEmpty(): boolean;

			/**
			 * Removes all stacks in the inventory matching the given material.
			 */
			remove(material: org.bukkit.Material): void;

			/**
			 * Removes all stacks in the inventory matching the given stack.
			 * 
			 * This will only match a slot if both the type and the amount of the
			 * stack match
			 */
			remove(item: org.bukkit.inventory.ItemStack): void;

			/**
			 * Clears out a particular slot in the index.
			 */
			clear(index: number): void;

			/**
			 * Clears out the whole Inventory.
			 */
			clear(): void;

			/**
			 * Gets a list of players viewing the inventory. Note that a player is
			 * considered to be viewing their own inventory and internal crafting
			 * screen even when said inventory is not open. They will normally be
			 * considered to be viewing their inventory even when they have a
			 * different inventory screen open, but it's possible for customized
			 * inventory screens to exclude the viewer's inventory, so this should
			 * never be assumed to be non-empty.
			 */
			getViewers(): globalThis.java.util.List<org.bukkit.entity.HumanEntity>;

			/**
			 * Returns what type of inventory this is.
			 */
			getType(): org.bukkit.event.inventory.InventoryType;

			/**
			 * Gets the block or entity belonging to the open inventory
			 */
			getHolder(): (org.bukkit.inventory.InventoryHolder | null);

			iterator(): globalThis.java.util.ListIterator<org.bukkit.inventory.ItemStack>;

			/**
			 * Returns an iterator starting at the given index. If the index is
			 * positive, then the first call to next() will return the item at that
			 * index; if it is negative, the first call to previous will return the
			 * item at index (getSize() + index).
			 */
			iterator(index: number): globalThis.java.util.ListIterator<org.bukkit.inventory.ItemStack>;

			/**
			 * Get the location of the block or entity which corresponds to this inventory. May return null if this container
			 * was custom created or is a virtual / subcontainer.
			 */
			getLocation(): (org.bukkit.Location | null);

		}
		interface InventoryHolder {
			/**
			 * Get the object's inventory.
			 */
			getInventory(): org.bukkit.inventory.Inventory;

		}
		interface InventoryView {
			/**
			 * Get the upper inventory involved in this transaction.
			 */
			getTopInventory(): org.bukkit.inventory.Inventory;

			/**
			 * Get the lower inventory involved in this transaction.
			 */
			getBottomInventory(): org.bukkit.inventory.Inventory;

			/**
			 * Get the player viewing.
			 */
			getPlayer(): org.bukkit.entity.HumanEntity;

			/**
			 * Determine the type of inventory involved in the transaction. This
			 * indicates the window style being shown. It will never return PLAYER,
			 * since that is common to all windows.
			 */
			getType(): org.bukkit.event.inventory.InventoryType;

			/**
			 * Sets one item in this inventory view by its raw slot ID.
			 * 
			 * Note: If slot ID -999 is chosen, it may be expected that the item is
			 * dropped on the ground. This is not required behaviour, however.
			 */
			setItem(slot: number, item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Gets one item in this inventory view by its raw slot ID.
			 */
			getItem(slot: number): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Sets the item on the cursor of one of the viewing players.
			 */
			setCursor(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Get the item on the cursor of one of the viewing players.
			 */
			getCursor(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Gets the inventory corresponding to the given raw slot ID.
			 * If the slot ID is OUTSIDE null will be returned, otherwise
			 * behaviour for illegal and negative slot IDs is undefined.
			 * May be used with convertSlot(int) to directly index an
			 * underlying inventory.
			 */
			getInventory(rawSlot: number): (org.bukkit.inventory.Inventory | null);

			/**
			 * Converts a raw slot ID into its local slot ID into whichever of the two
			 * inventories the slot points to.
			 * 
			 * If the raw slot refers to the upper inventory, it will be returned
			 * unchanged and thus be suitable for getTopInventory().getItem(); if it
			 * refers to the lower inventory, the output will differ from the input
			 * and be suitable for getBottomInventory().getItem().
			 */
			convertSlot(rawSlot: number): number;

			/**
			 * Determine the type of the slot by its raw slot ID.
			 * 
			 * If the type of the slot is unknown, then
			 * InventoryType.SlotType.CONTAINER will be returned.
			 */
			getSlotType(slot: number): org.bukkit.event.inventory.InventoryType.SlotType;

			/**
			 * Closes the inventory view.
			 */
			close(): void;

			/**
			 * Check the total number of slots in this view, combining the upper and
			 * lower inventories.
			 * 
			 * Note though that it's possible for this to be greater than the sum of
			 * the two inventories if for example some slots are not being used.
			 */
			countSlots(): number;

			/**
			 * Sets an extra property of this inventory if supported by that
			 * inventory, for example the state of a progress bar.
			 */
			setProperty(prop: org.bukkit.inventory.InventoryView.Property, value: number): boolean;

			/**
			 * Get the title of this inventory window.
			 */
			getTitle(): string;

			/**
			 * Get the original title of this inventory window, before any changes were
			 * made using setTitle(String).
			 */
			getOriginalTitle(): string;

			/**
			 * Sets the title of this inventory window to the specified title if the
			 * inventory window supports it.
			 * 
			 * Note if the inventory does not support titles that can be changed (ie, it
			 * is not creatable or viewed by a player), then this method will throw an
			 * exception.
			 */
			setTitle(title: string): void;

		}
		namespace InventoryView {
			const OUTSIDE: number;

		}
		namespace InventoryView {
			interface Property {
				getType(): org.bukkit.event.inventory.InventoryType;

				/**
				 * Gets the id of this view.
				 */
				getId(): number;

			}
			namespace Property {
				/**
				 * The progress of the down-pointing arrow in a brewing inventory.
				 */
				const BREW_TIME: org.bukkit.inventory.InventoryView.Property;

				/**
				 * The progress of the fuel slot in a brewing inventory.
				 * This is a value between 0 and 20, with 0 making the bar empty, and 20
				 * making the bar full.
				 */
				const FUEL_TIME: org.bukkit.inventory.InventoryView.Property;

				/**
				 * The progress of the flame in a furnace inventory.
				 */
				const BURN_TIME: org.bukkit.inventory.InventoryView.Property;

				/**
				 * How many total ticks the current fuel should last.
				 */
				const TICKS_FOR_CURRENT_FUEL: org.bukkit.inventory.InventoryView.Property;

				/**
				 * The progress of the right-pointing arrow in a furnace inventory.
				 */
				const COOK_TIME: org.bukkit.inventory.InventoryView.Property;

				/**
				 * How many total ticks the current smelting should last.
				 */
				const TICKS_FOR_CURRENT_SMELTING: org.bukkit.inventory.InventoryView.Property;

				/**
				 * In an enchanting inventory, the top button's experience level
				 * value.
				 */
				const ENCHANT_BUTTON1: org.bukkit.inventory.InventoryView.Property;

				/**
				 * In an enchanting inventory, the middle button's experience level
				 * value.
				 */
				const ENCHANT_BUTTON2: org.bukkit.inventory.InventoryView.Property;

				/**
				 * In an enchanting inventory, the bottom button's experience level
				 * value.
				 */
				const ENCHANT_BUTTON3: org.bukkit.inventory.InventoryView.Property;

				/**
				 * In an enchanting inventory, the first four bits of the player's xpSeed.
				 */
				const ENCHANT_XP_SEED: org.bukkit.inventory.InventoryView.Property;

				/**
				 * In an enchanting inventory, the top button's enchantment's id
				 */
				const ENCHANT_ID1: org.bukkit.inventory.InventoryView.Property;

				/**
				 * In an enchanting inventory, the middle button's enchantment's id
				 */
				const ENCHANT_ID2: org.bukkit.inventory.InventoryView.Property;

				/**
				 * In an enchanting inventory, the bottom button's enchantment's id
				 */
				const ENCHANT_ID3: org.bukkit.inventory.InventoryView.Property;

				/**
				 * In an enchanting inventory, the top button's level value.
				 */
				const ENCHANT_LEVEL1: org.bukkit.inventory.InventoryView.Property;

				/**
				 * In an enchanting inventory, the middle button's level value.
				 */
				const ENCHANT_LEVEL2: org.bukkit.inventory.InventoryView.Property;

				/**
				 * In an enchanting inventory, the bottom button's level value.
				 */
				const ENCHANT_LEVEL3: org.bukkit.inventory.InventoryView.Property;

				/**
				 * In an beacon inventory, the levels of the beacon
				 */
				const LEVELS: org.bukkit.inventory.InventoryView.Property;

				/**
				 * In an beacon inventory, the primary potion effect
				 */
				const PRIMARY_EFFECT: org.bukkit.inventory.InventoryView.Property;

				/**
				 * In an beacon inventory, the secondary potion effect
				 */
				const SECONDARY_EFFECT: org.bukkit.inventory.InventoryView.Property;

				/**
				 * The repair's cost in xp levels
				 */
				const REPAIR_COST: org.bukkit.inventory.InventoryView.Property;

				/**
				 * The lectern's current open book page
				 */
				const BOOK_PAGE: org.bukkit.inventory.InventoryView.Property;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.inventory.InventoryView.Property;

			}
		}
		interface ItemCraftResult {
			/**
			 * The resulting ItemStack that was crafted.
			 */
			getResult(): org.bukkit.inventory.ItemStack;

			/**
			 * Gets the overflowed items for items that don't fit back into the crafting
			 * matrix.
			 */
			getOverflowItems(): globalThis.java.util.List<org.bukkit.inventory.ItemStack>;

		}
		interface ItemFactory {
			/**
			 * This creates a new item meta for the material.
			 */
			getItemMeta(material: org.bukkit.Material): (org.bukkit.inventory.meta.ItemMeta | null);

			/**
			 * This method checks the item meta to confirm that it is applicable (no
			 * data lost if applied) to the specified ItemStack.
			 * 
			 * A SkullMeta would not be valid for a sword, but a normal ItemMeta from an enchanted dirt block would.
			 */
			isApplicable(meta: (org.bukkit.inventory.meta.ItemMeta | null), stack: (org.bukkit.inventory.ItemStack | null)): boolean;

			/**
			 * This method checks the item meta to confirm that it is applicable (no
			 * data lost if applied) to the specified Material.
			 * 
			 * A SkullMeta would not be valid for a sword, but a normal ItemMeta from an enchanted dirt block would.
			 */
			isApplicable(meta: (org.bukkit.inventory.meta.ItemMeta | null), material: (org.bukkit.Material | null)): boolean;

			/**
			 * This method is used to compare two item meta data objects.
			 */
			equals(meta1: (org.bukkit.inventory.meta.ItemMeta | null), meta2: (org.bukkit.inventory.meta.ItemMeta | null)): boolean;

			/**
			 * Returns an appropriate item meta for the specified stack.
			 * 
			 * The item meta returned will always be a valid meta for a given
			 * ItemStack of the specified material. It may be a more or less specific
			 * meta, and could also be the same meta or meta type as the parameter.
			 * The item meta returned will also always be the most appropriate meta.
			 * 
			 * Example, if a SkullMeta is being applied to a book, this method
			 * would return a BookMeta containing all information in the
			 * specified meta that is applicable to an ItemMeta, the highest
			 * common interface.
			 */
			asMetaFor(meta: org.bukkit.inventory.meta.ItemMeta, stack: org.bukkit.inventory.ItemStack): (org.bukkit.inventory.meta.ItemMeta | null);

			/**
			 * Returns an appropriate item meta for the specified material.
			 * 
			 * The item meta returned will always be a valid meta for a given
			 * ItemStack of the specified material. It may be a more or less specific
			 * meta, and could also be the same meta or meta type as the parameter.
			 * The item meta returned will also always be the most appropriate meta.
			 * 
			 * Example, if a SkullMeta is being applied to a book, this method
			 * would return a BookMeta containing all information in the
			 * specified meta that is applicable to an ItemMeta, the highest
			 * common interface.
			 */
			asMetaFor(meta: org.bukkit.inventory.meta.ItemMeta, material: org.bukkit.Material): (org.bukkit.inventory.meta.ItemMeta | null);

			/**
			 * Returns the default color for all leather armor.
			 */
			getDefaultLeatherColor(): org.bukkit.Color;

			/**
			 * Create a new ItemStack given the supplied input.
			 * 
			 * The input should match the same input as expected by Minecraft's /give
			 * command. For example,
			 * "minecraft:diamond_sword[minecraft:enchantments={levels:{"minecraft:sharpness": 3}}]"
			 * would yield an ItemStack of Material.DIAMOND_SWORD with an ItemMeta
			 * containing a level 3 Enchantment.SHARPNESS enchantment.
			 */
			createItemStack(input: string): org.bukkit.inventory.ItemStack;

			/**
			 * Gets a Material representing the spawn egg for the provided
			 * EntityType.
			 * Will return null for EntityTypes that do not have a corresponding spawn egg.
			 */
			getSpawnEgg(type: org.bukkit.entity.EntityType): (org.bukkit.Material | null);

			/**
			 * Enchants the given item at the provided level.
			 * 
			 * If an item that is air is passed through an error is thrown.
			 */
			enchantItem(entity: org.bukkit.entity.Entity, item: org.bukkit.inventory.ItemStack, level: number, allowTreasures: boolean): org.bukkit.inventory.ItemStack;

			/**
			 * Enchants the given item at the provided level.
			 * 
			 * If an item that is air is passed through an error is thrown.
			 */
			enchantItem(world: org.bukkit.World, item: org.bukkit.inventory.ItemStack, level: number, allowTreasures: boolean): org.bukkit.inventory.ItemStack;

			/**
			 * Enchants the given item at the provided level.
			 * 
			 * If an item that is air is passed through an error is thrown.
			 */
			enchantItem(item: org.bukkit.inventory.ItemStack, level: number, allowTreasures: boolean): org.bukkit.inventory.ItemStack;

		}
		interface ItemFlag {}
		namespace ItemFlag {
			/**
			 * Setting to show/hide enchants
			 */
			const HIDE_ENCHANTS: org.bukkit.inventory.ItemFlag;

			/**
			 * Setting to show/hide Attributes like Damage
			 */
			const HIDE_ATTRIBUTES: org.bukkit.inventory.ItemFlag;

			/**
			 * Setting to show/hide the unbreakable State
			 */
			const HIDE_UNBREAKABLE: org.bukkit.inventory.ItemFlag;

			/**
			 * Setting to show/hide what the ItemStack can break/destroy
			 */
			const HIDE_DESTROYS: org.bukkit.inventory.ItemFlag;

			/**
			 * Setting to show/hide where this ItemStack can be build/placed on
			 */
			const HIDE_PLACED_ON: org.bukkit.inventory.ItemFlag;

			/**
			 * Setting to show/hide potion effects, book and firework information, map
			 * tooltips, patterns of banners, and enchantments of enchanted books.
			 */
			const HIDE_ADDITIONAL_TOOLTIP: org.bukkit.inventory.ItemFlag;

			/**
			 * Setting to show/hide dyes from colored leather armor.
			 */
			const HIDE_DYE: org.bukkit.inventory.ItemFlag;

			/**
			 * Setting to show/hide armor trim from leather armor.
			 */
			const HIDE_ARMOR_TRIM: org.bukkit.inventory.ItemFlag;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.inventory.ItemFlag;

		}
		interface ItemRarity {}
		namespace ItemRarity {
			/**
			 * White item name.
			 */
			const COMMON: org.bukkit.inventory.ItemRarity;

			/**
			 * Yellow item name.
			 */
			const UNCOMMON: org.bukkit.inventory.ItemRarity;

			/**
			 * Aqua item name.
			 */
			const RARE: org.bukkit.inventory.ItemRarity;

			/**
			 * Light purple item name.
			 */
			const EPIC: org.bukkit.inventory.ItemRarity;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.inventory.ItemRarity;

		}
		interface ItemStack {
			/**
			 * Gets the type of this item
			 */
			getType(): org.bukkit.Material;

			/**
			 * Sets the type of this item
			 * 
			 * Note that in doing so you will reset the MaterialData for this stack.
			 * 
			 * IMPORTANT: An ItemStack is only designed to contain
			 * items. Do not use this class to encapsulate Materials for which
			 * Material.isItem() returns false.
			 */
			setType(type: org.bukkit.Material): void;

			/**
			 * Gets the amount of items in this stack
			 */
			getAmount(): number;

			/**
			 * Sets the amount of items in this stack
			 */
			setAmount(amount: number): void;

			/**
			 * Gets the MaterialData for this stack of items
			 */
			getData(): (org.bukkit.material.MaterialData | null);

			/**
			 * Sets the MaterialData for this stack of items
			 */
			setData(data: (org.bukkit.material.MaterialData | null)): void;

			/**
			 * Sets the durability of this item
			 */
			setDurability(durability: number): void;

			/**
			 * Gets the durability of this item
			 */
			getDurability(): number;

			/**
			 * Get the maximum stack size for this item. If this item has a max stack
			 * size component (ItemMeta.hasMaxStackSize()), the value of that
			 * component will be returned. Otherwise, this item's Material's default maximum stack size will be returned
			 * instead.
			 */
			getMaxStackSize(): number;

			toString(): string;

			equals(obj: any): boolean;

			/**
			 * This method is the same as equals, but does not consider stack size
			 * (amount).
			 */
			isSimilar(stack: (org.bukkit.inventory.ItemStack | null)): boolean;

			clone(): org.bukkit.inventory.ItemStack;

			hashCode(): number;

			/**
			 * Checks if this ItemStack contains the given Enchantment
			 */
			containsEnchantment(ench: org.bukkit.enchantments.Enchantment): boolean;

			/**
			 * Gets the level of the specified enchantment on this item stack
			 */
			getEnchantmentLevel(ench: org.bukkit.enchantments.Enchantment): number;

			/**
			 * Gets a map containing all enchantments and their levels on this item.
			 */
			getEnchantments(): globalThis.java.util.Map<org.bukkit.enchantments.Enchantment, number>;

			/**
			 * Adds the specified enchantments to this item stack.
			 * 
			 * This method is the same as calling addEnchantment(org.bukkit.enchantments.Enchantment, int) for each
			 * element of the map.
			 */
			addEnchantments(enchantments: globalThis.java.util.Map<org.bukkit.enchantments.Enchantment, number>): void;

			/**
			 * Adds the specified Enchantment to this item stack.
			 * 
			 * If this item stack already contained the given enchantment (at any
			 * level), it will be replaced.
			 */
			addEnchantment(ench: org.bukkit.enchantments.Enchantment, level: number): void;

			/**
			 * Adds the specified enchantments to this item stack in an unsafe manner.
			 * 
			 * This method is the same as calling addUnsafeEnchantment(org.bukkit.enchantments.Enchantment, int) for
			 * each element of the map.
			 */
			addUnsafeEnchantments(enchantments: globalThis.java.util.Map<org.bukkit.enchantments.Enchantment, number>): void;

			/**
			 * Adds the specified Enchantment to this item stack.
			 * 
			 * If this item stack already contained the given enchantment (at any
			 * level), it will be replaced.
			 * 
			 * This method is unsafe and will ignore level restrictions or item type.
			 * Use at your own discretion.
			 */
			addUnsafeEnchantment(ench: org.bukkit.enchantments.Enchantment, level: number): void;

			/**
			 * Removes the specified Enchantment if it exists on this
			 * ItemStack
			 */
			removeEnchantment(ench: org.bukkit.enchantments.Enchantment): number;

			/**
			 * Removes all enchantments on this ItemStack.
			 */
			removeEnchantments(): void;

			/**
			 * Description copied from interface:Â ConfigurationSerializable
			 */
			serialize(): globalThis.java.util.Map<string, any>;

			/**
			 * Get a copy of this ItemStack's ItemMeta.
			 */
			getItemMeta(): (org.bukkit.inventory.meta.ItemMeta | null);

			/**
			 * Checks to see if any meta data has been defined.
			 */
			hasItemMeta(): boolean;

			/**
			 * Set the ItemMeta of this ItemStack.
			 */
			setItemMeta(itemMeta: (org.bukkit.inventory.meta.ItemMeta | null)): boolean;

			/**
			 * Description copied from interface:Â Translatable
			 */
			getTranslationKey(): string;

		}
		class ItemStack {
			/**
			 * Defaults stack size to 1, with no extra data.
			 * 
			 * IMPORTANT: An ItemStack is only designed to contain
			 * items. Do not use this class to encapsulate Materials for which
			 * Material.isItem() returns false.
			 */
			constructor(type: org.bukkit.Material);

			/**
			 * An item stack with no extra data.
			 * 
			 * IMPORTANT: An ItemStack is only designed to contain
			 * items. Do not use this class to encapsulate Materials for which
			 * Material.isItem() returns false.
			 */
			constructor(type: org.bukkit.Material, amount: number);

			/**
			 * An item stack with the specified damage / durability
			 */
			constructor(type: org.bukkit.Material, amount: number, damage: number);

			constructor(type: org.bukkit.Material, amount: number, damage: number, data: (number | null));

			/**
			 * Creates a new item stack derived from the specified stack
			 */
			constructor(stack: org.bukkit.inventory.ItemStack);

		}
		namespace ItemStack {
			/**
			 * Required method for configuration serialization
			 */
			function deserialize(args: globalThis.java.util.Map<string, any>): org.bukkit.inventory.ItemStack;

		}
		interface ItemType extends Modify<org.bukkit.Keyed & org.bukkit.Translatable, {
			/**
			 * Yields this item type as a typed version of itself with a plain ItemMeta representing it.
			 */
			typed(): org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * Yields this item type as a typed version of itself with a plain ItemMeta representing it.
			 */
			typed<M = any>(itemMetaType: globalThis.java.lang.Class<M>): org.bukkit.inventory.ItemType.Typed<M>;

			/**
			 * Constructs a new itemstack with this item type that has the amount 1.
			 */
			createItemStack(): org.bukkit.inventory.ItemStack;

			/**
			 * Constructs a new itemstack with this item type.
			 */
			createItemStack(amount: number): org.bukkit.inventory.ItemStack;

			/**
			 * Returns true if this ItemType has a corresponding BlockType.
			 */
			hasBlockType(): boolean;

			/**
			 * Returns the corresponding BlockType for the given ItemType.
			 * 
			 * If there is no corresponding BlockType an error will be thrown.
			 */
			getBlockType(): org.bukkit.block.BlockType;

			/**
			 * Gets the ItemMeta class of this ItemType
			 */
			getItemMetaClass(): globalThis.java.lang.Class<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * Gets the maximum amount of this item type that can be held in a stack
			 */
			getMaxStackSize(): number;

			/**
			 * Gets the maximum durability of this item type
			 */
			getMaxDurability(): number;

			/**
			 * Checks if this item type is edible.
			 */
			isEdible(): boolean;

			isRecord(): boolean;

			/**
			 * Checks if this item type can be used as fuel in a Furnace
			 */
			isFuel(): boolean;

			/**
			 * Checks whether this item type is compostable (can be inserted into a
			 * composter).
			 */
			isCompostable(): boolean;

			/**
			 * Get the chance that this item type will successfully compost. The
			 * returned value is between 0 and 1 (inclusive).
			 * Items with a compost chance of 1 will always raise the composter's level,
			 * while items with a compost chance of 0 will never raise it.
			 * Plugins should check that isCompostable() returns true before
			 * calling this method.
			 */
			getCompostChance(): number;

			/**
			 * Determines the remaining item in a crafting grid after crafting with this
			 * ingredient.
			 */
			getCraftingRemainingItem(): (org.bukkit.inventory.ItemType | null);

			/**
			 * Return an immutable copy of all default Attributes and their
			 * AttributeModifiers for a given EquipmentSlot.
			 * Default attributes are those that are always preset on some items, such
			 * as the attack damage on weapons or the armor value on armor.
			 */
			getDefaultAttributeModifiers(slot: org.bukkit.inventory.EquipmentSlot): any /* com.google.common.collect.Multimap */;

			/**
			 * Get the CreativeCategory to which this item type belongs.
			 */
			getCreativeCategory(): (org.bukkit.inventory.CreativeCategory | null);

			/**
			 * Gets if the ItemType is enabled by the features in a world.
			 */
			isEnabledByFeature(world: org.bukkit.World): boolean;

			/**
			 * Tries to convert this ItemType into a Material
			 */
			asMaterial(): (org.bukkit.Material | null);

		}> {}
		namespace ItemType {
			/**
			 * Air does not have any ItemMeta
			 */
			const AIR: org.bukkit.inventory.ItemType;

			const STONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GRANITE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_GRANITE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DIORITE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_DIORITE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ANDESITE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_ANDESITE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEEPSLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COBBLED_DEEPSLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_DEEPSLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CALCITE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TUFF: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TUFF_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TUFF_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TUFF_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHISELED_TUFF: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_TUFF: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_TUFF_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_TUFF_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_TUFF_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TUFF_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TUFF_BRICK_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TUFF_BRICK_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TUFF_BRICK_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHISELED_TUFF_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DRIPSTONE_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GRASS_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DIRT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COARSE_DIRT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PODZOL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ROOTED_DIRT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CRIMSON_NYLIUM: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WARPED_NYLIUM: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COBBLESTONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OAK_PLANKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SPRUCE_PLANKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BIRCH_PLANKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const JUNGLE_PLANKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ACACIA_PLANKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHERRY_PLANKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DARK_OAK_PLANKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MANGROVE_PLANKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BAMBOO_PLANKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CRIMSON_PLANKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WARPED_PLANKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BAMBOO_MOSAIC: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OAK_SAPLING: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SPRUCE_SAPLING: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BIRCH_SAPLING: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const JUNGLE_SAPLING: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ACACIA_SAPLING: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHERRY_SAPLING: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DARK_OAK_SAPLING: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MANGROVE_PROPAGULE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BEDROCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SAND: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const SUSPICIOUS_SAND: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const SUSPICIOUS_GRAVEL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const RED_SAND: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GRAVEL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COAL_ORE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEEPSLATE_COAL_ORE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const IRON_ORE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEEPSLATE_IRON_ORE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COPPER_ORE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEEPSLATE_COPPER_ORE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GOLD_ORE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEEPSLATE_GOLD_ORE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const REDSTONE_ORE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEEPSLATE_REDSTONE_ORE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const EMERALD_ORE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEEPSLATE_EMERALD_ORE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LAPIS_ORE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEEPSLATE_LAPIS_ORE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DIAMOND_ORE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEEPSLATE_DIAMOND_ORE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NETHER_GOLD_ORE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NETHER_QUARTZ_ORE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ANCIENT_DEBRIS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COAL_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RAW_IRON_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RAW_COPPER_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RAW_GOLD_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const HEAVY_CORE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const AMETHYST_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BUDDING_AMETHYST: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const IRON_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COPPER_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GOLD_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DIAMOND_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NETHERITE_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const EXPOSED_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WEATHERED_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OXIDIZED_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHISELED_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const EXPOSED_CHISELED_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WEATHERED_CHISELED_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OXIDIZED_CHISELED_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CUT_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const EXPOSED_CUT_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WEATHERED_CUT_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OXIDIZED_CUT_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CUT_COPPER_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const EXPOSED_CUT_COPPER_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WEATHERED_CUT_COPPER_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OXIDIZED_CUT_COPPER_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CUT_COPPER_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const EXPOSED_CUT_COPPER_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WEATHERED_CUT_COPPER_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OXIDIZED_CUT_COPPER_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_COPPER_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_EXPOSED_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_WEATHERED_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_OXIDIZED_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_CHISELED_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_EXPOSED_CHISELED_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_WEATHERED_CHISELED_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_OXIDIZED_CHISELED_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_CUT_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_EXPOSED_CUT_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_WEATHERED_CUT_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_OXIDIZED_CUT_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_CUT_COPPER_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_EXPOSED_CUT_COPPER_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_WEATHERED_CUT_COPPER_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_OXIDIZED_CUT_COPPER_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_CUT_COPPER_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_EXPOSED_CUT_COPPER_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_WEATHERED_CUT_COPPER_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_OXIDIZED_CUT_COPPER_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OAK_LOG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SPRUCE_LOG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BIRCH_LOG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const JUNGLE_LOG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ACACIA_LOG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHERRY_LOG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DARK_OAK_LOG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MANGROVE_LOG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MANGROVE_ROOTS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUDDY_MANGROVE_ROOTS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CRIMSON_STEM: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WARPED_STEM: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BAMBOO_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_OAK_LOG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_SPRUCE_LOG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_BIRCH_LOG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_JUNGLE_LOG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_ACACIA_LOG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_CHERRY_LOG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_DARK_OAK_LOG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_MANGROVE_LOG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_CRIMSON_STEM: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_WARPED_STEM: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_OAK_WOOD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_SPRUCE_WOOD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_BIRCH_WOOD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_JUNGLE_WOOD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_ACACIA_WOOD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_CHERRY_WOOD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_DARK_OAK_WOOD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_MANGROVE_WOOD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_CRIMSON_HYPHAE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_WARPED_HYPHAE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRIPPED_BAMBOO_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OAK_WOOD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SPRUCE_WOOD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BIRCH_WOOD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const JUNGLE_WOOD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ACACIA_WOOD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHERRY_WOOD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DARK_OAK_WOOD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MANGROVE_WOOD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CRIMSON_HYPHAE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WARPED_HYPHAE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OAK_LEAVES: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SPRUCE_LEAVES: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BIRCH_LEAVES: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const JUNGLE_LEAVES: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ACACIA_LEAVES: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHERRY_LEAVES: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DARK_OAK_LEAVES: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MANGROVE_LEAVES: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const AZALEA_LEAVES: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const FLOWERING_AZALEA_LEAVES: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SPONGE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WET_SPONGE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GLASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TINTED_GLASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LAPIS_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SANDSTONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHISELED_SANDSTONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CUT_SANDSTONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COBWEB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SHORT_GRASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const FERN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const AZALEA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const FLOWERING_AZALEA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEAD_BUSH: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SEAGRASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SEA_PICKLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WHITE_WOOL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ORANGE_WOOL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MAGENTA_WOOL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_BLUE_WOOL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const YELLOW_WOOL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIME_WOOL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PINK_WOOL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GRAY_WOOL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_GRAY_WOOL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CYAN_WOOL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PURPLE_WOOL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLUE_WOOL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BROWN_WOOL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GREEN_WOOL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_WOOL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLACK_WOOL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DANDELION: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POPPY: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLUE_ORCHID: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ALLIUM: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const AZURE_BLUET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_TULIP: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ORANGE_TULIP: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WHITE_TULIP: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PINK_TULIP: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OXEYE_DAISY: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CORNFLOWER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LILY_OF_THE_VALLEY: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WITHER_ROSE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TORCHFLOWER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PITCHER_PLANT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SPORE_BLOSSOM: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BROWN_MUSHROOM: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_MUSHROOM: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CRIMSON_FUNGUS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WARPED_FUNGUS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CRIMSON_ROOTS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WARPED_ROOTS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NETHER_SPROUTS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WEEPING_VINES: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TWISTING_VINES: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SUGAR_CANE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const KELP: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MOSS_CARPET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PINK_PETALS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MOSS_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const HANGING_ROOTS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BIG_DRIPLEAF: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SMALL_DRIPLEAF: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BAMBOO: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OAK_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SPRUCE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BIRCH_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const JUNGLE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ACACIA_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHERRY_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DARK_OAK_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MANGROVE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BAMBOO_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BAMBOO_MOSAIC_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CRIMSON_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WARPED_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STONE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SMOOTH_STONE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SANDSTONE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CUT_SANDSTONE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PETRIFIED_OAK_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COBBLESTONE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BRICK_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STONE_BRICK_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUD_BRICK_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NETHER_BRICK_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const QUARTZ_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_SANDSTONE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CUT_RED_SANDSTONE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PURPUR_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PRISMARINE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PRISMARINE_BRICK_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DARK_PRISMARINE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SMOOTH_QUARTZ: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SMOOTH_RED_SANDSTONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SMOOTH_SANDSTONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SMOOTH_STONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BOOKSHELF: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const CHISELED_BOOKSHELF: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const DECORATED_POT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const MOSSY_COBBLESTONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OBSIDIAN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TORCH: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const END_ROD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHORUS_PLANT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHORUS_FLOWER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PURPUR_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PURPUR_PILLAR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PURPUR_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const SPAWNER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const CHEST: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const CRAFTING_TABLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const FARMLAND: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const FURNACE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const LADDER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COBBLESTONE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SNOW: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ICE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SNOW_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CACTUS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CLAY: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const JUKEBOX: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const OAK_FENCE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SPRUCE_FENCE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BIRCH_FENCE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const JUNGLE_FENCE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ACACIA_FENCE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHERRY_FENCE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DARK_OAK_FENCE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MANGROVE_FENCE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BAMBOO_FENCE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CRIMSON_FENCE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WARPED_FENCE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PUMPKIN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CARVED_PUMPKIN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const JACK_O_LANTERN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NETHERRACK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SOUL_SAND: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SOUL_SOIL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BASALT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_BASALT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SMOOTH_BASALT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SOUL_TORCH: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GLOWSTONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const INFESTED_STONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const INFESTED_COBBLESTONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const INFESTED_STONE_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const INFESTED_MOSSY_STONE_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const INFESTED_CRACKED_STONE_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const INFESTED_CHISELED_STONE_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const INFESTED_DEEPSLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STONE_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MOSSY_STONE_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CRACKED_STONE_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHISELED_STONE_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PACKED_MUD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUD_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEEPSLATE_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CRACKED_DEEPSLATE_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEEPSLATE_TILES: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CRACKED_DEEPSLATE_TILES: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHISELED_DEEPSLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const REINFORCED_DEEPSLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BROWN_MUSHROOM_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_MUSHROOM_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSHROOM_STEM: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const IRON_BARS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHAIN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GLASS_PANE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MELON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const VINE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GLOW_LICHEN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BRICK_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STONE_BRICK_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUD_BRICK_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MYCELIUM: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LILY_PAD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NETHER_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CRACKED_NETHER_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHISELED_NETHER_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NETHER_BRICK_FENCE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NETHER_BRICK_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SCULK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SCULK_VEIN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const SCULK_CATALYST: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const SCULK_SHRIEKER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const ENCHANTING_TABLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const END_PORTAL_FRAME: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const END_STONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const END_STONE_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DRAGON_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SANDSTONE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const ENDER_CHEST: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const EMERALD_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OAK_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SPRUCE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BIRCH_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const JUNGLE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ACACIA_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHERRY_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DARK_OAK_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MANGROVE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BAMBOO_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BAMBOO_MOSAIC_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CRIMSON_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WARPED_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const COMMAND_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const BEACON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const COBBLESTONE_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MOSSY_COBBLESTONE_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BRICK_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PRISMARINE_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_SANDSTONE_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MOSSY_STONE_BRICK_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GRANITE_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STONE_BRICK_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUD_BRICK_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NETHER_BRICK_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ANDESITE_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_NETHER_BRICK_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SANDSTONE_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const END_STONE_BRICK_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DIORITE_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLACKSTONE_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_BLACKSTONE_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_BLACKSTONE_BRICK_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COBBLED_DEEPSLATE_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_DEEPSLATE_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEEPSLATE_BRICK_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEEPSLATE_TILE_WALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ANVIL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHIPPED_ANVIL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DAMAGED_ANVIL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHISELED_QUARTZ_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const QUARTZ_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const QUARTZ_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const QUARTZ_PILLAR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const QUARTZ_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WHITE_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ORANGE_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MAGENTA_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_BLUE_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const YELLOW_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIME_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PINK_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GRAY_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_GRAY_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CYAN_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PURPLE_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLUE_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BROWN_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GREEN_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLACK_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BARRIER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const HAY_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WHITE_CARPET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ORANGE_CARPET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MAGENTA_CARPET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_BLUE_CARPET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const YELLOW_CARPET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIME_CARPET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PINK_CARPET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GRAY_CARPET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_GRAY_CARPET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CYAN_CARPET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PURPLE_CARPET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLUE_CARPET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BROWN_CARPET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GREEN_CARPET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_CARPET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLACK_CARPET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PACKED_ICE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DIRT_PATH: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SUNFLOWER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LILAC: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ROSE_BUSH: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PEONY: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TALL_GRASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LARGE_FERN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WHITE_STAINED_GLASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ORANGE_STAINED_GLASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MAGENTA_STAINED_GLASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_BLUE_STAINED_GLASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const YELLOW_STAINED_GLASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIME_STAINED_GLASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PINK_STAINED_GLASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GRAY_STAINED_GLASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_GRAY_STAINED_GLASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CYAN_STAINED_GLASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PURPLE_STAINED_GLASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLUE_STAINED_GLASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BROWN_STAINED_GLASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GREEN_STAINED_GLASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_STAINED_GLASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLACK_STAINED_GLASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WHITE_STAINED_GLASS_PANE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ORANGE_STAINED_GLASS_PANE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MAGENTA_STAINED_GLASS_PANE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_BLUE_STAINED_GLASS_PANE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const YELLOW_STAINED_GLASS_PANE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIME_STAINED_GLASS_PANE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PINK_STAINED_GLASS_PANE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GRAY_STAINED_GLASS_PANE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_GRAY_STAINED_GLASS_PANE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CYAN_STAINED_GLASS_PANE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PURPLE_STAINED_GLASS_PANE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLUE_STAINED_GLASS_PANE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BROWN_STAINED_GLASS_PANE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GREEN_STAINED_GLASS_PANE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_STAINED_GLASS_PANE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLACK_STAINED_GLASS_PANE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PRISMARINE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PRISMARINE_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DARK_PRISMARINE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PRISMARINE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PRISMARINE_BRICK_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DARK_PRISMARINE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SEA_LANTERN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_SANDSTONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHISELED_RED_SANDSTONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CUT_RED_SANDSTONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_SANDSTONE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const REPEATING_COMMAND_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const CHAIN_COMMAND_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const MAGMA_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NETHER_WART_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WARPED_WART_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_NETHER_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BONE_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRUCTURE_VOID: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const SHULKER_BOX: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const WHITE_SHULKER_BOX: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const ORANGE_SHULKER_BOX: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const MAGENTA_SHULKER_BOX: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const LIGHT_BLUE_SHULKER_BOX: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const YELLOW_SHULKER_BOX: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const LIME_SHULKER_BOX: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const PINK_SHULKER_BOX: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const GRAY_SHULKER_BOX: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const LIGHT_GRAY_SHULKER_BOX: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const CYAN_SHULKER_BOX: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const PURPLE_SHULKER_BOX: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const BLUE_SHULKER_BOX: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const BROWN_SHULKER_BOX: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const GREEN_SHULKER_BOX: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const RED_SHULKER_BOX: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const BLACK_SHULKER_BOX: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const WHITE_GLAZED_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ORANGE_GLAZED_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MAGENTA_GLAZED_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_BLUE_GLAZED_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const YELLOW_GLAZED_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIME_GLAZED_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PINK_GLAZED_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GRAY_GLAZED_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_GRAY_GLAZED_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CYAN_GLAZED_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PURPLE_GLAZED_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLUE_GLAZED_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BROWN_GLAZED_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GREEN_GLAZED_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_GLAZED_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLACK_GLAZED_TERRACOTTA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WHITE_CONCRETE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ORANGE_CONCRETE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MAGENTA_CONCRETE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_BLUE_CONCRETE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const YELLOW_CONCRETE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIME_CONCRETE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PINK_CONCRETE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GRAY_CONCRETE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_GRAY_CONCRETE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CYAN_CONCRETE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PURPLE_CONCRETE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLUE_CONCRETE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BROWN_CONCRETE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GREEN_CONCRETE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_CONCRETE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLACK_CONCRETE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WHITE_CONCRETE_POWDER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ORANGE_CONCRETE_POWDER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MAGENTA_CONCRETE_POWDER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_BLUE_CONCRETE_POWDER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const YELLOW_CONCRETE_POWDER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIME_CONCRETE_POWDER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PINK_CONCRETE_POWDER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GRAY_CONCRETE_POWDER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_GRAY_CONCRETE_POWDER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CYAN_CONCRETE_POWDER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PURPLE_CONCRETE_POWDER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLUE_CONCRETE_POWDER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BROWN_CONCRETE_POWDER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GREEN_CONCRETE_POWDER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_CONCRETE_POWDER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLACK_CONCRETE_POWDER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TURTLE_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SNIFFER_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEAD_TUBE_CORAL_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEAD_BRAIN_CORAL_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEAD_BUBBLE_CORAL_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEAD_FIRE_CORAL_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEAD_HORN_CORAL_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TUBE_CORAL_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BRAIN_CORAL_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BUBBLE_CORAL_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const FIRE_CORAL_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const HORN_CORAL_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TUBE_CORAL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BRAIN_CORAL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BUBBLE_CORAL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const FIRE_CORAL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const HORN_CORAL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEAD_BRAIN_CORAL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEAD_BUBBLE_CORAL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEAD_FIRE_CORAL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEAD_HORN_CORAL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEAD_TUBE_CORAL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TUBE_CORAL_FAN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BRAIN_CORAL_FAN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BUBBLE_CORAL_FAN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const FIRE_CORAL_FAN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const HORN_CORAL_FAN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEAD_TUBE_CORAL_FAN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEAD_BRAIN_CORAL_FAN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEAD_BUBBLE_CORAL_FAN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEAD_FIRE_CORAL_FAN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEAD_HORN_CORAL_FAN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLUE_ICE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CONDUIT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_GRANITE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SMOOTH_RED_SANDSTONE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MOSSY_STONE_BRICK_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_DIORITE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MOSSY_COBBLESTONE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const END_STONE_BRICK_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STONE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SMOOTH_SANDSTONE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SMOOTH_QUARTZ_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GRANITE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ANDESITE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_NETHER_BRICK_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_ANDESITE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DIORITE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COBBLED_DEEPSLATE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_DEEPSLATE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEEPSLATE_BRICK_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEEPSLATE_TILE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_GRANITE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SMOOTH_RED_SANDSTONE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MOSSY_STONE_BRICK_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_DIORITE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MOSSY_COBBLESTONE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const END_STONE_BRICK_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SMOOTH_SANDSTONE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SMOOTH_QUARTZ_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GRANITE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ANDESITE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_NETHER_BRICK_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_ANDESITE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DIORITE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COBBLED_DEEPSLATE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_DEEPSLATE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEEPSLATE_BRICK_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DEEPSLATE_TILE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SCAFFOLDING: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const REDSTONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const REDSTONE_TORCH: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const REDSTONE_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const REPEATER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const COMPARATOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const PISTON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STICKY_PISTON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SLIME_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const HONEY_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OBSERVER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const HOPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const DISPENSER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const DROPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const LECTERN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const TARGET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LEVER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHTNING_ROD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const DAYLIGHT_DETECTOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const SCULK_SENSOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const CALIBRATED_SCULK_SENSOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const TRIPWIRE_HOOK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const TRAPPED_CHEST: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const TNT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const REDSTONE_LAMP: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NOTE_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STONE_BUTTON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_BLACKSTONE_BUTTON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OAK_BUTTON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SPRUCE_BUTTON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BIRCH_BUTTON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const JUNGLE_BUTTON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ACACIA_BUTTON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHERRY_BUTTON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DARK_OAK_BUTTON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MANGROVE_BUTTON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BAMBOO_BUTTON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CRIMSON_BUTTON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WARPED_BUTTON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STONE_PRESSURE_PLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_BLACKSTONE_PRESSURE_PLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_WEIGHTED_PRESSURE_PLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const HEAVY_WEIGHTED_PRESSURE_PLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OAK_PRESSURE_PLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SPRUCE_PRESSURE_PLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BIRCH_PRESSURE_PLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const JUNGLE_PRESSURE_PLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ACACIA_PRESSURE_PLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHERRY_PRESSURE_PLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DARK_OAK_PRESSURE_PLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MANGROVE_PRESSURE_PLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BAMBOO_PRESSURE_PLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CRIMSON_PRESSURE_PLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WARPED_PRESSURE_PLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const IRON_DOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OAK_DOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SPRUCE_DOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BIRCH_DOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const JUNGLE_DOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ACACIA_DOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHERRY_DOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DARK_OAK_DOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MANGROVE_DOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BAMBOO_DOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CRIMSON_DOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WARPED_DOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COPPER_DOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const EXPOSED_COPPER_DOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WEATHERED_COPPER_DOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OXIDIZED_COPPER_DOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_COPPER_DOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_EXPOSED_COPPER_DOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_WEATHERED_COPPER_DOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_OXIDIZED_COPPER_DOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const IRON_TRAPDOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OAK_TRAPDOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SPRUCE_TRAPDOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BIRCH_TRAPDOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const JUNGLE_TRAPDOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ACACIA_TRAPDOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHERRY_TRAPDOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DARK_OAK_TRAPDOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MANGROVE_TRAPDOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BAMBOO_TRAPDOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CRIMSON_TRAPDOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WARPED_TRAPDOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COPPER_TRAPDOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const EXPOSED_COPPER_TRAPDOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WEATHERED_COPPER_TRAPDOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OXIDIZED_COPPER_TRAPDOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_COPPER_TRAPDOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_EXPOSED_COPPER_TRAPDOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_WEATHERED_COPPER_TRAPDOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_OXIDIZED_COPPER_TRAPDOOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OAK_FENCE_GATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SPRUCE_FENCE_GATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BIRCH_FENCE_GATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const JUNGLE_FENCE_GATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ACACIA_FENCE_GATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHERRY_FENCE_GATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DARK_OAK_FENCE_GATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MANGROVE_FENCE_GATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BAMBOO_FENCE_GATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CRIMSON_FENCE_GATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WARPED_FENCE_GATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POWERED_RAIL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DETECTOR_RAIL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RAIL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ACTIVATOR_RAIL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SADDLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MINECART: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHEST_MINECART: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const FURNACE_MINECART: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TNT_MINECART: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const HOPPER_MINECART: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CARROT_ON_A_STICK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WARPED_FUNGUS_ON_A_STICK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ELYTRA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OAK_BOAT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OAK_CHEST_BOAT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SPRUCE_BOAT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SPRUCE_CHEST_BOAT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BIRCH_BOAT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BIRCH_CHEST_BOAT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const JUNGLE_BOAT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const JUNGLE_CHEST_BOAT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ACACIA_BOAT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ACACIA_CHEST_BOAT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHERRY_BOAT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHERRY_CHEST_BOAT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DARK_OAK_BOAT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DARK_OAK_CHEST_BOAT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MANGROVE_BOAT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MANGROVE_CHEST_BOAT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BAMBOO_RAFT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BAMBOO_CHEST_RAFT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const STRUCTURE_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const JIGSAW: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const TURTLE_HELMET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			const TURTLE_SCUTE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ARMADILLO_SCUTE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: ColorableArmorMeta
			 */
			const WOLF_ARMOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ColorableArmorMeta>;

			const BOWL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const FLINT_AND_STEEL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const APPLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BOW: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ARROW: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COAL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHARCOAL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DIAMOND: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const EMERALD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LAPIS_LAZULI: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const QUARTZ: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const AMETHYST_SHARD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RAW_IRON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const IRON_INGOT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RAW_COPPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COPPER_INGOT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RAW_GOLD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GOLD_INGOT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NETHERITE_INGOT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NETHERITE_SCRAP: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WOODEN_SWORD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WOODEN_SHOVEL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WOODEN_PICKAXE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WOODEN_AXE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WOODEN_HOE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STONE_SWORD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STONE_SHOVEL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STONE_PICKAXE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STONE_AXE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STONE_HOE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GOLDEN_SWORD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GOLDEN_SHOVEL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GOLDEN_PICKAXE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GOLDEN_AXE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GOLDEN_HOE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const IRON_SWORD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const IRON_SHOVEL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const IRON_PICKAXE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const IRON_AXE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const IRON_HOE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DIAMOND_SWORD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DIAMOND_SHOVEL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DIAMOND_PICKAXE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DIAMOND_AXE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DIAMOND_HOE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NETHERITE_SWORD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NETHERITE_SHOVEL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NETHERITE_PICKAXE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NETHERITE_AXE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NETHERITE_HOE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STICK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSHROOM_STEW: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STRING: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const FEATHER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GUNPOWDER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WHEAT_SEEDS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WHEAT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BREAD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: ColorableArmorMeta
			 */
			const LEATHER_HELMET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ColorableArmorMeta>;

			/**
			 * ItemMeta: ColorableArmorMeta
			 */
			const LEATHER_CHESTPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ColorableArmorMeta>;

			/**
			 * ItemMeta: ColorableArmorMeta
			 */
			const LEATHER_LEGGINGS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ColorableArmorMeta>;

			/**
			 * ItemMeta: ColorableArmorMeta
			 */
			const LEATHER_BOOTS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ColorableArmorMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const CHAINMAIL_HELMET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const CHAINMAIL_CHESTPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const CHAINMAIL_LEGGINGS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const CHAINMAIL_BOOTS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const IRON_HELMET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const IRON_CHESTPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const IRON_LEGGINGS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const IRON_BOOTS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const DIAMOND_HELMET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const DIAMOND_CHESTPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const DIAMOND_LEGGINGS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const DIAMOND_BOOTS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const GOLDEN_HELMET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const GOLDEN_CHESTPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const GOLDEN_LEGGINGS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const GOLDEN_BOOTS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const NETHERITE_HELMET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const NETHERITE_CHESTPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const NETHERITE_LEGGINGS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			/**
			 * ItemMeta: ArmorMeta
			 */
			const NETHERITE_BOOTS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ArmorMeta>;

			const FLINT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PORKCHOP: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COOKED_PORKCHOP: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PAINTING: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GOLDEN_APPLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ENCHANTED_GOLDEN_APPLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const OAK_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const SPRUCE_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const BIRCH_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const JUNGLE_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const ACACIA_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const CHERRY_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const DARK_OAK_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const MANGROVE_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const BAMBOO_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const CRIMSON_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const WARPED_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const OAK_HANGING_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const SPRUCE_HANGING_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const BIRCH_HANGING_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const JUNGLE_HANGING_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const ACACIA_HANGING_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const CHERRY_HANGING_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const DARK_OAK_HANGING_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const MANGROVE_HANGING_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const BAMBOO_HANGING_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const CRIMSON_HANGING_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const WARPED_HANGING_SIGN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const BUCKET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WATER_BUCKET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LAVA_BUCKET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POWDER_SNOW_BUCKET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SNOWBALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LEATHER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MILK_BUCKET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PUFFERFISH_BUCKET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SALMON_BUCKET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COD_BUCKET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: TropicalFishBucketMeta
			 */
			const TROPICAL_FISH_BUCKET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.TropicalFishBucketMeta>;

			/**
			 * ItemMeta: AxolotlBucketMeta
			 */
			const AXOLOTL_BUCKET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.AxolotlBucketMeta>;

			const TADPOLE_BUCKET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BRICK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CLAY_BALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DRIED_KELP_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PAPER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BOOK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SLIME_BALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: CompassMeta
			 */
			const COMPASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.CompassMeta>;

			const RECOVERY_COMPASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BundleMeta
			 */
			const BUNDLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BundleMeta>;

			const FISHING_ROD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SPYGLASS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GLOWSTONE_DUST: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SALMON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TROPICAL_FISH: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PUFFERFISH: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COOKED_COD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COOKED_SALMON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const INK_SAC: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GLOW_INK_SAC: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COCOA_BEANS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WHITE_DYE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ORANGE_DYE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MAGENTA_DYE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_BLUE_DYE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const YELLOW_DYE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIME_DYE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PINK_DYE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GRAY_DYE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_GRAY_DYE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CYAN_DYE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PURPLE_DYE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLUE_DYE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BROWN_DYE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GREEN_DYE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_DYE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLACK_DYE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BONE_MEAL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SUGAR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CAKE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WHITE_BED: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ORANGE_BED: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MAGENTA_BED: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_BLUE_BED: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const YELLOW_BED: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIME_BED: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PINK_BED: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GRAY_BED: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_GRAY_BED: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CYAN_BED: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PURPLE_BED: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLUE_BED: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BROWN_BED: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GREEN_BED: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_BED: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLACK_BED: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COOKIE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const CRAFTER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: MapMeta
			 */
			const FILLED_MAP: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.MapMeta>;

			const SHEARS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MELON_SLICE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DRIED_KELP: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PUMPKIN_SEEDS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MELON_SEEDS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BEEF: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COOKED_BEEF: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHICKEN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COOKED_CHICKEN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ROTTEN_FLESH: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ENDER_PEARL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLAZE_ROD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GHAST_TEAR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GOLD_NUGGET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NETHER_WART: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: PotionMeta
			 */
			const POTION: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.PotionMeta>;

			const GLASS_BOTTLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SPIDER_EYE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const FERMENTED_SPIDER_EYE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLAZE_POWDER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MAGMA_CREAM: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const BREWING_STAND: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const CAULDRON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ENDER_EYE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GLISTERING_MELON_SLICE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const ARMADILLO_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const ALLAY_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const AXOLOTL_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const BAT_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const BEE_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const BLAZE_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const BOGGED_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const BREEZE_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const CAT_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const CAMEL_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const CAVE_SPIDER_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const CHICKEN_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const COD_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const COW_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const CREEPER_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const DOLPHIN_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const DONKEY_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const DROWNED_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const ELDER_GUARDIAN_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const ENDER_DRAGON_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const ENDERMAN_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const ENDERMITE_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const EVOKER_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const FOX_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const FROG_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const GHAST_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const GLOW_SQUID_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const GOAT_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const GUARDIAN_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const HOGLIN_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const HORSE_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const HUSK_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const IRON_GOLEM_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const LLAMA_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const MAGMA_CUBE_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const MOOSHROOM_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const MULE_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const OCELOT_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const PANDA_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const PARROT_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const PHANTOM_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const PIG_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const PIGLIN_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const PIGLIN_BRUTE_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const PILLAGER_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const POLAR_BEAR_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const PUFFERFISH_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const RABBIT_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const RAVAGER_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const SALMON_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const SHEEP_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const SHULKER_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const SILVERFISH_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const SKELETON_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const SKELETON_HORSE_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const SLIME_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const SNIFFER_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const SNOW_GOLEM_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const SPIDER_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const SQUID_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const STRAY_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const STRIDER_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const TADPOLE_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const TRADER_LLAMA_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const TROPICAL_FISH_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const TURTLE_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const VEX_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const VILLAGER_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const VINDICATOR_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const WANDERING_TRADER_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const WARDEN_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const WITCH_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const WITHER_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const WITHER_SKELETON_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const WOLF_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const ZOGLIN_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const ZOMBIE_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const ZOMBIE_HORSE_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const ZOMBIE_VILLAGER_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			/**
			 * ItemMeta: SpawnEggMeta
			 */
			const ZOMBIFIED_PIGLIN_SPAWN_EGG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SpawnEggMeta>;

			const EXPERIENCE_BOTTLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const FIRE_CHARGE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WIND_CHARGE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BookMeta
			 */
			const WRITABLE_BOOK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BookMeta>;

			/**
			 * ItemMeta: BookMeta
			 */
			const WRITTEN_BOOK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BookMeta>;

			const MACE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ITEM_FRAME: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GLOW_ITEM_FRAME: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const FLOWER_POT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CARROT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POTATO: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BAKED_POTATO: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POISONOUS_POTATO: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MAP: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GOLDEN_CARROT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: SkullMeta
			 */
			const SKELETON_SKULL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SkullMeta>;

			/**
			 * ItemMeta: SkullMeta
			 */
			const WITHER_SKELETON_SKULL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SkullMeta>;

			/**
			 * ItemMeta: SkullMeta
			 */
			const PLAYER_HEAD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SkullMeta>;

			/**
			 * ItemMeta: SkullMeta
			 */
			const ZOMBIE_HEAD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SkullMeta>;

			/**
			 * ItemMeta: SkullMeta
			 */
			const CREEPER_HEAD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SkullMeta>;

			/**
			 * ItemMeta: SkullMeta
			 */
			const DRAGON_HEAD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SkullMeta>;

			/**
			 * ItemMeta: SkullMeta
			 */
			const PIGLIN_HEAD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SkullMeta>;

			const NETHER_STAR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PUMPKIN_PIE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: FireworkMeta
			 */
			const FIREWORK_ROCKET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.FireworkMeta>;

			/**
			 * ItemMeta: FireworkEffectMeta
			 */
			const FIREWORK_STAR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.FireworkEffectMeta>;

			/**
			 * ItemMeta: EnchantmentStorageMeta
			 */
			const ENCHANTED_BOOK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.EnchantmentStorageMeta>;

			const NETHER_BRICK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PRISMARINE_SHARD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PRISMARINE_CRYSTALS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RABBIT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COOKED_RABBIT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RABBIT_STEW: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RABBIT_FOOT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RABBIT_HIDE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ARMOR_STAND: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const IRON_HORSE_ARMOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GOLDEN_HORSE_ARMOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DIAMOND_HORSE_ARMOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: LeatherArmorMeta
			 */
			const LEATHER_HORSE_ARMOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.LeatherArmorMeta>;

			const LEAD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NAME_TAG: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COMMAND_BLOCK_MINECART: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUTTON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COOKED_MUTTON: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BannerMeta
			 */
			const WHITE_BANNER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BannerMeta>;

			/**
			 * ItemMeta: BannerMeta
			 */
			const ORANGE_BANNER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BannerMeta>;

			/**
			 * ItemMeta: BannerMeta
			 */
			const MAGENTA_BANNER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BannerMeta>;

			/**
			 * ItemMeta: BannerMeta
			 */
			const LIGHT_BLUE_BANNER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BannerMeta>;

			/**
			 * ItemMeta: BannerMeta
			 */
			const YELLOW_BANNER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BannerMeta>;

			/**
			 * ItemMeta: BannerMeta
			 */
			const LIME_BANNER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BannerMeta>;

			/**
			 * ItemMeta: BannerMeta
			 */
			const PINK_BANNER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BannerMeta>;

			/**
			 * ItemMeta: BannerMeta
			 */
			const GRAY_BANNER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BannerMeta>;

			/**
			 * ItemMeta: BannerMeta
			 */
			const LIGHT_GRAY_BANNER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BannerMeta>;

			/**
			 * ItemMeta: BannerMeta
			 */
			const CYAN_BANNER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BannerMeta>;

			/**
			 * ItemMeta: BannerMeta
			 */
			const PURPLE_BANNER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BannerMeta>;

			/**
			 * ItemMeta: BannerMeta
			 */
			const BLUE_BANNER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BannerMeta>;

			/**
			 * ItemMeta: BannerMeta
			 */
			const BROWN_BANNER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BannerMeta>;

			/**
			 * ItemMeta: BannerMeta
			 */
			const GREEN_BANNER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BannerMeta>;

			/**
			 * ItemMeta: BannerMeta
			 */
			const RED_BANNER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BannerMeta>;

			/**
			 * ItemMeta: BannerMeta
			 */
			const BLACK_BANNER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BannerMeta>;

			const END_CRYSTAL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHORUS_FRUIT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POPPED_CHORUS_FRUIT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TORCHFLOWER_SEEDS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PITCHER_POD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BEETROOT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BEETROOT_SEEDS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BEETROOT_SOUP: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DRAGON_BREATH: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: PotionMeta
			 */
			const SPLASH_POTION: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.PotionMeta>;

			const SPECTRAL_ARROW: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: PotionMeta
			 */
			const TIPPED_ARROW: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.PotionMeta>;

			/**
			 * ItemMeta: PotionMeta
			 */
			const LINGERING_POTION: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.PotionMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const SHIELD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const TOTEM_OF_UNDYING: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SHULKER_SHELL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const IRON_NUGGET: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: KnowledgeBookMeta
			 */
			const KNOWLEDGE_BOOK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.KnowledgeBookMeta>;

			const DEBUG_STICK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSIC_DISC_13: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSIC_DISC_CAT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSIC_DISC_BLOCKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSIC_DISC_CHIRP: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSIC_DISC_CREATOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSIC_DISC_CREATOR_MUSIC_BOX: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSIC_DISC_FAR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSIC_DISC_MALL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSIC_DISC_MELLOHI: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSIC_DISC_STAL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSIC_DISC_STRAD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSIC_DISC_WARD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSIC_DISC_11: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSIC_DISC_WAIT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSIC_DISC_OTHERSIDE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSIC_DISC_RELIC: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSIC_DISC_5: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSIC_DISC_PIGSTEP: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MUSIC_DISC_PRECIPICE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DISC_FRAGMENT_5: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TRIDENT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PHANTOM_MEMBRANE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NAUTILUS_SHELL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const HEART_OF_THE_SEA: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: CrossbowMeta
			 */
			const CROSSBOW: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.CrossbowMeta>;

			/**
			 * ItemMeta: SuspiciousStewMeta
			 */
			const SUSPICIOUS_STEW: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.SuspiciousStewMeta>;

			const LOOM: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const FLOWER_BANNER_PATTERN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CREEPER_BANNER_PATTERN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SKULL_BANNER_PATTERN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MOJANG_BANNER_PATTERN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GLOBE_BANNER_PATTERN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PIGLIN_BANNER_PATTERN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const FLOW_BANNER_PATTERN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GUSTER_BANNER_PATTERN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: MusicInstrumentMeta
			 */
			const GOAT_HORN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.MusicInstrumentMeta>;

			const COMPOSTER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const BARREL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const SMOKER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const BLAST_FURNACE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const CARTOGRAPHY_TABLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const FLETCHING_TABLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GRINDSTONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SMITHING_TABLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const STONECUTTER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const BELL: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const LANTERN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SOUL_LANTERN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SWEET_BERRIES: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GLOW_BERRIES: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const CAMPFIRE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const SOUL_CAMPFIRE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const SHROOMLIGHT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const HONEYCOMB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const BEE_NEST: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const BEEHIVE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const HONEY_BOTTLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const HONEYCOMB_BLOCK: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LODESTONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CRYING_OBSIDIAN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLACKSTONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLACKSTONE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLACKSTONE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GILDED_BLACKSTONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_BLACKSTONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_BLACKSTONE_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_BLACKSTONE_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CHISELED_POLISHED_BLACKSTONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_BLACKSTONE_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_BLACKSTONE_BRICK_SLAB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POLISHED_BLACKSTONE_BRICK_STAIRS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CRACKED_POLISHED_BLACKSTONE_BRICKS: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RESPAWN_ANCHOR: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CANDLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WHITE_CANDLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ORANGE_CANDLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MAGENTA_CANDLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_BLUE_CANDLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const YELLOW_CANDLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIME_CANDLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PINK_CANDLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GRAY_CANDLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LIGHT_GRAY_CANDLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const CYAN_CANDLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PURPLE_CANDLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLUE_CANDLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BROWN_CANDLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GREEN_CANDLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RED_CANDLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLACK_CANDLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SMALL_AMETHYST_BUD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MEDIUM_AMETHYST_BUD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const LARGE_AMETHYST_BUD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const AMETHYST_CLUSTER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const POINTED_DRIPSTONE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OCHRE_FROGLIGHT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const VERDANT_FROGLIGHT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PEARLESCENT_FROGLIGHT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const FROGSPAWN: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ECHO_SHARD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BRUSH: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const NETHERITE_UPGRADE_SMITHING_TEMPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SENTRY_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DUNE_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COAST_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WILD_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WARD_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const EYE_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const VEX_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const TIDE_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SNOUT_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RIB_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SPIRE_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAYFINDER_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SHAPER_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SILENCE_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const RAISER_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const HOST_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const FLOW_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BOLT_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ANGLER_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ARCHER_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const ARMS_UP_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BLADE_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BREWER_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const BURN_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const DANGER_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const EXPLORER_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const FLOW_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const FRIEND_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const GUSTER_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const HEART_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const HEARTBREAK_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const HOWL_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MINER_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const MOURNER_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PLENTY_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const PRIZE_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SCRAPE_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SHEAF_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SHELTER_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SKULL_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const SNORT_POTTERY_SHERD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COPPER_GRATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const EXPOSED_COPPER_GRATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WEATHERED_COPPER_GRATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OXIDIZED_COPPER_GRATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_COPPER_GRATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_EXPOSED_COPPER_GRATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_WEATHERED_COPPER_GRATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_OXIDIZED_COPPER_GRATE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const COPPER_BULB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const EXPOSED_COPPER_BULB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WEATHERED_COPPER_BULB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OXIDIZED_COPPER_BULB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_COPPER_BULB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_EXPOSED_COPPER_BULB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_WEATHERED_COPPER_BULB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const WAXED_OXIDIZED_COPPER_BULB: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const TRIAL_SPAWNER: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			const TRIAL_KEY: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			const OMINOUS_TRIAL_KEY: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

			/**
			 * ItemMeta: BlockStateMeta
			 */
			const VAULT: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.BlockStateMeta>;

			/**
			 * ItemMeta: OminousBottleMeta
			 */
			const OMINOUS_BOTTLE: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.OminousBottleMeta>;

			const BREEZE_ROD: org.bukkit.inventory.ItemType.Typed<org.bukkit.inventory.meta.ItemMeta>;

		}
		namespace ItemType {
			interface Typed<M = any> extends Modify<org.bukkit.inventory.ItemType, {
				/**
				 * Gets the ItemMeta class of this ItemType
				 */
				getItemMetaClass(): globalThis.java.lang.Class<M>;

				/**
				 * Constructs a new item stack with this item type with the amount 1.
				 */
				createItemStack(metaConfigurator: ((value: M) => void | null)): org.bukkit.inventory.ItemStack;

				/**
				 * Constructs a new item stack with this item type.
				 */
				createItemStack(amount: number, metaConfigurator: ((value: M) => void | null)): org.bukkit.inventory.ItemStack;

			}> {}
		}
		interface JukeboxInventory extends Modify<org.bukkit.inventory.Inventory, {
			/**
			 * Set the record in the jukebox.
			 * 
			 * This will immediately start playing the inserted item or stop playing if the
			 * item provided is null.
			 */
			setRecord(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Get the record in the jukebox.
			 */
			getRecord(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Description copied from interface:Â Inventory
			 */
			getHolder(): (org.bukkit.block.Jukebox | null);

		}> {}
		interface LecternInventory extends Modify<org.bukkit.inventory.Inventory, {
			/**
			 * Description copied from interface:Â Inventory
			 */
			getHolder(): (org.bukkit.block.Lectern | null);

		}> {}
		interface LlamaInventory extends Modify<org.bukkit.inventory.AbstractHorseInventory, {
			/**
			 * Gets the item in the llama's decor slot.
			 */
			getDecor(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Sets the item in the llama's decor slot.
			 */
			setDecor(stack: (org.bukkit.inventory.ItemStack | null)): void;

		}> {}
		interface LoomInventory extends Modify<org.bukkit.inventory.Inventory, {}> {}
		interface MainHand {}
		namespace MainHand {
			const LEFT: org.bukkit.inventory.MainHand;

			const RIGHT: org.bukkit.inventory.MainHand;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.inventory.MainHand;

		}
		interface Merchant {
			/**
			 * Get a list of trades currently available from this merchant.
			 */
			getRecipes(): globalThis.java.util.List<org.bukkit.inventory.MerchantRecipe>;

			/**
			 * Set the list of trades currently available from this merchant.
			 * 
			 * This will not change the selected trades of players currently trading
			 * with this merchant.
			 */
			setRecipes(recipes: globalThis.java.util.List<org.bukkit.inventory.MerchantRecipe>): void;

			/**
			 * Get the recipe at a certain index of this merchant's trade list.
			 */
			getRecipe(i: number): org.bukkit.inventory.MerchantRecipe;

			/**
			 * Set the recipe at a certain index of this merchant's trade list.
			 */
			setRecipe(i: number, recipe: org.bukkit.inventory.MerchantRecipe): void;

			/**
			 * Get the number of trades this merchant currently has available.
			 */
			getRecipeCount(): number;

			/**
			 * Gets whether this merchant is currently trading.
			 */
			isTrading(): boolean;

			/**
			 * Gets the player this merchant is trading with, or null if it is not
			 * currently trading.
			 */
			getTrader(): (org.bukkit.entity.HumanEntity | null);

		}
		interface MerchantInventory extends Modify<org.bukkit.inventory.Inventory, {
			/**
			 * Get the index of the currently selected recipe.
			 */
			getSelectedRecipeIndex(): number;

			/**
			 * Get the currently active recipe.
			 * 
			 * This will be null if the items provided by the player do
			 * not match the ingredients of the selected recipe. This does not
			 * necessarily match the recipe selected by the player: If the player has
			 * selected the first recipe, the merchant will search all of its offers
			 * for a matching recipe to activate.
			 */
			getSelectedRecipe(): (org.bukkit.inventory.MerchantRecipe | null);

			/**
			 * Gets the Merchant associated with this inventory.
			 */
			getMerchant(): org.bukkit.inventory.Merchant;

		}> {}
		interface MerchantRecipe {
			/**
			 * Description copied from interface:Â Recipe
			 */
			getResult(): org.bukkit.inventory.ItemStack;

			addIngredient(item: org.bukkit.inventory.ItemStack): void;

			removeIngredient(index: number): void;

			setIngredients(ingredients: globalThis.java.util.List<org.bukkit.inventory.ItemStack>): void;

			getIngredients(): globalThis.java.util.List<org.bukkit.inventory.ItemStack>;

			/**
			 * Gets the adjusted first ingredient.
			 */
			getAdjustedIngredient1(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Modifies the amount of the given ItemStack in the same way as
			 * MerchantRecipe dynamically adjusts the amount of the first ingredient
			 * during trading.
			 * 
			 * This is calculated by adding up the original amount of the item, the
			 * demand scaled by the recipe's
			 * price multiplier and truncated to the next
			 * lowest integer value greater than or equal to 0, and the special price,
			 * and then constraining the resulting value between 1 and the
			 * ItemStack's maximum stack size.
			 */
			adjust(itemStack: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Get the demand for this trade.
			 */
			getDemand(): number;

			/**
			 * Set the demand for this trade.
			 */
			setDemand(demand: number): void;

			/**
			 * Get the special price for this trade.
			 */
			getSpecialPrice(): number;

			/**
			 * Set the special price for this trade.
			 */
			setSpecialPrice(specialPrice: number): void;

			/**
			 * Get the number of times this trade has been used.
			 */
			getUses(): number;

			/**
			 * Set the number of times this trade has been used.
			 */
			setUses(uses: number): void;

			/**
			 * Get the maximum number of uses this trade has.
			 */
			getMaxUses(): number;

			/**
			 * Set the maximum number of uses this trade has.
			 */
			setMaxUses(maxUses: number): void;

			/**
			 * Whether to reward experience to the player for the trade.
			 */
			hasExperienceReward(): boolean;

			/**
			 * Set whether to reward experience to the player for the trade.
			 */
			setExperienceReward(flag: boolean): void;

			/**
			 * Gets the amount of experience the villager earns from this trade.
			 */
			getVillagerExperience(): number;

			/**
			 * Sets the amount of experience the villager earns from this trade.
			 */
			setVillagerExperience(villagerExperience: number): void;

			/**
			 * Gets the price multiplier for the cost of this trade.
			 */
			getPriceMultiplier(): number;

			/**
			 * Sets the price multiplier for the cost of this trade.
			 */
			setPriceMultiplier(priceMultiplier: number): void;

		}
		class MerchantRecipe {
			constructor(result: org.bukkit.inventory.ItemStack, maxUses: number);

			constructor(result: org.bukkit.inventory.ItemStack, uses: number, maxUses: number, experienceReward: boolean);

			constructor(result: org.bukkit.inventory.ItemStack, uses: number, maxUses: number, experienceReward: boolean, villagerExperience: number, priceMultiplier: number);

			constructor(result: org.bukkit.inventory.ItemStack, uses: number, maxUses: number, experienceReward: boolean, villagerExperience: number, priceMultiplier: number, demand: number, specialPrice: number);

		}
		interface PlayerInventory extends Modify<org.bukkit.inventory.Inventory, {
			/**
			 * Return the ItemStack from the helmet slot
			 */
			getHelmet(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Return the ItemStack from the chestplate slot
			 */
			getChestplate(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Return the ItemStack from the leg slot
			 */
			getLeggings(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Return the ItemStack from the boots slot
			 */
			getBoots(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Stores the ItemStack at the given index of the inventory.
			 * 
			 * Indexes 0 through 8 refer to the hotbar. 9 through 35 refer to the main inventory, counting up from 9 at the top
			 * left corner of the inventory, moving to the right, and moving to the row below it back on the left side when it
			 * reaches the end of the row. It follows the same path in the inventory like you would read a book.
			 * 
			 * Indexes 36 through 39 refer to the armor slots. Though you can set armor with this method using these indexes,
			 * you are encouraged to use the provided methods for those slots.
			 * 
			 * Index 40 refers to the off hand (shield) item slot. Though you can set off hand with this method using this index,
			 * you are encouraged to use the provided method for this slot.
			 * 
			 * If you attempt to use this method with an index less than 0 or greater than 40, an ArrayIndexOutOfBounds
			 * exception will be thrown.
			 */
			setItem(index: number, item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Stores the ItemStack at the given equipment slot in the inventory.
			 */
			setItem(slot: org.bukkit.inventory.EquipmentSlot, item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Gets the ItemStack at the given equipment slot in the inventory.
			 */
			getItem(slot: org.bukkit.inventory.EquipmentSlot): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Put the given ItemStacks into the armor slots
			 */
			setArmorContents(items: (org.bukkit.inventory.ItemStack | null)[]): void;

			/**
			 * Put the given ItemStacks into the extra slots
			 * 
			 * See getExtraContents() for an explanation of extra slots.
			 */
			setExtraContents(items: (org.bukkit.inventory.ItemStack | null)[]): void;

			/**
			 * Put the given ItemStack into the helmet slot. This does not check if
			 * the ItemStack is a helmet
			 */
			setHelmet(helmet: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Put the given ItemStack into the chestplate slot. This does not check
			 * if the ItemStack is a chestplate
			 */
			setChestplate(chestplate: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Put the given ItemStack into the leg slot. This does not check if the
			 * ItemStack is a pair of leggings
			 */
			setLeggings(leggings: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Put the given ItemStack into the boots slot. This does not check if the
			 * ItemStack is a boots
			 */
			setBoots(boots: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Gets a copy of the item the player is currently holding
			 * in their main hand.
			 */
			getItemInMainHand(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the item the player is holding in their main hand.
			 */
			setItemInMainHand(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Gets a copy of the item the player is currently holding
			 * in their off hand.
			 */
			getItemInOffHand(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the item the player is holding in their off hand.
			 */
			setItemInOffHand(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Gets a copy of the item the player is currently holding
			 */
			getItemInHand(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the item the player is holding
			 */
			setItemInHand(stack: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Get the slot number of the currently held item
			 */
			getHeldItemSlot(): number;

			/**
			 * Set the slot number of the currently held item.
			 * 
			 * This validates whether the slot is between 0 and 8 inclusive.
			 */
			setHeldItemSlot(slot: number): void;

			/**
			 * Description copied from interface:Â Inventory
			 */
			getHolder(): (org.bukkit.entity.HumanEntity | null);

		}> {}
		interface Recipe {
			/**
			 * Get the result of this recipe.
			 */
			getResult(): org.bukkit.inventory.ItemStack;

		}
		interface RecipeChoice {
			/**
			 * Gets a single item stack representative of this stack choice.
			 */
			getItemStack(): org.bukkit.inventory.ItemStack;

			clone(): org.bukkit.inventory.RecipeChoice;

			test(itemStack: org.bukkit.inventory.ItemStack): boolean;

		}
		namespace RecipeChoice {
			interface ExactChoice {
				/**
				 * Description copied from interface:Â RecipeChoice
				 */
				getItemStack(): org.bukkit.inventory.ItemStack;

				getChoices(): globalThis.java.util.List<org.bukkit.inventory.ItemStack>;

				clone(): org.bukkit.inventory.RecipeChoice.ExactChoice;

				test(t: org.bukkit.inventory.ItemStack): boolean;

				hashCode(): number;

				equals(obj: any): boolean;

				toString(): string;

			}
			class ExactChoice {
				constructor(stack: org.bukkit.inventory.ItemStack);

				constructor(...stacks: org.bukkit.inventory.ItemStack[]);

				constructor(choices: globalThis.java.util.List<org.bukkit.inventory.ItemStack>);

			}
		}
		namespace RecipeChoice {
			interface MaterialChoice {
				test(t: org.bukkit.inventory.ItemStack): boolean;

				/**
				 * Description copied from interface:Â RecipeChoice
				 */
				getItemStack(): org.bukkit.inventory.ItemStack;

				getChoices(): globalThis.java.util.List<org.bukkit.Material>;

				clone(): org.bukkit.inventory.RecipeChoice.MaterialChoice;

				hashCode(): number;

				equals(obj: any): boolean;

				toString(): string;

			}
			class MaterialChoice {
				constructor(choice: org.bukkit.Material);

				constructor(...choices: org.bukkit.Material[]);

				/**
				 * Constructs a MaterialChoice with the current values of the specified
				 * tag.
				 */
				constructor(choices: org.bukkit.Tag<org.bukkit.Material>);

				constructor(choices: globalThis.java.util.List<org.bukkit.Material>);

			}
		}
		interface ShapedRecipe extends Modify<org.bukkit.inventory.CraftingRecipe, {
			/**
			 * Set the shape of this recipe to the specified rows. Each character
			 * represents a different ingredient; excluding space characters, which
			 * must be empty, exactly what each character represents is set separately.
			 * The first row supplied corresponds with the upper most part of the recipe
			 * on the workbench e.g. if all three rows are supplies the first string
			 * represents the top row on the workbench.
			 */
			shape(...shape: string[]): org.bukkit.inventory.ShapedRecipe;

			/**
			 * Sets the material that a character in the recipe shape refers to.
			 * 
			 * Note that before an ingredient can be set, the recipe's shape must be defined
			 * with shape(String...).
			 */
			setIngredient(key: any /* char */, ingredient: org.bukkit.material.MaterialData): org.bukkit.inventory.ShapedRecipe;

			/**
			 * Sets the material that a character in the recipe shape refers to.
			 * 
			 * Note that before an ingredient can be set, the recipe's shape must be defined
			 * with shape(String...).
			 */
			setIngredient(key: any /* char */, ingredient: org.bukkit.Material): org.bukkit.inventory.ShapedRecipe;

			/**
			 * Sets the material that a character in the recipe shape refers to.
			 * 
			 * Note that before an ingredient can be set, the recipe's shape must be defined
			 * with shape(String...).
			 */
			setIngredient(key: any /* char */, ingredient: org.bukkit.Material, raw: number): org.bukkit.inventory.ShapedRecipe;

			/**
			 * Sets the RecipeChoice that a character in the recipe shape refers to.
			 * 
			 * Note that before an ingredient can be set, the recipe's shape must be defined
			 * with shape(String...).
			 */
			setIngredient(key: any /* char */, ingredient: org.bukkit.inventory.RecipeChoice): org.bukkit.inventory.ShapedRecipe;

			/**
			 * Get a copy of the ingredients map.
			 */
			getIngredientMap(): globalThis.java.util.Map<string, org.bukkit.inventory.ItemStack>;

			/**
			 * Get a copy of the choice map.
			 */
			getChoiceMap(): globalThis.java.util.Map<string, org.bukkit.inventory.RecipeChoice>;

		}> {}
		class ShapedRecipe {
			/**
			 * Create a shaped recipe to craft the specified ItemStack. The
			 * constructor merely determines the result and type; to set the actual
			 * recipe, you'll need to call the appropriate methods.
			 */
			constructor(result: org.bukkit.inventory.ItemStack);

			/**
			 * Create a shaped recipe to craft the specified ItemStack. The
			 * constructor merely determines the result and type; to set the actual
			 * recipe, you'll need to call the appropriate methods.
			 */
			constructor(key: org.bukkit.NamespacedKey, result: org.bukkit.inventory.ItemStack);

		}
		interface ShapelessRecipe extends Modify<org.bukkit.inventory.CraftingRecipe, {
			/**
			 * Adds the specified ingredient.
			 */
			addIngredient(ingredient: org.bukkit.material.MaterialData): org.bukkit.inventory.ShapelessRecipe;

			/**
			 * Adds the specified ingredient.
			 */
			addIngredient(ingredient: org.bukkit.Material): org.bukkit.inventory.ShapelessRecipe;

			/**
			 * Adds the specified ingredient.
			 */
			addIngredient(ingredient: org.bukkit.Material, rawdata: number): org.bukkit.inventory.ShapelessRecipe;

			/**
			 * Adds multiples of the specified ingredient.
			 */
			addIngredient(count: number, ingredient: org.bukkit.material.MaterialData): org.bukkit.inventory.ShapelessRecipe;

			/**
			 * Adds multiples of the specified ingredient.
			 */
			addIngredient(count: number, ingredient: org.bukkit.Material): org.bukkit.inventory.ShapelessRecipe;

			/**
			 * Adds multiples of the specified ingredient.
			 */
			addIngredient(count: number, ingredient: org.bukkit.Material, rawdata: number): org.bukkit.inventory.ShapelessRecipe;

			addIngredient(ingredient: org.bukkit.inventory.RecipeChoice): org.bukkit.inventory.ShapelessRecipe;

			/**
			 * Removes an ingredient from the list.
			 */
			removeIngredient(ingredient: org.bukkit.inventory.RecipeChoice): org.bukkit.inventory.ShapelessRecipe;

			/**
			 * Removes an ingredient from the list. If the ingredient occurs multiple
			 * times, only one instance of it is removed. Only removes exact matches,
			 * with a data value of 0.
			 */
			removeIngredient(ingredient: org.bukkit.Material): org.bukkit.inventory.ShapelessRecipe;

			/**
			 * Removes an ingredient from the list. If the ingredient occurs multiple
			 * times, only one instance of it is removed. If the data value is -1,
			 * only ingredients with a -1 data value will be removed.
			 */
			removeIngredient(ingredient: org.bukkit.material.MaterialData): org.bukkit.inventory.ShapelessRecipe;

			/**
			 * Removes multiple instances of an ingredient from the list. If there are
			 * less instances then specified, all will be removed. Only removes exact
			 * matches, with a data value of 0.
			 */
			removeIngredient(count: number, ingredient: org.bukkit.Material): org.bukkit.inventory.ShapelessRecipe;

			/**
			 * Removes multiple instances of an ingredient from the list. If there are
			 * less instances then specified, all will be removed. If the data value
			 * is -1, only ingredients with a -1 data value will be removed.
			 */
			removeIngredient(count: number, ingredient: org.bukkit.material.MaterialData): org.bukkit.inventory.ShapelessRecipe;

			/**
			 * Removes an ingredient from the list. If the ingredient occurs multiple
			 * times, only one instance of it is removed. If the data value is -1,
			 * only ingredients with a -1 data value will be removed.
			 */
			removeIngredient(ingredient: org.bukkit.Material, rawdata: number): org.bukkit.inventory.ShapelessRecipe;

			/**
			 * Removes multiple instances of an ingredient from the list. If there are
			 * less instances then specified, all will be removed. If the data value
			 * is -1, only ingredients with a -1 data value will be removed.
			 */
			removeIngredient(count: number, ingredient: org.bukkit.Material, rawdata: number): org.bukkit.inventory.ShapelessRecipe;

			/**
			 * Get the list of ingredients used for this recipe.
			 */
			getIngredientList(): globalThis.java.util.List<org.bukkit.inventory.ItemStack>;

			getChoiceList(): globalThis.java.util.List<org.bukkit.inventory.RecipeChoice>;

		}> {}
		class ShapelessRecipe {
			constructor(result: org.bukkit.inventory.ItemStack);

			/**
			 * Create a shapeless recipe to craft the specified ItemStack. The
			 * constructor merely determines the result and type; to set the actual
			 * recipe, you'll need to call the appropriate methods.
			 */
			constructor(key: org.bukkit.NamespacedKey, result: org.bukkit.inventory.ItemStack);

		}
		interface SmithingInventory extends Modify<org.bukkit.inventory.Inventory, {
			/**
			 * Check what item is in the result slot of this smithing table.
			 */
			getResult(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Set the item in the result slot of the smithing table
			 */
			setResult(newResult: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Get the current recipe formed on the smithing table, if any.
			 */
			getRecipe(): (org.bukkit.inventory.Recipe | null);

		}> {}
		interface SmithingRecipe {
			/**
			 * Get the base recipe item.
			 */
			getBase(): org.bukkit.inventory.RecipeChoice;

			/**
			 * Get the addition recipe item.
			 */
			getAddition(): org.bukkit.inventory.RecipeChoice;

			/**
			 * Description copied from interface:Â Recipe
			 */
			getResult(): org.bukkit.inventory.ItemStack;

			/**
			 * Description copied from interface:Â Keyed
			 */
			getKey(): org.bukkit.NamespacedKey;

		}
		class SmithingRecipe {
			/**
			 * Create a smithing recipe to produce the specified result ItemStack.
			 */
			constructor(key: org.bukkit.NamespacedKey, result: org.bukkit.inventory.ItemStack, base: org.bukkit.inventory.RecipeChoice, addition: org.bukkit.inventory.RecipeChoice);

		}
		interface SmithingTransformRecipe extends Modify<org.bukkit.inventory.SmithingRecipe, {
			/**
			 * Get the template recipe item.
			 */
			getTemplate(): org.bukkit.inventory.RecipeChoice;

		}> {}
		class SmithingTransformRecipe {
			/**
			 * Create a smithing recipe to produce the specified result ItemStack.
			 */
			constructor(key: org.bukkit.NamespacedKey, result: org.bukkit.inventory.ItemStack, template: org.bukkit.inventory.RecipeChoice, base: org.bukkit.inventory.RecipeChoice, addition: org.bukkit.inventory.RecipeChoice);

		}
		interface SmithingTrimRecipe extends Modify<org.bukkit.inventory.SmithingRecipe, {
			/**
			 * Get the template recipe item.
			 */
			getTemplate(): org.bukkit.inventory.RecipeChoice;

		}> {}
		class SmithingTrimRecipe {
			/**
			 * Create a smithing recipe to produce the specified result ItemStack.
			 */
			constructor(key: org.bukkit.NamespacedKey, template: org.bukkit.inventory.RecipeChoice, base: org.bukkit.inventory.RecipeChoice, addition: org.bukkit.inventory.RecipeChoice);

		}
		interface SmokingRecipe extends Modify<org.bukkit.inventory.CookingRecipe<org.bukkit.inventory.SmokingRecipe>, {
		}> {}
		class SmokingRecipe {
			constructor(key: org.bukkit.NamespacedKey, result: org.bukkit.inventory.ItemStack, source: org.bukkit.Material, experience: number, cookingTime: number);

			constructor(key: org.bukkit.NamespacedKey, result: org.bukkit.inventory.ItemStack, input: org.bukkit.inventory.RecipeChoice, experience: number, cookingTime: number);

		}
		interface StonecutterInventory extends Modify<org.bukkit.inventory.Inventory, {}> {}
		interface StonecuttingRecipe {
			/**
			 * Sets the input of this cooking recipe.
			 */
			setInput(input: org.bukkit.Material): org.bukkit.inventory.StonecuttingRecipe;

			/**
			 * Get the input material.
			 */
			getInput(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the input of this cooking recipe.
			 */
			setInputChoice(input: org.bukkit.inventory.RecipeChoice): org.bukkit.inventory.StonecuttingRecipe;

			/**
			 * Get the input choice.
			 */
			getInputChoice(): org.bukkit.inventory.RecipeChoice;

			/**
			 * Get the result of this recipe.
			 */
			getResult(): org.bukkit.inventory.ItemStack;

			/**
			 * Description copied from interface:Â Keyed
			 */
			getKey(): org.bukkit.NamespacedKey;

			/**
			 * Get the group of this recipe. Recipes with the same group may be grouped
			 * together when displayed in the client.
			 */
			getGroup(): string;

			/**
			 * Set the group of this recipe. Recipes with the same group may be grouped
			 * together when displayed in the client.
			 */
			setGroup(group: string): void;

		}
		class StonecuttingRecipe {
			/**
			 * Create a Stonecutting recipe to craft the specified ItemStack.
			 */
			constructor(key: org.bukkit.NamespacedKey, result: org.bukkit.inventory.ItemStack, source: org.bukkit.Material);

			/**
			 * Create a cooking recipe to craft the specified ItemStack.
			 */
			constructor(key: org.bukkit.NamespacedKey, result: org.bukkit.inventory.ItemStack, input: org.bukkit.inventory.RecipeChoice);

		}
	}
	namespace org.bukkit.event.block {
		interface Action {}
		namespace Action {
			/**
			 * Left-clicking a block
			 */
			const LEFT_CLICK_BLOCK: org.bukkit.event.block.Action;

			/**
			 * Right-clicking a block
			 */
			const RIGHT_CLICK_BLOCK: org.bukkit.event.block.Action;

			/**
			 * Left-clicking the air
			 */
			const LEFT_CLICK_AIR: org.bukkit.event.block.Action;

			/**
			 * Right-clicking the air
			 */
			const RIGHT_CLICK_AIR: org.bukkit.event.block.Action;

			/**
			 * Stepping onto or into a block (Ass-pressure)
			 * Examples:
			 * 
			 * Jumping on soil
			 * Standing on pressure plate
			 * Triggering redstone ore
			 * Triggering tripwire
			 * 
			 */
			const PHYSICAL: org.bukkit.event.block.Action;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.event.block.Action;

		}
		interface BellResonateEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Get a mutable list of all LivingEntities to be
			 * highlighted by the bell's resonating. This list can be added to or
			 * removed from to change which entities are highlighted, and may be empty
			 * if no entities were resonated as a result of this event.
			 * 
			 * While the highlighted entities will change, the particles that display
			 * over a resonated entity and their colors will not. This is handled by the
			 * client and cannot be controlled by the server.
			 */
			getResonatedEntities(): globalThis.java.util.List<org.bukkit.entity.LivingEntity>;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BellResonateEvent {
			constructor(theBlock: org.bukkit.block.Block, resonatedEntities: globalThis.java.util.List<org.bukkit.entity.LivingEntity>);

		}
		namespace BellResonateEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BellRingEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Get the direction in which the bell was rung.
			 */
			getDirection(): org.bukkit.block.BlockFace;

			/**
			 * Get the Entity that rang the bell (if there was one).
			 */
			getEntity(): (org.bukkit.entity.Entity | null);

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancelled: boolean): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BellRingEvent {
			constructor(theBlock: org.bukkit.block.Block, direction: org.bukkit.block.BlockFace, entity: (org.bukkit.entity.Entity | null));

		}
		namespace BellRingEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockBreakEvent extends Modify<org.bukkit.event.block.BlockExpEvent, {
			/**
			 * Gets the Player that is breaking the block involved in this event.
			 */
			getPlayer(): org.bukkit.entity.Player;

			/**
			 * Sets whether or not the block will attempt to drop items as it normally
			 * would.
			 * If and only if this is false then BlockDropItemEvent will not be
			 * called after this event.
			 */
			setDropItems(dropItems: boolean): void;

			/**
			 * Gets whether or not the block will attempt to drop items.
			 * If and only if this is false then BlockDropItemEvent will not be
			 * called after this event.
			 */
			isDropItems(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

		}> {}
		class BlockBreakEvent {
			constructor(theBlock: org.bukkit.block.Block, player: org.bukkit.entity.Player);

		}
		interface BlockBurnEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets the block which ignited this block.
			 */
			getIgnitingBlock(): (org.bukkit.block.Block | null);

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockBurnEvent {
			constructor(block: org.bukkit.block.Block);

			constructor(block: org.bukkit.block.Block, ignitingBlock: (org.bukkit.block.Block | null));

		}
		namespace BlockBurnEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockCanBuildEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets whether or not the block can be built here.
			 * 
			 * By default, returns Minecraft's answer on whether the block can be
			 * built here or not.
			 */
			isBuildable(): boolean;

			/**
			 * Sets whether the block can be built here or not.
			 */
			setBuildable(cancel: boolean): void;

			/**
			 * Gets the Material that we are trying to place.
			 */
			getMaterial(): org.bukkit.Material;

			/**
			 * Gets the BlockData that we are trying to place.
			 */
			getBlockData(): org.bukkit.block.data.BlockData;

			/**
			 * Gets the player who placed the block involved in this event.
			 * 
			 * May be null for legacy calls of the event.
			 */
			getPlayer(): (org.bukkit.entity.Player | null);

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockCanBuildEvent {
			constructor(block: org.bukkit.block.Block, type: org.bukkit.block.data.BlockData, canBuild: boolean);

			constructor(block: org.bukkit.block.Block, player: (org.bukkit.entity.Player | null), type: org.bukkit.block.data.BlockData, canBuild: boolean);

		}
		namespace BlockCanBuildEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockCookEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets the smelted ItemStack for this event
			 */
			getSource(): org.bukkit.inventory.ItemStack;

			/**
			 * Gets the resultant ItemStack for this event
			 */
			getResult(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the resultant ItemStack for this event
			 */
			setResult(result: org.bukkit.inventory.ItemStack): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockCookEvent {
			constructor(block: org.bukkit.block.Block, source: org.bukkit.inventory.ItemStack, result: org.bukkit.inventory.ItemStack);

		}
		namespace BlockCookEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockDamageAbortEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets the player that stopped damaging the block involved in this event.
			 */
			getPlayer(): org.bukkit.entity.Player;

			/**
			 * Gets the ItemStack for the item currently in the player's hand.
			 */
			getItemInHand(): org.bukkit.inventory.ItemStack;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockDamageAbortEvent {
			constructor(player: org.bukkit.entity.Player, block: org.bukkit.block.Block, itemInHand: org.bukkit.inventory.ItemStack);

		}
		namespace BlockDamageAbortEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockDamageEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets the player damaging the block involved in this event.
			 */
			getPlayer(): org.bukkit.entity.Player;

			/**
			 * Gets if the block is set to instantly break when damaged by the player.
			 */
			getInstaBreak(): boolean;

			/**
			 * Sets if the block should instantly break when damaged by the player.
			 */
			setInstaBreak(bool: boolean): void;

			/**
			 * Gets the ItemStack for the item currently in the player's hand.
			 */
			getItemInHand(): org.bukkit.inventory.ItemStack;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockDamageEvent {
			constructor(player: org.bukkit.entity.Player, block: org.bukkit.block.Block, itemInHand: org.bukkit.inventory.ItemStack, instaBreak: boolean);

		}
		namespace BlockDamageEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockDispenseArmorEvent extends Modify<org.bukkit.event.block.BlockDispenseEvent, {
			/**
			 * Get the living entity on which the armor was dispensed.
			 */
			getTargetEntity(): org.bukkit.entity.LivingEntity;

		}> {}
		class BlockDispenseArmorEvent {
			constructor(block: org.bukkit.block.Block, dispensed: org.bukkit.inventory.ItemStack, target: org.bukkit.entity.LivingEntity);

		}
		interface BlockDispenseEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets the item that is being dispensed. Modifying the returned item will
			 * have no effect, you must use setItem(org.bukkit.inventory.ItemStack) instead.
			 */
			getItem(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the item being dispensed.
			 */
			setItem(item: org.bukkit.inventory.ItemStack): void;

			/**
			 * Gets the velocity in meters per tick.
			 * 
			 * Note: Modifying the returned Vector will not change the velocity, you
			 * must use setVelocity(org.bukkit.util.Vector) instead.
			 */
			getVelocity(): org.bukkit.util.Vector;

			/**
			 * Sets the velocity of the item being dispensed in meters per tick.
			 */
			setVelocity(vel: org.bukkit.util.Vector): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockDispenseEvent {
			constructor(block: org.bukkit.block.Block, dispensed: org.bukkit.inventory.ItemStack, velocity: org.bukkit.util.Vector);

		}
		namespace BlockDispenseEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockDropItemEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets the Player that is breaking the block involved in this event.
			 */
			getPlayer(): org.bukkit.entity.Player;

			/**
			 * Gets the BlockState of the block involved in this event before it was
			 * broken.
			 */
			getBlockState(): org.bukkit.block.BlockState;

			/**
			 * Gets list of the Item drops caused by the block break.
			 * This list is mutable - removing an item from it will cause it to not
			 * drop. It is not legal however to add new items to the list.
			 */
			getItems(): globalThis.java.util.List<org.bukkit.entity.Item>;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockDropItemEvent {
			constructor(block: org.bukkit.block.Block, blockState: org.bukkit.block.BlockState, player: org.bukkit.entity.Player, items: globalThis.java.util.List<org.bukkit.entity.Item>);

		}
		namespace BlockDropItemEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockEvent extends Modify<org.bukkit.event.Event, {
			/**
			 * Gets the block involved in this event.
			 */
			getBlock(): org.bukkit.block.Block;

		}> {}
		class BlockEvent {
			constructor(theBlock: org.bukkit.block.Block);

		}
		interface BlockExpEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Get the experience dropped by the block after the event has processed
			 */
			getExpToDrop(): number;

			/**
			 * Set the amount of experience dropped by the block after the event has
			 * processed
			 */
			setExpToDrop(exp: number): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockExpEvent {
			constructor(block: org.bukkit.block.Block, exp: number);

		}
		namespace BlockExpEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockExplodeEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Returns the captured BlockState of the block that exploded.
			 */
			getExplodedBlockState(): org.bukkit.block.BlockState;

			/**
			 * Returns the list of blocks that would have been removed or were removed
			 * from the explosion event.
			 */
			blockList(): globalThis.java.util.List<org.bukkit.block.Block>;

			/**
			 * Returns the percentage of blocks to drop from this explosion
			 */
			getYield(): number;

			/**
			 * Sets the percentage of blocks to drop from this explosion
			 */
			setYield(yield: number): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockExplodeEvent {
			constructor(what: org.bukkit.block.Block, blockState: org.bukkit.block.BlockState, blocks: globalThis.java.util.List<org.bukkit.block.Block>, yield: number);

			constructor(what: org.bukkit.block.Block, blocks: globalThis.java.util.List<org.bukkit.block.Block>, yield: number);

		}
		namespace BlockExplodeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockFadeEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets the state of the block that will be fading, melting or
			 * disappearing.
			 */
			getNewState(): org.bukkit.block.BlockState;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockFadeEvent {
			constructor(block: org.bukkit.block.Block, newState: org.bukkit.block.BlockState);

		}
		namespace BlockFadeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockFertilizeEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets the player that triggered the fertilization.
			 */
			getPlayer(): (org.bukkit.entity.Player | null);

			/**
			 * Gets a list of all blocks changed by the fertilization.
			 */
			getBlocks(): globalThis.java.util.List<org.bukkit.block.BlockState>;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancelled: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockFertilizeEvent {
			constructor(theBlock: org.bukkit.block.Block, player: (org.bukkit.entity.Player | null), blocks: globalThis.java.util.List<org.bukkit.block.BlockState>);

		}
		namespace BlockFertilizeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockFormEvent extends Modify<org.bukkit.event.block.BlockGrowEvent, {
			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockFormEvent {
			constructor(block: org.bukkit.block.Block, newState: org.bukkit.block.BlockState);

		}
		namespace BlockFormEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockFromToEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets the BlockFace that the block is moving to.
			 */
			getFace(): org.bukkit.block.BlockFace;

			/**
			 * Convenience method for getting the faced Block.
			 */
			getToBlock(): org.bukkit.block.Block;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockFromToEvent {
			constructor(block: org.bukkit.block.Block, face: org.bukkit.block.BlockFace);

			constructor(block: org.bukkit.block.Block, toBlock: org.bukkit.block.Block);

		}
		namespace BlockFromToEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockGrowEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets the state of the block where it will form or spread to.
			 */
			getNewState(): org.bukkit.block.BlockState;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockGrowEvent {
			constructor(block: org.bukkit.block.Block, newState: org.bukkit.block.BlockState);

		}
		namespace BlockGrowEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockIgniteEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the cause of block ignite.
			 */
			getCause(): org.bukkit.event.block.BlockIgniteEvent.IgniteCause;

			/**
			 * Gets the player who ignited this block
			 */
			getPlayer(): (org.bukkit.entity.Player | null);

			/**
			 * Gets the entity who ignited this block
			 */
			getIgnitingEntity(): (org.bukkit.entity.Entity | null);

			/**
			 * Gets the block which ignited this block
			 */
			getIgnitingBlock(): (org.bukkit.block.Block | null);

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockIgniteEvent {
			constructor(theBlock: org.bukkit.block.Block, cause: org.bukkit.event.block.BlockIgniteEvent.IgniteCause, ignitingEntity: (org.bukkit.entity.Entity | null));

			constructor(theBlock: org.bukkit.block.Block, cause: org.bukkit.event.block.BlockIgniteEvent.IgniteCause, ignitingBlock: org.bukkit.block.Block);

			constructor(theBlock: org.bukkit.block.Block, cause: org.bukkit.event.block.BlockIgniteEvent.IgniteCause, ignitingEntity: (org.bukkit.entity.Entity | null), ignitingBlock: (org.bukkit.block.Block | null));

		}
		namespace BlockIgniteEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace BlockIgniteEvent {
			interface IgniteCause {}
			namespace IgniteCause {
				/**
				 * Block ignition caused by lava.
				 */
				const LAVA: org.bukkit.event.block.BlockIgniteEvent.IgniteCause;

				/**
				 * Block ignition caused by a player or dispenser using flint-and-steel.
				 */
				const FLINT_AND_STEEL: org.bukkit.event.block.BlockIgniteEvent.IgniteCause;

				/**
				 * Block ignition caused by dynamic spreading of fire.
				 */
				const SPREAD: org.bukkit.event.block.BlockIgniteEvent.IgniteCause;

				/**
				 * Block ignition caused by lightning.
				 */
				const LIGHTNING: org.bukkit.event.block.BlockIgniteEvent.IgniteCause;

				/**
				 * Block ignition caused by an entity using a fireball.
				 */
				const FIREBALL: org.bukkit.event.block.BlockIgniteEvent.IgniteCause;

				/**
				 * Block ignition caused by an Ender Crystal.
				 */
				const ENDER_CRYSTAL: org.bukkit.event.block.BlockIgniteEvent.IgniteCause;

				/**
				 * Block ignition caused by explosion.
				 */
				const EXPLOSION: org.bukkit.event.block.BlockIgniteEvent.IgniteCause;

				/**
				 * Block ignition caused by a flaming arrow.
				 */
				const ARROW: org.bukkit.event.block.BlockIgniteEvent.IgniteCause;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.block.BlockIgniteEvent.IgniteCause;

			}
		}
		interface BlockMultiPlaceEvent extends Modify<org.bukkit.event.block.BlockPlaceEvent, {
			/**
			 * Gets a list of blockstates for all blocks which were replaced by the
			 * placement of the new blocks. Most of these blocks will just have a
			 * Material type of AIR.
			 */
			getReplacedBlockStates(): globalThis.java.util.List<org.bukkit.block.BlockState>;

		}> {}
		class BlockMultiPlaceEvent {
			constructor(states: globalThis.java.util.List<org.bukkit.block.BlockState>, clicked: org.bukkit.block.Block, itemInHand: org.bukkit.inventory.ItemStack, thePlayer: org.bukkit.entity.Player, canBuild: boolean);

		}
		interface BlockPhysicsEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets the source block that triggered this event.
			 * Note: This will default to block if not set.
			 */
			getSourceBlock(): org.bukkit.block.Block;

			/**
			 * Gets the type of block that changed, causing this event
			 */
			getChangedType(): org.bukkit.Material;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockPhysicsEvent {
			constructor(block: org.bukkit.block.Block, changed: org.bukkit.block.data.BlockData);

			constructor(block: org.bukkit.block.Block, changed: org.bukkit.block.data.BlockData, sourceBlock: org.bukkit.block.Block);

		}
		namespace BlockPhysicsEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockPistonEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancelled: boolean): void;

			/**
			 * Returns true if the Piston in the event is sticky.
			 */
			isSticky(): boolean;

			/**
			 * Return the direction in which the piston will operate.
			 */
			getDirection(): org.bukkit.block.BlockFace;

		}> {}
		class BlockPistonEvent {
			constructor(block: org.bukkit.block.Block, direction: org.bukkit.block.BlockFace);

		}
		interface BlockPistonExtendEvent extends Modify<org.bukkit.event.block.BlockPistonEvent, {
			/**
			 * Get the amount of blocks which will be moved while extending.
			 */
			getLength(): number;

			/**
			 * Get an immutable list of the blocks which will be moved by the
			 * extending.
			 */
			getBlocks(): globalThis.java.util.List<org.bukkit.block.Block>;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockPistonExtendEvent {
			constructor(block: org.bukkit.block.Block, length: number, direction: org.bukkit.block.BlockFace);

			constructor(block: org.bukkit.block.Block, blocks: globalThis.java.util.List<org.bukkit.block.Block>, direction: org.bukkit.block.BlockFace);

		}
		namespace BlockPistonExtendEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockPistonRetractEvent extends Modify<org.bukkit.event.block.BlockPistonEvent, {
			/**
			 * Gets the location where the possible moving block might be if the
			 * retracting piston is sticky.
			 */
			getRetractLocation(): org.bukkit.Location;

			/**
			 * Get an immutable list of the blocks which will be moved by the
			 * extending.
			 */
			getBlocks(): globalThis.java.util.List<org.bukkit.block.Block>;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockPistonRetractEvent {
			constructor(block: org.bukkit.block.Block, blocks: globalThis.java.util.List<org.bukkit.block.Block>, direction: org.bukkit.block.BlockFace);

		}
		namespace BlockPistonRetractEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockPlaceEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the player who placed the block involved in this event.
			 */
			getPlayer(): org.bukkit.entity.Player;

			/**
			 * Clarity method for getting the placed block. Not really needed except
			 * for reasons of clarity.
			 */
			getBlockPlaced(): org.bukkit.block.Block;

			/**
			 * Gets the BlockState for the block which was replaced. Material type air
			 * mostly.
			 */
			getBlockReplacedState(): org.bukkit.block.BlockState;

			/**
			 * Gets the block that this block was placed against
			 */
			getBlockAgainst(): org.bukkit.block.Block;

			/**
			 * Gets the item in the player's hand when they placed the block.
			 */
			getItemInHand(): org.bukkit.inventory.ItemStack;

			/**
			 * Gets the hand which placed the block
			 */
			getHand(): org.bukkit.inventory.EquipmentSlot;

			/**
			 * Gets the value whether the player would be allowed to build here.
			 * Defaults to spawn if the server was going to stop them (such as, the
			 * player is in Spawn). Note that this is an entirely different check
			 * than BLOCK_CANBUILD, as this refers to a player, not universe-physics
			 * rule like cactus on dirt.
			 */
			canBuild(): boolean;

			/**
			 * Sets the canBuild state of this event. Set to true if you want the
			 * player to be able to build.
			 */
			setBuild(canBuild: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockPlaceEvent {
			constructor(placedBlock: org.bukkit.block.Block, replacedBlockState: org.bukkit.block.BlockState, placedAgainst: org.bukkit.block.Block, itemInHand: org.bukkit.inventory.ItemStack, thePlayer: org.bukkit.entity.Player, canBuild: boolean);

			constructor(placedBlock: org.bukkit.block.Block, replacedBlockState: org.bukkit.block.BlockState, placedAgainst: org.bukkit.block.Block, itemInHand: org.bukkit.inventory.ItemStack, thePlayer: org.bukkit.entity.Player, canBuild: boolean, hand: org.bukkit.inventory.EquipmentSlot);

		}
		namespace BlockPlaceEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockReceiveGameEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Get the underlying event.
			 */
			getEvent(): org.bukkit.GameEvent;

			/**
			 * Get the entity which triggered this event, if present.
			 */
			getEntity(): (org.bukkit.entity.Entity | null);

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockReceiveGameEvent {
			constructor(event: org.bukkit.GameEvent, block: org.bukkit.block.Block, entity: (org.bukkit.entity.Entity | null));

		}
		namespace BlockReceiveGameEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockRedstoneEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets the old current of this block
			 */
			getOldCurrent(): number;

			/**
			 * Gets the new current of this block
			 */
			getNewCurrent(): number;

			/**
			 * Sets the new current of this block
			 */
			setNewCurrent(newCurrent: number): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockRedstoneEvent {
			constructor(block: org.bukkit.block.Block, oldCurrent: number, newCurrent: number);

		}
		namespace BlockRedstoneEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockShearEntityEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets the entity that was sheared.
			 */
			getEntity(): org.bukkit.entity.Entity;

			/**
			 * Gets the item used to shear this sheep.
			 */
			getTool(): org.bukkit.inventory.ItemStack;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancelled: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockShearEntityEvent {
			constructor(dispenser: org.bukkit.block.Block, sheared: org.bukkit.entity.Entity, tool: org.bukkit.inventory.ItemStack);

		}
		namespace BlockShearEntityEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BlockSpreadEvent extends Modify<org.bukkit.event.block.BlockFormEvent, {
			/**
			 * Gets the source block involved in this event.
			 */
			getSource(): org.bukkit.block.Block;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BlockSpreadEvent {
			constructor(block: org.bukkit.block.Block, source: org.bukkit.block.Block, newState: org.bukkit.block.BlockState);

		}
		namespace BlockSpreadEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BrewingStartEvent extends Modify<org.bukkit.event.block.InventoryBlockStartEvent, {
			/**
			 * Gets the total brew time associated with this event.
			 */
			getTotalBrewTime(): number;

			/**
			 * Sets the total brew time for this event.
			 */
			setTotalBrewTime(brewTime: number): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BrewingStartEvent {
			constructor(furnace: org.bukkit.block.Block, source: org.bukkit.inventory.ItemStack, brewingTime: number);

		}
		namespace BrewingStartEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface CampfireStartEvent extends Modify<org.bukkit.event.block.InventoryBlockStartEvent, {
			/**
			 * Gets the CampfireRecipe associated with this event.
			 */
			getRecipe(): org.bukkit.inventory.CampfireRecipe;

			/**
			 * Gets the total cook time associated with this event.
			 */
			getTotalCookTime(): number;

			/**
			 * Sets the total cook time for this event.
			 */
			setTotalCookTime(cookTime: number): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class CampfireStartEvent {
			constructor(furnace: org.bukkit.block.Block, source: org.bukkit.inventory.ItemStack, recipe: org.bukkit.inventory.CampfireRecipe);

		}
		namespace CampfireStartEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface CauldronLevelChangeEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Get entity which did this. May be null.
			 */
			getEntity(): (org.bukkit.entity.Entity | null);

			getReason(): org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason;

			/**
			 * Gets the new state of the cauldron.
			 */
			getNewState(): org.bukkit.block.BlockState;

			/**
			 * Gets the old level of the cauldron.
			 */
			getOldLevel(): number;

			/**
			 * Gets the new level of the cauldron.
			 */
			getNewLevel(): number;

			/**
			 * Sets the new level of the cauldron.
			 */
			setNewLevel(newLevel: number): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancelled: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class CauldronLevelChangeEvent {
			constructor(block: org.bukkit.block.Block, entity: (org.bukkit.entity.Entity | null), reason: org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason, newBlock: org.bukkit.block.BlockState);

		}
		namespace CauldronLevelChangeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace CauldronLevelChangeEvent {
			interface ChangeReason {}
			namespace ChangeReason {
				/**
				 * Player emptying the cauldron by filling their bucket.
				 */
				const BUCKET_FILL: org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason;

				/**
				 * Player filling the cauldron by emptying their bucket.
				 */
				const BUCKET_EMPTY: org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason;

				/**
				 * Player emptying the cauldron by filling their bottle.
				 */
				const BOTTLE_FILL: org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason;

				/**
				 * Player filling the cauldron by emptying their bottle.
				 */
				const BOTTLE_EMPTY: org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason;

				/**
				 * Player cleaning their banner.
				 */
				const BANNER_WASH: org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason;

				/**
				 * Player cleaning their armor.
				 */
				const ARMOR_WASH: org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason;

				/**
				 * Player cleaning a shulker box.
				 */
				const SHULKER_WASH: org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason;

				/**
				 * Entity being extinguished.
				 */
				const EXTINGUISH: org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason;

				/**
				 * Evaporating due to biome dryness.
				 */
				const EVAPORATE: org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason;

				/**
				 * Filling due to natural fluid sources, eg rain or dripstone.
				 */
				const NATURAL_FILL: org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason;

				/**
				 * Unknown.
				 */
				const UNKNOWN: org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.block.CauldronLevelChangeEvent.ChangeReason;

			}
		}
		interface EntityBlockFormEvent extends Modify<org.bukkit.event.block.BlockFormEvent, {
			/**
			 * Get the entity that formed the block.
			 */
			getEntity(): org.bukkit.entity.Entity;

		}> {}
		class EntityBlockFormEvent {
			constructor(entity: org.bukkit.entity.Entity, block: org.bukkit.block.Block, blockstate: org.bukkit.block.BlockState);

		}
		interface FluidLevelChangeEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets the new data of the changed block.
			 */
			getNewData(): org.bukkit.block.data.BlockData;

			/**
			 * Sets the new data of the changed block. Must be of the same Material as
			 * the old one.
			 */
			setNewData(newData: org.bukkit.block.data.BlockData): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancelled: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class FluidLevelChangeEvent {
			constructor(theBlock: org.bukkit.block.Block, newData: org.bukkit.block.data.BlockData);

		}
		namespace FluidLevelChangeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface InventoryBlockStartEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets the source ItemStack for this event.
			 */
			getSource(): org.bukkit.inventory.ItemStack;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class InventoryBlockStartEvent {
			constructor(block: org.bukkit.block.Block, source: org.bukkit.inventory.ItemStack);

		}
		namespace InventoryBlockStartEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface LeavesDecayEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class LeavesDecayEvent {
			constructor(block: org.bukkit.block.Block);

		}
		namespace LeavesDecayEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface MoistureChangeEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets the new state of the affected block.
			 */
			getNewState(): org.bukkit.block.BlockState;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class MoistureChangeEvent {
			constructor(block: org.bukkit.block.Block, newState: org.bukkit.block.BlockState);

		}
		namespace MoistureChangeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface NotePlayEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the Instrument to be used.
			 */
			getInstrument(): org.bukkit.Instrument;

			/**
			 * Gets the Note to be played.
			 */
			getNote(): org.bukkit.Note;

			/**
			 * Overrides the Instrument to be used.
			 */
			setInstrument(instrument: org.bukkit.Instrument): void;

			/**
			 * Overrides the Note to be played.
			 */
			setNote(note: org.bukkit.Note): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class NotePlayEvent {
			constructor(block: org.bukkit.block.Block, instrument: org.bukkit.Instrument, note: org.bukkit.Note);

		}
		namespace NotePlayEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface SculkBloomEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Returns the charge of the cursor, < 1000 by default.
			 */
			getCharge(): number;

			/**
			 * Sets the charge of the cursor.
			 * 
			 * Increasing the charge of a cursor makes the cursor last longer, giving
			 * it more time to spread sculk blocks across a larger range.
			 * 
			 * Typically, charges should be set to the exp reward of a mob
			 * (EntityDeathEvent.getDroppedExp()), which is usually
			 * 3-5 for animals, and 5-10 for the average mob (up to 50 for
			 * wither skeletons). Roughly speaking, for each charge, 1 more
			 * sculk block will be placed.
			 */
			setCharge(charge: number): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class SculkBloomEvent {
			constructor(theBlock: org.bukkit.block.Block, charge: number);

		}
		namespace SculkBloomEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface SignChangeEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets the player changing the sign involved in this event.
			 */
			getPlayer(): org.bukkit.entity.Player;

			/**
			 * Gets a single line of text from the sign involved in this event.
			 */
			getLine(index: number): (string | null);

			/**
			 * Sets a single line for the sign involved in this event
			 */
			setLine(index: number, line: (string | null)): void;

			/**
			 * Returns which side is changed.
			 */
			getSide(): org.bukkit.block.sign.Side;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class SignChangeEvent {
			constructor(theBlock: org.bukkit.block.Block, thePlayer: org.bukkit.entity.Player, theLines: string[]);

			constructor(theBlock: org.bukkit.block.Block, thePlayer: org.bukkit.entity.Player, theLines: string[], side: org.bukkit.block.sign.Side);

		}
		namespace SignChangeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface SpongeAbsorbEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Get a list of all blocks to be removed by the sponge.
			 * 
			 * This list is mutable and contains the blocks in their removed state, i.e.
			 * having a type of Material.AIR.
			 */
			getBlocks(): globalThis.java.util.List<org.bukkit.block.BlockState>;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class SpongeAbsorbEvent {
			constructor(block: org.bukkit.block.Block, waterblocks: globalThis.java.util.List<org.bukkit.block.BlockState>);

		}
		namespace SpongeAbsorbEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface TNTPrimeEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Get the cause of the TNT becoming primed.
			 */
			getCause(): org.bukkit.event.block.TNTPrimeEvent.PrimeCause;

			/**
			 * Get the entity that caused the TNT to be primed.
			 */
			getPrimingEntity(): (org.bukkit.entity.Entity | null);

			/**
			 * Get the block that caused the TNT to be primed.
			 */
			getPrimingBlock(): (org.bukkit.block.Block | null);

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class TNTPrimeEvent {
			constructor(block: org.bukkit.block.Block, igniteCause: org.bukkit.event.block.TNTPrimeEvent.PrimeCause, primingEntity: (org.bukkit.entity.Entity | null), primingBlock: (org.bukkit.block.Block | null));

		}
		namespace TNTPrimeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace TNTPrimeEvent {
			interface PrimeCause {}
			namespace PrimeCause {
				/**
				 * When TNT is primed by fire spreading.
				 */
				const FIRE: org.bukkit.event.block.TNTPrimeEvent.PrimeCause;

				/**
				 * When TNT is primed by a redstone signal.
				 */
				const REDSTONE: org.bukkit.event.block.TNTPrimeEvent.PrimeCause;

				/**
				 * When TNT is primed by a player interacting with it directly.
				 */
				const PLAYER: org.bukkit.event.block.TNTPrimeEvent.PrimeCause;

				/**
				 * When TNT is primed by a nearby explosion.
				 */
				const EXPLOSION: org.bukkit.event.block.TNTPrimeEvent.PrimeCause;

				/**
				 * When TNT is primed after getting hit with a burning projectile.
				 */
				const PROJECTILE: org.bukkit.event.block.TNTPrimeEvent.PrimeCause;

				/**
				 * When TNT with the unstable block state set to true is broken.
				 * 
				 * Note: Canceling a prime event with this cause will stop the primed
				 * TNT from spawning but will not stop the block from being broken.
				 */
				const BLOCK_BREAK: org.bukkit.event.block.TNTPrimeEvent.PrimeCause;

				/**
				 * When TNT is primed by a dispenser holding flint and steel.
				 * 
				 * Note: This event is not called for a dispenser dispensing TNT
				 * directly.
				 */
				const DISPENSER: org.bukkit.event.block.TNTPrimeEvent.PrimeCause;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.block.TNTPrimeEvent.PrimeCause;

			}
		}
	}
	namespace org.bukkit.event.entity {
		interface AreaEffectCloudApplyEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.AreaEffectCloud;

			/**
			 * Retrieves a mutable list of the effected entities
			 * 
			 * It is important to note that not every entity in this list
			 * is guaranteed to be effected. The cloud may die during the
			 * application of its effects due to the depletion of AreaEffectCloud.getDurationOnUse()
			 * or AreaEffectCloud.getRadiusOnUse()
			 */
			getAffectedEntities(): globalThis.java.util.List<org.bukkit.entity.LivingEntity>;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class AreaEffectCloudApplyEvent {
			constructor(entity: org.bukkit.entity.AreaEffectCloud, affectedEntities: globalThis.java.util.List<org.bukkit.entity.LivingEntity>);

		}
		namespace AreaEffectCloudApplyEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface ArrowBodyCountChangeEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Whether the event was called because the entity was reset.
			 */
			isReset(): boolean;

			/**
			 * Gets the old amount of arrows in the entity's body.
			 */
			getOldAmount(): number;

			/**
			 * Get the new amount of arrows in the entity's body.
			 */
			getNewAmount(): number;

			/**
			 * Sets the final amount of arrows in the entity's body.
			 */
			setNewAmount(newAmount: number): void;

			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.LivingEntity;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class ArrowBodyCountChangeEvent {
			constructor(entity: org.bukkit.entity.LivingEntity, oldAmount: number, newAmount: number, isReset: boolean);

		}
		namespace ArrowBodyCountChangeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BatToggleSleepEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Get whether or not the bat is attempting to awaken.
			 */
			isAwake(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BatToggleSleepEvent {
			constructor(what: org.bukkit.entity.Bat, awake: boolean);

		}
		namespace BatToggleSleepEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface CreatureSpawnEvent extends Modify<org.bukkit.event.entity.EntitySpawnEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.LivingEntity;

			/**
			 * Gets the reason for why the creature is being spawned.
			 */
			getSpawnReason(): org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

		}> {}
		class CreatureSpawnEvent {
			constructor(spawnee: org.bukkit.entity.LivingEntity, spawnReason: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason);

		}
		namespace CreatureSpawnEvent {
			interface SpawnReason {}
			namespace SpawnReason {
				/**
				 * When something spawns from natural means
				 */
				const NATURAL: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When an entity spawns as a jockey of another entity (mostly spider
				 * jockeys)
				 */
				const JOCKEY: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a creature spawns due to chunk generation
				 */
				const CHUNK_GEN: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a creature spawns from a spawner
				 */
				const SPAWNER: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a creature spawns from a trial spawner
				 */
				const TRIAL_SPAWNER: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a creature spawns from an egg
				 */
				const EGG: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a creature spawns from a Spawner Egg
				 */
				const SPAWNER_EGG: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a creature spawns because of a lightning strike
				 */
				const LIGHTNING: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a snowman is spawned by being built
				 */
				const BUILD_SNOWMAN: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When an iron golem is spawned by being built
				 */
				const BUILD_IRONGOLEM: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a wither boss is spawned by being built
				 */
				const BUILD_WITHER: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When an iron golem is spawned to defend a village
				 */
				const VILLAGE_DEFENSE: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a zombie is spawned to invade a village
				 */
				const VILLAGE_INVASION: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When an entity breeds to create a child, this also include Shulker and Allay
				 */
				const BREEDING: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a slime splits
				 */
				const SLIME_SPLIT: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When an entity calls for reinforcements
				 */
				const REINFORCEMENTS: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a creature is spawned by nether portal
				 */
				const NETHER_PORTAL: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a creature is spawned by a dispenser dispensing an egg
				 */
				const DISPENSE_EGG: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a zombie infects a villager
				 */
				const INFECTION: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a villager is cured from infection
				 */
				const CURED: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When an ocelot has a baby spawned along with them
				 */
				const OCELOT_BABY: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a silverfish spawns from a block
				 */
				const SILVERFISH_BLOCK: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When an entity spawns as a mount of another entity (mostly chicken
				 * jockeys)
				 */
				const MOUNT: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When an entity spawns as a trap for players approaching
				 */
				const TRAP: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When an entity is spawned as a result of ender pearl usage
				 */
				const ENDER_PEARL: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When an entity is spawned as a result of the entity it is being
				 * perched on jumping or being damaged
				 */
				const SHOULDER_ENTITY: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a creature is spawned by another entity drowning
				 */
				const DROWNED: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When an cow is spawned by shearing a mushroom cow
				 */
				const SHEARED: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When eg an effect cloud is spawned as a result of a creeper exploding
				 */
				const EXPLOSION: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When an entity is spawned as part of a raid
				 */
				const RAID: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When an entity is spawned as part of a patrol
				 */
				const PATROL: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a bee is released from a beehive/bee nest
				 */
				const BEEHIVE: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a piglin is converted to a zombified piglin.
				 */
				const PIGLIN_ZOMBIFIED: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When an entity is created by a cast spell.
				 */
				const SPELL: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When an entity is shaking in Powder Snow and a new entity spawns.
				 */
				const FROZEN: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a tadpole converts to a frog
				 */
				const METAMORPHOSIS: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When an Allay duplicate itself
				 */
				const DUPLICATION: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a creature is spawned by the "/summon" command
				 */
				const COMMAND: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a creature is spawned by an enchantment
				 */
				const ENCHANTMENT: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When a creature is spawned by plugins
				 */
				const CUSTOM: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * When an entity is missing a SpawnReason
				 */
				const DEFAULT: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;

			}
		}
		interface CreeperPowerEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.Creeper;

			/**
			 * Gets the lightning bolt which is striking the Creeper.
			 */
			getLightning(): (org.bukkit.entity.LightningStrike | null);

			/**
			 * Gets the cause of the creeper being (un)powered.
			 */
			getCause(): org.bukkit.event.entity.CreeperPowerEvent.PowerCause;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class CreeperPowerEvent {
			constructor(creeper: org.bukkit.entity.Creeper, bolt: org.bukkit.entity.LightningStrike, cause: org.bukkit.event.entity.CreeperPowerEvent.PowerCause);

			constructor(creeper: org.bukkit.entity.Creeper, cause: org.bukkit.event.entity.CreeperPowerEvent.PowerCause);

		}
		namespace CreeperPowerEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace CreeperPowerEvent {
			interface PowerCause {}
			namespace PowerCause {
				/**
				 * Power change caused by a lightning bolt
				 * 
				 * Powered state: true
				 */
				const LIGHTNING: org.bukkit.event.entity.CreeperPowerEvent.PowerCause;

				/**
				 * Power change caused by something else (probably a plugin)
				 * 
				 * Powered state: true
				 */
				const SET_ON: org.bukkit.event.entity.CreeperPowerEvent.PowerCause;

				/**
				 * Power change caused by something else (probably a plugin)
				 * 
				 * Powered state: false
				 */
				const SET_OFF: org.bukkit.event.entity.CreeperPowerEvent.PowerCause;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.entity.CreeperPowerEvent.PowerCause;

			}
		}
		interface EnderDragonChangePhaseEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.EnderDragon;

			/**
			 * Gets the current phase that the dragon is in. This method will return null
			 * when a dragon is first spawned and hasn't yet been assigned a phase.
			 */
			getCurrentPhase(): (org.bukkit.entity.EnderDragon.Phase | null);

			/**
			 * Gets the new phase that the dragon will switch to.
			 */
			getNewPhase(): org.bukkit.entity.EnderDragon.Phase;

			/**
			 * Sets the new phase for the ender dragon.
			 */
			setNewPhase(newPhase: org.bukkit.entity.EnderDragon.Phase): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EnderDragonChangePhaseEvent {
			constructor(enderDragon: org.bukkit.entity.EnderDragon, currentPhase: (org.bukkit.entity.EnderDragon.Phase | null), newPhase: org.bukkit.entity.EnderDragon.Phase);

		}
		namespace EnderDragonChangePhaseEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityAirChangeEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Gets the amount of air the entity has left (measured in ticks).
			 */
			getAmount(): number;

			/**
			 * Sets the amount of air remaining for the entity (measured in ticks.
			 */
			setAmount(amount: number): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancelled: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityAirChangeEvent {
			constructor(what: org.bukkit.entity.Entity, amount: number);

		}
		namespace EntityAirChangeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityBreakDoorEvent extends Modify<org.bukkit.event.entity.EntityChangeBlockEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.LivingEntity;

		}> {}
		class EntityBreakDoorEvent {
			constructor(entity: org.bukkit.entity.LivingEntity, targetBlock: org.bukkit.block.Block);

		}
		interface EntityBreedEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.LivingEntity;

			/**
			 * Gets the parent creating this entity.
			 */
			getMother(): org.bukkit.entity.LivingEntity;

			/**
			 * Gets the other parent of the newly born entity.
			 */
			getFather(): org.bukkit.entity.LivingEntity;

			/**
			 * Gets the Entity responsible for breeding. Breeder is null for spontaneous
			 * conception.
			 */
			getBreeder(): (org.bukkit.entity.LivingEntity | null);

			/**
			 * The ItemStack that was used to initiate breeding, if present.
			 */
			getBredWith(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Get the amount of experience granted by breeding.
			 */
			getExperience(): number;

			/**
			 * Set the amount of experience granted by breeding.
			 */
			setExperience(experience: number): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityBreedEvent {
			constructor(child: org.bukkit.entity.LivingEntity, mother: org.bukkit.entity.LivingEntity, father: org.bukkit.entity.LivingEntity, breeder: (org.bukkit.entity.LivingEntity | null), bredWith: (org.bukkit.inventory.ItemStack | null), experience: number);

		}
		namespace EntityBreedEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityChangeBlockEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Gets the block the entity is changing
			 */
			getBlock(): org.bukkit.block.Block;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the Material that the block is changing into
			 */
			getTo(): org.bukkit.Material;

			/**
			 * Gets the data for the block that would be changed into
			 */
			getBlockData(): org.bukkit.block.data.BlockData;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityChangeBlockEvent {
			constructor(what: org.bukkit.entity.Entity, block: org.bukkit.block.Block, to: org.bukkit.block.data.BlockData);

		}
		namespace EntityChangeBlockEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityCombustByBlockEvent extends Modify<org.bukkit.event.entity.EntityCombustEvent, {
			/**
			 * The combuster can be lava or a block that is on fire.
			 * 
			 * WARNING: block may be null.
			 */
			getCombuster(): (org.bukkit.block.Block | null);

		}> {}
		class EntityCombustByBlockEvent {
			constructor(combuster: (org.bukkit.block.Block | null), combustee: org.bukkit.entity.Entity, duration: number);

			constructor(combuster: (org.bukkit.block.Block | null), combustee: org.bukkit.entity.Entity, duration: number);

		}
		interface EntityCombustByEntityEvent extends Modify<org.bukkit.event.entity.EntityCombustEvent, {
			/**
			 * Get the entity that caused the combustion event.
			 */
			getCombuster(): org.bukkit.entity.Entity;

		}> {}
		class EntityCombustByEntityEvent {
			constructor(combuster: org.bukkit.entity.Entity, combustee: org.bukkit.entity.Entity, duration: number);

			constructor(combuster: org.bukkit.entity.Entity, combustee: org.bukkit.entity.Entity, duration: number);

		}
		interface EntityCombustEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getDuration(): number;

			/**
			 * The number of seconds the combustee should be alight for.
			 * 
			 * This value will only ever increase the combustion time, not decrease
			 * existing combustion times.
			 */
			setDuration(duration: number): void;

			/**
			 * The number of seconds the combustee should be alight for.
			 * 
			 * This value will only ever increase the combustion time, not decrease
			 * existing combustion times.
			 */
			setDuration(duration: number): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityCombustEvent {
			constructor(combustee: org.bukkit.entity.Entity, duration: number);

			constructor(combustee: org.bukkit.entity.Entity, duration: number);

		}
		namespace EntityCombustEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityCreatePortalEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.LivingEntity;

			/**
			 * Gets a list of all blocks associated with the portal.
			 */
			getBlocks(): globalThis.java.util.List<org.bukkit.block.BlockState>;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the type of portal that is trying to be created.
			 */
			getPortalType(): org.bukkit.PortalType;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityCreatePortalEvent {
			constructor(what: org.bukkit.entity.LivingEntity, blocks: globalThis.java.util.List<org.bukkit.block.BlockState>, type: org.bukkit.PortalType);

		}
		namespace EntityCreatePortalEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityDamageByBlockEvent extends Modify<org.bukkit.event.entity.EntityDamageEvent, {
			/**
			 * Returns the block that damaged the player.
			 */
			getDamager(): (org.bukkit.block.Block | null);

			/**
			 * Returns the captured BlockState of the block that damaged the player.
			 */
			getDamagerBlockState(): (org.bukkit.block.BlockState | null);

		}> {}
		class EntityDamageByBlockEvent {
			constructor(damager: (org.bukkit.block.Block | null), damagee: org.bukkit.entity.Entity, cause: org.bukkit.event.entity.EntityDamageEvent.DamageCause, damage: number);

			constructor(damager: (org.bukkit.block.Block | null), damagerState: (org.bukkit.block.BlockState | null), damagee: org.bukkit.entity.Entity, cause: org.bukkit.event.entity.EntityDamageEvent.DamageCause, damageSource: org.bukkit.damage.DamageSource, damage: number);

			constructor(damager: (org.bukkit.block.Block | null), damagee: org.bukkit.entity.Entity, cause: org.bukkit.event.entity.EntityDamageEvent.DamageCause, modifiers: globalThis.java.util.Map<org.bukkit.event.entity.EntityDamageEvent.DamageModifier, number>, modifierFunctions: globalThis.java.util.Map<org.bukkit.event.entity.EntityDamageEvent.DamageModifier>);

			constructor(damager: (org.bukkit.block.Block | null), damagerState: (org.bukkit.block.BlockState | null), damagee: org.bukkit.entity.Entity, cause: org.bukkit.event.entity.EntityDamageEvent.DamageCause, damageSource: org.bukkit.damage.DamageSource, modifiers: globalThis.java.util.Map<org.bukkit.event.entity.EntityDamageEvent.DamageModifier, number>, modifierFunctions: globalThis.java.util.Map<org.bukkit.event.entity.EntityDamageEvent.DamageModifier>);

		}
		interface EntityDamageByEntityEvent extends Modify<org.bukkit.event.entity.EntityDamageEvent, {
			/**
			 * Returns the entity that damaged the defender.
			 */
			getDamager(): org.bukkit.entity.Entity;

		}> {}
		class EntityDamageByEntityEvent {
			constructor(damager: org.bukkit.entity.Entity, damagee: org.bukkit.entity.Entity, cause: org.bukkit.event.entity.EntityDamageEvent.DamageCause, damage: number);

			constructor(damager: org.bukkit.entity.Entity, damagee: org.bukkit.entity.Entity, cause: org.bukkit.event.entity.EntityDamageEvent.DamageCause, damageSource: org.bukkit.damage.DamageSource, damage: number);

			constructor(damager: org.bukkit.entity.Entity, damagee: org.bukkit.entity.Entity, cause: org.bukkit.event.entity.EntityDamageEvent.DamageCause, modifiers: globalThis.java.util.Map<org.bukkit.event.entity.EntityDamageEvent.DamageModifier, number>, modifierFunctions: globalThis.java.util.Map<org.bukkit.event.entity.EntityDamageEvent.DamageModifier>);

			constructor(damager: org.bukkit.entity.Entity, damagee: org.bukkit.entity.Entity, cause: org.bukkit.event.entity.EntityDamageEvent.DamageCause, damageSource: org.bukkit.damage.DamageSource, modifiers: globalThis.java.util.Map<org.bukkit.event.entity.EntityDamageEvent.DamageModifier, number>, modifierFunctions: globalThis.java.util.Map<org.bukkit.event.entity.EntityDamageEvent.DamageModifier>);

		}
		interface EntityDamageEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the original damage for the specified modifier, as defined at this
			 * event's construction.
			 */
			getOriginalDamage(type: org.bukkit.event.entity.EntityDamageEvent.DamageModifier): number;

			/**
			 * Sets the damage for the specified modifier.
			 */
			setDamage(type: org.bukkit.event.entity.EntityDamageEvent.DamageModifier, damage: number): void;

			/**
			 * Gets the damage change for some modifier
			 */
			getDamage(type: org.bukkit.event.entity.EntityDamageEvent.DamageModifier): number;

			/**
			 * This checks to see if a particular modifier is valid for this event's
			 * caller, such that, setDamage(DamageModifier, double) will not
			 * throw an UnsupportedOperationException.
			 * 
			 * EntityDamageEvent.DamageModifier.BASE is always applicable.
			 */
			isApplicable(type: org.bukkit.event.entity.EntityDamageEvent.DamageModifier): boolean;

			/**
			 * Gets the raw amount of damage caused by the event
			 */
			getDamage(): number;

			/**
			 * Gets the amount of damage caused by the event after all damage
			 * reduction is applied.
			 */
			getFinalDamage(): number;

			/**
			 * Sets the raw amount of damage caused by the event.
			 * 
			 * For compatibility this also recalculates the modifiers and scales
			 * them by the difference between the modifier for the previous damage
			 * value and the new one.
			 */
			setDamage(damage: number): void;

			/**
			 * Gets the cause of the damage.
			 * 
			 * While a DamageCause may indicate a specific Bukkit-assigned cause of damage,
			 * getDamageSource() may expose additional types of damage such as custom
			 * damage types provided by data packs, as well as any direct or indirect entities,
			 * locations, or other contributing factors to the damage being inflicted. The
			 * alternative is generally preferred, but DamageCauses provided to this event
			 * should largely encompass most common use cases for developers if a simple cause
			 * is required.
			 */
			getCause(): org.bukkit.event.entity.EntityDamageEvent.DamageCause;

			/**
			 * Get the source of damage.
			 */
			getDamageSource(): org.bukkit.damage.DamageSource;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityDamageEvent {
			constructor(damagee: org.bukkit.entity.Entity, cause: org.bukkit.event.entity.EntityDamageEvent.DamageCause, damage: number);

			constructor(damagee: org.bukkit.entity.Entity, cause: org.bukkit.event.entity.EntityDamageEvent.DamageCause, damageSource: org.bukkit.damage.DamageSource, damage: number);

			constructor(damagee: org.bukkit.entity.Entity, cause: org.bukkit.event.entity.EntityDamageEvent.DamageCause, modifiers: globalThis.java.util.Map<org.bukkit.event.entity.EntityDamageEvent.DamageModifier, number>, modifierFunctions: globalThis.java.util.Map<org.bukkit.event.entity.EntityDamageEvent.DamageModifier>);

			constructor(damagee: org.bukkit.entity.Entity, cause: org.bukkit.event.entity.EntityDamageEvent.DamageCause, damageSource: org.bukkit.damage.DamageSource, modifiers: globalThis.java.util.Map<org.bukkit.event.entity.EntityDamageEvent.DamageModifier, number>, modifierFunctions: globalThis.java.util.Map<org.bukkit.event.entity.EntityDamageEvent.DamageModifier>);

		}
		namespace EntityDamageEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace EntityDamageEvent {
			interface DamageCause {}
			namespace DamageCause {
				/**
				 * Damage caused by /kill command
				 * 
				 * Damage: Float.MAX_VALUE
				 */
				const KILL: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused by the World Border
				 * 
				 * Damage: WorldBorder.getDamageAmount()
				 */
				const WORLD_BORDER: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused when an entity contacts a block such as a Cactus,
				 * Dripstone (Stalagmite) or Berry Bush.
				 * 
				 * Damage: variable
				 */
				const CONTACT: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused when an entity attacks another entity.
				 * 
				 * Damage: variable
				 */
				const ENTITY_ATTACK: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused when an entity attacks another entity in a sweep attack.
				 * 
				 * Damage: variable
				 */
				const ENTITY_SWEEP_ATTACK: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused when attacked by a projectile.
				 * 
				 * Damage: variable
				 */
				const PROJECTILE: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused by being put in a block
				 * 
				 * Damage: 1
				 */
				const SUFFOCATION: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused when an entity falls a distance greater than 3 blocks
				 * 
				 * Damage: fall height - 3.0
				 */
				const FALL: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused by direct exposure to fire
				 * 
				 * Damage: 1
				 */
				const FIRE: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused due to burns caused by fire
				 * 
				 * Damage: 1
				 */
				const FIRE_TICK: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused due to a snowman melting
				 * 
				 * Damage: 1
				 */
				const MELTING: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused by direct exposure to lava
				 * 
				 * Damage: 4
				 */
				const LAVA: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused by running out of air while in water
				 * 
				 * Damage: 2
				 */
				const DROWNING: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused by being in the area when a block explodes.
				 * 
				 * Damage: variable
				 */
				const BLOCK_EXPLOSION: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused by being in the area when an entity, such as a
				 * Creeper, explodes.
				 * 
				 * Damage: variable
				 */
				const ENTITY_EXPLOSION: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused by falling into the void
				 * 
				 * Damage: 4 for players
				 */
				const VOID: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused by being struck by lightning
				 * 
				 * Damage: 5
				 */
				const LIGHTNING: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused by committing suicide.
				 * 
				 * Note: This is currently only used by plugins, default commands
				 * like /minecraft:kill use KILL to damage players.
				 * 
				 * Damage: variable
				 */
				const SUICIDE: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused by starving due to having an empty hunger bar
				 * 
				 * Damage: 1
				 */
				const STARVATION: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused due to an ongoing poison effect
				 * 
				 * Damage: 1
				 */
				const POISON: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused by being hit by a damage potion or spell
				 * 
				 * Damage: variable
				 */
				const MAGIC: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused by Wither potion effect
				 */
				const WITHER: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused by being hit by a falling block which deals damage
				 * 
				 * Note: Not every block deals damage
				 * 
				 * Damage: variable
				 */
				const FALLING_BLOCK: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused in retaliation to another attack by the Thorns
				 * enchantment.
				 * 
				 * Damage: 1-4 (Thorns)
				 */
				const THORNS: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused by a dragon breathing fire.
				 * 
				 * Damage: variable
				 */
				const DRAGON_BREATH: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Custom damage.
				 * 
				 * Damage: variable
				 */
				const CUSTOM: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused when an entity runs into a wall.
				 * 
				 * Damage: variable
				 */
				const FLY_INTO_WALL: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused when an entity steps on Material.MAGMA_BLOCK.
				 * 
				 * Damage: 1
				 */
				const HOT_FLOOR: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused when an entity steps on Material.CAMPFIRE or Material.SOUL_CAMPFIRE.
				 * 
				 * Damage: 1
				 */
				const CAMPFIRE: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused when an entity is colliding with too many entities due
				 * to the maxEntityCramming game rule.
				 * 
				 * Damage: 6
				 */
				const CRAMMING: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused when an entity that should be in water is not.
				 * 
				 * Damage: 1
				 */
				const DRYOUT: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused from freezing.
				 * 
				 * Damage: 1 or 5
				 */
				const FREEZE: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Damage caused by the Sonic Boom attack from Warden
				 * 
				 * Damage: 10
				 */
				const SONIC_BOOM: org.bukkit.event.entity.EntityDamageEvent.DamageCause;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.entity.EntityDamageEvent.DamageCause;

			}
		}
		namespace EntityDamageEvent {
			interface DamageModifier {}
			namespace DamageModifier {
				/**
				 * This represents the amount of damage being done, also known as the
				 * raw EntityDamageEvent.getDamage().
				 */
				const BASE: org.bukkit.event.entity.EntityDamageEvent.DamageModifier;

				/**
				 * This represents the damage reduced by a wearing a helmet when hit
				 * by a falling block.
				 */
				const HARD_HAT: org.bukkit.event.entity.EntityDamageEvent.DamageModifier;

				/**
				 * This represents the damage reduction caused by blocking, only present for
				 * Players.
				 */
				const BLOCKING: org.bukkit.event.entity.EntityDamageEvent.DamageModifier;

				/**
				 * This represents the damage reduction caused by wearing armor.
				 */
				const ARMOR: org.bukkit.event.entity.EntityDamageEvent.DamageModifier;

				/**
				 * This represents the damage reduction caused by the Resistance potion effect.
				 */
				const RESISTANCE: org.bukkit.event.entity.EntityDamageEvent.DamageModifier;

				/**
				 * This represents the damage reduction caused by the combination of:
				 * 
				 * 
				 * Armor enchantments
				 * 
				 * Witch's potion resistance
				 * 
				 * 
				 */
				const MAGIC: org.bukkit.event.entity.EntityDamageEvent.DamageModifier;

				/**
				 * This represents the damage reduction caused by the absorption potion
				 * effect.
				 */
				const ABSORPTION: org.bukkit.event.entity.EntityDamageEvent.DamageModifier;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.entity.EntityDamageEvent.DamageModifier;

			}
		}
		interface EntityDeathEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.LivingEntity;

			/**
			 * Gets the source of damage which caused the death.
			 */
			getDamageSource(): org.bukkit.damage.DamageSource;

			/**
			 * Gets how much EXP should be dropped from this death.
			 * 
			 * This does not indicate how much EXP should be taken from the entity in
			 * question, merely how much should be created after its death.
			 */
			getDroppedExp(): number;

			/**
			 * Sets how much EXP should be dropped from this death.
			 * 
			 * This does not indicate how much EXP should be taken from the entity in
			 * question, merely how much should be created after its death.
			 */
			setDroppedExp(exp: number): void;

			/**
			 * Gets all the items which will drop when the entity dies
			 */
			getDrops(): globalThis.java.util.List<org.bukkit.inventory.ItemStack>;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityDeathEvent {
			constructor(entity: org.bukkit.entity.LivingEntity, damageSource: org.bukkit.damage.DamageSource, drops: globalThis.java.util.List<org.bukkit.inventory.ItemStack>);

			constructor(what: org.bukkit.entity.LivingEntity, damageSource: org.bukkit.damage.DamageSource, drops: globalThis.java.util.List<org.bukkit.inventory.ItemStack>, droppedExp: number);

		}
		namespace EntityDeathEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityDismountEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Gets the entity which will no longer be ridden.
			 */
			getDismounted(): org.bukkit.entity.Entity;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityDismountEvent {
			constructor(what: org.bukkit.entity.Entity, dismounted: org.bukkit.entity.Entity);

		}
		namespace EntityDismountEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityDropItemEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Gets the Item created by the entity
			 */
			getItemDrop(): org.bukkit.entity.Item;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityDropItemEvent {
			constructor(entity: org.bukkit.entity.Entity, drop: org.bukkit.entity.Item);

		}
		namespace EntityDropItemEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityEnterBlockEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Get the block the entity will enter.
			 */
			getBlock(): org.bukkit.block.Block;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityEnterBlockEvent {
			constructor(entity: org.bukkit.entity.Entity, block: org.bukkit.block.Block);

		}
		namespace EntityEnterBlockEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityEnterLoveModeEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Gets the animal that is entering love mode.
			 */
			getEntity(): org.bukkit.entity.Animals;

			/**
			 * Gets the Human Entity that caused the animal to enter love mode.
			 */
			getHumanEntity(): (org.bukkit.entity.HumanEntity | null);

			/**
			 * Gets the amount of ticks that the animal will fall in love for.
			 */
			getTicksInLove(): number;

			/**
			 * Sets the amount of ticks that the animal will fall in love for.
			 */
			setTicksInLove(ticksInLove: number): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityEnterLoveModeEvent {
			constructor(animalInLove: org.bukkit.entity.Animals, humanEntity: (org.bukkit.entity.HumanEntity | null), ticksInLove: number);

		}
		namespace EntityEnterLoveModeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityEvent extends Modify<org.bukkit.event.Event, {
			/**
			 * Returns the Entity involved in this event
			 */
			getEntity(): org.bukkit.entity.Entity;

			/**
			 * Gets the EntityType of the Entity involved in this event.
			 */
			getEntityType(): org.bukkit.entity.EntityType;

		}> {}
		class EntityEvent {
			constructor(what: org.bukkit.entity.Entity);

		}
		interface EntityExhaustionEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Gets the EntityExhaustionEvent.ExhaustionReason for this event
			 */
			getExhaustionReason(): org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason;

			/**
			 * Get the amount of exhaustion to add to the player's current exhaustion.
			 */
			getExhaustion(): number;

			/**
			 * Set the exhaustion to apply to the player.
			 * The maximum exhaustion that a player can have is 40. No error will be
			 * thrown if this limit is hit. This value may be negative, but there is
			 * unknown behavior for when exhaustion is below 0.
			 */
			setExhaustion(exhaustion: number): void;

			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.HumanEntity;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityExhaustionEvent {
			constructor(who: org.bukkit.entity.HumanEntity, exhaustionReason: org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason, exhaustion: number);

		}
		namespace EntityExhaustionEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace EntityExhaustionEvent {
			interface ExhaustionReason {}
			namespace ExhaustionReason {
				/**
				 * Player mines a block
				 */
				const BLOCK_MINED: org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason;

				/**
				 * Player has the hunger potion effect
				 */
				const HUNGER_EFFECT: org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason;

				/**
				 * Player takes damage
				 */
				const DAMAGED: org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason;

				/**
				 * Player attacks another entity
				 */
				const ATTACK: org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason;

				/**
				 * Player is sprint jumping
				 */
				const JUMP_SPRINT: org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason;

				/**
				 * Player jumps
				 */
				const JUMP: org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason;

				/**
				 * Player swims one centimeter
				 */
				const SWIM: org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason;

				/**
				 * Player walks underwater one centimeter
				 */
				const WALK_UNDERWATER: org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason;

				/**
				 * Player moves on the surface of water one centimeter
				 */
				const WALK_ON_WATER: org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason;

				/**
				 * Player sprints one centimeter
				 */
				const SPRINT: org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason;

				/**
				 * Player crouches one centimeter (does not effect exhaustion, but fires
				 * nonetheless)
				 */
				const CROUCH: org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason;

				/**
				 * Player walks one centimeter (does not effect exhaustion, but fires
				 * nonetheless)
				 */
				const WALK: org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason;

				/**
				 * Player regenerated health
				 */
				const REGEN: org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason;

				/**
				 * Unknown exhaustion reason
				 */
				const UNKNOWN: org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.entity.EntityExhaustionEvent.ExhaustionReason;

			}
		}
		interface EntityExplodeEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Returns the list of blocks that would have been removed or were removed
			 * from the explosion event.
			 */
			blockList(): globalThis.java.util.List<org.bukkit.block.Block>;

			/**
			 * Returns the location where the explosion happened.
			 * 
			 * It is not possible to get this value from the Entity as the Entity no
			 * longer exists in the world.
			 */
			getLocation(): org.bukkit.Location;

			/**
			 * Returns the percentage of blocks to drop from this explosion
			 */
			getYield(): number;

			/**
			 * Sets the percentage of blocks to drop from this explosion
			 */
			setYield(yield: number): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityExplodeEvent {
			constructor(what: org.bukkit.entity.Entity, location: org.bukkit.Location, blocks: globalThis.java.util.List<org.bukkit.block.Block>, yield: number);

		}
		namespace EntityExplodeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityInteractEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Returns the involved block
			 */
			getBlock(): org.bukkit.block.Block;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityInteractEvent {
			constructor(entity: org.bukkit.entity.Entity, block: org.bukkit.block.Block);

		}
		namespace EntityInteractEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityKnockbackByEntityEvent extends Modify<org.bukkit.event.entity.EntityKnockbackEvent, {
			/**
			 * Get the entity that has caused knockback to the defender.
			 */
			getSourceEntity(): org.bukkit.entity.Entity;

		}> {}
		class EntityKnockbackByEntityEvent {
			constructor(entity: org.bukkit.entity.LivingEntity, source: org.bukkit.entity.Entity, cause: org.bukkit.event.entity.EntityKnockbackEvent.KnockbackCause, force: number, rawKnockback: org.bukkit.util.Vector, knockback: org.bukkit.util.Vector);

		}
		interface EntityKnockbackEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.LivingEntity;

			/**
			 * Gets the cause of the knockback.
			 */
			getCause(): org.bukkit.event.entity.EntityKnockbackEvent.KnockbackCause;

			/**
			 * Gets the raw force of the knockback.
			 * This value is based on factors such as the Enchantment.KNOCKBACK
			 * level of an attacker and the
			 * Attribute.GENERIC_KNOCKBACK_RESISTANCE of the entity.
			 */
			getForce(): number;

			/**
			 * Gets the raw knockback force that will be applied to the entity.
			 * This value is read-only, changes made to it will not have any
			 * effect on the final knockback received.
			 */
			getKnockback(): org.bukkit.util.Vector;

			/**
			 * Gets the force that will be applied to the entity.
			 * In contrast to getKnockback() this value is
			 * affected by the entities current velocity and whether they are touching
			 * the ground.
			 * 
			 * Note: this method returns a copy, changes must be applied with
			 * setFinalKnockback(Vector).
			 */
			getFinalKnockback(): org.bukkit.util.Vector;

			/**
			 * Sets the force that will be applied to the entity.
			 */
			setFinalKnockback(knockback: org.bukkit.util.Vector): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityKnockbackEvent {
			constructor(entity: org.bukkit.entity.LivingEntity, cause: org.bukkit.event.entity.EntityKnockbackEvent.KnockbackCause, force: number, rawKnockback: org.bukkit.util.Vector, knockback: org.bukkit.util.Vector);

		}
		namespace EntityKnockbackEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace EntityKnockbackEvent {
			interface KnockbackCause {}
			namespace KnockbackCause {
				/**
				 * Knockback caused by non-entity damage.
				 */
				const DAMAGE: org.bukkit.event.entity.EntityKnockbackEvent.KnockbackCause;

				/**
				 * Knockback caused by an attacking entity.
				 */
				const ENTITY_ATTACK: org.bukkit.event.entity.EntityKnockbackEvent.KnockbackCause;

				/**
				 * Knockback caused by an explosion.
				 */
				const EXPLOSION: org.bukkit.event.entity.EntityKnockbackEvent.KnockbackCause;

				/**
				 * Knockback caused by the target blocking with a shield.
				 */
				const SHIELD_BLOCK: org.bukkit.event.entity.EntityKnockbackEvent.KnockbackCause;

				/**
				 * Knockback caused by a sweeping attack.
				 */
				const SWEEP_ATTACK: org.bukkit.event.entity.EntityKnockbackEvent.KnockbackCause;

				/**
				 * Knockback with an unknown cause.
				 */
				const UNKNOWN: org.bukkit.event.entity.EntityKnockbackEvent.KnockbackCause;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.entity.EntityKnockbackEvent.KnockbackCause;

			}
		}
		interface EntityMountEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Gets the entity which will be ridden.
			 */
			getMount(): org.bukkit.entity.Entity;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityMountEvent {
			constructor(what: org.bukkit.entity.Entity, mount: org.bukkit.entity.Entity);

		}
		namespace EntityMountEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityPickupItemEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.LivingEntity;

			/**
			 * Gets the Item picked up by the entity.
			 */
			getItem(): org.bukkit.entity.Item;

			/**
			 * Gets the amount remaining on the ground, if any
			 */
			getRemaining(): number;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityPickupItemEvent {
			constructor(entity: org.bukkit.entity.LivingEntity, item: org.bukkit.entity.Item, remaining: number);

		}
		namespace EntityPickupItemEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityPlaceEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Returns the player placing the entity
			 */
			getPlayer(): (org.bukkit.entity.Player | null);

			/**
			 * Returns the block that the entity was placed on
			 */
			getBlock(): org.bukkit.block.Block;

			/**
			 * Returns the face of the block that the entity was placed on
			 */
			getBlockFace(): org.bukkit.block.BlockFace;

			/**
			 * Get the hand used to place the entity.
			 */
			getHand(): org.bukkit.inventory.EquipmentSlot;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityPlaceEvent {
			constructor(entity: org.bukkit.entity.Entity, player: (org.bukkit.entity.Player | null), block: org.bukkit.block.Block, blockFace: org.bukkit.block.BlockFace, hand: org.bukkit.inventory.EquipmentSlot);

			constructor(entity: org.bukkit.entity.Entity, player: (org.bukkit.entity.Player | null), block: org.bukkit.block.Block, blockFace: org.bukkit.block.BlockFace);

		}
		namespace EntityPlaceEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityPortalEnterEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Gets the portal block the entity is touching
			 */
			getLocation(): org.bukkit.Location;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityPortalEnterEvent {
			constructor(entity: org.bukkit.entity.Entity, location: org.bukkit.Location);

		}
		namespace EntityPortalEnterEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityPortalEvent extends Modify<org.bukkit.event.entity.EntityTeleportEvent, {
			/**
			 * Set the Block radius to search in for available portals.
			 */
			setSearchRadius(searchRadius: number): void;

			/**
			 * Gets the search radius value for finding an available portal.
			 */
			getSearchRadius(): number;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityPortalEvent {
			constructor(entity: org.bukkit.entity.Entity, from: org.bukkit.Location, to: (org.bukkit.Location | null));

			constructor(entity: org.bukkit.entity.Entity, from: org.bukkit.Location, to: (org.bukkit.Location | null), searchRadius: number);

		}
		namespace EntityPortalEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityPortalExitEvent extends Modify<org.bukkit.event.entity.EntityTeleportEvent, {
			/**
			 * Gets a copy of the velocity that the entity has before entering the
			 * portal.
			 */
			getBefore(): org.bukkit.util.Vector;

			/**
			 * Gets a copy of the velocity that the entity will have after exiting the
			 * portal.
			 */
			getAfter(): org.bukkit.util.Vector;

			/**
			 * Sets the velocity that the entity will have after exiting the portal.
			 */
			setAfter(after: org.bukkit.util.Vector): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityPortalExitEvent {
			constructor(entity: org.bukkit.entity.Entity, from: org.bukkit.Location, to: org.bukkit.Location, before: org.bukkit.util.Vector, after: org.bukkit.util.Vector);

		}
		namespace EntityPortalExitEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityPoseChangeEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Gets the entity's new pose.
			 */
			getPose(): org.bukkit.entity.Pose;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityPoseChangeEvent {
			constructor(who: org.bukkit.entity.Entity, pose: org.bukkit.entity.Pose);

		}
		namespace EntityPoseChangeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityPotionEffectEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Gets the old potion effect of the changed type, which will be removed.
			 */
			getOldEffect(): (org.bukkit.potion.PotionEffect | null);

			/**
			 * Gets new potion effect of the changed type to be applied.
			 */
			getNewEffect(): (org.bukkit.potion.PotionEffect | null);

			/**
			 * Gets the cause why the effect has changed.
			 */
			getCause(): org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

			/**
			 * Gets the action which will be performed on the potion effect type.
			 */
			getAction(): org.bukkit.event.entity.EntityPotionEffectEvent.Action;

			/**
			 * Gets the modified potion effect type.
			 */
			getModifiedType(): org.bukkit.potion.PotionEffectType;

			/**
			 * Returns if the new potion effect will override the old potion effect
			 * (Only applicable for the CHANGED Action).
			 */
			isOverride(): boolean;

			/**
			 * Sets if the new potion effect will override the old potion effect (Only
			 * applicable for the CHANGED action).
			 */
			setOverride(override: boolean): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityPotionEffectEvent {
			constructor(livingEntity: org.bukkit.entity.LivingEntity, oldEffect: (org.bukkit.potion.PotionEffect | null), newEffect: (org.bukkit.potion.PotionEffect | null), cause: org.bukkit.event.entity.EntityPotionEffectEvent.Cause, action: org.bukkit.event.entity.EntityPotionEffectEvent.Action, override: boolean);

		}
		namespace EntityPotionEffectEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace EntityPotionEffectEvent {
			interface Action {}
			namespace Action {
				/**
				 * When the potion effect is added because the entity didn't have it's
				 * type.
				 */
				const ADDED: org.bukkit.event.entity.EntityPotionEffectEvent.Action;

				/**
				 * When the entity already had the potion effect type, but the effect is
				 * changed.
				 */
				const CHANGED: org.bukkit.event.entity.EntityPotionEffectEvent.Action;

				/**
				 * When the effect is removed due to all effects being removed.
				 */
				const CLEARED: org.bukkit.event.entity.EntityPotionEffectEvent.Action;

				/**
				 * When the potion effect type is completely removed.
				 */
				const REMOVED: org.bukkit.event.entity.EntityPotionEffectEvent.Action;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.entity.EntityPotionEffectEvent.Action;

			}
		}
		namespace EntityPotionEffectEvent {
			interface Cause {}
			namespace Cause {
				/**
				 * When the entity stands inside an area effect cloud.
				 */
				const AREA_EFFECT_CLOUD: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When the entity is hit by an spectral or tipped arrow.
				 */
				const ARROW: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When the entity is inflicted with a potion effect due to an entity
				 * attack (e.g. a cave spider or a shulker bullet).
				 */
				const ATTACK: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When an entity gets the effect from an axolotl.
				 */
				const AXOLOTL: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When beacon effects get applied due to the entity being nearby.
				 */
				const BEACON: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When a potion effect is changed due to the /effect command.
				 */
				const COMMAND: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When the entity gets the effect from a conduit.
				 */
				const CONDUIT: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When a conversion from a villager zombie to a villager is started or
				 * finished.
				 */
				const CONVERSION: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When all effects are removed due to death.
				 */
				const DEATH: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When the entity gets the effect from a dolphin.
				 */
				const DOLPHIN: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When the effect was removed due to expiration.
				 */
				const EXPIRATION: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When an effect is inflicted due to food (e.g. when a player eats or a
				 * cookie is given to a parrot).
				 */
				const FOOD: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When an illusion illager makes himself disappear.
				 */
				const ILLUSION: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When all effects are removed due to a bucket of milk.
				 */
				const MILK: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When a player gets bad omen after killing a patrol captain.
				 */
				const PATROL_CAPTAIN: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When a potion effect is modified through the plugin methods.
				 */
				const PLUGIN: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When the entity drinks a potion.
				 */
				const POTION_DRINK: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When the entity is inflicted with an effect due to a splash potion.
				 */
				const POTION_SPLASH: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When a spider gets effects when spawning on hard difficulty.
				 */
				const SPIDER_SPAWN: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When the entity gets effects from a totem item saving it's life.
				 */
				const TOTEM: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When the entity gets water breathing by wearing a turtle helmet.
				 */
				const TURTLE_HELMET: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When the Cause is missing.
				 */
				const UNKNOWN: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When a villager gets regeneration after a trade.
				 */
				const VILLAGER_TRADE: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When an entity gets the effect from a warden.
				 */
				const WARDEN: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * When an entity comes in contact with a wither rose.
				 */
				const WITHER_ROSE: org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.entity.EntityPotionEffectEvent.Cause;

			}
		}
		interface EntityRegainHealthEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Gets the amount of regained health
			 */
			getAmount(): number;

			/**
			 * Sets the amount of regained health
			 */
			setAmount(amount: number): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the reason for why the entity is regaining health
			 */
			getRegainReason(): org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityRegainHealthEvent {
			constructor(entity: org.bukkit.entity.Entity, amount: number, regainReason: org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason);

		}
		namespace EntityRegainHealthEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace EntityRegainHealthEvent {
			interface RegainReason {}
			namespace RegainReason {
				/**
				 * When a player regains health from regenerating due to Peaceful mode
				 * (difficulty=0)
				 */
				const REGEN: org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason;

				/**
				 * When a player regains health from regenerating due to their hunger
				 * being satisfied
				 */
				const SATIATED: org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason;

				/**
				 * When a player regains health from eating consumables
				 */
				const EATING: org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason;

				/**
				 * When an ender dragon regains health from an ender crystal
				 */
				const ENDER_CRYSTAL: org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason;

				/**
				 * When a player is healed by a potion or spell
				 */
				const MAGIC: org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason;

				/**
				 * When a player is healed over time by a potion or spell
				 */
				const MAGIC_REGEN: org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason;

				/**
				 * When a wither is filling its health during spawning
				 */
				const WITHER_SPAWN: org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason;

				/**
				 * When an entity is damaged by the Wither potion effect
				 */
				const WITHER: org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason;

				/**
				 * Any other reason not covered by the reasons above
				 */
				const CUSTOM: org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.entity.EntityRegainHealthEvent.RegainReason;

			}
		}
		interface EntityRemoveEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Gets the cause why the entity got removed.
			 */
			getCause(): org.bukkit.event.entity.EntityRemoveEvent.Cause;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityRemoveEvent {
			constructor(what: org.bukkit.entity.Entity, cause: org.bukkit.event.entity.EntityRemoveEvent.Cause);

		}
		namespace EntityRemoveEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace EntityRemoveEvent {
			interface Cause {}
			namespace Cause {
				/**
				 * When an entity dies.
				 */
				const DEATH: org.bukkit.event.entity.EntityRemoveEvent.Cause;

				/**
				 * When an entity does despawn. This includes mobs which are too far away,
				 * items or arrows which lay to long on the ground or area effect cloud.
				 */
				const DESPAWN: org.bukkit.event.entity.EntityRemoveEvent.Cause;

				/**
				 * When an entity gets removed because it drops as an item.
				 * For example, trident or falling sand.
				 * 
				 * Note: Depending on other factors, such as gamerules, no item will actually drop,
				 * the cause, however, will still be drop.
				 */
				const DROP: org.bukkit.event.entity.EntityRemoveEvent.Cause;

				/**
				 * When an entity gets removed because it enters a block.
				 * For example, bees or silverfish.
				 */
				const ENTER_BLOCK: org.bukkit.event.entity.EntityRemoveEvent.Cause;

				/**
				 * When an entity gets removed because it exploded.
				 * For example, creepers, tnt or firework.
				 */
				const EXPLODE: org.bukkit.event.entity.EntityRemoveEvent.Cause;

				/**
				 * When an entity gets removed because it hit something. This mainly applies to projectiles.
				 */
				const HIT: org.bukkit.event.entity.EntityRemoveEvent.Cause;

				/**
				 * When an entity gets removed because it merges with another one.
				 * For example, items or xp.
				 */
				const MERGE: org.bukkit.event.entity.EntityRemoveEvent.Cause;

				/**
				 * When an entity gets removed because it is too far below the world.
				 * This only applies to entities which get removed immediately,
				 * some entities get damage instead.
				 */
				const OUT_OF_WORLD: org.bukkit.event.entity.EntityRemoveEvent.Cause;

				/**
				 * When an entity gets removed because it got pickup.
				 * For example, items, arrows, xp or parrots which get on a player shoulder.
				 */
				const PICKUP: org.bukkit.event.entity.EntityRemoveEvent.Cause;

				/**
				 * When an entity gets removed with a player because the player quits the game.
				 * For example, a boat which gets removed with the player when he quits.
				 */
				const PLAYER_QUIT: org.bukkit.event.entity.EntityRemoveEvent.Cause;

				/**
				 * When a plugin manually removes an entity.
				 */
				const PLUGIN: org.bukkit.event.entity.EntityRemoveEvent.Cause;

				/**
				 * When an entity gets removed because it transforms into another one.
				 */
				const TRANSFORMATION: org.bukkit.event.entity.EntityRemoveEvent.Cause;

				/**
				 * When the chunk an entity is in gets unloaded.
				 */
				const UNLOAD: org.bukkit.event.entity.EntityRemoveEvent.Cause;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.entity.EntityRemoveEvent.Cause;

			}
		}
		interface EntityResurrectEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.LivingEntity;

			/**
			 * Get the hand in which the totem of undying was found, or null if the
			 * entity did not have a totem of undying.
			 */
			getHand(): (org.bukkit.inventory.EquipmentSlot | null);

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancelled: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityResurrectEvent {
			constructor(what: org.bukkit.entity.LivingEntity, hand: (org.bukkit.inventory.EquipmentSlot | null));

			constructor(what: org.bukkit.entity.LivingEntity);

		}
		namespace EntityResurrectEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityShootBowEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.LivingEntity;

			/**
			 * Gets the bow ItemStack used to fire the arrow.
			 */
			getBow(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Get the ItemStack to be consumed in this event (if any).
			 * For instance, bows will consume an arrow ItemStack in a player's
			 * inventory.
			 */
			getConsumable(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Gets the projectile which will be launched by this event
			 */
			getProjectile(): org.bukkit.entity.Entity;

			/**
			 * Replaces the projectile which will be launched
			 */
			setProjectile(projectile: org.bukkit.entity.Entity): void;

			/**
			 * Get the hand from which the bow was shot.
			 */
			getHand(): org.bukkit.inventory.EquipmentSlot;

			/**
			 * Gets the force the arrow was launched with
			 */
			getForce(): number;

			/**
			 * Set whether or not the consumable item should be consumed in this event.
			 * If set to false, it is recommended that a call to
			 * Player.updateInventory() is made as the client may disagree with
			 * the server's decision to not consume a consumable item.
			 * 
			 * This value is ignored for entities where items are not required
			 * (skeletons, pillagers, etc.) or with crossbows (as no item is being
			 * consumed).
			 */
			setConsumeItem(consumeItem: boolean): void;

			/**
			 * Get whether or not the consumable item should be consumed in this event.
			 */
			shouldConsumeItem(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityShootBowEvent {
			constructor(shooter: org.bukkit.entity.LivingEntity, bow: (org.bukkit.inventory.ItemStack | null), consumable: (org.bukkit.inventory.ItemStack | null), projectile: org.bukkit.entity.Entity, hand: org.bukkit.inventory.EquipmentSlot, force: number, consumeItem: boolean);

		}
		namespace EntityShootBowEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntitySpawnEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the location at which the entity is spawning.
			 */
			getLocation(): org.bukkit.Location;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntitySpawnEvent {
			constructor(spawnee: org.bukkit.entity.Entity);

		}
		namespace EntitySpawnEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntitySpellCastEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.Spellcaster;

			/**
			 * Get the spell to be cast in this event.
			 * This is a convenience method equivalent to
			 * Spellcaster.getSpell().
			 */
			getSpell(): org.bukkit.entity.Spellcaster.Spell;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancelled: boolean): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntitySpellCastEvent {
			constructor(what: org.bukkit.entity.Spellcaster, spell: org.bukkit.entity.Spellcaster.Spell);

		}
		namespace EntitySpellCastEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityTameEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.LivingEntity;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the owning AnimalTamer
			 */
			getOwner(): org.bukkit.entity.AnimalTamer;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityTameEvent {
			constructor(entity: org.bukkit.entity.LivingEntity, owner: org.bukkit.entity.AnimalTamer);

		}
		namespace EntityTameEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityTargetEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Returns the reason for the targeting
			 */
			getReason(): org.bukkit.event.entity.EntityTargetEvent.TargetReason;

			/**
			 * Get the entity that this is targeting.
			 * 
			 * This will be null in the case that the event is called when the mob
			 * forgets its target.
			 */
			getTarget(): (org.bukkit.entity.Entity | null);

			/**
			 * Set the entity that you want the mob to target instead.
			 * 
			 * It is possible to be null, null will cause the entity to be
			 * target-less.
			 * 
			 * This is different from cancelling the event. Cancelling the event will
			 * cause the entity to keep an original target, while setting to be null
			 * will cause the entity to be reset.
			 */
			setTarget(target: (org.bukkit.entity.Entity | null)): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityTargetEvent {
			constructor(entity: org.bukkit.entity.Entity, target: (org.bukkit.entity.Entity | null), reason: org.bukkit.event.entity.EntityTargetEvent.TargetReason);

		}
		namespace EntityTargetEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace EntityTargetEvent {
			interface TargetReason {}
			namespace TargetReason {
				/**
				 * When the entity's target has died, and so it no longer targets it
				 */
				const TARGET_DIED: org.bukkit.event.entity.EntityTargetEvent.TargetReason;

				/**
				 * When the entity doesn't have a target, so it attacks the nearest
				 * player
				 */
				const CLOSEST_PLAYER: org.bukkit.event.entity.EntityTargetEvent.TargetReason;

				/**
				 * When the target attacks the entity, so entity targets it
				 */
				const TARGET_ATTACKED_ENTITY: org.bukkit.event.entity.EntityTargetEvent.TargetReason;

				/**
				 * When the target attacks a fellow pig zombie, so the whole group
				 * will target him with this reason.
				 */
				const PIG_ZOMBIE_TARGET: org.bukkit.event.entity.EntityTargetEvent.TargetReason;

				/**
				 * When the target is forgotten for whatever reason.
				 */
				const FORGOT_TARGET: org.bukkit.event.entity.EntityTargetEvent.TargetReason;

				/**
				 * When the target attacks the owner of the entity, so the entity
				 * targets it.
				 */
				const TARGET_ATTACKED_OWNER: org.bukkit.event.entity.EntityTargetEvent.TargetReason;

				/**
				 * When the owner of the entity attacks the target attacks, so the
				 * entity targets it.
				 */
				const OWNER_ATTACKED_TARGET: org.bukkit.event.entity.EntityTargetEvent.TargetReason;

				/**
				 * When the entity has no target, so the entity randomly chooses one.
				 */
				const RANDOM_TARGET: org.bukkit.event.entity.EntityTargetEvent.TargetReason;

				/**
				 * When an entity selects a target while defending a village.
				 */
				const DEFEND_VILLAGE: org.bukkit.event.entity.EntityTargetEvent.TargetReason;

				/**
				 * When the target attacks a nearby entity of the same type, so the entity targets it
				 */
				const TARGET_ATTACKED_NEARBY_ENTITY: org.bukkit.event.entity.EntityTargetEvent.TargetReason;

				/**
				 * When a zombie targeting an entity summons reinforcements, so the reinforcements target the same entity
				 */
				const REINFORCEMENT_TARGET: org.bukkit.event.entity.EntityTargetEvent.TargetReason;

				/**
				 * When an entity targets another entity after colliding with it.
				 */
				const COLLISION: org.bukkit.event.entity.EntityTargetEvent.TargetReason;

				/**
				 * For custom calls to the event.
				 */
				const CUSTOM: org.bukkit.event.entity.EntityTargetEvent.TargetReason;

				/**
				 * When the entity doesn't have a target, so it attacks the nearest
				 * entity
				 */
				const CLOSEST_ENTITY: org.bukkit.event.entity.EntityTargetEvent.TargetReason;

				/**
				 * When a raiding entity selects the same target as one of its compatriots.
				 */
				const FOLLOW_LEADER: org.bukkit.event.entity.EntityTargetEvent.TargetReason;

				/**
				 * When another entity tempts this entity by having a desired item such
				 * as wheat in it's hand.
				 */
				const TEMPT: org.bukkit.event.entity.EntityTargetEvent.TargetReason;

				/**
				 * A currently unknown reason for the entity changing target.
				 */
				const UNKNOWN: org.bukkit.event.entity.EntityTargetEvent.TargetReason;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.entity.EntityTargetEvent.TargetReason;

			}
		}
		interface EntityTargetLivingEntityEvent extends Modify<org.bukkit.event.entity.EntityTargetEvent, {
			/**
			 * Description copied from class:Â EntityTargetEvent
			 */
			getTarget(): (org.bukkit.entity.LivingEntity | null);

			/**
			 * Set the Entity that you want the mob to target.
			 * 
			 * It is possible to be null, null will cause the entity to be
			 * target-less.
			 * 
			 * Must be a LivingEntity, or null.
			 */
			setTarget(target: (org.bukkit.entity.Entity | null)): void;

		}> {}
		class EntityTargetLivingEntityEvent {
			constructor(entity: org.bukkit.entity.Entity, target: (org.bukkit.entity.LivingEntity | null), reason: (org.bukkit.event.entity.EntityTargetEvent.TargetReason | null));

		}
		interface EntityTeleportEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the location that this entity moved from
			 */
			getFrom(): org.bukkit.Location;

			/**
			 * Sets the location that this entity moved from
			 */
			setFrom(from: org.bukkit.Location): void;

			/**
			 * Gets the location that this entity moved to
			 */
			getTo(): (org.bukkit.Location | null);

			/**
			 * Sets the location that this entity moved to
			 */
			setTo(to: (org.bukkit.Location | null)): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityTeleportEvent {
			constructor(what: org.bukkit.entity.Entity, from: org.bukkit.Location, to: (org.bukkit.Location | null));

		}
		namespace EntityTeleportEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityToggleGlideEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Returns true if the entity is now gliding or
			 * false if the entity stops gliding.
			 */
			isGliding(): boolean;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityToggleGlideEvent {
			constructor(who: org.bukkit.entity.LivingEntity, isGliding: boolean);

		}
		namespace EntityToggleGlideEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityToggleSwimEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Returns true if the entity is now swims or
			 * false if the entity stops swimming.
			 */
			isSwimming(): boolean;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityToggleSwimEvent {
			constructor(who: org.bukkit.entity.LivingEntity, isSwimming: boolean);

		}
		namespace EntityToggleSwimEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntityTransformEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Gets the entity that the original entity was transformed to.
			 * This returns the first entity in the transformed entity list.
			 */
			getTransformedEntity(): org.bukkit.entity.Entity;

			/**
			 * Gets the entities that the original entity was transformed to.
			 */
			getTransformedEntities(): globalThis.java.util.List<org.bukkit.entity.Entity>;

			/**
			 * Gets the reason for the conversion that has occurred.
			 */
			getTransformReason(): org.bukkit.event.entity.EntityTransformEvent.TransformReason;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityTransformEvent {
			constructor(original: org.bukkit.entity.Entity, convertedList: globalThis.java.util.List<org.bukkit.entity.Entity>, transformReason: org.bukkit.event.entity.EntityTransformEvent.TransformReason);

		}
		namespace EntityTransformEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace EntityTransformEvent {
			interface TransformReason {}
			namespace TransformReason {
				/**
				 * When a zombie gets cured and a villager is spawned.
				 */
				const CURED: org.bukkit.event.entity.EntityTransformEvent.TransformReason;

				/**
				 * When an entity is shaking in Powder Snow and a new entity spawns.
				 */
				const FROZEN: org.bukkit.event.entity.EntityTransformEvent.TransformReason;

				/**
				 * When a villager gets infected and a zombie villager spawns.
				 */
				const INFECTION: org.bukkit.event.entity.EntityTransformEvent.TransformReason;

				/**
				 * When an entity drowns in water and a new entity spawns.
				 */
				const DROWNED: org.bukkit.event.entity.EntityTransformEvent.TransformReason;

				/**
				 * When a mooshroom (or MUSHROOM_COW) is sheared and a cow spawns.
				 */
				const SHEARED: org.bukkit.event.entity.EntityTransformEvent.TransformReason;

				/**
				 * When lightning strikes a entity.
				 */
				const LIGHTNING: org.bukkit.event.entity.EntityTransformEvent.TransformReason;

				/**
				 * When a slime splits into multiple smaller slimes.
				 */
				const SPLIT: org.bukkit.event.entity.EntityTransformEvent.TransformReason;

				/**
				 * When a piglin converts to a zombified piglin.
				 */
				const PIGLIN_ZOMBIFIED: org.bukkit.event.entity.EntityTransformEvent.TransformReason;

				/**
				 * When a tadpole converts to a frog
				 */
				const METAMORPHOSIS: org.bukkit.event.entity.EntityTransformEvent.TransformReason;

				/**
				 * When reason is unknown.
				 */
				const UNKNOWN: org.bukkit.event.entity.EntityTransformEvent.TransformReason;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.entity.EntityTransformEvent.TransformReason;

			}
		}
		interface EntityUnleashEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Returns the reason for the unleashing.
			 */
			getReason(): org.bukkit.event.entity.EntityUnleashEvent.UnleashReason;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntityUnleashEvent {
			constructor(entity: org.bukkit.entity.Entity, reason: org.bukkit.event.entity.EntityUnleashEvent.UnleashReason);

		}
		namespace EntityUnleashEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace EntityUnleashEvent {
			interface UnleashReason {}
			namespace UnleashReason {
				/**
				 * When the entity's leashholder has died or logged out, and so is
				 * unleashed
				 */
				const HOLDER_GONE: org.bukkit.event.entity.EntityUnleashEvent.UnleashReason;

				/**
				 * When the entity's leashholder attempts to unleash it
				 */
				const PLAYER_UNLEASH: org.bukkit.event.entity.EntityUnleashEvent.UnleashReason;

				/**
				 * When the entity's leashholder is more than 10 blocks away
				 */
				const DISTANCE: org.bukkit.event.entity.EntityUnleashEvent.UnleashReason;

				const UNKNOWN: org.bukkit.event.entity.EntityUnleashEvent.UnleashReason;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.entity.EntityUnleashEvent.UnleashReason;

			}
		}
		interface ExpBottleEvent extends Modify<org.bukkit.event.entity.ProjectileHitEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.ThrownExpBottle;

			/**
			 * This method indicates if the particle effect should be shown.
			 */
			getShowEffect(): boolean;

			/**
			 * This method sets if the particle effect will be shown.
			 * 
			 * This does not change the experience created.
			 */
			setShowEffect(showEffect: boolean): void;

			/**
			 * This method retrieves the amount of experience to be created.
			 * 
			 * The number indicates a total amount to be divided into orbs.
			 */
			getExperience(): number;

			/**
			 * This method sets the amount of experience to be created.
			 * 
			 * The number indicates a total amount to be divided into orbs.
			 */
			setExperience(exp: number): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class ExpBottleEvent {
			constructor(bottle: org.bukkit.entity.ThrownExpBottle, exp: number);

			constructor(bottle: org.bukkit.entity.ThrownExpBottle, hitEntity: (org.bukkit.entity.Entity | null), hitBlock: (org.bukkit.block.Block | null), hitFace: (org.bukkit.block.BlockFace | null), exp: number);

		}
		namespace ExpBottleEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface ExplosionPrimeEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the radius of the explosion
			 */
			getRadius(): number;

			/**
			 * Sets the radius of the explosion
			 */
			setRadius(radius: number): void;

			/**
			 * Gets whether this explosion will create fire or not
			 */
			getFire(): boolean;

			/**
			 * Sets whether this explosion will create fire or not
			 */
			setFire(fire: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class ExplosionPrimeEvent {
			constructor(what: org.bukkit.entity.Entity, radius: number, fire: boolean);

			constructor(explosive: org.bukkit.entity.Explosive);

		}
		namespace ExplosionPrimeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface FireworkExplodeEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Set the cancelled state of this event. If the firework explosion is
			 * cancelled, the firework will still be removed, but no particles will be
			 * displayed.
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.Firework;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class FireworkExplodeEvent {
			constructor(what: org.bukkit.entity.Firework);

		}
		namespace FireworkExplodeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface FoodLevelChangeEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.HumanEntity;

			/**
			 * Gets the item that triggered this event, if any.
			 */
			getItem(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Gets the resultant food level that the entity involved in this event
			 * should be set to.
			 * 
			 * Where 20 is a full food bar and 0 is an empty one.
			 */
			getFoodLevel(): number;

			/**
			 * Sets the resultant food level that the entity involved in this event
			 * should be set to
			 */
			setFoodLevel(level: number): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class FoodLevelChangeEvent {
			constructor(what: org.bukkit.entity.HumanEntity, level: number);

			constructor(what: org.bukkit.entity.HumanEntity, level: number, item: (org.bukkit.inventory.ItemStack | null));

		}
		namespace FoodLevelChangeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface HorseJumpEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.AbstractHorse;

			/**
			 * Gets the power of the jump.
			 * 
			 * Power is a value that defines how much of the horse's jump strength
			 * should be used for the jump. Power is effectively multiplied times
			 * the horse's jump strength to determine how high the jump is; 0
			 * represents no jump strength while 1 represents full jump strength.
			 * Setting power to a value above 1 will use additional jump strength
			 * that the horse does not usually have.
			 * 
			 * Power does not affect how high the horse is capable of jumping, only
			 * how much of its jumping capability will be used in this jump. To set
			 * the horse's overall jump strength, see AbstractHorse.setJumpStrength(double).
			 */
			getPower(): number;

			/**
			 * Sets the power of the jump.
			 * 
			 * Jump power can be set to a value above 1.0 which will increase the
			 * strength of this jump above the horse's actual jump strength.
			 * 
			 * Setting the jump power to 0 will result in the jump animation still
			 * playing, but the horse not leaving the ground. Only canceling this
			 * event will result in no jump animation at all.
			 */
			setPower(power: number): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class HorseJumpEvent {
			constructor(horse: org.bukkit.entity.AbstractHorse, power: number);

		}
		namespace HorseJumpEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface ItemDespawnEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.Item;

			/**
			 * Gets the location at which the item is despawning.
			 */
			getLocation(): org.bukkit.Location;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class ItemDespawnEvent {
			constructor(despawnee: org.bukkit.entity.Item, loc: org.bukkit.Location);

		}
		namespace ItemDespawnEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface ItemMergeEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancelled: boolean): void;

			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.Item;

			/**
			 * Gets the Item entity the main Item is being merged into.
			 */
			getTarget(): org.bukkit.entity.Item;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class ItemMergeEvent {
			constructor(item: org.bukkit.entity.Item, target: org.bukkit.entity.Item);

		}
		namespace ItemMergeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface ItemSpawnEvent extends Modify<org.bukkit.event.entity.EntitySpawnEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.Item;

		}> {}
		class ItemSpawnEvent {
			constructor(spawnee: org.bukkit.entity.Item, loc: org.bukkit.Location);

			constructor(spawnee: org.bukkit.entity.Item);

		}
		interface LingeringPotionSplashEvent extends Modify<org.bukkit.event.entity.ProjectileHitEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.ThrownPotion;

			/**
			 * Gets the AreaEffectCloud spawned
			 */
			getAreaEffectCloud(): org.bukkit.entity.AreaEffectCloud;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from class:Â ProjectileHitEvent
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class LingeringPotionSplashEvent {
			constructor(potion: org.bukkit.entity.ThrownPotion, entity: org.bukkit.entity.AreaEffectCloud);

			constructor(potion: org.bukkit.entity.ThrownPotion, hitEntity: (org.bukkit.entity.Entity | null), hitBlock: (org.bukkit.block.Block | null), hitFace: (org.bukkit.block.BlockFace | null), entity: org.bukkit.entity.AreaEffectCloud);

		}
		namespace LingeringPotionSplashEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PigZapEvent extends Modify<org.bukkit.event.entity.EntityTransformEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.Pig;

			/**
			 * Gets the bolt which is striking the pig.
			 */
			getLightning(): org.bukkit.entity.LightningStrike;

			/**
			 * Gets the zombie pig that will replace the pig, provided the event is
			 * not cancelled first.
			 */
			getPigZombie(): org.bukkit.entity.PigZombie;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PigZapEvent {
			constructor(pig: org.bukkit.entity.Pig, bolt: org.bukkit.entity.LightningStrike, pigzombie: org.bukkit.entity.PigZombie);

		}
		namespace PigZapEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PigZombieAngerEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Gets the entity (if any) which triggered this anger update.
			 */
			getTarget(): (org.bukkit.entity.Entity | null);

			/**
			 * Gets the new anger resulting from this event.
			 */
			getNewAnger(): number;

			/**
			 * Sets the new anger resulting from this event.
			 */
			setNewAnger(newAnger: number): void;

			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.PigZombie;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PigZombieAngerEvent {
			constructor(pigZombie: org.bukkit.entity.PigZombie, target: (org.bukkit.entity.Entity | null), newAnger: number);

		}
		namespace PigZombieAngerEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PiglinBarterEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.Piglin;

			/**
			 * Gets the input of the barter.
			 */
			getInput(): org.bukkit.inventory.ItemStack;

			/**
			 * Returns a mutable list representing the outcome of the barter.
			 */
			getOutcome(): globalThis.java.util.List<org.bukkit.inventory.ItemStack>;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PiglinBarterEvent {
			constructor(what: org.bukkit.entity.Piglin, input: org.bukkit.inventory.ItemStack, outcome: globalThis.java.util.List<org.bukkit.inventory.ItemStack>);

		}
		namespace PiglinBarterEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerDeathEvent extends Modify<org.bukkit.event.entity.EntityDeathEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.Player;

			/**
			 * Set the death message that will appear to everyone on the server.
			 */
			setDeathMessage(deathMessage: (string | null)): void;

			/**
			 * Get the death message that will appear to everyone on the server.
			 */
			getDeathMessage(): (string | null);

			/**
			 * Gets how much EXP the Player should have at respawn.
			 * 
			 * This does not indicate how much EXP should be dropped, please see
			 * EntityDeathEvent.getDroppedExp() for that.
			 */
			getNewExp(): number;

			/**
			 * Sets how much EXP the Player should have at respawn.
			 * 
			 * This does not indicate how much EXP should be dropped, please see
			 * EntityDeathEvent.setDroppedExp(int) for that.
			 */
			setNewExp(exp: number): void;

			/**
			 * Gets the Level the Player should have at respawn.
			 */
			getNewLevel(): number;

			/**
			 * Sets the Level the Player should have at respawn.
			 */
			setNewLevel(level: number): void;

			/**
			 * Gets the Total EXP the Player should have at respawn.
			 */
			getNewTotalExp(): number;

			/**
			 * Sets the Total EXP the Player should have at respawn.
			 */
			setNewTotalExp(totalExp: number): void;

			/**
			 * Gets if the Player should keep all EXP at respawn.
			 * 
			 * This flag overrides other EXP settings
			 */
			getKeepLevel(): boolean;

			/**
			 * Sets if the Player should keep all EXP at respawn.
			 * 
			 * This overrides all other EXP settings
			 * 
			 * This doesn't prevent the EXP from dropping.
			 * EntityDeathEvent.setDroppedExp(int) should be used stop the
			 * EXP from dropping.
			 */
			setKeepLevel(keepLevel: boolean): void;

			/**
			 * Sets if the Player keeps inventory on death.
			 * 
			 * This doesn't prevent the items from dropping.
			 * getDrops().clear() should be used stop the
			 * items from dropping.
			 */
			setKeepInventory(keepInventory: boolean): void;

			/**
			 * Gets if the Player keeps inventory on death.
			 */
			getKeepInventory(): boolean;

		}> {}
		class PlayerDeathEvent {
			constructor(player: org.bukkit.entity.Player, damageSource: org.bukkit.damage.DamageSource, drops: globalThis.java.util.List<org.bukkit.inventory.ItemStack>, droppedExp: number, deathMessage: (string | null));

			constructor(player: org.bukkit.entity.Player, damageSource: org.bukkit.damage.DamageSource, drops: globalThis.java.util.List<org.bukkit.inventory.ItemStack>, droppedExp: number, newExp: number, deathMessage: (string | null));

			constructor(player: org.bukkit.entity.Player, damageSource: org.bukkit.damage.DamageSource, drops: globalThis.java.util.List<org.bukkit.inventory.ItemStack>, droppedExp: number, newExp: number, newTotalExp: number, newLevel: number, deathMessage: (string | null));

		}
		interface PlayerLeashEntityEvent extends Modify<org.bukkit.event.Event, {
			/**
			 * Returns the entity that is holding the leash.
			 */
			getLeashHolder(): org.bukkit.entity.Entity;

			/**
			 * Returns the entity being leashed.
			 */
			getEntity(): org.bukkit.entity.Entity;

			/**
			 * Returns the player involved in this event
			 */
			getPlayer(): org.bukkit.entity.Player;

			/**
			 * Returns the hand used by the player to leash the entity.
			 */
			getHand(): org.bukkit.inventory.EquipmentSlot;

			getHandlers(): org.bukkit.event.HandlerList;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

		}> {}
		class PlayerLeashEntityEvent {
			constructor(what: org.bukkit.entity.Entity, leashHolder: org.bukkit.entity.Entity, leasher: org.bukkit.entity.Player, hand: org.bukkit.inventory.EquipmentSlot);

			constructor(what: org.bukkit.entity.Entity, leashHolder: org.bukkit.entity.Entity, leasher: org.bukkit.entity.Player);

		}
		namespace PlayerLeashEntityEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PotionSplashEvent extends Modify<org.bukkit.event.entity.ProjectileHitEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.ThrownPotion;

			/**
			 * Gets the potion which caused this event
			 */
			getPotion(): org.bukkit.entity.ThrownPotion;

			/**
			 * Retrieves a list of all effected entities
			 */
			getAffectedEntities(): globalThis.java.util.Collection<org.bukkit.entity.LivingEntity>;

			/**
			 * Gets the intensity of the potion's effects for given entity; This
			 * depends on the distance to the impact center
			 */
			getIntensity(entity: org.bukkit.entity.LivingEntity): number;

			/**
			 * Overwrites the intensity for a given entity
			 */
			setIntensity(entity: org.bukkit.entity.LivingEntity, intensity: number): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from class:Â ProjectileHitEvent
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PotionSplashEvent {
			constructor(potion: org.bukkit.entity.ThrownPotion, affectedEntities: globalThis.java.util.Map<org.bukkit.entity.LivingEntity, number>);

			constructor(potion: org.bukkit.entity.ThrownPotion, hitEntity: (org.bukkit.entity.Entity | null), hitBlock: (org.bukkit.block.Block | null), hitFace: (org.bukkit.block.BlockFace | null), affectedEntities: globalThis.java.util.Map<org.bukkit.entity.LivingEntity, number>);

		}
		namespace PotionSplashEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface ProjectileHitEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.Projectile;

			/**
			 * Gets the block that was hit, if it was a block that was hit.
			 */
			getHitBlock(): (org.bukkit.block.Block | null);

			/**
			 * Gets the block face that was hit, if it was a block that was hit and the
			 * face was provided in the event.
			 */
			getHitBlockFace(): (org.bukkit.block.BlockFace | null);

			/**
			 * Gets the entity that was hit, if it was an entity that was hit.
			 */
			getHitEntity(): (org.bukkit.entity.Entity | null);

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Whether to cancel the action that occurs when the projectile hits.
			 * In the case of an entity, it will not collide (unless it's a firework,
			 * then use FireworkExplodeEvent).
			 * 
			 * In the case of a block, some blocks (eg target block, bell) will not
			 * perform the action associated.
			 * 
			 * This does NOT prevent block collisions, and explosions will still occur
			 * unless their respective events are cancelled.
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class ProjectileHitEvent {
			constructor(projectile: org.bukkit.entity.Projectile);

			constructor(projectile: org.bukkit.entity.Projectile, hitEntity: (org.bukkit.entity.Entity | null));

			constructor(projectile: org.bukkit.entity.Projectile, hitBlock: (org.bukkit.block.Block | null));

			constructor(projectile: org.bukkit.entity.Projectile, hitEntity: (org.bukkit.entity.Entity | null), hitBlock: (org.bukkit.block.Block | null));

			constructor(projectile: org.bukkit.entity.Projectile, hitEntity: (org.bukkit.entity.Entity | null), hitBlock: (org.bukkit.block.Block | null), hitFace: (org.bukkit.block.BlockFace | null));

		}
		namespace ProjectileHitEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface ProjectileLaunchEvent extends Modify<org.bukkit.event.entity.EntitySpawnEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.Projectile;

		}> {}
		class ProjectileLaunchEvent {
			constructor(what: org.bukkit.entity.Entity);

		}
		interface SheepDyeWoolEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.Sheep;

			/**
			 * Returns the player dyeing the sheep, if available.
			 */
			getPlayer(): (org.bukkit.entity.Player | null);

			/**
			 * Gets the DyeColor the sheep is being dyed
			 */
			getColor(): org.bukkit.DyeColor;

			/**
			 * Sets the DyeColor the sheep is being dyed
			 */
			setColor(color: org.bukkit.DyeColor): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class SheepDyeWoolEvent {
			constructor(sheep: org.bukkit.entity.Sheep, color: org.bukkit.DyeColor);

			constructor(sheep: org.bukkit.entity.Sheep, color: org.bukkit.DyeColor, player: (org.bukkit.entity.Player | null));

		}
		namespace SheepDyeWoolEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface SheepRegrowWoolEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.Sheep;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class SheepRegrowWoolEvent {
			constructor(sheep: org.bukkit.entity.Sheep);

		}
		namespace SheepRegrowWoolEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface SlimeSplitEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.Slime;

			/**
			 * Gets the amount of smaller slimes to spawn
			 */
			getCount(): number;

			/**
			 * Sets how many smaller slimes will spawn on the split
			 */
			setCount(count: number): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class SlimeSplitEvent {
			constructor(slime: org.bukkit.entity.Slime, count: number);

		}
		namespace SlimeSplitEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface SpawnerSpawnEvent extends Modify<org.bukkit.event.entity.EntitySpawnEvent, {
			getSpawner(): org.bukkit.block.CreatureSpawner;

		}> {}
		class SpawnerSpawnEvent {
			constructor(spawnee: org.bukkit.entity.Entity, spawner: org.bukkit.block.CreatureSpawner);

		}
		interface StriderTemperatureChangeEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.Strider;

			/**
			 * Get the Strider's new shivering state.
			 */
			isShivering(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancelled: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class StriderTemperatureChangeEvent {
			constructor(what: org.bukkit.entity.Strider, shivering: boolean);

		}
		namespace StriderTemperatureChangeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface VillagerAcquireTradeEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Get the recipe to be acquired.
			 */
			getRecipe(): org.bukkit.inventory.MerchantRecipe;

			/**
			 * Set the recipe to be acquired.
			 */
			setRecipe(recipe: org.bukkit.inventory.MerchantRecipe): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.AbstractVillager;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class VillagerAcquireTradeEvent {
			constructor(what: org.bukkit.entity.AbstractVillager, recipe: org.bukkit.inventory.MerchantRecipe);

		}
		namespace VillagerAcquireTradeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface VillagerCareerChangeEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.Villager;

			/**
			 * Gets the future profession of the villager.
			 */
			getProfession(): org.bukkit.entity.Villager.Profession;

			/**
			 * Sets the profession the villager will become from this event.
			 */
			setProfession(profession: org.bukkit.entity.Villager.Profession): void;

			/**
			 * Gets the reason for why the villager's career is changing.
			 */
			getReason(): org.bukkit.event.entity.VillagerCareerChangeEvent.ChangeReason;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class VillagerCareerChangeEvent {
			constructor(what: org.bukkit.entity.Villager, profession: org.bukkit.entity.Villager.Profession, reason: org.bukkit.event.entity.VillagerCareerChangeEvent.ChangeReason);

		}
		namespace VillagerCareerChangeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace VillagerCareerChangeEvent {
			interface ChangeReason {}
			namespace ChangeReason {
				/**
				 * Villager lost their job due to too little experience.
				 */
				const LOSING_JOB: org.bukkit.event.entity.VillagerCareerChangeEvent.ChangeReason;

				/**
				 * Villager gained employment.
				 */
				const EMPLOYED: org.bukkit.event.entity.VillagerCareerChangeEvent.ChangeReason;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.entity.VillagerCareerChangeEvent.ChangeReason;

			}
		}
		interface VillagerReplenishTradeEvent extends Modify<org.bukkit.event.entity.EntityEvent, {
			/**
			 * Get the recipe to replenish.
			 */
			getRecipe(): org.bukkit.inventory.MerchantRecipe;

			/**
			 * Set the recipe to replenish.
			 */
			setRecipe(recipe: org.bukkit.inventory.MerchantRecipe): void;

			/**
			 * Get the bonus uses added.
			 */
			getBonus(): number;

			/**
			 * Set the bonus uses added.
			 */
			setBonus(bonus: number): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Description copied from class:Â EntityEvent
			 */
			getEntity(): org.bukkit.entity.AbstractVillager;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class VillagerReplenishTradeEvent {
			constructor(what: org.bukkit.entity.AbstractVillager, recipe: org.bukkit.inventory.MerchantRecipe);

		}
		namespace VillagerReplenishTradeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
	}
	namespace org.bukkit.advancement {
		interface Advancement extends Modify<org.bukkit.Keyed, {
			/**
			 * Get all the criteria present in this advancement.
			 */
			getCriteria(): globalThis.java.util.Collection<string>;

			/**
			 * Returns the display information for this advancement.
			 * This includes it's name, description and other visible tags.
			 */
			getDisplay(): (org.bukkit.advancement.AdvancementDisplay | null);

		}> {}
		interface AdvancementDisplay {
			/**
			 * Gets the title of the advancement.
			 */
			getTitle(): string;

			/**
			 * Gets the visible description of the advancement.
			 */
			getDescription(): string;

			/**
			 * The icon that is used for this advancement.
			 */
			getIcon(): org.bukkit.inventory.ItemStack;

			/**
			 * Whether to show a toast to the player when this advancement has been
			 * completed.
			 */
			shouldShowToast(): boolean;

			/**
			 * Whether to announce in the chat when this advancement has been completed.
			 */
			shouldAnnounceChat(): boolean;

			/**
			 * Whether to hide this advancement and all its children from the
			 * advancement screen until this advancement have been completed.
			 * Has no effect on root advancements themselves, but still affects all
			 * their children.
			 */
			isHidden(): boolean;

			/**
			 * The X position of the advancement in the advancement screen.
			 */
			getX(): number;

			/**
			 * The Y position of the advancement in the advancement screen.
			 */
			getY(): number;

			/**
			 * The display type of this advancement.
			 */
			getType(): org.bukkit.advancement.AdvancementDisplayType;

		}
		interface AdvancementDisplayType {
			/**
			 * The chat color used by Minecraft for this advancement.
			 */
			getColor(): org.bukkit.ChatColor;

		}
		namespace AdvancementDisplayType {
			/**
			 * Task or normal icons have a square icon frame.
			 */
			const TASK: org.bukkit.advancement.AdvancementDisplayType;

			/**
			 * Challenge icons have a stylised icon frame.
			 */
			const CHALLENGE: org.bukkit.advancement.AdvancementDisplayType;

			/**
			 * Goal icons have a rounded icon frame.
			 */
			const GOAL: org.bukkit.advancement.AdvancementDisplayType;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.advancement.AdvancementDisplayType;

		}
		interface AdvancementProgress {
			/**
			 * The advancement this progress is concerning.
			 */
			getAdvancement(): org.bukkit.advancement.Advancement;

			/**
			 * Check if all criteria for this advancement have been met.
			 */
			isDone(): boolean;

			/**
			 * Mark the specified criteria as awarded at the current time.
			 */
			awardCriteria(criteria: string): boolean;

			/**
			 * Mark the specified criteria as uncompleted.
			 */
			revokeCriteria(criteria: string): boolean;

			/**
			 * Get the date the specified criteria was awarded.
			 */
			getDateAwarded(criteria: string): (globalThis.java.util.Date | null);

			/**
			 * Get the criteria which have not been awarded.
			 */
			getRemainingCriteria(): globalThis.java.util.Collection<string>;

			/**
			 * Gets the criteria which have been awarded.
			 */
			getAwardedCriteria(): globalThis.java.util.Collection<string>;

		}
	}
	namespace org.bukkit.block.data {
		interface Ageable extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'age' property.
			 */
			getAge(): number;

			/**
			 * Sets the value of the 'age' property.
			 */
			setAge(age: number): void;

			/**
			 * Gets the maximum allowed value of the 'age' property.
			 */
			getMaximumAge(): number;

		}> {}
		interface AnaloguePowerable extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'power' property.
			 */
			getPower(): number;

			/**
			 * Sets the value of the 'power' property.
			 */
			setPower(power: number): void;

			/**
			 * Gets the maximum allowed value of the 'power' property.
			 */
			getMaximumPower(): number;

		}> {}
		interface Attachable extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'attached' property.
			 */
			isAttached(): boolean;

			/**
			 * Sets the value of the 'attached' property.
			 */
			setAttached(attached: boolean): void;

		}> {}
		interface Bisected extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'half' property.
			 */
			getHalf(): org.bukkit.block.data.Bisected.Half;

			/**
			 * Sets the value of the 'half' property.
			 */
			setHalf(half: org.bukkit.block.data.Bisected.Half): void;

		}> {}
		namespace Bisected {
			interface Half {}
			namespace Half {
				/**
				 * The top half of the block, normally with the higher y coordinate.
				 */
				const TOP: org.bukkit.block.data.Bisected.Half;

				/**
				 * The bottom half of the block, normally with the lower y coordinate.
				 */
				const BOTTOM: org.bukkit.block.data.Bisected.Half;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.Bisected.Half;

			}
		}
		interface BlockData {
			/**
			 * Get the Material represented by this block data.
			 */
			getMaterial(): org.bukkit.Material;

			/**
			 * Gets a string, which when passed into a method such as
			 * Server.createBlockData(java.lang.String) will unambiguously
			 * recreate this instance.
			 */
			getAsString(): string;

			/**
			 * Gets a string, which when passed into a method such as
			 * Server.createBlockData(java.lang.String) will recreate this or a
			 * similar instance where unspecified states (if any) may be optionally
			 * omitted. If this instance was parsed and states are omitted, this exact
			 * instance will be creatable when parsed again, else their equality cannot
			 * be guaranteed.
			 * 
			 * This method will only take effect for BlockData instances created by
			 * methods such as Server.createBlockData(String) or any similar
			 * method whereby states are optionally defined. If otherwise, the result of
			 * getAsString() will be returned. The following behaviour would be
			 * expected:
			 * 
			 * String dataString = "minecraft:chest[waterlogged=true]"
			 * BlockData data = Bukkit.createBlockData(dataString);
			 * dataString.equals(data.getAsString(true)); // This would return true
			 * dataString.equals(data.getAsString(false)); // This would return false as all states are present
			 * dataString.equals(data.getAsString()); // This is equivalent to the above, "getAsString(false)"
			 * 
			 */
			getAsString(hideUnspecified: boolean): string;

			/**
			 * Merges all explicitly set states from the given data with this BlockData.
			 * 
			 * Note that the given data MUST have been created from one of the String
			 * parse methods, e.g. Server.createBlockData(java.lang.String) and
			 * not have been subsequently modified.
			 * 
			 * Note also that the block types must match identically.
			 */
			merge(data: org.bukkit.block.data.BlockData): org.bukkit.block.data.BlockData;

			/**
			 * Checks if the specified BlockData matches this block data.
			 * 
			 * The semantics of this method are such that for manually created or
			 * modified BlockData it has the same effect as
			 * Object.equals(java.lang.Object), whilst for parsed data (that to
			 * which merge(org.bukkit.block.data.BlockData) applies, it will
			 * return true when the type and all explicitly set states match.
			 * 
			 * Note that these semantics mean that a.matches(b) may not be the same
			 * as b.matches(a)
			 */
			matches(data: (org.bukkit.block.data.BlockData | null)): boolean;

			/**
			 * Returns a copy of this BlockData.
			 */
			clone(): org.bukkit.block.data.BlockData;

			/**
			 * Gets the block's SoundGroup which can be used to get its step
			 * sound, hit sound, and others.
			 */
			getSoundGroup(): org.bukkit.SoundGroup;

			/**
			 * Get the amount of light emitted by this state when in the world.
			 */
			getLightEmission(): number;

			/**
			 * Check whether or not this state will occlude other blocks.
			 * 
			 * Block state occlusion affects visual features of other blocks (e.g. leaves and
			 * wet sponges will not spawn dripping water particles if an occluding state is
			 * below it), or whether light will pass through it.
			 */
			isOccluding(): boolean;

			/**
			 * Check whether or not this state requires a specific item to be used to drop
			 * items when broken. For example, diamond ore requires an iron pickaxe and will
			 * not drop diamonds when broken with a wooden or stone pickaxe.
			 */
			requiresCorrectToolForDrops(): boolean;

			/**
			 * Returns if the given item is a preferred choice to break this Block.
			 * In some cases this determines if a block will drop anything or extra
			 * loot.
			 */
			isPreferredTool(tool: org.bukkit.inventory.ItemStack): boolean;

			/**
			 * Returns the reaction of the block when moved by a piston
			 */
			getPistonMoveReaction(): org.bukkit.block.PistonMoveReaction;

			/**
			 * Checks if this state would be properly supported if it were placed at
			 * the given Block.
			 * 
			 * This may be useful, for instance, to check whether or not a wall torch is
			 * capable of surviving on its neighbouring block states.
			 */
			isSupported(block: org.bukkit.block.Block): boolean;

			/**
			 * Checks if this state would be properly supported if it were placed at
			 * the block at the given Location.
			 * 
			 * This may be useful, for instance, to check whether or not a wall torch is
			 * capable of surviving on its neighbouring block states.
			 */
			isSupported(location: org.bukkit.Location): boolean;

			/**
			 * Checks if a state's BlockFace is capable of providing a given level
			 * of BlockSupport for neighbouring block states.
			 * 
			 * Any given state may support either none, one, or more than one level of block
			 * support depending on its states. A common example would be a wall's ability to support
			 * torches only on the center of the upper block face, whereas a grass block would
			 * support all levels of block support on all block faces.
			 */
			isFaceSturdy(face: org.bukkit.block.BlockFace, support: org.bukkit.block.BlockSupport): boolean;

			/**
			 * Gets the color this block should appear as when rendered on a map.
			 */
			getMapColor(): org.bukkit.Color;

			/**
			 * Gets the material that a player would use to place this block.
			 * 
			 * For most blocks this is the same as getMaterial() but some blocks
			 * have different materials used to place them.
			 * For example:
			 * Material.REDSTONE_WIRE -> Material.REDSTONE
			 * Material.CARROTS -> Material.CARROT
			 * 
			 */
			getPlacementMaterial(): org.bukkit.Material;

			/**
			 * Rotates this blockdata by the specified StructureRotation.
			 * 
			 * This has no effect on blocks that do not have any rotatable states.
			 */
			rotate(rotation: org.bukkit.block.structure.StructureRotation): void;

			/**
			 * Mirrors this blockdata using the specified Mirror.
			 * 
			 * This has no effect on blocks that do not have any mirrorable states.
			 */
			mirror(mirror: org.bukkit.block.structure.Mirror): void;

			/**
			 * Copies all applicable properties from this BlockData to the provided
			 * BlockData.
			 * 
			 * Only modifies properties that both blocks share in common.
			 */
			copyTo(other: org.bukkit.block.data.BlockData): void;

			/**
			 * Creates a new default BlockState for this type of Block, not
			 * bound to a location.
			 */
			createBlockState(): org.bukkit.block.BlockState;

		}
		interface Brushable extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'dusted' property.
			 */
			getDusted(): number;

			/**
			 * Sets the value of the 'dusted' property.
			 */
			setDusted(dusted: number): void;

			/**
			 * Gets the maximum allowed value of the 'dusted' property.
			 */
			getMaximumDusted(): number;

		}> {}
		interface Directional extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'facing' property.
			 */
			getFacing(): org.bukkit.block.BlockFace;

			/**
			 * Sets the value of the 'facing' property.
			 */
			setFacing(facing: org.bukkit.block.BlockFace): void;

			/**
			 * Gets the faces which are applicable to this block.
			 */
			getFaces(): globalThis.java.util.Set<org.bukkit.block.BlockFace>;

		}> {}
		interface FaceAttachable extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'face' property.
			 */
			getAttachedFace(): org.bukkit.block.data.FaceAttachable.AttachedFace;

			/**
			 * Sets the value of the 'face' property.
			 */
			setAttachedFace(face: org.bukkit.block.data.FaceAttachable.AttachedFace): void;

		}> {}
		namespace FaceAttachable {
			interface AttachedFace {}
			namespace AttachedFace {
				/**
				 * The switch is mounted to the floor and pointing upwards.
				 */
				const FLOOR: org.bukkit.block.data.FaceAttachable.AttachedFace;

				/**
				 * The switch is mounted to the wall.
				 */
				const WALL: org.bukkit.block.data.FaceAttachable.AttachedFace;

				/**
				 * The switch is mounted to the ceiling and pointing dowanrds.
				 */
				const CEILING: org.bukkit.block.data.FaceAttachable.AttachedFace;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.FaceAttachable.AttachedFace;

			}
		}
		interface Hangable extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'hanging' property.
			 */
			isHanging(): boolean;

			/**
			 * Sets the value of the 'hanging' property.
			 */
			setHanging(hanging: boolean): void;

		}> {}
		interface Hatchable extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'hatch' property.
			 */
			getHatch(): number;

			/**
			 * Sets the value of the 'hatch' property.
			 */
			setHatch(hatch: number): void;

			/**
			 * Gets the maximum allowed value of the 'hatch' property.
			 */
			getMaximumHatch(): number;

		}> {}
		interface Levelled extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'level' property.
			 */
			getLevel(): number;

			/**
			 * Sets the value of the 'level' property.
			 */
			setLevel(level: number): void;

			/**
			 * Gets the maximum allowed value of the 'level' property.
			 */
			getMaximumLevel(): number;

		}> {}
		interface Lightable extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'lit' property.
			 */
			isLit(): boolean;

			/**
			 * Sets the value of the 'lit' property.
			 */
			setLit(lit: boolean): void;

		}> {}
		interface MultipleFacing extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Checks if this block has the specified face enabled.
			 */
			hasFace(face: org.bukkit.block.BlockFace): boolean;

			/**
			 * Set whether this block has the specified face enabled.
			 */
			setFace(face: org.bukkit.block.BlockFace, has: boolean): void;

			/**
			 * Get all of the faces which are enabled on this block.
			 */
			getFaces(): globalThis.java.util.Set<org.bukkit.block.BlockFace>;

			/**
			 * Gets all of this faces which may be set on this block.
			 */
			getAllowedFaces(): globalThis.java.util.Set<org.bukkit.block.BlockFace>;

		}> {}
		interface Openable extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'open' property.
			 */
			isOpen(): boolean;

			/**
			 * Sets the value of the 'open' property.
			 */
			setOpen(open: boolean): void;

		}> {}
		interface Orientable extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'axis' property.
			 */
			getAxis(): org.bukkit.Axis;

			/**
			 * Sets the value of the 'axis' property.
			 */
			setAxis(axis: org.bukkit.Axis): void;

			/**
			 * Gets the axes which are applicable to this block.
			 */
			getAxes(): globalThis.java.util.Set<org.bukkit.Axis>;

		}> {}
		interface Powerable extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'powered' property.
			 */
			isPowered(): boolean;

			/**
			 * Sets the value of the 'powered' property.
			 */
			setPowered(powered: boolean): void;

		}> {}
		interface Rail extends Modify<org.bukkit.block.data.Waterlogged, {
			/**
			 * Gets the value of the 'shape' property.
			 */
			getShape(): org.bukkit.block.data.Rail.Shape;

			/**
			 * Sets the value of the 'shape' property.
			 */
			setShape(shape: org.bukkit.block.data.Rail.Shape): void;

			/**
			 * Gets the shapes which are applicable to this block.
			 */
			getShapes(): globalThis.java.util.Set<org.bukkit.block.data.Rail.Shape>;

		}> {}
		namespace Rail {
			interface Shape {}
			namespace Shape {
				/**
				 * The rail runs flat along the north/south (Z) axis.
				 */
				const NORTH_SOUTH: org.bukkit.block.data.Rail.Shape;

				/**
				 * The rail runs flat along the east/west (X) axis.
				 */
				const EAST_WEST: org.bukkit.block.data.Rail.Shape;

				/**
				 * The rail ascends in the east (positive X) direction.
				 */
				const ASCENDING_EAST: org.bukkit.block.data.Rail.Shape;

				/**
				 * The rail ascends in the west (negative X) direction.
				 */
				const ASCENDING_WEST: org.bukkit.block.data.Rail.Shape;

				/**
				 * The rail ascends in the north (negative Z) direction.
				 */
				const ASCENDING_NORTH: org.bukkit.block.data.Rail.Shape;

				/**
				 * The rail ascends in the south (positive Z) direction.
				 */
				const ASCENDING_SOUTH: org.bukkit.block.data.Rail.Shape;

				/**
				 * The rail forms a curve connecting the south and east faces of the
				 * block.
				 */
				const SOUTH_EAST: org.bukkit.block.data.Rail.Shape;

				/**
				 * The rail forms a curve connecting the south and west faces of the
				 * block.
				 */
				const SOUTH_WEST: org.bukkit.block.data.Rail.Shape;

				/**
				 * The rail forms a curve connecting the north and west faces of the
				 * block.
				 */
				const NORTH_WEST: org.bukkit.block.data.Rail.Shape;

				/**
				 * The rail forms a curve connecting the north and east faces of the
				 * block.
				 */
				const NORTH_EAST: org.bukkit.block.data.Rail.Shape;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.Rail.Shape;

			}
		}
		interface Rotatable extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'rotation' property.
			 */
			getRotation(): org.bukkit.block.BlockFace;

			/**
			 * Sets the value of the 'rotation' property.
			 */
			setRotation(rotation: org.bukkit.block.BlockFace): void;

		}> {}
		interface Snowable extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'snowy' property.
			 */
			isSnowy(): boolean;

			/**
			 * Sets the value of the 'snowy' property.
			 */
			setSnowy(snowy: boolean): void;

		}> {}
		interface Waterlogged extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'waterlogged' property.
			 */
			isWaterlogged(): boolean;

			/**
			 * Sets the value of the 'waterlogged' property.
			 */
			setWaterlogged(waterlogged: boolean): void;

		}> {}
	}
	namespace org.bukkit.block.data.type {
		interface AmethystCluster extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.Waterlogged, {}> {}
		interface Bamboo extends Modify<org.bukkit.block.data.Ageable & org.bukkit.block.data.type.Sapling, {
			/**
			 * Gets the value of the 'leaves' property.
			 */
			getLeaves(): org.bukkit.block.data.type.Bamboo.Leaves;

			/**
			 * Sets the value of the 'leaves' property.
			 */
			setLeaves(leaves: org.bukkit.block.data.type.Bamboo.Leaves): void;

		}> {}
		namespace Bamboo {
			interface Leaves {}
			namespace Leaves {
				/**
				 * No leaves.
				 */
				const NONE: org.bukkit.block.data.type.Bamboo.Leaves;

				/**
				 * Small leaves.
				 */
				const SMALL: org.bukkit.block.data.type.Bamboo.Leaves;

				/**
				 * Large leaves.
				 */
				const LARGE: org.bukkit.block.data.type.Bamboo.Leaves;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.type.Bamboo.Leaves;

			}
		}
		interface Barrel extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.Openable, {}> {}
		interface Bed extends Modify<org.bukkit.block.data.Directional, {
			/**
			 * Gets the value of the 'part' property.
			 */
			getPart(): org.bukkit.block.data.type.Bed.Part;

			/**
			 * Sets the value of the 'part' property.
			 */
			setPart(part: org.bukkit.block.data.type.Bed.Part): void;

			/**
			 * Gets the value of the 'occupied' property.
			 */
			isOccupied(): boolean;

		}> {}
		namespace Bed {
			interface Part {}
			namespace Part {
				/**
				 * The head is the upper part of the bed containing the pillow.
				 */
				const HEAD: org.bukkit.block.data.type.Bed.Part;

				/**
				 * The foot is the lower half of the bed.
				 */
				const FOOT: org.bukkit.block.data.type.Bed.Part;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.type.Bed.Part;

			}
		}
		interface Beehive extends Modify<org.bukkit.block.data.Directional, {
			/**
			 * Gets the value of the 'honey_level' property.
			 */
			getHoneyLevel(): number;

			/**
			 * Sets the value of the 'honey_level' property.
			 */
			setHoneyLevel(honeyLevel: number): void;

			/**
			 * Gets the maximum allowed value of the 'honey_level' property.
			 */
			getMaximumHoneyLevel(): number;

		}> {}
		interface Bell extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.Powerable, {
			/**
			 * Gets the value of the 'attachment' property.
			 */
			getAttachment(): org.bukkit.block.data.type.Bell.Attachment;

			/**
			 * Sets the value of the 'attachment' property.
			 */
			setAttachment(attachment: org.bukkit.block.data.type.Bell.Attachment): void;

		}> {}
		namespace Bell {
			interface Attachment {}
			namespace Attachment {
				/**
				 * Placed on floor.
				 */
				const FLOOR: org.bukkit.block.data.type.Bell.Attachment;

				/**
				 * Placed on ceiling.
				 */
				const CEILING: org.bukkit.block.data.type.Bell.Attachment;

				/**
				 * Placed on one wall.
				 */
				const SINGLE_WALL: org.bukkit.block.data.type.Bell.Attachment;

				/**
				 * Placed between two walls.
				 */
				const DOUBLE_WALL: org.bukkit.block.data.type.Bell.Attachment;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.type.Bell.Attachment;

			}
		}
		interface BigDripleaf extends Modify<org.bukkit.block.data.type.Dripleaf, {
			/**
			 * Gets the value of the 'tilt' property.
			 */
			getTilt(): org.bukkit.block.data.type.BigDripleaf.Tilt;

			/**
			 * Sets the value of the 'tilt' property.
			 */
			setTilt(tilt: org.bukkit.block.data.type.BigDripleaf.Tilt): void;

		}> {}
		namespace BigDripleaf {
			interface Tilt {}
			namespace Tilt {
				/**
				 * No tilt.
				 */
				const NONE: org.bukkit.block.data.type.BigDripleaf.Tilt;

				/**
				 * Unstable tilt.
				 */
				const UNSTABLE: org.bukkit.block.data.type.BigDripleaf.Tilt;

				/**
				 * Partial tilt.
				 */
				const PARTIAL: org.bukkit.block.data.type.BigDripleaf.Tilt;

				/**
				 * Pinball.
				 */
				const FULL: org.bukkit.block.data.type.BigDripleaf.Tilt;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.type.BigDripleaf.Tilt;

			}
		}
		interface BrewingStand extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Checks if the stand has the following bottle
			 */
			hasBottle(bottle: number): boolean;

			/**
			 * Set whether the stand has this bottle present.
			 */
			setBottle(bottle: number, has: boolean): void;

			/**
			 * Get the indexes of all the bottles present on this block.
			 */
			getBottles(): globalThis.java.util.Set<number>;

			/**
			 * Get the maximum amount of bottles present on this stand.
			 */
			getMaximumBottles(): number;

		}> {}
		interface BubbleColumn extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'drag' property.
			 */
			isDrag(): boolean;

			/**
			 * Sets the value of the 'drag' property.
			 */
			setDrag(drag: boolean): void;

		}> {}
		interface Cake extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'bites' property.
			 */
			getBites(): number;

			/**
			 * Sets the value of the 'bites' property.
			 */
			setBites(bites: number): void;

			/**
			 * Gets the maximum allowed value of the 'bites' property.
			 */
			getMaximumBites(): number;

		}> {}
		interface CalibratedSculkSensor extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.type.SculkSensor, {}> {}
		interface Campfire extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.Lightable & org.bukkit.block.data.Waterlogged, {
			/**
			 * Gets the value of the 'signal_fire' property.
			 */
			isSignalFire(): boolean;

			/**
			 * Sets the value of the 'signal_fire' property.
			 */
			setSignalFire(signalFire: boolean): void;

		}> {}
		interface Candle extends Modify<org.bukkit.block.data.Lightable & org.bukkit.block.data.Waterlogged, {
			/**
			 * Gets the value of the 'candles' property.
			 */
			getCandles(): number;

			/**
			 * Sets the value of the 'candles' property.
			 */
			setCandles(candles: number): void;

			/**
			 * Gets the maximum allowed value of the 'candles' property.
			 */
			getMaximumCandles(): number;

		}> {}
		interface CaveVines extends Modify<org.bukkit.block.data.Ageable & org.bukkit.block.data.type.CaveVinesPlant, {}> {}
		interface CaveVinesPlant extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'berries' property.
			 */
			isBerries(): boolean;

			/**
			 * Sets the value of the 'berries' property.
			 */
			setBerries(berries: boolean): void;

		}> {}
		interface Chain extends Modify<org.bukkit.block.data.Orientable & org.bukkit.block.data.Waterlogged, {}> {}
		interface Chest extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.Waterlogged, {
			/**
			 * Gets the value of the 'type' property.
			 */
			getType(): org.bukkit.block.data.type.Chest.Type;

			/**
			 * Sets the value of the 'type' property.
			 */
			setType(type: org.bukkit.block.data.type.Chest.Type): void;

		}> {}
		namespace Chest {
			interface Type {}
			namespace Type {
				/**
				 * The chest is not linked to any others and contains only one 27 slot
				 * inventory.
				 */
				const SINGLE: org.bukkit.block.data.type.Chest.Type;

				/**
				 * The chest is the left hand side of a double chest and shares a 54
				 * block inventory with the chest to its right.
				 */
				const LEFT: org.bukkit.block.data.type.Chest.Type;

				/**
				 * The chest is the right hand side of a double chest and shares a 54
				 * block inventory with the chest to its left.
				 */
				const RIGHT: org.bukkit.block.data.type.Chest.Type;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.type.Chest.Type;

			}
		}
		interface ChiseledBookshelf extends Modify<org.bukkit.block.data.Directional, {
			/**
			 * Checks if the following slot is occupied.
			 */
			isSlotOccupied(slot: number): boolean;

			/**
			 * Sets whether the following slot is occupied.
			 */
			setSlotOccupied(slot: number, occupied: boolean): void;

			/**
			 * Get the indexes of all the occupied slots present on this block.
			 */
			getOccupiedSlots(): globalThis.java.util.Set<number>;

			/**
			 * Get the maximum amount of slots on this block.
			 */
			getMaximumOccupiedSlots(): number;

		}> {}
		interface Cocoa extends Modify<org.bukkit.block.data.Ageable & org.bukkit.block.data.Directional, {}> {}
		interface CommandBlock extends Modify<org.bukkit.block.data.Directional, {
			/**
			 * Gets the value of the 'conditional' property.
			 */
			isConditional(): boolean;

			/**
			 * Sets the value of the 'conditional' property.
			 */
			setConditional(conditional: boolean): void;

		}> {}
		interface Comparator extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.Powerable, {
			/**
			 * Gets the value of the 'mode' property.
			 */
			getMode(): org.bukkit.block.data.type.Comparator.Mode;

			/**
			 * Sets the value of the 'mode' property.
			 */
			setMode(mode: org.bukkit.block.data.type.Comparator.Mode): void;

		}> {}
		namespace Comparator {
			interface Mode {}
			namespace Mode {
				/**
				 * The default mode, similar to a transistor. The comparator will turn
				 * off if either side input is greater than the rear input.
				 */
				const COMPARE: org.bukkit.block.data.type.Comparator.Mode;

				/**
				 * Alternate subtraction mode. The output signal strength will be equal
				 * to max(rear-max(left,right),0).
				 */
				const SUBTRACT: org.bukkit.block.data.type.Comparator.Mode;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.type.Comparator.Mode;

			}
		}
		interface CopperBulb extends Modify<org.bukkit.block.data.Lightable & org.bukkit.block.data.Powerable, {}> {}
		interface CoralWallFan extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.Waterlogged, {}> {}
		interface Crafter extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'crafting' property.
			 */
			isCrafting(): boolean;

			/**
			 * Sets the value of the 'crafting' property.
			 */
			setCrafting(crafting: boolean): void;

			/**
			 * Gets the value of the 'triggered' property.
			 */
			isTriggered(): boolean;

			/**
			 * Sets the value of the 'triggered' property.
			 */
			setTriggered(triggered: boolean): void;

			/**
			 * Gets the value of the 'orientation' property.
			 */
			getOrientation(): org.bukkit.block.data.type.Crafter.Orientation;

			/**
			 * Sets the value of the 'orientation' property.
			 */
			setOrientation(orientation: org.bukkit.block.data.type.Crafter.Orientation): void;

		}> {}
		namespace Crafter {
			interface Orientation {}
			namespace Orientation {
				const DOWN_EAST: org.bukkit.block.data.type.Crafter.Orientation;

				const DOWN_NORTH: org.bukkit.block.data.type.Crafter.Orientation;

				const DOWN_SOUTH: org.bukkit.block.data.type.Crafter.Orientation;

				const DOWN_WEST: org.bukkit.block.data.type.Crafter.Orientation;

				const UP_EAST: org.bukkit.block.data.type.Crafter.Orientation;

				const UP_NORTH: org.bukkit.block.data.type.Crafter.Orientation;

				const UP_SOUTH: org.bukkit.block.data.type.Crafter.Orientation;

				const UP_WEST: org.bukkit.block.data.type.Crafter.Orientation;

				const WEST_UP: org.bukkit.block.data.type.Crafter.Orientation;

				const EAST_UP: org.bukkit.block.data.type.Crafter.Orientation;

				const NORTH_UP: org.bukkit.block.data.type.Crafter.Orientation;

				const SOUTH_UP: org.bukkit.block.data.type.Crafter.Orientation;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.type.Crafter.Orientation;

			}
		}
		interface DaylightDetector extends Modify<org.bukkit.block.data.AnaloguePowerable, {
			/**
			 * Gets the value of the 'inverted' property.
			 */
			isInverted(): boolean;

			/**
			 * Sets the value of the 'inverted' property.
			 */
			setInverted(inverted: boolean): void;

		}> {}
		interface DecoratedPot extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.Waterlogged, {}> {}
		interface Dispenser extends Modify<org.bukkit.block.data.Directional, {
			/**
			 * Gets the value of the 'triggered' property.
			 */
			isTriggered(): boolean;

			/**
			 * Sets the value of the 'triggered' property.
			 */
			setTriggered(triggered: boolean): void;

		}> {}
		interface Door extends Modify<org.bukkit.block.data.Bisected & org.bukkit.block.data.Directional & org.bukkit.block.data.Openable & org.bukkit.block.data.Powerable, {
			/**
			 * Gets the value of the 'hinge' property.
			 */
			getHinge(): org.bukkit.block.data.type.Door.Hinge;

			/**
			 * Sets the value of the 'hinge' property.
			 */
			setHinge(hinge: org.bukkit.block.data.type.Door.Hinge): void;

		}> {}
		namespace Door {
			interface Hinge {}
			namespace Hinge {
				/**
				 * Door is attached to the left side.
				 */
				const LEFT: org.bukkit.block.data.type.Door.Hinge;

				/**
				 * Door is attached to the right side.
				 */
				const RIGHT: org.bukkit.block.data.type.Door.Hinge;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.type.Door.Hinge;

			}
		}
		interface Dripleaf extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.Waterlogged, {}> {}
		interface EndPortalFrame extends Modify<org.bukkit.block.data.Directional, {
			/**
			 * Gets the value of the 'eye' property.
			 */
			hasEye(): boolean;

			/**
			 * Sets the value of the 'eye' property.
			 */
			setEye(eye: boolean): void;

		}> {}
		interface EnderChest extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.Waterlogged, {}> {}
		interface Farmland extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'moisture' property.
			 */
			getMoisture(): number;

			/**
			 * Sets the value of the 'moisture' property.
			 */
			setMoisture(moisture: number): void;

			/**
			 * Gets the maximum allowed value of the 'moisture' property.
			 */
			getMaximumMoisture(): number;

		}> {}
		interface Fence extends Modify<org.bukkit.block.data.MultipleFacing & org.bukkit.block.data.Waterlogged, {}> {}
		interface Fire extends Modify<org.bukkit.block.data.Ageable & org.bukkit.block.data.MultipleFacing, {}> {}
		interface Furnace extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.Lightable, {}> {}
		interface Gate extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.Openable & org.bukkit.block.data.Powerable, {
			/**
			 * Gets the value of the 'in_wall' property.
			 */
			isInWall(): boolean;

			/**
			 * Sets the value of the 'in_wall' property.
			 */
			setInWall(inWall: boolean): void;

		}> {}
		interface GlassPane extends Modify<org.bukkit.block.data.MultipleFacing & org.bukkit.block.data.Waterlogged, {}> {}
		interface GlowLichen extends Modify<org.bukkit.block.data.MultipleFacing & org.bukkit.block.data.Waterlogged, {}> {}
		interface Grindstone extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.FaceAttachable, {}> {}
		interface HangingSign extends Modify<org.bukkit.block.data.Attachable & org.bukkit.block.data.Rotatable & org.bukkit.block.data.Waterlogged, {}> {}
		interface Hopper extends Modify<org.bukkit.block.data.Directional, {
			/**
			 * Gets the value of the 'enabled' property.
			 */
			isEnabled(): boolean;

			/**
			 * Sets the value of the 'enabled' property.
			 */
			setEnabled(enabled: boolean): void;

		}> {}
		interface Jigsaw extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'orientation' property.
			 */
			getOrientation(): org.bukkit.block.data.type.Jigsaw.Orientation;

			/**
			 * Sets the value of the 'orientation' property.
			 */
			setOrientation(orientation: org.bukkit.block.data.type.Jigsaw.Orientation): void;

		}> {}
		namespace Jigsaw {
			interface Orientation {}
			namespace Orientation {
				const DOWN_EAST: org.bukkit.block.data.type.Jigsaw.Orientation;

				const DOWN_NORTH: org.bukkit.block.data.type.Jigsaw.Orientation;

				const DOWN_SOUTH: org.bukkit.block.data.type.Jigsaw.Orientation;

				const DOWN_WEST: org.bukkit.block.data.type.Jigsaw.Orientation;

				const UP_EAST: org.bukkit.block.data.type.Jigsaw.Orientation;

				const UP_NORTH: org.bukkit.block.data.type.Jigsaw.Orientation;

				const UP_SOUTH: org.bukkit.block.data.type.Jigsaw.Orientation;

				const UP_WEST: org.bukkit.block.data.type.Jigsaw.Orientation;

				const WEST_UP: org.bukkit.block.data.type.Jigsaw.Orientation;

				const EAST_UP: org.bukkit.block.data.type.Jigsaw.Orientation;

				const NORTH_UP: org.bukkit.block.data.type.Jigsaw.Orientation;

				const SOUTH_UP: org.bukkit.block.data.type.Jigsaw.Orientation;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.type.Jigsaw.Orientation;

			}
		}
		interface Jukebox extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'has_record' property.
			 */
			hasRecord(): boolean;

		}> {}
		interface Ladder extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.Waterlogged, {}> {}
		interface Lantern extends Modify<org.bukkit.block.data.Hangable & org.bukkit.block.data.Waterlogged, {}> {}
		interface Leaves extends Modify<org.bukkit.block.data.Waterlogged, {
			/**
			 * Gets the value of the 'persistent' property.
			 */
			isPersistent(): boolean;

			/**
			 * Sets the value of the 'persistent' property.
			 */
			setPersistent(persistent: boolean): void;

			/**
			 * Gets the value of the 'distance' property.
			 */
			getDistance(): number;

			/**
			 * Sets the value of the 'distance' property.
			 */
			setDistance(distance: number): void;

		}> {}
		interface Lectern extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.Powerable, {
			/**
			 * Gets the value of the 'has_book' property.
			 */
			hasBook(): boolean;

		}> {}
		interface Light extends Modify<org.bukkit.block.data.Levelled & org.bukkit.block.data.Waterlogged, {}> {}
		interface LightningRod extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.Powerable & org.bukkit.block.data.Waterlogged, {}> {}
		interface MangrovePropagule extends Modify<org.bukkit.block.data.Ageable & org.bukkit.block.data.Hangable & org.bukkit.block.data.type.Sapling & org.bukkit.block.data.Waterlogged, {}> {}
		interface NoteBlock extends Modify<org.bukkit.block.data.Powerable, {
			/**
			 * Gets the value of the 'instrument' property.
			 */
			getInstrument(): org.bukkit.Instrument;

			/**
			 * Sets the value of the 'instrument' property.
			 */
			setInstrument(instrument: org.bukkit.Instrument): void;

			/**
			 * Gets the value of the 'note' property.
			 */
			getNote(): org.bukkit.Note;

			/**
			 * Sets the value of the 'note' property.
			 */
			setNote(note: org.bukkit.Note): void;

		}> {}
		interface Observer extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.Powerable, {}> {}
		interface PinkPetals extends Modify<org.bukkit.block.data.Directional, {
			/**
			 * Gets the value of the 'flower_amount' property.
			 */
			getFlowerAmount(): number;

			/**
			 * Sets the value of the 'flower_amount' property.
			 */
			setFlowerAmount(flower_amount: number): void;

			/**
			 * Gets the maximum allowed value of the 'flower_amount' property.
			 */
			getMaximumFlowerAmount(): number;

		}> {}
		interface Piston extends Modify<org.bukkit.block.data.Directional, {
			/**
			 * Gets the value of the 'extended' property.
			 */
			isExtended(): boolean;

			/**
			 * Sets the value of the 'extended' property.
			 */
			setExtended(extended: boolean): void;

		}> {}
		interface PistonHead extends Modify<org.bukkit.block.data.type.TechnicalPiston, {
			/**
			 * Gets the value of the 'short' property.
			 */
			isShort(): boolean;

			/**
			 * Sets the value of the 'short' property.
			 */
			setShort(_short: boolean): void;

		}> {}
		interface PitcherCrop extends Modify<org.bukkit.block.data.Ageable & org.bukkit.block.data.Bisected, {}> {}
		interface PointedDripstone extends Modify<org.bukkit.block.data.Waterlogged, {
			/**
			 * Gets the value of the 'vertical_direction' property.
			 */
			getVerticalDirection(): org.bukkit.block.BlockFace;

			/**
			 * Sets the value of the 'vertical_direction' property.
			 */
			setVerticalDirection(direction: org.bukkit.block.BlockFace): void;

			/**
			 * Gets the faces which are applicable to this block.
			 */
			getVerticalDirections(): globalThis.java.util.Set<org.bukkit.block.BlockFace>;

			/**
			 * Gets the value of the 'thickness' property.
			 */
			getThickness(): org.bukkit.block.data.type.PointedDripstone.Thickness;

			/**
			 * Sets the value of the 'thickness' property.
			 */
			setThickness(thickness: org.bukkit.block.data.type.PointedDripstone.Thickness): void;

		}> {}
		namespace PointedDripstone {
			interface Thickness {}
			namespace Thickness {
				/**
				 * Extended tip.
				 */
				const TIP_MERGE: org.bukkit.block.data.type.PointedDripstone.Thickness;

				/**
				 * Just the tip.
				 */
				const TIP: org.bukkit.block.data.type.PointedDripstone.Thickness;

				/**
				 * Top section.
				 */
				const FRUSTUM: org.bukkit.block.data.type.PointedDripstone.Thickness;

				/**
				 * Middle section.
				 */
				const MIDDLE: org.bukkit.block.data.type.PointedDripstone.Thickness;

				/**
				 * Base.
				 */
				const BASE: org.bukkit.block.data.type.PointedDripstone.Thickness;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.type.PointedDripstone.Thickness;

			}
		}
		interface RedstoneRail extends Modify<org.bukkit.block.data.Powerable & org.bukkit.block.data.Rail, {}> {}
		interface RedstoneWallTorch extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.Lightable, {}> {}
		interface RedstoneWire extends Modify<org.bukkit.block.data.AnaloguePowerable, {
			/**
			 * Checks the type of connection on the specified face.
			 */
			getFace(face: org.bukkit.block.BlockFace): org.bukkit.block.data.type.RedstoneWire.Connection;

			/**
			 * Sets the type of connection on the specified face.
			 */
			setFace(face: org.bukkit.block.BlockFace, connection: org.bukkit.block.data.type.RedstoneWire.Connection): void;

			/**
			 * Gets all of this faces which may be set on this block.
			 */
			getAllowedFaces(): globalThis.java.util.Set<org.bukkit.block.BlockFace>;

		}> {}
		namespace RedstoneWire {
			interface Connection {}
			namespace Connection {
				/**
				 * The wire travels up the side of the block adjacent to this face.
				 */
				const UP: org.bukkit.block.data.type.RedstoneWire.Connection;

				/**
				 * The wire travels flat from this face and into the adjacent block.
				 */
				const SIDE: org.bukkit.block.data.type.RedstoneWire.Connection;

				/**
				 * The wire does not connect in this direction.
				 */
				const NONE: org.bukkit.block.data.type.RedstoneWire.Connection;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.type.RedstoneWire.Connection;

			}
		}
		interface Repeater extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.Powerable, {
			/**
			 * Gets the value of the 'delay' property.
			 */
			getDelay(): number;

			/**
			 * Sets the value of the 'delay' property.
			 */
			setDelay(delay: number): void;

			/**
			 * Gets the minimum allowed value of the 'delay' property.
			 */
			getMinimumDelay(): number;

			/**
			 * Gets the maximum allowed value of the 'delay' property.
			 */
			getMaximumDelay(): number;

			/**
			 * Gets the value of the 'locked' property.
			 */
			isLocked(): boolean;

			/**
			 * Sets the value of the 'locked' property.
			 */
			setLocked(locked: boolean): void;

		}> {}
		interface RespawnAnchor extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'charges' property.
			 */
			getCharges(): number;

			/**
			 * Sets the value of the 'charges' property.
			 */
			setCharges(charges: number): void;

			/**
			 * Gets the maximum allowed value of the 'charges' property.
			 */
			getMaximumCharges(): number;

		}> {}
		interface Sapling extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'stage' property.
			 */
			getStage(): number;

			/**
			 * Sets the value of the 'stage' property.
			 */
			setStage(stage: number): void;

			/**
			 * Gets the maximum allowed value of the 'stage' property.
			 */
			getMaximumStage(): number;

		}> {}
		interface Scaffolding extends Modify<org.bukkit.block.data.Waterlogged, {
			/**
			 * Gets the value of the 'bottom' property.
			 */
			isBottom(): boolean;

			/**
			 * Sets the value of the 'bottom' property.
			 */
			setBottom(bottom: boolean): void;

			/**
			 * Gets the value of the 'distance' property.
			 */
			getDistance(): number;

			/**
			 * Sets the value of the 'distance' property.
			 */
			setDistance(distance: number): void;

			/**
			 * Gets the maximum allowed value of the 'distance' property.
			 */
			getMaximumDistance(): number;

		}> {}
		interface SculkCatalyst extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'bloom' property.
			 */
			isBloom(): boolean;

			/**
			 * Sets the value of the 'bloom' property.
			 */
			setBloom(bloom: boolean): void;

		}> {}
		interface SculkSensor extends Modify<org.bukkit.block.data.AnaloguePowerable & org.bukkit.block.data.Waterlogged, {
			/**
			 * Gets the value of the 'sculk_sensor_phase' property.
			 */
			getPhase(): org.bukkit.block.data.type.SculkSensor.Phase;

			/**
			 * Sets the value of the 'sculk_sensor_phase' property.
			 */
			setPhase(phase: org.bukkit.block.data.type.SculkSensor.Phase): void;

		}> {}
		namespace SculkSensor {
			interface Phase {}
			namespace Phase {
				/**
				 * The sensor is inactive.
				 */
				const INACTIVE: org.bukkit.block.data.type.SculkSensor.Phase;

				/**
				 * The sensor is active.
				 */
				const ACTIVE: org.bukkit.block.data.type.SculkSensor.Phase;

				/**
				 * The sensor is cooling down.
				 */
				const COOLDOWN: org.bukkit.block.data.type.SculkSensor.Phase;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.type.SculkSensor.Phase;

			}
		}
		interface SculkShrieker extends Modify<org.bukkit.block.data.Waterlogged, {
			/**
			 * Gets the value of the 'can_summon' property.
			 */
			isCanSummon(): boolean;

			/**
			 * Sets the value of the 'can_summon' property.
			 */
			setCanSummon(can_summon: boolean): void;

			/**
			 * Gets the value of the 'shrieking' property.
			 */
			isShrieking(): boolean;

			/**
			 * Sets the value of the 'shrieking' property.
			 */
			setShrieking(shrieking: boolean): void;

		}> {}
		interface SculkVein extends Modify<org.bukkit.block.data.MultipleFacing & org.bukkit.block.data.Waterlogged, {}> {}
		interface SeaPickle extends Modify<org.bukkit.block.data.Waterlogged, {
			/**
			 * Gets the value of the 'pickles' property.
			 */
			getPickles(): number;

			/**
			 * Sets the value of the 'pickles' property.
			 */
			setPickles(pickles: number): void;

			/**
			 * Gets the minimum allowed value of the 'pickles' property.
			 */
			getMinimumPickles(): number;

			/**
			 * Gets the maximum allowed value of the 'pickles' property.
			 */
			getMaximumPickles(): number;

		}> {}
		interface Sign extends Modify<org.bukkit.block.data.Rotatable & org.bukkit.block.data.Waterlogged, {}> {}
		interface Slab extends Modify<org.bukkit.block.data.Waterlogged, {
			/**
			 * Gets the value of the 'type' property.
			 */
			getType(): org.bukkit.block.data.type.Slab.Type;

			/**
			 * Sets the value of the 'type' property.
			 */
			setType(type: org.bukkit.block.data.type.Slab.Type): void;

		}> {}
		namespace Slab {
			interface Type {}
			namespace Type {
				/**
				 * The slab occupies the upper y half of the block.
				 */
				const TOP: org.bukkit.block.data.type.Slab.Type;

				/**
				 * The slab occupies the lower y half of the block.
				 */
				const BOTTOM: org.bukkit.block.data.type.Slab.Type;

				/**
				 * The slab occupies the entire block.
				 */
				const DOUBLE: org.bukkit.block.data.type.Slab.Type;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.type.Slab.Type;

			}
		}
		interface SmallDripleaf extends Modify<org.bukkit.block.data.type.Dripleaf & org.bukkit.block.data.Bisected, {}> {}
		interface Snow extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'layers' property.
			 */
			getLayers(): number;

			/**
			 * Sets the value of the 'layers' property.
			 */
			setLayers(layers: number): void;

			/**
			 * Gets the minimum allowed value of the 'layers' property.
			 */
			getMinimumLayers(): number;

			/**
			 * Gets the maximum allowed value of the 'layers' property.
			 */
			getMaximumLayers(): number;

		}> {}
		interface Stairs extends Modify<org.bukkit.block.data.Bisected & org.bukkit.block.data.Directional & org.bukkit.block.data.Waterlogged, {
			/**
			 * Gets the value of the 'shape' property.
			 */
			getShape(): org.bukkit.block.data.type.Stairs.Shape;

			/**
			 * Sets the value of the 'shape' property.
			 */
			setShape(shape: org.bukkit.block.data.type.Stairs.Shape): void;

		}> {}
		namespace Stairs {
			interface Shape {}
			namespace Shape {
				/**
				 * Regular stair block.
				 */
				const STRAIGHT: org.bukkit.block.data.type.Stairs.Shape;

				/**
				 * Inner corner stair block with higher left side.
				 */
				const INNER_LEFT: org.bukkit.block.data.type.Stairs.Shape;

				/**
				 * Inner corner stair block with higher right side.
				 */
				const INNER_RIGHT: org.bukkit.block.data.type.Stairs.Shape;

				/**
				 * Outer corner stair block with higher left side.
				 */
				const OUTER_LEFT: org.bukkit.block.data.type.Stairs.Shape;

				/**
				 * Outer corner stair block with higher right side.
				 */
				const OUTER_RIGHT: org.bukkit.block.data.type.Stairs.Shape;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.type.Stairs.Shape;

			}
		}
		interface StructureBlock extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'mode' property.
			 */
			getMode(): org.bukkit.block.data.type.StructureBlock.Mode;

			/**
			 * Sets the value of the 'mode' property.
			 */
			setMode(mode: org.bukkit.block.data.type.StructureBlock.Mode): void;

		}> {}
		namespace StructureBlock {
			interface Mode {}
			namespace Mode {
				/**
				 * Allows selection and saving of a structure.
				 */
				const SAVE: org.bukkit.block.data.type.StructureBlock.Mode;

				/**
				 * Allows loading of a structure.
				 */
				const LOAD: org.bukkit.block.data.type.StructureBlock.Mode;

				/**
				 * Used for detection of two opposite corners of a structure.
				 */
				const CORNER: org.bukkit.block.data.type.StructureBlock.Mode;

				/**
				 * Dummy block used to run a custom function during world generation
				 * before being removed.
				 */
				const DATA: org.bukkit.block.data.type.StructureBlock.Mode;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.type.StructureBlock.Mode;

			}
		}
		interface Switch extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.FaceAttachable & org.bukkit.block.data.Powerable, {
			/**
			 * Gets the value of the 'face' property.
			 */
			getFace(): org.bukkit.block.data.type.Switch.Face;

			/**
			 * Sets the value of the 'face' property.
			 */
			setFace(face: org.bukkit.block.data.type.Switch.Face): void;

		}> {}
		namespace Switch {
			interface Face {}
			namespace Face {
				/**
				 * The switch is mounted to the floor and pointing upwards.
				 */
				const FLOOR: org.bukkit.block.data.type.Switch.Face;

				/**
				 * The switch is mounted to the wall.
				 */
				const WALL: org.bukkit.block.data.type.Switch.Face;

				/**
				 * The switch is mounted to the ceiling and pointing dowanrds.
				 */
				const CEILING: org.bukkit.block.data.type.Switch.Face;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.type.Switch.Face;

			}
		}
		interface TNT extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'unstable' property.
			 */
			isUnstable(): boolean;

			/**
			 * Sets the value of the 'unstable' property.
			 */
			setUnstable(unstable: boolean): void;

		}> {}
		interface TechnicalPiston extends Modify<org.bukkit.block.data.Directional, {
			/**
			 * Gets the value of the 'type' property.
			 */
			getType(): org.bukkit.block.data.type.TechnicalPiston.Type;

			/**
			 * Sets the value of the 'type' property.
			 */
			setType(type: org.bukkit.block.data.type.TechnicalPiston.Type): void;

		}> {}
		namespace TechnicalPiston {
			interface Type {}
			namespace Type {
				/**
				 * A normal piston which does not pull connected blocks backwards on
				 * retraction.
				 */
				const NORMAL: org.bukkit.block.data.type.TechnicalPiston.Type;

				/**
				 * A sticky piston which will also retract connected blocks.
				 */
				const STICKY: org.bukkit.block.data.type.TechnicalPiston.Type;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.type.TechnicalPiston.Type;

			}
		}
		interface TrapDoor extends Modify<org.bukkit.block.data.Bisected & org.bukkit.block.data.Directional & org.bukkit.block.data.Openable & org.bukkit.block.data.Powerable & org.bukkit.block.data.Waterlogged, {}> {}
		interface TrialSpawner extends Modify<org.bukkit.block.data.BlockData, {
			/**
			 * Gets the value of the 'trial_spawner_state' property.
			 */
			getTrialSpawnerState(): org.bukkit.block.data.type.TrialSpawner.State;

			/**
			 * Sets the value of the 'trial_spawner_state' property.
			 */
			setTrialSpawnerState(state: org.bukkit.block.data.type.TrialSpawner.State): void;

			/**
			 * Gets the value of the 'ominous' property.
			 */
			isOminous(): boolean;

			/**
			 * Sets the value of the 'ominous' property.
			 */
			setOminous(ominous: boolean): void;

		}> {}
		namespace TrialSpawner {
			interface State {}
			namespace State {
				const INACTIVE: org.bukkit.block.data.type.TrialSpawner.State;

				const WAITING_FOR_PLAYERS: org.bukkit.block.data.type.TrialSpawner.State;

				const ACTIVE: org.bukkit.block.data.type.TrialSpawner.State;

				const WAITING_FOR_REWARD_EJECTION: org.bukkit.block.data.type.TrialSpawner.State;

				const EJECTING_REWARD: org.bukkit.block.data.type.TrialSpawner.State;

				const COOLDOWN: org.bukkit.block.data.type.TrialSpawner.State;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.type.TrialSpawner.State;

			}
		}
		interface Tripwire extends Modify<org.bukkit.block.data.Attachable & org.bukkit.block.data.MultipleFacing & org.bukkit.block.data.Powerable, {
			/**
			 * Gets the value of the 'disarmed' property.
			 */
			isDisarmed(): boolean;

			/**
			 * Sets the value of the 'disarmed' property.
			 */
			setDisarmed(disarmed: boolean): void;

		}> {}
		interface TripwireHook extends Modify<org.bukkit.block.data.Attachable & org.bukkit.block.data.Directional & org.bukkit.block.data.Powerable, {}> {}
		interface TurtleEgg extends Modify<org.bukkit.block.data.Hatchable, {
			/**
			 * Gets the value of the 'eggs' property.
			 */
			getEggs(): number;

			/**
			 * Sets the value of the 'eggs' property.
			 */
			setEggs(eggs: number): void;

			/**
			 * Gets the minimum allowed value of the 'eggs' property.
			 */
			getMinimumEggs(): number;

			/**
			 * Gets the maximum allowed value of the 'eggs' property.
			 */
			getMaximumEggs(): number;

		}> {}
		interface Vault extends Modify<org.bukkit.block.data.Directional, {
			/**
			 * Gets the value of the 'vault_state' property.
			 */
			getTrialSpawnerState(): org.bukkit.block.data.type.Vault.State;

			/**
			 * Sets the value of the 'vault_state' property.
			 */
			setTrialSpawnerState(state: org.bukkit.block.data.type.Vault.State): void;

			/**
			 * Gets the value of the 'ominous' property.
			 */
			isOminous(): boolean;

			/**
			 * Sets the value of the 'ominous' property.
			 */
			setOminous(ominous: boolean): void;

		}> {}
		namespace Vault {
			interface State {}
			namespace State {
				const INACTIVE: org.bukkit.block.data.type.Vault.State;

				const ACTIVE: org.bukkit.block.data.type.Vault.State;

				const UNLOCKING: org.bukkit.block.data.type.Vault.State;

				const EJECTING: org.bukkit.block.data.type.Vault.State;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.type.Vault.State;

			}
		}
		interface Wall extends Modify<org.bukkit.block.data.Waterlogged, {
			/**
			 * Gets the value of the 'up' property.
			 */
			isUp(): boolean;

			/**
			 * Sets the value of the 'up' property.
			 */
			setUp(up: boolean): void;

			/**
			 * Gets the height of the specified face.
			 */
			getHeight(face: org.bukkit.block.BlockFace): org.bukkit.block.data.type.Wall.Height;

			/**
			 * Set the height of the specified face.
			 */
			setHeight(face: org.bukkit.block.BlockFace, height: org.bukkit.block.data.type.Wall.Height): void;

		}> {}
		namespace Wall {
			interface Height {}
			namespace Height {
				/**
				 * No wall present.
				 */
				const NONE: org.bukkit.block.data.type.Wall.Height;

				/**
				 * Low wall present.
				 */
				const LOW: org.bukkit.block.data.type.Wall.Height;

				/**
				 * Tall wall present.
				 */
				const TALL: org.bukkit.block.data.type.Wall.Height;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.data.type.Wall.Height;

			}
		}
		interface WallHangingSign extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.Waterlogged, {}> {}
		interface WallSign extends Modify<org.bukkit.block.data.Directional & org.bukkit.block.data.Waterlogged, {}> {}
	}
	namespace org.bukkit.inventory.meta {
		interface ArmorMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Check whether or not this item has an armor trim.
			 */
			hasTrim(): boolean;

			/**
			 * Set the ArmorTrim.
			 */
			setTrim(trim: (org.bukkit.inventory.meta.trim.ArmorTrim | null)): void;

			/**
			 * Get the ArmorTrim.
			 */
			getTrim(): (org.bukkit.inventory.meta.trim.ArmorTrim | null);

			clone(): org.bukkit.inventory.meta.ArmorMeta;

		}> {}
		interface AxolotlBucketMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Get the variant of the axolotl in the bucket.
			 * 
			 * Plugins should check that hasVariant() returns true before
			 * calling this method.
			 */
			getVariant(): org.bukkit.entity.Axolotl.Variant;

			/**
			 * Set the variant of this axolotl in the bucket.
			 */
			setVariant(variant: org.bukkit.entity.Axolotl.Variant): void;

			/**
			 * Checks for existence of a variant tag indicating a specific axolotl will be
			 * spawned.
			 */
			hasVariant(): boolean;

			clone(): org.bukkit.inventory.meta.AxolotlBucketMeta;

		}> {}
		interface BannerMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Returns a list of patterns on this banner
			 */
			getPatterns(): globalThis.java.util.List<org.bukkit.block.banner.Pattern>;

			/**
			 * Sets the patterns used on this banner
			 */
			setPatterns(patterns: globalThis.java.util.List<org.bukkit.block.banner.Pattern>): void;

			/**
			 * Adds a new pattern on top of the existing
			 * patterns
			 */
			addPattern(pattern: org.bukkit.block.banner.Pattern): void;

			/**
			 * Returns the pattern at the specified index
			 */
			getPattern(i: number): org.bukkit.block.banner.Pattern;

			/**
			 * Removes the pattern at the specified index
			 */
			removePattern(i: number): org.bukkit.block.banner.Pattern;

			/**
			 * Sets the pattern at the specified index
			 */
			setPattern(i: number, pattern: org.bukkit.block.banner.Pattern): void;

			/**
			 * Returns the number of patterns on this
			 * banner
			 */
			numberOfPatterns(): number;

		}> {}
		interface BlockDataMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Returns whether the item has block data currently attached to it.
			 */
			hasBlockData(): boolean;

			/**
			 * Returns the currently attached block data for this item or creates a new
			 * one if one doesn't exist.
			 * The state is a copy, it must be set back (or to another item) with
			 * setBlockData(org.bukkit.block.data.BlockData)
			 */
			getBlockData(material: org.bukkit.Material): org.bukkit.block.data.BlockData;

			/**
			 * Attaches a copy of the passed block data to the item.
			 */
			setBlockData(blockData: org.bukkit.block.data.BlockData): void;

		}> {}
		interface BlockStateMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Returns whether the item has a block state currently
			 * attached to it.
			 */
			hasBlockState(): boolean;

			/**
			 * Returns the currently attached block state for this
			 * item or creates a new one if one doesn't exist.
			 * The state is a copy, it must be set back (or to another
			 * item) with setBlockState(org.bukkit.block.BlockState)
			 */
			getBlockState(): org.bukkit.block.BlockState;

			/**
			 * Attaches a copy of the passed block state to the item.
			 */
			setBlockState(blockState: org.bukkit.block.BlockState): void;

		}> {}
		interface BookMeta extends Modify<org.bukkit.inventory.meta.WritableBookMeta, {
			/**
			 * Checks for the existence of a title in the book.
			 */
			hasTitle(): boolean;

			/**
			 * Gets the title of the book.
			 * 
			 * Plugins should check that hasTitle() returns true before calling this
			 * method.
			 */
			getTitle(): (string | null);

			/**
			 * Sets the title of the book.
			 * 
			 * Limited to 32 characters. Removes title when given null.
			 */
			setTitle(title: (string | null)): boolean;

			/**
			 * Checks for the existence of an author in the book.
			 */
			hasAuthor(): boolean;

			/**
			 * Gets the author of the book.
			 * 
			 * Plugins should check that hasAuthor() returns true before calling this
			 * method.
			 */
			getAuthor(): (string | null);

			/**
			 * Sets the author of the book. Removes author when given null.
			 */
			setAuthor(author: (string | null)): void;

			/**
			 * Checks for the existence of generation level in the book.
			 */
			hasGeneration(): boolean;

			/**
			 * Gets the generation of the book.
			 * 
			 * Plugins should check that hasGeneration() returns true before calling
			 * this method.
			 */
			getGeneration(): (org.bukkit.inventory.meta.BookMeta.Generation | null);

			/**
			 * Sets the generation of the book. Removes generation when given null.
			 */
			setGeneration(generation: (org.bukkit.inventory.meta.BookMeta.Generation | null)): void;

			clone(): org.bukkit.inventory.meta.BookMeta;

		}> {}
		namespace BookMeta {
			interface Generation {}
			namespace Generation {
				/**
				 * Book written into a book-and-quill. Can be copied. (Default value)
				 */
				const ORIGINAL: org.bukkit.inventory.meta.BookMeta.Generation;

				/**
				 * Book that was copied from an original. Can be copied.
				 */
				const COPY_OF_ORIGINAL: org.bukkit.inventory.meta.BookMeta.Generation;

				/**
				 * Book that was copied from a copy of an original. Can't be copied.
				 */
				const COPY_OF_COPY: org.bukkit.inventory.meta.BookMeta.Generation;

				/**
				 * Unused; unobtainable by players. Can't be copied.
				 */
				const TATTERED: org.bukkit.inventory.meta.BookMeta.Generation;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.inventory.meta.BookMeta.Generation;

			}
		}
		interface BundleMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Returns whether the item has any items.
			 */
			hasItems(): boolean;

			/**
			 * Returns an immutable list of the items stored in this item.
			 */
			getItems(): globalThis.java.util.List<org.bukkit.inventory.ItemStack>;

			/**
			 * Sets the items stored in this item.
			 * 
			 * Removes all items when given null.
			 */
			setItems(items: (globalThis.java.util.List<org.bukkit.inventory.ItemStack> | null)): void;

			/**
			 * Adds an item to this item.
			 */
			addItem(item: org.bukkit.inventory.ItemStack): void;

		}> {}
		interface ColorableArmorMeta extends Modify<org.bukkit.inventory.meta.ArmorMeta & org.bukkit.inventory.meta.LeatherArmorMeta, {
			clone(): org.bukkit.inventory.meta.ColorableArmorMeta;

		}> {}
		interface CompassMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Checks if this compass has been paired to a lodestone.
			 */
			hasLodestone(): boolean;

			/**
			 * Gets the location that this compass will point to.
			 * Check hasLodestone() first!
			 */
			getLodestone(): (org.bukkit.Location | null);

			/**
			 * Sets the location this lodestone compass will point to.
			 */
			setLodestone(lodestone: (org.bukkit.Location | null)): void;

			/**
			 * Gets if this compass is tracking a specific lodestone.
			 * If true the compass will only work if there is a lodestone at the tracked
			 * location.
			 */
			isLodestoneTracked(): boolean;

			/**
			 * Sets if this compass is tracking a specific lodestone.
			 * If true the compass will only work if there is a lodestone at the tracked
			 * location.
			 */
			setLodestoneTracked(tracked: boolean): void;

			clone(): org.bukkit.inventory.meta.CompassMeta;

		}> {}
		interface CrossbowMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Returns whether the item has any charged projectiles.
			 */
			hasChargedProjectiles(): boolean;

			/**
			 * Returns an immutable list of the projectiles charged on this item.
			 */
			getChargedProjectiles(): globalThis.java.util.List<org.bukkit.inventory.ItemStack>;

			/**
			 * Sets the projectiles charged on this item.
			 * Removes all projectiles when given null.
			 */
			setChargedProjectiles(projectiles: (globalThis.java.util.List<org.bukkit.inventory.ItemStack> | null)): void;

			/**
			 * Adds a charged projectile to this item.
			 */
			addChargedProjectile(item: org.bukkit.inventory.ItemStack): void;

		}> {}
		interface Damageable extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Checks to see if this item has damage
			 */
			hasDamage(): boolean;

			/**
			 * Gets the damage
			 */
			getDamage(): number;

			/**
			 * Sets the damage
			 */
			setDamage(damage: number): void;

			/**
			 * Checks to see if this item has a maximum amount of damage.
			 */
			hasMaxDamage(): boolean;

			/**
			 * Gets the maximum amount of damage.
			 * Plugins should check hasMaxDamage() before calling this method.
			 */
			getMaxDamage(): number;

			/**
			 * Sets the maximum amount of damage.
			 */
			setMaxDamage(maxDamage: (number | null)): void;

			clone(): org.bukkit.inventory.meta.Damageable;

		}> {}
		interface EnchantmentStorageMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Checks for the existence of any stored enchantments.
			 */
			hasStoredEnchants(): boolean;

			/**
			 * Checks for storage of the specified enchantment.
			 */
			hasStoredEnchant(ench: org.bukkit.enchantments.Enchantment): boolean;

			/**
			 * Checks for the level of the stored enchantment.
			 */
			getStoredEnchantLevel(ench: org.bukkit.enchantments.Enchantment): number;

			/**
			 * Gets a copy the stored enchantments in this ItemMeta.
			 */
			getStoredEnchants(): globalThis.java.util.Map<org.bukkit.enchantments.Enchantment, number>;

			/**
			 * Stores the specified enchantment in this item meta.
			 */
			addStoredEnchant(ench: org.bukkit.enchantments.Enchantment, level: number, ignoreLevelRestriction: boolean): boolean;

			/**
			 * Remove the specified stored enchantment from this item meta.
			 */
			removeStoredEnchant(ench: org.bukkit.enchantments.Enchantment): boolean;

			/**
			 * Checks if the specified enchantment conflicts with any enchantments in
			 * this ItemMeta.
			 */
			hasConflictingStoredEnchant(ench: org.bukkit.enchantments.Enchantment): boolean;

			clone(): org.bukkit.inventory.meta.EnchantmentStorageMeta;

		}> {}
		interface FireworkEffectMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Sets the firework effect for this meta.
			 */
			setEffect(effect: (org.bukkit.FireworkEffect | null)): void;

			/**
			 * Checks if this meta has an effect.
			 */
			hasEffect(): boolean;

			/**
			 * Gets the firework effect for this meta.
			 */
			getEffect(): (org.bukkit.FireworkEffect | null);

			clone(): org.bukkit.inventory.meta.FireworkEffectMeta;

		}> {}
		interface FireworkMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Add another effect to this firework.
			 */
			addEffect(effect: org.bukkit.FireworkEffect): void;

			/**
			 * Add several effects to this firework.
			 */
			addEffects(...effects: org.bukkit.FireworkEffect[]): void;

			/**
			 * Add several firework effects to this firework.
			 */
			addEffects(effects: globalThis.java.lang.Iterable<org.bukkit.FireworkEffect>): void;

			/**
			 * Get the effects in this firework.
			 */
			getEffects(): globalThis.java.util.List<org.bukkit.FireworkEffect>;

			/**
			 * Get the number of effects in this firework.
			 */
			getEffectsSize(): number;

			/**
			 * Remove an effect from this firework.
			 */
			removeEffect(index: number): void;

			/**
			 * Remove all effects from this firework.
			 */
			clearEffects(): void;

			/**
			 * Get whether this firework has any effects.
			 */
			hasEffects(): boolean;

			/**
			 * Gets the approximate height the firework will fly.
			 */
			getPower(): number;

			/**
			 * Sets the approximate power of the firework. Each level of power is half
			 * a second of flight time.
			 */
			setPower(power: number): void;

			clone(): org.bukkit.inventory.meta.FireworkMeta;

		}> {}
		interface ItemMeta extends Modify<org.bukkit.configuration.serialization.ConfigurationSerializable & org.bukkit.persistence.PersistentDataHolder, {
			/**
			 * Checks for existence of a display name.
			 */
			hasDisplayName(): boolean;

			/**
			 * Gets the display name that is set.
			 * 
			 * Plugins should check that hasDisplayName() returns true
			 * before calling this method.
			 */
			getDisplayName(): string;

			/**
			 * Sets the display name.
			 */
			setDisplayName(name: (string | null)): void;

			/**
			 * Checks for existence of an item name.
			 * 
			 * Item name differs from display name in that it is cannot be edited by an
			 * anvil, is not styled with italics, and does not show labels.
			 */
			hasItemName(): boolean;

			/**
			 * Gets the item name that is set.
			 * 
			 * Item name differs from display name in that it is cannot be edited by an
			 * anvil, is not styled with italics, and does not show labels.
			 * 
			 * Plugins should check that hasItemName() returns true before
			 * calling this method.
			 */
			getItemName(): string;

			/**
			 * Sets the item name.
			 * 
			 * Item name differs from display name in that it is cannot be edited by an
			 * anvil, is not styled with italics, and does not show labels.
			 */
			setItemName(name: (string | null)): void;

			/**
			 * Checks for existence of a localized name.
			 */
			hasLocalizedName(): boolean;

			/**
			 * Gets the localized display name that is set.
			 * 
			 * Plugins should check that hasLocalizedName() returns true
			 * before calling this method.
			 */
			getLocalizedName(): string;

			/**
			 * Sets the localized name.
			 */
			setLocalizedName(name: (string | null)): void;

			/**
			 * Checks for existence of lore.
			 */
			hasLore(): boolean;

			/**
			 * Gets the lore that is set.
			 * 
			 * Plugins should check if hasLore() returns true before
			 * calling this method.
			 */
			getLore(): (globalThis.java.util.List<string> | null);

			/**
			 * Sets the lore for this item.
			 * Removes lore when given null.
			 */
			setLore(lore: (globalThis.java.util.List<string> | null)): void;

			/**
			 * Checks for existence of custom model data.
			 * 
			 * CustomModelData is an integer that may be associated client side with a
			 * custom item model.
			 */
			hasCustomModelData(): boolean;

			/**
			 * Gets the custom model data that is set.
			 * 
			 * CustomModelData is an integer that may be associated client side with a
			 * custom item model.
			 * 
			 * Plugins should check that hasCustomModelData() returns true
			 * before calling this method.
			 */
			getCustomModelData(): number;

			/**
			 * Sets the custom model data.
			 * 
			 * CustomModelData is an integer that may be associated client side with a
			 * custom item model.
			 */
			setCustomModelData(data: (number | null)): void;

			/**
			 * Checks for the existence of any enchantments.
			 */
			hasEnchants(): boolean;

			/**
			 * Checks for existence of the specified enchantment.
			 */
			hasEnchant(ench: org.bukkit.enchantments.Enchantment): boolean;

			/**
			 * Checks for the level of the specified enchantment.
			 */
			getEnchantLevel(ench: org.bukkit.enchantments.Enchantment): number;

			/**
			 * Returns a copy the enchantments in this ItemMeta.
			 * Returns an empty map if none.
			 */
			getEnchants(): globalThis.java.util.Map<org.bukkit.enchantments.Enchantment, number>;

			/**
			 * Adds the specified enchantment to this item meta.
			 */
			addEnchant(ench: org.bukkit.enchantments.Enchantment, level: number, ignoreLevelRestriction: boolean): boolean;

			/**
			 * Removes the specified enchantment from this item meta.
			 */
			removeEnchant(ench: org.bukkit.enchantments.Enchantment): boolean;

			/**
			 * Removes all enchantments from this item meta.
			 */
			removeEnchantments(): void;

			/**
			 * Checks if the specified enchantment conflicts with any enchantments in
			 * this ItemMeta.
			 */
			hasConflictingEnchant(ench: org.bukkit.enchantments.Enchantment): boolean;

			/**
			 * Set itemflags which should be ignored when rendering a ItemStack in the Client. This Method does silently ignore double set itemFlags.
			 */
			addItemFlags(...itemFlags: org.bukkit.inventory.ItemFlag[]): void;

			/**
			 * Remove specific set of itemFlags. This tells the Client it should render it again. This Method does silently ignore double removed itemFlags.
			 */
			removeItemFlags(...itemFlags: org.bukkit.inventory.ItemFlag[]): void;

			/**
			 * Get current set itemFlags. The collection returned is unmodifiable.
			 */
			getItemFlags(): globalThis.java.util.Set<org.bukkit.inventory.ItemFlag>;

			/**
			 * Check if the specified flag is present on this item.
			 */
			hasItemFlag(flag: org.bukkit.inventory.ItemFlag): boolean;

			/**
			 * Gets if this item has hide_tooltip set. An item with this set will not
			 * show any tooltip whatsoever.
			 */
			isHideTooltip(): boolean;

			/**
			 * Sets if this item has hide_tooltip set. An item with this set will not
			 * show any tooltip whatsoever.
			 */
			setHideTooltip(hideTooltip: boolean): void;

			/**
			 * Return if the unbreakable tag is true. An unbreakable item will not lose
			 * durability.
			 */
			isUnbreakable(): boolean;

			/**
			 * Sets the unbreakable tag. An unbreakable item will not lose durability.
			 */
			setUnbreakable(unbreakable: boolean): void;

			/**
			 * Gets if an enchantment_glint_override is set.
			 */
			hasEnchantmentGlintOverride(): boolean;

			/**
			 * Sets the enchantment_glint_override. If true, the item will glint, even
			 * without enchantments; if false, the item will not glint, even with
			 * enchantments.
			 * Plugins should check hasEnchantmentGlintOverride() before
			 * calling this method.
			 */
			getEnchantmentGlintOverride(): boolean;

			/**
			 * Sets the enchantment_glint_override. If true, the item will glint, even
			 * without enchantments; if false, the item will not glint, even with
			 * enchantments. If null, the override will be cleared.
			 */
			setEnchantmentGlintOverride(override: (boolean | null)): void;

			/**
			 * Checks if this item is fire_resistant. If true, it will not burn in fire
			 * or lava.
			 */
			isFireResistant(): boolean;

			/**
			 * Sets if this item is fire_resistant. If true, it will not burn in fire
			 * or lava.
			 */
			setFireResistant(fireResistant: boolean): void;

			/**
			 * Gets if the max_stack_size is set.
			 */
			hasMaxStackSize(): boolean;

			/**
			 * Gets the max_stack_size. This is the maximum amount which an item will
			 * stack.
			 */
			getMaxStackSize(): number;

			/**
			 * Sets the max_stack_size. This is the maximum amount which an item will
			 * stack.
			 */
			setMaxStackSize(max: (number | null)): void;

			/**
			 * Gets if the rarity is set.
			 */
			hasRarity(): boolean;

			/**
			 * Gets the item rarity.
			 * Plugins should check hasRarity() before calling this method.
			 */
			getRarity(): org.bukkit.inventory.ItemRarity;

			/**
			 * Sets the item rarity.
			 */
			setRarity(rarity: (org.bukkit.inventory.ItemRarity | null)): void;

			/**
			 * Checks if the food is set.
			 */
			hasFood(): boolean;

			/**
			 * Gets the food set on this item, or creates an empty food instance.
			 * 
			 * The returned component is a snapshot of its current state and does not
			 * reflect a live view of what is on an item. After changing any value on
			 * this component, it must be set with setFood(FoodComponent) to
			 * apply the changes.
			 */
			getFood(): org.bukkit.inventory.meta.components.FoodComponent;

			/**
			 * Sets the item food.
			 */
			setFood(food: (org.bukkit.inventory.meta.components.FoodComponent | null)): void;

			/**
			 * Checks if the tool is set.
			 */
			hasTool(): boolean;

			/**
			 * Gets the tool set on this item, or creates an empty tool instance.
			 * 
			 * The returned component is a snapshot of its current state and does not
			 * reflect a live view of what is on an item. After changing any value on
			 * this component, it must be set with setTool(ToolComponent) to
			 * apply the changes.
			 */
			getTool(): org.bukkit.inventory.meta.components.ToolComponent;

			/**
			 * Sets the item tool.
			 */
			setTool(tool: (org.bukkit.inventory.meta.components.ToolComponent | null)): void;

			/**
			 * Checks if the jukebox playable is set.
			 */
			hasJukeboxPlayable(): boolean;

			/**
			 * Gets the jukebox playable component set on this item.
			 * 
			 * The returned component is a snapshot of its current state and does not
			 * reflect a live view of what is on an item. After changing any value on
			 * this component, it must be set with
			 * setJukeboxPlayable(org.bukkit.inventory.meta.components.JukeboxComponent)
			 * to apply the changes.
			 */
			getJukeboxPlayable(): (org.bukkit.inventory.meta.components.JukeboxPlayableComponent | null);

			/**
			 * Sets the item tool.
			 */
			setJukeboxPlayable(jukeboxPlayable: (org.bukkit.inventory.meta.components.JukeboxPlayableComponent | null)): void;

			/**
			 * Checks for the existence of any AttributeModifiers.
			 */
			hasAttributeModifiers(): boolean;

			/**
			 * Return an immutable copy of all Attributes and
			 * their modifiers in this ItemMeta.
			 * Returns null if none exist.
			 */
			getAttributeModifiers(): (any /* com.google.common.collect.Multimap */ | null);

			/**
			 * Return an immutable copy of all Attributes and their
			 * AttributeModifiers for a given EquipmentSlot.
			 * Any AttributeModifier that does have have a given
			 * EquipmentSlot will be returned. This is because
			 * AttributeModifiers without a slot are active in any slot.
			 * If there are no attributes set for the given slot, an empty map
			 * will be returned.
			 */
			getAttributeModifiers(slot: org.bukkit.inventory.EquipmentSlot): any /* com.google.common.collect.Multimap */;

			/**
			 * Return an immutable copy of all AttributeModifiers
			 * for a given Attribute
			 */
			getAttributeModifiers(attribute: org.bukkit.attribute.Attribute): (globalThis.java.util.Collection<org.bukkit.attribute.AttributeModifier> | null);

			/**
			 * Add an Attribute and it's Modifier.
			 * AttributeModifiers can now support EquipmentSlots.
			 * If not set, the AttributeModifier will be active in ALL slots.
			 * 
			 * Two AttributeModifiers that have the same UUID
			 * cannot exist on the same Attribute.
			 */
			addAttributeModifier(attribute: org.bukkit.attribute.Attribute, modifier: org.bukkit.attribute.AttributeModifier): boolean;

			/**
			 * Set all Attributes and their AttributeModifiers.
			 * To clear all currently set Attributes and AttributeModifiers use
			 * null or an empty Multimap.
			 * If not null nor empty, this will filter all entries that are not-null
			 * and add them to the ItemStack.
			 */
			setAttributeModifiers(attributeModifiers: (any /* com.google.common.collect.Multimap */ | null)): void;

			/**
			 * Remove all AttributeModifiers associated with the given
			 * Attribute.
			 * This will return false if nothing was removed.
			 */
			removeAttributeModifier(attribute: org.bukkit.attribute.Attribute): boolean;

			/**
			 * Remove all Attributes and AttributeModifiers for a
			 * given EquipmentSlot.
			 * If the given EquipmentSlot is null, this will remove all
			 * AttributeModifiers that do not have an EquipmentSlot set.
			 */
			removeAttributeModifier(slot: org.bukkit.inventory.EquipmentSlot): boolean;

			/**
			 * Remove a specific Attribute and AttributeModifier.
			 * AttributeModifiers are matched according to their UUID.
			 */
			removeAttributeModifier(attribute: org.bukkit.attribute.Attribute, modifier: org.bukkit.attribute.AttributeModifier): boolean;

			/**
			 * Get this ItemMeta as an NBT string. If this ItemMeta does not have any
			 * NBT, then "{}" will be returned.
			 * 
			 * This string should NEVER be relied upon as a serializable value. If
			 * serialization is desired, the ConfigurationSerializable API should be used
			 * instead.
			 */
			getAsString(): string;

			/**
			 * Get this ItemMeta as a component-compliant string. If this ItemMeta does
			 * not contain any components, then "[]" will be returned.
			 * 
			 * The result of this method should yield a string representing the components
			 * altered by this ItemMeta instance. When passed to ItemFactory.createItemStack(String)
			 * with a prepended item type, it will create an ItemStack that has an ItemMeta
			 * matching this ItemMeta instance exactly. Note that this method returns
			 * ONLY the components and cannot be passed to createItemStack() alone.
			 * An example may look something like this:
			 * ItemStack itemStack = // ... an item stack obtained from somewhere
			 * ItemMeta itemMeta = itemStack.getItemMeta();
			 * 
			 * String components = itemMeta.getAsComponentString(); // example: "[minecraft:damage=53]"
			 * String itemTypeKey = itemStack.getType().getKey().toString(); // example: "minecraft:diamond_sword"
			 * String itemAsString = itemTypeKey + components; // results in: "minecraft:diamond_sword[minecraft:damage=53]"
			 * 
			 * ItemStack recreatedItemStack = Bukkit.getItemFactory().createItemStack(itemAsString);
			 * assert itemStack.isSimilar(recreatedItemStack); // Should be true*
			 * 
			 * 
			 * *Components not represented or explicitly overridden by this ItemMeta instance
			 * will not be included in the resulting string and therefore may result in ItemStacks
			 * that do not match exactly. For example, if setDisplayName(String)
			 * is not set, then the custom name component will not be included. Or if this ItemMeta
			 * is a PotionMeta, it will not include any components related to lodestone compasses,
			 * banners, or books, etc., only components modifiable by a PotionMeta instance.
			 * 
			 * This string should NEVER be relied upon as a serializable value. If
			 * serialization is desired, the ConfigurationSerializable API should be used
			 * instead.
			 */
			getAsComponentString(): string;

			/**
			 * Returns a public custom tag container capable of storing tags on the
			 * item.
			 * Those tags will be sent to the client with all of their content, so the
			 * client is capable of reading them. This will result in the player seeing
			 * a NBT Tag notification on the item.
			 * These tags can also be modified by the client once in creative mode
			 */
			getCustomTagContainer(): org.bukkit.inventory.meta.tags.CustomItemTagContainer;

			/**
			 * Internal use only! Do not use under any circumstances!
			 */
			setVersion(version: number): void;

			clone(): org.bukkit.inventory.meta.ItemMeta;

		}> {}
		interface KnowledgeBookMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Checks for the existence of recipes in the book.
			 */
			hasRecipes(): boolean;

			/**
			 * Gets all the recipes in the book.
			 */
			getRecipes(): globalThis.java.util.List<org.bukkit.NamespacedKey>;

			/**
			 * Clears the existing book recipes, and sets the book to use the provided
			 * recipes.
			 */
			setRecipes(recipes: globalThis.java.util.List<org.bukkit.NamespacedKey>): void;

			/**
			 * Adds new recipe to the end of the book.
			 */
			addRecipe(...recipes: org.bukkit.NamespacedKey[]): void;

			clone(): org.bukkit.inventory.meta.KnowledgeBookMeta;

		}> {}
		interface LeatherArmorMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Gets the color of the armor. If it has not been set otherwise, it will
			 * be ItemFactory.getDefaultLeatherColor().
			 */
			getColor(): org.bukkit.Color;

			/**
			 * Sets the color of the armor.
			 */
			setColor(color: (org.bukkit.Color | null)): void;

			clone(): org.bukkit.inventory.meta.LeatherArmorMeta;

		}> {}
		interface MapMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Checks for existence of a map ID number.
			 */
			hasMapId(): boolean;

			/**
			 * Gets the map ID that is set. This is used to determine what map is
			 * displayed.
			 * 
			 * Plugins should check that hasMapId() returns true before
			 * calling this method.
			 */
			getMapId(): number;

			/**
			 * Sets the map ID. This is used to determine what map is displayed.
			 */
			setMapId(id: number): void;

			/**
			 * Checks for existence of an associated map.
			 */
			hasMapView(): boolean;

			/**
			 * Gets the map view that is associated with this map item.
			 * 
			 * Plugins should check that hasMapView() returns true before
			 * calling this method.
			 */
			getMapView(): (org.bukkit.map.MapView | null);

			/**
			 * Sets the associated map. This is used to determine what map is displayed.
			 * 
			 * The implementation may allow null to clear the associated map, but
			 * this is not required and is liable to generate a new (undefined) map when
			 * the item is first used.
			 */
			setMapView(map: org.bukkit.map.MapView): void;

			/**
			 * Checks to see if this map is scaling.
			 */
			isScaling(): boolean;

			/**
			 * Sets if this map is scaling or not.
			 */
			setScaling(value: boolean): void;

			/**
			 * Checks for existence of a location name.
			 */
			hasLocationName(): boolean;

			/**
			 * Gets the location name that is set.
			 * 
			 * Plugins should check that hasLocationName() returns true
			 * before calling this method.
			 */
			getLocationName(): (string | null);

			/**
			 * Sets the location name.
			 */
			setLocationName(name: (string | null)): void;

			/**
			 * Checks for existence of a map color.
			 */
			hasColor(): boolean;

			/**
			 * Gets the map color that is set. A custom map color will alter the display
			 * of the map in an inventory slot.
			 * 
			 * Plugins should check that hasColor() returns true before
			 * calling this method.
			 */
			getColor(): (org.bukkit.Color | null);

			/**
			 * Sets the map color. A custom map color will alter the display of the map
			 * in an inventory slot.
			 */
			setColor(color: (org.bukkit.Color | null)): void;

			clone(): org.bukkit.inventory.meta.MapMeta;

		}> {}
		interface MusicInstrumentMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Sets the goat horn's instrument.
			 */
			setInstrument(instrument: (org.bukkit.MusicInstrument | null)): void;

			/**
			 * Gets the instrument of the goat horn.
			 */
			getInstrument(): (org.bukkit.MusicInstrument | null);

			clone(): org.bukkit.inventory.meta.MusicInstrumentMeta;

		}> {}
		interface OminousBottleMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Checks for the presence of an amplifier.
			 */
			hasAmplifier(): boolean;

			/**
			 * Gets the amplifier amount for an Ominous Bottle's bad omen effect.
			 * 
			 * Plugins should check that hasAmplifier() returns true before calling this
			 * method.
			 */
			getAmplifier(): number;

			/**
			 * Sets the amplifier amount for an Ominous Bottle's bad omen effect.
			 */
			setAmplifier(amplifier: number): void;

			clone(): org.bukkit.inventory.meta.OminousBottleMeta;

		}> {}
		interface PotionMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Sets the underlying potion data
			 */
			setBasePotionData(data: (org.bukkit.potion.PotionData | null)): void;

			/**
			 * Returns the potion data about the base potion
			 */
			getBasePotionData(): (org.bukkit.potion.PotionData | null);

			/**
			 * Sets the underlying potion type
			 */
			setBasePotionType(type: (org.bukkit.potion.PotionType | null)): void;

			/**
			 * Returns the potion type about the base potion
			 */
			getBasePotionType(): (org.bukkit.potion.PotionType | null);

			/**
			 * Checks for the presence of a base potion type
			 */
			hasBasePotionType(): boolean;

			/**
			 * Checks for the presence of custom potion effects.
			 */
			hasCustomEffects(): boolean;

			/**
			 * Gets an immutable list containing all custom potion effects applied to
			 * this potion.
			 * 
			 * Plugins should check that hasCustomEffects() returns true before calling
			 * this method.
			 */
			getCustomEffects(): globalThis.java.util.List<org.bukkit.potion.PotionEffect>;

			/**
			 * Adds a custom potion effect to this potion.
			 */
			addCustomEffect(effect: org.bukkit.potion.PotionEffect, overwrite: boolean): boolean;

			/**
			 * Removes a custom potion effect from this potion.
			 */
			removeCustomEffect(type: org.bukkit.potion.PotionEffectType): boolean;

			/**
			 * Checks for a specific custom potion effect type on this potion.
			 */
			hasCustomEffect(type: org.bukkit.potion.PotionEffectType): boolean;

			/**
			 * Moves a potion effect to the top of the potion effect list.
			 * 
			 * This causes the client to display the potion effect in the potion's name.
			 */
			setMainEffect(type: org.bukkit.potion.PotionEffectType): boolean;

			/**
			 * Removes all custom potion effects from this potion.
			 */
			clearCustomEffects(): boolean;

			/**
			 * Checks for existence of a potion color.
			 */
			hasColor(): boolean;

			/**
			 * Gets the potion color that is set. A custom potion color will alter the
			 * display of the potion in an inventory slot.
			 * 
			 * Plugins should check that hasColor() returns true before
			 * calling this method.
			 */
			getColor(): (org.bukkit.Color | null);

			/**
			 * Sets the potion color. A custom potion color will alter the display of
			 * the potion in an inventory slot.
			 */
			setColor(color: (org.bukkit.Color | null)): void;

			clone(): org.bukkit.inventory.meta.PotionMeta;

		}> {}
		interface Repairable extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Checks to see if this has a repair penalty
			 */
			hasRepairCost(): boolean;

			/**
			 * Gets the repair penalty
			 */
			getRepairCost(): number;

			/**
			 * Sets the repair penalty
			 */
			setRepairCost(cost: number): void;

			clone(): org.bukkit.inventory.meta.Repairable;

		}> {}
		interface SkullMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Gets the owner of the skull.
			 */
			getOwner(): (string | null);

			/**
			 * Checks to see if the skull has an owner.
			 */
			hasOwner(): boolean;

			/**
			 * Sets the owner of the skull.
			 */
			setOwner(owner: (string | null)): boolean;

			/**
			 * Gets the owner of the skull.
			 */
			getOwningPlayer(): (org.bukkit.OfflinePlayer | null);

			/**
			 * Sets the owner of the skull.
			 * 
			 * Plugins should check that hasOwner() returns true before calling this
			 * plugin.
			 */
			setOwningPlayer(owner: (org.bukkit.OfflinePlayer | null)): boolean;

			/**
			 * Gets the profile of the player who owns the skull. This player profile
			 * may appear as the texture depending on skull type.
			 */
			getOwnerProfile(): (org.bukkit.profile.PlayerProfile | null);

			/**
			 * Sets the profile of the player who owns the skull. This player profile
			 * may appear as the texture depending on skull type.
			 * 
			 * The profile must contain both a unique id and a skin texture. If either
			 * of these is missing, the profile must contain a name by which the server
			 * will then attempt to look up the unique id and skin texture.
			 */
			setOwnerProfile(profile: (org.bukkit.profile.PlayerProfile | null)): void;

			/**
			 * Sets the sound to play if the skull is placed on a note block.
			 * 
			 * Note: This only works for player heads. For other heads,
			 * see Instrument.
			 */
			setNoteBlockSound(noteBlockSound: (org.bukkit.NamespacedKey | null)): void;

			/**
			 * Gets the sound to play if the skull is placed on a note block.
			 * 
			 * Note: This only works for player heads. For other heads,
			 * see Instrument.
			 */
			getNoteBlockSound(): (org.bukkit.NamespacedKey | null);

			clone(): org.bukkit.inventory.meta.SkullMeta;

		}> {}
		interface SpawnEggMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Get the type of entity this egg will spawn.
			 */
			getSpawnedType(): org.bukkit.entity.EntityType;

			/**
			 * Set the type of entity this egg will spawn.
			 */
			setSpawnedType(type: org.bukkit.entity.EntityType): void;

			/**
			 * Gets the EntitySnapshot that will be spawned by this spawn egg or null if no entity
			 * has been set.
			 * 
			 * All applicable data from the egg will be copied, such as custom name, health,
			 * and velocity.
			 */
			getSpawnedEntity(): (org.bukkit.entity.EntitySnapshot | null);

			/**
			 * Sets the EntitySnapshot that will be spawned by this spawn egg.
			 * 
			 * All applicable data from the entity will be copied, such as custom name,
			 * health, and velocity.
			 */
			setSpawnedEntity(snapshot: org.bukkit.entity.EntitySnapshot): void;

			clone(): org.bukkit.inventory.meta.SpawnEggMeta;

		}> {}
		interface SuspiciousStewMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Checks for the presence of custom potion effects.
			 */
			hasCustomEffects(): boolean;

			/**
			 * Gets an immutable list containing all custom potion effects applied to
			 * this suspicious stew.
			 * 
			 * Plugins should check that hasCustomEffects() returns true before calling
			 * this method.
			 */
			getCustomEffects(): globalThis.java.util.List<org.bukkit.potion.PotionEffect>;

			/**
			 * Adds a custom potion effect to this suspicious stew.
			 */
			addCustomEffect(effect: org.bukkit.potion.PotionEffect, overwrite: boolean): boolean;

			/**
			 * Removes a custom potion effect from this suspicious stew.
			 */
			removeCustomEffect(type: org.bukkit.potion.PotionEffectType): boolean;

			/**
			 * Checks for a specific custom potion effect type on this suspicious stew.
			 */
			hasCustomEffect(type: org.bukkit.potion.PotionEffectType): boolean;

			/**
			 * Removes all custom potion effects from this suspicious stew.
			 */
			clearCustomEffects(): boolean;

			clone(): org.bukkit.inventory.meta.SuspiciousStewMeta;

		}> {}
		interface TropicalFishBucketMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Gets the color of the fish's pattern.
			 * 
			 * Plugins should check that hasVariant() returns true before
			 * calling this method.
			 */
			getPatternColor(): org.bukkit.DyeColor;

			/**
			 * Sets the color of the fish's pattern.
			 * 
			 * Setting this when hasVariant() returns false will initialize
			 * all other values to unspecified defaults.
			 */
			setPatternColor(color: org.bukkit.DyeColor): void;

			/**
			 * Gets the color of the fish's body.
			 * 
			 * Plugins should check that hasVariant() returns true before
			 * calling this method.
			 */
			getBodyColor(): org.bukkit.DyeColor;

			/**
			 * Sets the color of the fish's body.
			 * 
			 * Setting this when hasVariant() returns false will initialize
			 * all other values to unspecified defaults.
			 */
			setBodyColor(color: org.bukkit.DyeColor): void;

			/**
			 * Gets the fish's pattern.
			 * 
			 * Plugins should check that hasVariant() returns true before
			 * calling this method.
			 */
			getPattern(): org.bukkit.entity.TropicalFish.Pattern;

			/**
			 * Sets the fish's pattern.
			 * 
			 * Setting this when hasVariant() returns false will initialize
			 * all other values to unspecified defaults.
			 */
			setPattern(pattern: org.bukkit.entity.TropicalFish.Pattern): void;

			/**
			 * Checks for existence of a variant tag indicating a specific fish will be
			 * spawned.
			 */
			hasVariant(): boolean;

			clone(): org.bukkit.inventory.meta.TropicalFishBucketMeta;

		}> {}
		interface WritableBookMeta extends Modify<org.bukkit.inventory.meta.ItemMeta, {
			/**
			 * Checks for the existence of pages in the book.
			 */
			hasPages(): boolean;

			/**
			 * Gets the specified page in the book. The given page must exist.
			 * 
			 * Pages are 1-indexed.
			 */
			getPage(page: number): string;

			/**
			 * Sets the specified page in the book. Pages of the book must be
			 * contiguous.
			 * 
			 * The data can be up to 1024 characters in length, additional characters
			 * are truncated.
			 * 
			 * Pages are 1-indexed.
			 */
			setPage(page: number, data: string): void;

			/**
			 * Gets all the pages in the book.
			 */
			getPages(): globalThis.java.util.List<string>;

			/**
			 * Clears the existing book pages, and sets the book to use the provided
			 * pages. Maximum 100 pages with 1024 characters per page.
			 */
			setPages(pages: globalThis.java.util.List<string>): void;

			/**
			 * Clears the existing book pages, and sets the book to use the provided
			 * pages. Maximum 100 pages with 1024 characters per page.
			 */
			setPages(...pages: string[]): void;

			/**
			 * Adds new pages to the end of the book. Up to a maximum of 100 pages with
			 * 1024 characters per page.
			 */
			addPage(...pages: string[]): void;

			/**
			 * Gets the number of pages in the book.
			 */
			getPageCount(): number;

			clone(): org.bukkit.inventory.meta.WritableBookMeta;

		}> {}
	}
	namespace org.bukkit.inventory.meta.trim {
		interface ArmorTrim {
			/**
			 * Get the TrimMaterial for this armor trim.
			 */
			getMaterial(): org.bukkit.inventory.meta.trim.TrimMaterial;

			/**
			 * Get the TrimPattern for this armor trim.
			 */
			getPattern(): org.bukkit.inventory.meta.trim.TrimPattern;

			hashCode(): number;

			equals(obj: any): boolean;

		}
		class ArmorTrim {
			/**
			 * Create a new ArmorTrim given a TrimMaterial and
			 * TrimPattern.
			 */
			constructor(material: org.bukkit.inventory.meta.trim.TrimMaterial, pattern: org.bukkit.inventory.meta.trim.TrimPattern);

		}
		interface TrimMaterial extends Modify<org.bukkit.Keyed & org.bukkit.Translatable, {}> {}
		namespace TrimMaterial {
			/**
			 * Material.QUARTZ.
			 */
			const QUARTZ: org.bukkit.inventory.meta.trim.TrimMaterial;

			/**
			 * Material.IRON_INGOT.
			 */
			const IRON: org.bukkit.inventory.meta.trim.TrimMaterial;

			/**
			 * Material.NETHERITE_INGOT.
			 */
			const NETHERITE: org.bukkit.inventory.meta.trim.TrimMaterial;

			/**
			 * Material.REDSTONE.
			 */
			const REDSTONE: org.bukkit.inventory.meta.trim.TrimMaterial;

			/**
			 * Material.COPPER_INGOT.
			 */
			const COPPER: org.bukkit.inventory.meta.trim.TrimMaterial;

			/**
			 * Material.GOLD_INGOT.
			 */
			const GOLD: org.bukkit.inventory.meta.trim.TrimMaterial;

			/**
			 * Material.EMERALD.
			 */
			const EMERALD: org.bukkit.inventory.meta.trim.TrimMaterial;

			/**
			 * Material.DIAMOND.
			 */
			const DIAMOND: org.bukkit.inventory.meta.trim.TrimMaterial;

			/**
			 * Material.LAPIS_LAZULI.
			 */
			const LAPIS: org.bukkit.inventory.meta.trim.TrimMaterial;

			/**
			 * Material.AMETHYST_SHARD.
			 */
			const AMETHYST: org.bukkit.inventory.meta.trim.TrimMaterial;

		}
		interface TrimPattern extends Modify<org.bukkit.Keyed & org.bukkit.Translatable, {}> {}
		namespace TrimPattern {
			/**
			 * Material.SENTRY_ARMOR_TRIM_SMITHING_TEMPLATE.
			 */
			const SENTRY: org.bukkit.inventory.meta.trim.TrimPattern;

			/**
			 * Material.DUNE_ARMOR_TRIM_SMITHING_TEMPLATE.
			 */
			const DUNE: org.bukkit.inventory.meta.trim.TrimPattern;

			/**
			 * Material.COAST_ARMOR_TRIM_SMITHING_TEMPLATE.
			 */
			const COAST: org.bukkit.inventory.meta.trim.TrimPattern;

			/**
			 * Material.WILD_ARMOR_TRIM_SMITHING_TEMPLATE.
			 */
			const WILD: org.bukkit.inventory.meta.trim.TrimPattern;

			/**
			 * Material.WARD_ARMOR_TRIM_SMITHING_TEMPLATE.
			 */
			const WARD: org.bukkit.inventory.meta.trim.TrimPattern;

			/**
			 * Material.EYE_ARMOR_TRIM_SMITHING_TEMPLATE.
			 */
			const EYE: org.bukkit.inventory.meta.trim.TrimPattern;

			/**
			 * Material.VEX_ARMOR_TRIM_SMITHING_TEMPLATE.
			 */
			const VEX: org.bukkit.inventory.meta.trim.TrimPattern;

			/**
			 * Material.TIDE_ARMOR_TRIM_SMITHING_TEMPLATE.
			 */
			const TIDE: org.bukkit.inventory.meta.trim.TrimPattern;

			/**
			 * Material.SNOUT_ARMOR_TRIM_SMITHING_TEMPLATE.
			 */
			const SNOUT: org.bukkit.inventory.meta.trim.TrimPattern;

			/**
			 * Material.RIB_ARMOR_TRIM_SMITHING_TEMPLATE.
			 */
			const RIB: org.bukkit.inventory.meta.trim.TrimPattern;

			/**
			 * Material.SPIRE_ARMOR_TRIM_SMITHING_TEMPLATE.
			 */
			const SPIRE: org.bukkit.inventory.meta.trim.TrimPattern;

			/**
			 * Material.WAYFINDER_ARMOR_TRIM_SMITHING_TEMPLATE.
			 */
			const WAYFINDER: org.bukkit.inventory.meta.trim.TrimPattern;

			/**
			 * Material.SHAPER_ARMOR_TRIM_SMITHING_TEMPLATE.
			 */
			const SHAPER: org.bukkit.inventory.meta.trim.TrimPattern;

			/**
			 * Material.SILENCE_ARMOR_TRIM_SMITHING_TEMPLATE.
			 */
			const SILENCE: org.bukkit.inventory.meta.trim.TrimPattern;

			/**
			 * Material.RAISER_ARMOR_TRIM_SMITHING_TEMPLATE.
			 */
			const RAISER: org.bukkit.inventory.meta.trim.TrimPattern;

			/**
			 * Material.HOST_ARMOR_TRIM_SMITHING_TEMPLATE.
			 */
			const HOST: org.bukkit.inventory.meta.trim.TrimPattern;

			/**
			 * Material.FLOW_ARMOR_TRIM_SMITHING_TEMPLATE.
			 */
			const FLOW: org.bukkit.inventory.meta.trim.TrimPattern;

			/**
			 * Material.BOLT_ARMOR_TRIM_SMITHING_TEMPLATE.
			 */
			const BOLT: org.bukkit.inventory.meta.trim.TrimPattern;

		}
	}
	namespace org.bukkit {
		interface Art {
			/**
			 * Gets the width of the painting, in blocks
			 */
			getBlockWidth(): number;

			/**
			 * Gets the height of the painting, in blocks
			 */
			getBlockHeight(): number;

			/**
			 * Get the ID of this painting.
			 */
			getId(): number;

			/**
			 * Description copied from interface:Â Keyed
			 */
			getKey(): org.bukkit.NamespacedKey;

		}
		namespace Art {
			const KEBAB: org.bukkit.Art;

			const AZTEC: org.bukkit.Art;

			const ALBAN: org.bukkit.Art;

			const AZTEC2: org.bukkit.Art;

			const BOMB: org.bukkit.Art;

			const PLANT: org.bukkit.Art;

			const WASTELAND: org.bukkit.Art;

			const POOL: org.bukkit.Art;

			const COURBET: org.bukkit.Art;

			const SEA: org.bukkit.Art;

			const SUNSET: org.bukkit.Art;

			const CREEBET: org.bukkit.Art;

			const WANDERER: org.bukkit.Art;

			const GRAHAM: org.bukkit.Art;

			const MATCH: org.bukkit.Art;

			const BUST: org.bukkit.Art;

			const STAGE: org.bukkit.Art;

			const VOID: org.bukkit.Art;

			const SKULL_AND_ROSES: org.bukkit.Art;

			const WITHER: org.bukkit.Art;

			const FIGHTERS: org.bukkit.Art;

			const POINTER: org.bukkit.Art;

			const PIGSCENE: org.bukkit.Art;

			const BURNING_SKULL: org.bukkit.Art;

			const SKELETON: org.bukkit.Art;

			const DONKEY_KONG: org.bukkit.Art;

			const EARTH: org.bukkit.Art;

			const WIND: org.bukkit.Art;

			const WATER: org.bukkit.Art;

			const FIRE: org.bukkit.Art;

			const BAROQUE: org.bukkit.Art;

			const HUMBLE: org.bukkit.Art;

			const MEDITATIVE: org.bukkit.Art;

			const PRAIRIE_RIDE: org.bukkit.Art;

			const UNPACKED: org.bukkit.Art;

			const BACKYARD: org.bukkit.Art;

			const BOUQUET: org.bukkit.Art;

			const CAVEBIRD: org.bukkit.Art;

			const CHANGING: org.bukkit.Art;

			const COTAN: org.bukkit.Art;

			const ENDBOSS: org.bukkit.Art;

			const FERN: org.bukkit.Art;

			const FINDING: org.bukkit.Art;

			const LOWMIST: org.bukkit.Art;

			const ORB: org.bukkit.Art;

			const OWLEMONS: org.bukkit.Art;

			const PASSAGE: org.bukkit.Art;

			const POND: org.bukkit.Art;

			const SUNFLOWERS: org.bukkit.Art;

			const TIDES: org.bukkit.Art;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.Art;

			/**
			 * Get a painting by its numeric ID
			 */
			function getById(id: number): (org.bukkit.Art | null);

			/**
			 * Get a painting by its unique name
			 * 
			 * This ignores underscores and capitalization
			 */
			function getByName(name: string): (org.bukkit.Art | null);

		}
		interface Axis {}
		namespace Axis {
			/**
			 * The x axis.
			 */
			const X: org.bukkit.Axis;

			/**
			 * The y axis.
			 */
			const Y: org.bukkit.Axis;

			/**
			 * The z axis.
			 */
			const Z: org.bukkit.Axis;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.Axis;

		}
		interface BanEntry<T = any> {
			/**
			 * Gets the target involved. This may be in the form of an IP or a player
			 * name.
			 */
			getTarget(): string;

			/**
			 * Gets the target involved.
			 */
			getBanTarget(): T;

			/**
			 * Gets the date this ban entry was created.
			 */
			getCreated(): globalThis.java.util.Date;

			/**
			 * Sets the date this ban entry was created.
			 */
			setCreated(created: globalThis.java.util.Date): void;

			/**
			 * Gets the source of this ban.
			 * 
			 * Note: A source is considered any String, although this is generally a
			 * player name.
			 */
			getSource(): string;

			/**
			 * Sets the source of this ban.
			 * 
			 * Note: A source is considered any String, although this is generally a
			 * player name.
			 */
			setSource(source: string): void;

			/**
			 * Gets the date this ban expires on, or null for no defined end date.
			 */
			getExpiration(): (globalThis.java.util.Date | null);

			/**
			 * Sets the date this ban expires on. Null values are considered
			 * "infinite" bans.
			 */
			setExpiration(expiration: (globalThis.java.util.Date | null)): void;

			/**
			 * Gets the reason for this ban.
			 */
			getReason(): (string | null);

			/**
			 * Sets the reason for this ban. Reasons must not be null.
			 */
			setReason(reason: (string | null)): void;

			/**
			 * Saves the ban entry, overwriting any previous data in the ban list.
			 * 
			 * Saving the ban entry of an unbanned player will cause the player to be
			 * banned once again.
			 */
			save(): void;

			/**
			 * Removes this ban entry from the appropriate ban list.
			 */
			remove(): void;

		}
		interface BanList<T = any> {
			/**
			 * Gets a BanEntry by target.
			 */
			getBanEntry(target: string): (org.bukkit.BanEntry<T> | null);

			/**
			 * Gets a BanEntry by target.
			 */
			getBanEntry(target: T): (org.bukkit.BanEntry<T> | null);

			/**
			 * Adds a ban to this list. If a previous ban exists, this will
			 * update the previous entry.
			 */
			addBan(target: string, reason: (string | null), expires: (globalThis.java.util.Date | null), source: (string | null)): (org.bukkit.BanEntry<T> | null);

			/**
			 * Adds a ban to this list. If a previous ban exists, this will
			 * update the previous entry.
			 */
			addBan(target: T, reason: (string | null), expires: (globalThis.java.util.Date | null), source: (string | null)): (org.bukkit.BanEntry<T> | null);

			/**
			 * Adds a ban to this list. If a previous ban exists, this will
			 * update the previous entry.
			 */
			addBan(target: T, reason: (string | null), expires: (any /* java.time.Instant */ | null), source: (string | null)): (org.bukkit.BanEntry<T> | null);

			/**
			 * Adds a ban to this list. If a previous ban exists, this will
			 * update the previous entry.
			 */
			addBan(target: T, reason: (string | null), duration: (any /* java.time.Duration */ | null), source: (string | null)): (org.bukkit.BanEntry<T> | null);

			/**
			 * Gets a set containing every BanEntry in this list.
			 */
			getBanEntries(): globalThis.java.util.Set<org.bukkit.BanEntry>;

			/**
			 * Gets a set containing every BanEntry in this list.
			 */
			getEntries(): globalThis.java.util.Set<org.bukkit.BanEntry<T>>;

			/**
			 * Gets if a BanEntry exists for the target, indicating an active
			 * ban status.
			 */
			isBanned(target: T): boolean;

			/**
			 * Gets if a BanEntry exists for the target, indicating an active
			 * ban status.
			 */
			isBanned(target: string): boolean;

			/**
			 * Removes the specified target from this list, therefore indicating a
			 * "not banned" status.
			 */
			pardon(target: T): void;

			/**
			 * Removes the specified target from this list, therefore indicating a
			 * "not banned" status.
			 */
			pardon(target: string): void;

		}
		namespace BanList {
			interface Type {}
			namespace Type {
				/**
				 * Banned player names
				 */
				const NAME: org.bukkit.BanList.Type;

				/**
				 * Banned IP addresses
				 */
				const IP: org.bukkit.BanList.Type;

				/**
				 * Banned player profiles
				 */
				const PROFILE: org.bukkit.BanList.Type;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.BanList.Type;

			}
		}
		interface BlockChangeDelegate {
			/**
			 * Set a block data at the specified coordinates.
			 */
			setBlockData(x: number, y: number, z: number, blockData: org.bukkit.block.data.BlockData): boolean;

			/**
			 * Get the block data at the location.
			 */
			getBlockData(x: number, y: number, z: number): org.bukkit.block.data.BlockData;

			/**
			 * Gets the height of the world.
			 */
			getHeight(): number;

			/**
			 * Checks if the specified block is empty (air) or not.
			 */
			isEmpty(x: number, y: number, z: number): boolean;

		}
		interface Bukkit {}
		namespace Bukkit {
			/**
			 * Gets the current Server singleton
			 */
			function getServer(): org.bukkit.Server;

			/**
			 * Attempts to set the Server singleton.
			 * 
			 * This cannot be done if the Server is already set.
			 */
			function setServer(server: org.bukkit.Server): void;

			/**
			 * Gets the name of this server implementation.
			 */
			function getName(): string;

			/**
			 * Gets the version string of this server implementation.
			 */
			function getVersion(): string;

			/**
			 * Gets the Bukkit version that this server is running.
			 */
			function getBukkitVersion(): string;

			/**
			 * Gets a view of all currently logged in players. This view is a reused
			 * object, making some operations like Collection.size()
			 * zero-allocation.
			 * 
			 * The collection is a view backed by the internal representation, such
			 * that, changes to the internal state of the server will be reflected
			 * immediately. However, the reuse of the returned collection (identity)
			 * is not strictly guaranteed for future or all implementations. Casting
			 * the collection, or relying on interface implementations (like Serializable or List), is deprecated.
			 * 
			 * Iteration behavior is undefined outside of self-contained main-thread
			 * uses. Normal and immediate iterator use without consequences that
			 * affect the collection are fully supported. The effects following
			 * (non-exhaustive) teleportation,
			 * death, and kicking are undefined. Any use of this collection from
			 * asynchronous threads is unsafe.
			 * 
			 * For safe consequential iteration or mimicking the old array behavior,
			 * using Collection.toArray(Object[]) is recommended. For making
			 * snapshots, ImmutableList.copyOf(Collection) is recommended.
			 */
			function getOnlinePlayers(): globalThis.java.util.Collection<org.bukkit.entity.Player>;

			/**
			 * Get the maximum amount of players which can login to this server.
			 */
			function getMaxPlayers(): number;

			/**
			 * Set the maximum amount of players allowed to be logged in at once.
			 */
			function setMaxPlayers(maxPlayers: number): void;

			/**
			 * Get the game port that the server runs on.
			 */
			function getPort(): number;

			/**
			 * Get the view distance from this server.
			 */
			function getViewDistance(): number;

			/**
			 * Get the simulation distance from this server.
			 */
			function getSimulationDistance(): number;

			/**
			 * Get the IP that this server is bound to, or empty string if not
			 * specified.
			 */
			function getIp(): string;

			/**
			 * Get world type (level-type setting) for default world.
			 */
			function getWorldType(): string;

			/**
			 * Get generate-structures setting.
			 */
			function getGenerateStructures(): boolean;

			/**
			 * Get max world size.
			 */
			function getMaxWorldSize(): number;

			/**
			 * Gets whether this server allows the End or not.
			 */
			function getAllowEnd(): boolean;

			/**
			 * Gets whether this server allows the Nether or not.
			 */
			function getAllowNether(): boolean;

			/**
			 * Gets whether the server is logging the IP addresses of players.
			 */
			function isLoggingIPs(): boolean;

			function getInitialEnabledPacks(): globalThis.java.util.List<string>;

			function getInitialDisabledPacks(): globalThis.java.util.List<string>;

			/**
			 * Get the DataPack Manager.
			 */
			function getDataPackManager(): org.bukkit.packs.DataPackManager;

			/**
			 * Gets the resource pack configured to be sent to clients by the server.
			 */
			function getServerResourcePack(): (org.bukkit.packs.ResourcePack | null);

			/**
			 * Get the ServerTick Manager.
			 */
			function getServerTickManager(): org.bukkit.ServerTickManager;

			/**
			 * Gets the server resource pack uri, or empty string if not specified.
			 */
			function getResourcePack(): string;

			/**
			 * Gets the SHA-1 digest of the server resource pack, or empty string if
			 * not specified.
			 */
			function getResourcePackHash(): string;

			/**
			 * Gets the custom prompt message to be shown when the server resource
			 * pack is required, or empty string if not specified.
			 */
			function getResourcePackPrompt(): string;

			/**
			 * Gets whether the server resource pack is enforced.
			 */
			function isResourcePackRequired(): boolean;

			/**
			 * Gets whether this server has a whitelist or not.
			 */
			function hasWhitelist(): boolean;

			/**
			 * Sets if the server is whitelisted.
			 */
			function setWhitelist(value: boolean): void;

			/**
			 * Gets whether the server whitelist is enforced.
			 * If the whitelist is enforced, non-whitelisted players will be
			 * disconnected when the server whitelist is reloaded.
			 */
			function isWhitelistEnforced(): boolean;

			/**
			 * Sets if the server whitelist is enforced.
			 * If the whitelist is enforced, non-whitelisted players will be
			 * disconnected when the server whitelist is reloaded.
			 */
			function setWhitelistEnforced(value: boolean): void;

			/**
			 * Gets a list of whitelisted players.
			 */
			function getWhitelistedPlayers(): globalThis.java.util.Set<org.bukkit.OfflinePlayer>;

			/**
			 * Reloads the whitelist from disk.
			 */
			function reloadWhitelist(): void;

			/**
			 * Broadcast a message to all players.
			 * 
			 * This is the same as calling broadcast(java.lang.String, java.lang.String) to Server.BROADCAST_CHANNEL_USERS
			 */
			function broadcastMessage(message: string): number;

			/**
			 * Gets the name of the update folder. The update folder is used to safely
			 * update plugins at the right moment on a plugin load.
			 * 
			 * The update folder name is relative to the plugins folder.
			 */
			function getUpdateFolder(): string;

			/**
			 * Gets the update folder. The update folder is used to safely update
			 * plugins at the right moment on a plugin load.
			 */
			function getUpdateFolderFile(): any /* java.io.File */;

			/**
			 * Gets the value of the connection throttle setting.
			 */
			function getConnectionThrottle(): number;

			/**
			 * Gets default ticks per animal spawns value.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn monsters
			 * every tick.
			 * A value of 400 will mean the server will attempt to spawn monsters
			 * every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note: If set to 0, animal spawning will be disabled. We
			 * recommend using spawn-animals to control this instead.
			 * 
			 * Minecraft default: 400.
			 */
			function getTicksPerAnimalSpawns(): number;

			/**
			 * Gets the default ticks per monster spawns value.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn monsters
			 * every tick.
			 * A value of 400 will mean the server will attempt to spawn monsters
			 * every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note: If set to 0, monsters spawning will be disabled. We
			 * recommend using spawn-monsters to control this instead.
			 * 
			 * Minecraft default: 1.
			 */
			function getTicksPerMonsterSpawns(): number;

			/**
			 * Gets the default ticks per water mob spawns value.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn water mobs
			 * every tick.
			 * A value of 400 will mean the server will attempt to spawn water mobs
			 * every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note: If set to 0, water mobs spawning will be disabled.
			 * 
			 * Minecraft default: 1.
			 */
			function getTicksPerWaterSpawns(): number;

			/**
			 * Gets the default ticks per ambient mob spawns value.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn ambient mobs
			 * every tick.
			 * A value of 400 will mean the server will attempt to spawn ambient mobs
			 * every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note: If set to 0, ambient mobs spawning will be disabled.
			 * 
			 * Minecraft default: 1.
			 */
			function getTicksPerAmbientSpawns(): number;

			/**
			 * Gets the default ticks per water ambient mob spawns value.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn water ambient mobs
			 * every tick.
			 * A value of 400 will mean the server will attempt to spawn water ambient mobs
			 * every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note: If set to 0, ambient mobs spawning will be disabled.
			 * 
			 * Minecraft default: 1.
			 */
			function getTicksPerWaterAmbientSpawns(): number;

			/**
			 * Gets the default ticks per water underground creature spawns value.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn water underground creature
			 * every tick.
			 * A value of 400 will mean the server will attempt to spawn water underground creature
			 * every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note: If set to 0, water underground creature spawning will be disabled.
			 * 
			 * Minecraft default: 1.
			 */
			function getTicksPerWaterUndergroundCreatureSpawns(): number;

			/**
			 * Gets the default ticks per SpawnCategory spawns value.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn SpawnCategory mobs
			 * every tick.
			 * A value of 400 will mean the server will attempt to spawn SpawnCategory mobs
			 * every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note: If set to 0, SpawnCategory mobs spawning will be disabled.
			 * 
			 * Minecraft default: 1.
			 * 
			 * Note:  the SpawnCategory.MISC are not consider.
			 */
			function getTicksPerSpawns(spawnCategory: org.bukkit.entity.SpawnCategory): number;

			/**
			 * Gets a player object by the given username.
			 * 
			 * This method may not return objects for offline players.
			 */
			function getPlayer(name: string): (org.bukkit.entity.Player | null);

			/**
			 * Gets the player with the exact given name, case insensitive.
			 */
			function getPlayerExact(name: string): (org.bukkit.entity.Player | null);

			/**
			 * Attempts to match any players with the given name, and returns a list
			 * of all possibly matches.
			 * 
			 * This list is not sorted in any particular order. If an exact match is
			 * found, the returned list will only contain a single result.
			 */
			function matchPlayer(name: string): globalThis.java.util.List<org.bukkit.entity.Player>;

			/**
			 * Gets the player with the given UUID.
			 */
			function getPlayer(id: globalThis.java.util.UUID): (org.bukkit.entity.Player | null);

			/**
			 * Gets the plugin manager for interfacing with plugins.
			 */
			function getPluginManager(): org.bukkit.plugin.PluginManager;

			/**
			 * Gets the scheduler for managing scheduled events.
			 */
			function getScheduler(): org.bukkit.scheduler.BukkitScheduler;

			/**
			 * Gets a services manager.
			 */
			function getServicesManager(): org.bukkit.plugin.ServicesManager;

			/**
			 * Gets a list of all worlds on this server.
			 */
			function getWorlds(): globalThis.java.util.List<org.bukkit.World>;

			/**
			 * Creates or loads a world with the given name using the specified
			 * options.
			 * 
			 * If the world is already loaded, it will just return the equivalent of
			 * getWorld(creator.name()).
			 */
			function createWorld(creator: org.bukkit.WorldCreator): (org.bukkit.World | null);

			/**
			 * Unloads a world with the given name.
			 */
			function unloadWorld(name: string, save: boolean): boolean;

			/**
			 * Unloads the given world.
			 */
			function unloadWorld(world: org.bukkit.World, save: boolean): boolean;

			/**
			 * Gets the world with the given name.
			 */
			function getWorld(name: string): (org.bukkit.World | null);

			/**
			 * Gets the world from the given Unique ID.
			 */
			function getWorld(uid: globalThis.java.util.UUID): (org.bukkit.World | null);

			/**
			 * Create a new virtual WorldBorder.
			 */
			function createWorldBorder(): org.bukkit.WorldBorder;

			/**
			 * Gets the map from the given item ID.
			 */
			function getMap(id: number): (org.bukkit.map.MapView | null);

			/**
			 * Create a new map with an automatically assigned ID.
			 */
			function createMap(world: org.bukkit.World): org.bukkit.map.MapView;

			/**
			 * Create a new explorer map targeting the closest nearby structure of a
			 * given StructureType.
			 * 
			 * This method uses implementation default values for radius and
			 * findUnexplored (usually 100, true).
			 */
			function createExplorerMap(world: org.bukkit.World, location: org.bukkit.Location, structureType: org.bukkit.StructureType): org.bukkit.inventory.ItemStack;

			/**
			 * Create a new explorer map targeting the closest nearby structure of a
			 * given StructureType.
			 * 
			 * This method uses implementation default values for radius and
			 * findUnexplored (usually 100, true).
			 */
			function createExplorerMap(world: org.bukkit.World, location: org.bukkit.Location, structureType: org.bukkit.StructureType, radius: number, findUnexplored: boolean): org.bukkit.inventory.ItemStack;

			/**
			 * Reloads the server, refreshing settings and plugin information.
			 */
			function reload(): void;

			/**
			 * Reload only the Minecraft data for the server. This includes custom
			 * advancements and loot tables.
			 */
			function reloadData(): void;

			/**
			 * Returns the primary logger associated with this server instance.
			 */
			function getLogger(): globalThis.java.util.logging.Logger;

			/**
			 * Gets a PluginCommand with the given name or alias.
			 */
			function getPluginCommand(name: string): (org.bukkit.command.PluginCommand | null);

			/**
			 * Writes loaded players to disk.
			 */
			function savePlayers(): void;

			/**
			 * Dispatches a command on this server, and executes it if found.
			 */
			function dispatchCommand(sender: org.bukkit.command.CommandSender, commandLine: string): boolean;

			/**
			 * Adds a recipe to the crafting manager.
			 */
			function addRecipe(recipe: (org.bukkit.inventory.Recipe | null)): boolean;

			/**
			 * Get a list of all recipes for a given item. The stack size is ignored
			 * in comparisons. If the durability is -1, it will match any data value.
			 */
			function getRecipesFor(result: org.bukkit.inventory.ItemStack): globalThis.java.util.List<org.bukkit.inventory.Recipe>;

			/**
			 * Get the Recipe for the given key.
			 */
			function getRecipe(recipeKey: org.bukkit.NamespacedKey): (org.bukkit.inventory.Recipe | null);

			/**
			 * Get the Recipe for the list of ItemStacks provided.
			 * The list is formatted as a crafting matrix where the index follow
			 * the pattern below:
			 * [ 0 1 2 ]
			 * [ 3 4 5 ]
			 * [ 6 7 8 ]
			 * 
			 * NOTE: This method will not modify the provided ItemStack array, for that, use
			 * craftItem(ItemStack[], World, Player).
			 */
			function getCraftingRecipe(craftingMatrix: org.bukkit.inventory.ItemStack[], world: org.bukkit.World): (org.bukkit.inventory.Recipe | null);

			/**
			 * Get the crafted item using the list of ItemStack provided.
			 * The list is formatted as a crafting matrix where the index follow
			 * the pattern below:
			 * [ 0 1 2 ]
			 * [ 3 4 5 ]
			 * [ 6 7 8 ]
			 * 
			 * The World and Player arguments are required to fulfill the Bukkit Crafting
			 * events.
			 * Calls PrepareItemCraftEvent to imitate the Player
			 * initiating the crafting event.
			 */
			function craftItemResult(craftingMatrix: org.bukkit.inventory.ItemStack[], world: org.bukkit.World, player: org.bukkit.entity.Player): org.bukkit.inventory.ItemCraftResult;

			/**
			 * Get the crafted item using the list of ItemStack provided.
			 * The list is formatted as a crafting matrix where the index follow
			 * the pattern below:
			 * [ 0 1 2 ]
			 * [ 3 4 5 ]
			 * [ 6 7 8 ]
			 * 
			 */
			function craftItemResult(craftingMatrix: org.bukkit.inventory.ItemStack[], world: org.bukkit.World): org.bukkit.inventory.ItemCraftResult;

			/**
			 * Get the crafted item using the list of ItemStack provided.
			 * The list is formatted as a crafting matrix where the index follow
			 * the pattern below:
			 * [ 0 1 2 ]
			 * [ 3 4 5 ]
			 * [ 6 7 8 ]
			 * 
			 * The World and Player arguments are required to fulfill the Bukkit Crafting
			 * events.
			 * Calls PrepareItemCraftEvent to imitate the Player
			 * initiating the crafting event.
			 */
			function craftItem(craftingMatrix: org.bukkit.inventory.ItemStack[], world: org.bukkit.World, player: org.bukkit.entity.Player): org.bukkit.inventory.ItemStack;

			/**
			 * Get the crafted item using the list of ItemStack provided.
			 * The list is formatted as a crafting matrix where the index follow
			 * the pattern below:
			 * [ 0 1 2 ]
			 * [ 3 4 5 ]
			 * [ 6 7 8 ]
			 * 
			 */
			function craftItem(craftingMatrix: org.bukkit.inventory.ItemStack[], world: org.bukkit.World): org.bukkit.inventory.ItemStack;

			/**
			 * Get an iterator through the list of crafting recipes.
			 */
			function recipeIterator(): globalThis.java.util.Iterator<org.bukkit.inventory.Recipe>;

			/**
			 * Clears the list of crafting recipes.
			 */
			function clearRecipes(): void;

			/**
			 * Resets the list of crafting recipes to the default.
			 */
			function resetRecipes(): void;

			/**
			 * Remove a recipe from the server.
			 * Note that removing a recipe may cause permanent loss of data
			 * associated with that recipe (eg whether it has been discovered by
			 * players).
			 */
			function removeRecipe(key: org.bukkit.NamespacedKey): boolean;

			/**
			 * Gets a list of command aliases defined in the server properties.
			 */
			function getCommandAliases(): globalThis.java.util.Map<string>;

			/**
			 * Gets the radius, in blocks, around each worlds spawn point to protect.
			 */
			function getSpawnRadius(): number;

			/**
			 * Sets the radius, in blocks, around each worlds spawn point to protect.
			 */
			function setSpawnRadius(value: number): void;

			/**
			 * Gets whether the server should send a preview of the player's chat
			 * message to the client when the player sends a message
			 */
			function shouldSendChatPreviews(): boolean;

			/**
			 * Gets whether the server only allow players with Mojang-signed public key
			 * to join
			 */
			function isEnforcingSecureProfiles(): boolean;

			/**
			 * Gets whether this server is allowing connections transferred from other
			 * servers.
			 */
			function isAcceptingTransfers(): boolean;

			/**
			 * Gets whether the Server hide online players in server status.
			 */
			function getHideOnlinePlayers(): boolean;

			/**
			 * Gets whether the Server is in online mode or not.
			 */
			function getOnlineMode(): boolean;

			/**
			 * Gets whether this server allows flying or not.
			 */
			function getAllowFlight(): boolean;

			/**
			 * Gets whether the server is in hardcore mode or not.
			 */
			function isHardcore(): boolean;

			/**
			 * Shutdowns the server, stopping everything.
			 */
			function shutdown(): void;

			/**
			 * Broadcasts the specified message to every user with the given
			 * permission name.
			 */
			function broadcast(message: string, permission: string): number;

			/**
			 * Gets the player by the given name, regardless if they are offline or
			 * online.
			 * 
			 * This method may involve a blocking web request to get the UUID for the
			 * given name.
			 * 
			 * This will return an object even if the player does not exist. To this
			 * method, all players will exist.
			 */
			function getOfflinePlayer(name: string): org.bukkit.OfflinePlayer;

			/**
			 * Gets the player by the given UUID, regardless if they are offline or
			 * online.
			 * 
			 * This will return an object even if the player does not exist. To this
			 * method, all players will exist.
			 */
			function getOfflinePlayer(id: globalThis.java.util.UUID): org.bukkit.OfflinePlayer;

			/**
			 * Creates a new PlayerProfile.
			 */
			function createPlayerProfile(uniqueId: (globalThis.java.util.UUID | null), name: (string | null)): org.bukkit.profile.PlayerProfile;

			/**
			 * Creates a new PlayerProfile.
			 */
			function createPlayerProfile(uniqueId: globalThis.java.util.UUID): org.bukkit.profile.PlayerProfile;

			/**
			 * Creates a new PlayerProfile.
			 */
			function createPlayerProfile(name: string): org.bukkit.profile.PlayerProfile;

			/**
			 * Gets a set containing all current IPs that are banned.
			 */
			function getIPBans(): globalThis.java.util.Set<string>;

			/**
			 * Bans the specified address from the server.
			 */
			function banIP(address: string): void;

			/**
			 * Unbans the specified address from the server.
			 */
			function unbanIP(address: string): void;

			/**
			 * Bans the specified address from the server.
			 */
			function banIP(address: any /* java.net.InetAddress */): void;

			/**
			 * Unbans the specified address from the server.
			 */
			function unbanIP(address: any /* java.net.InetAddress */): void;

			/**
			 * Gets a set containing all banned players.
			 */
			function getBannedPlayers(): globalThis.java.util.Set<org.bukkit.OfflinePlayer>;

			/**
			 * Gets a ban list for the supplied type.
			 */
			function getBanList<T = any>(type: org.bukkit.BanList.Type): T;

			/**
			 * Gets a set containing all player operators.
			 */
			function getOperators(): globalThis.java.util.Set<org.bukkit.OfflinePlayer>;

			/**
			 * Gets the default GameMode for new players.
			 */
			function getDefaultGameMode(): org.bukkit.GameMode;

			/**
			 * Sets the default GameMode for new players.
			 */
			function setDefaultGameMode(mode: org.bukkit.GameMode): void;

			/**
			 * Gets a ConsoleCommandSender that may be used as an input source
			 * for this server.
			 */
			function getConsoleSender(): org.bukkit.command.ConsoleCommandSender;

			/**
			 * Gets the folder that contains all of the various Worlds.
			 */
			function getWorldContainer(): any /* java.io.File */;

			/**
			 * Gets the Messenger responsible for this server.
			 */
			function getMessenger(): org.bukkit.plugin.messaging.Messenger;

			/**
			 * Gets the HelpMap providing help topics for this server.
			 */
			function getHelpMap(): org.bukkit.help.HelpMap;

			/**
			 * Creates an empty inventory with the specified type. If the type
			 * is InventoryType.CHEST, the new inventory has a size of 27;
			 * otherwise the new inventory has the normal size for its type.
			 * 
			 * InventoryType.WORKBENCH will not process crafting recipes if
			 * created with this method. Use
			 * HumanEntity.openWorkbench(Location, boolean) instead.
			 * 
			 * InventoryType.ENCHANTING will not process ItemStacks
			 * for possible enchanting results. Use
			 * HumanEntity.openEnchanting(Location, boolean) instead.
			 */
			function createInventory(owner: (org.bukkit.inventory.InventoryHolder | null), type: org.bukkit.event.inventory.InventoryType): org.bukkit.inventory.Inventory;

			/**
			 * Creates an empty inventory with the specified type and title. If the type
			 * is InventoryType.CHEST, the new inventory has a size of 27;
			 * otherwise the new inventory has the normal size for its type.
			 * It should be noted that some inventory types do not support titles and
			 * may not render with said titles on the Minecraft client.
			 * 
			 * InventoryType.WORKBENCH will not process crafting recipes if
			 * created with this method. Use
			 * HumanEntity.openWorkbench(Location, boolean) instead.
			 * 
			 * InventoryType.ENCHANTING will not process ItemStacks
			 * for possible enchanting results. Use
			 * HumanEntity.openEnchanting(Location, boolean) instead.
			 */
			function createInventory(owner: (org.bukkit.inventory.InventoryHolder | null), type: org.bukkit.event.inventory.InventoryType, title: string): org.bukkit.inventory.Inventory;

			/**
			 * Creates an empty inventory of type InventoryType.CHEST with the
			 * specified size.
			 */
			function createInventory(owner: (org.bukkit.inventory.InventoryHolder | null), size: number): org.bukkit.inventory.Inventory;

			/**
			 * Creates an empty inventory of type InventoryType.CHEST with the
			 * specified size and title.
			 */
			function createInventory(owner: (org.bukkit.inventory.InventoryHolder | null), size: number, title: string): org.bukkit.inventory.Inventory;

			/**
			 * Creates an empty merchant.
			 */
			function createMerchant(title: (string | null)): org.bukkit.inventory.Merchant;

			/**
			 * Gets the amount of consecutive neighbor updates before skipping
			 * additional ones.
			 */
			function getMaxChainedNeighborUpdates(): number;

			/**
			 * Gets user-specified limit for number of monsters that can spawn in a
			 * chunk.
			 */
			function getMonsterSpawnLimit(): number;

			/**
			 * Gets user-specified limit for number of animals that can spawn in a
			 * chunk.
			 */
			function getAnimalSpawnLimit(): number;

			/**
			 * Gets user-specified limit for number of water animals that can spawn in
			 * a chunk.
			 */
			function getWaterAnimalSpawnLimit(): number;

			/**
			 * Gets user-specified limit for number of water ambient mobs that can spawn
			 * in a chunk.
			 */
			function getWaterAmbientSpawnLimit(): number;

			/**
			 * Get user-specified limit for number of water creature underground that can spawn
			 * in a chunk.
			 */
			function getWaterUndergroundCreatureSpawnLimit(): number;

			/**
			 * Gets user-specified limit for number of ambient mobs that can spawn in
			 * a chunk.
			 */
			function getAmbientSpawnLimit(): number;

			/**
			 * Gets user-specified limit for number of SpawnCategory mobs that can spawn in
			 * a chunk.
			 * Note: the SpawnCategory.MISC are not consider.
			 */
			function getSpawnLimit(spawnCategory: org.bukkit.entity.SpawnCategory): number;

			/**
			 * Checks the current thread against the expected primary thread for the
			 * server.
			 * 
			 * Note: this method should not be used to indicate the current
			 * synchronized state of the runtime. A current thread matching the main
			 * thread indicates that it is synchronized, but a mismatch does not
			 * preclude the same assumption.
			 */
			function isPrimaryThread(): boolean;

			/**
			 * Gets the message that is displayed on the server list.
			 */
			function getMotd(): string;

			/**
			 * Set the message that is displayed on the server list.
			 */
			function setMotd(motd: string): void;

			/**
			 * Gets the server links which will be sent to clients
			 */
			function getServerLinks(): org.bukkit.ServerLinks;

			/**
			 * Gets the default message that is displayed when the server is stopped.
			 */
			function getShutdownMessage(): (string | null);

			/**
			 * Gets the current warning state for the server.
			 */
			function getWarningState(): org.bukkit.Warning.WarningState;

			/**
			 * Gets the instance of the item factory (for ItemMeta).
			 */
			function getItemFactory(): org.bukkit.inventory.ItemFactory;

			/**
			 * Gets the instance of the entity factory (for EntitySnapshot).
			 */
			function getEntityFactory(): org.bukkit.entity.EntityFactory;

			/**
			 * Gets the instance of the scoreboard manager.
			 * 
			 * This will only exist after the first world has loaded.
			 */
			function getScoreboardManager(): (org.bukkit.scoreboard.ScoreboardManager | null);

			/**
			 * Get (or create) a new Criteria by its name.
			 */
			function getScoreboardCriteria(name: string): org.bukkit.scoreboard.Criteria;

			/**
			 * Gets an instance of the server's default server-icon.
			 */
			function getServerIcon(): (org.bukkit.util.CachedServerIcon | null);

			/**
			 * Loads an image from a file, and returns a cached image for the specific
			 * server-icon.
			 * 
			 * Size and type are implementation defined. An incompatible file is
			 * guaranteed to throw an implementation-defined Exception.
			 */
			function loadServerIcon(file: any /* java.io.File */): org.bukkit.util.CachedServerIcon;

			/**
			 * Creates a cached server-icon for the specific image.
			 * 
			 * Size and type are implementation defined. An incompatible file is
			 * guaranteed to throw an implementation-defined Exception.
			 */
			function loadServerIcon(image: any /* java.awt.image.BufferedImage */): org.bukkit.util.CachedServerIcon;

			/**
			 * Set the idle kick timeout. Any players idle for the specified amount of
			 * time will be automatically kicked.
			 * 
			 * A value of 0 will disable the idle kick timeout.
			 */
			function setIdleTimeout(threshold: number): void;

			/**
			 * Gets the idle kick timeout.
			 */
			function getIdleTimeout(): number;

			/**
			 * Create a ChunkData for use in a generator.
			 * See ChunkGenerator.generateChunkData(org.bukkit.World, java.util.Random, int, int, org.bukkit.generator.ChunkGenerator.BiomeGrid)
			 */
			function createChunkData(world: org.bukkit.World): org.bukkit.generator.ChunkGenerator.ChunkData;

			/**
			 * Creates a boss bar instance to display to players. The progress
			 * defaults to 1.0
			 */
			function createBossBar(title: (string | null), color: org.bukkit.boss.BarColor, style: org.bukkit.boss.BarStyle, ...flags: org.bukkit.boss.BarFlag[]): org.bukkit.boss.BossBar;

			/**
			 * Creates a boss bar instance to display to players. The progress defaults
			 * to 1.0.
			 * 
			 * This instance is added to the persistent storage of the server and will
			 * be editable by commands and restored after restart.
			 */
			function createBossBar(key: org.bukkit.NamespacedKey, title: (string | null), color: org.bukkit.boss.BarColor, style: org.bukkit.boss.BarStyle, ...flags: org.bukkit.boss.BarFlag[]): org.bukkit.boss.KeyedBossBar;

			/**
			 * Gets an unmodifiable iterator through all persistent bossbars.
			 * 
			 * not bound to a Boss
			 * 
			 * not created using
			 * createBossBar(String, BarColor, BarStyle, BarFlag...)
			 * 
			 * 
			 * e.g. bossbars created using the bossbar command
			 */
			function getBossBars(): globalThis.java.util.Iterator<org.bukkit.boss.KeyedBossBar>;

			/**
			 * Gets the KeyedBossBar specified by this key.
			 * 
			 * not bound to a Boss
			 * 
			 * not created using
			 * createBossBar(String, BarColor, BarStyle, BarFlag...)
			 * 
			 * 
			 * e.g. bossbars created using the bossbar command
			 */
			function getBossBar(key: org.bukkit.NamespacedKey): (org.bukkit.boss.KeyedBossBar | null);

			/**
			 * Removes a KeyedBossBar specified by this key.
			 * 
			 * not bound to a Boss
			 * 
			 * not created using
			 * createBossBar(String, BarColor, BarStyle, BarFlag...)
			 * 
			 * 
			 * e.g. bossbars created using the bossbar command
			 */
			function removeBossBar(key: org.bukkit.NamespacedKey): boolean;

			/**
			 * Gets an entity on the server by its UUID
			 */
			function getEntity(uuid: globalThis.java.util.UUID): (org.bukkit.entity.Entity | null);

			/**
			 * Get the advancement specified by this key.
			 */
			function getAdvancement(key: org.bukkit.NamespacedKey): (org.bukkit.advancement.Advancement | null);

			/**
			 * Get an iterator through all advancements. Advancements cannot be removed
			 * from this iterator,
			 */
			function advancementIterator(): globalThis.java.util.Iterator<org.bukkit.advancement.Advancement>;

			/**
			 * Creates a new BlockData instance for the specified Material, with
			 * all properties initialized to unspecified defaults.
			 */
			function createBlockData(material: org.bukkit.Material): org.bukkit.block.data.BlockData;

			/**
			 * Creates a new BlockData instance for the specified Material, with
			 * all properties initialized to unspecified defaults.
			 */
			function createBlockData(material: org.bukkit.Material, consumer: ((value: org.bukkit.block.data.BlockData) => void | null)): org.bukkit.block.data.BlockData;

			/**
			 * Creates a new BlockData instance with material and properties
			 * parsed from provided data.
			 */
			function createBlockData(data: string): org.bukkit.block.data.BlockData;

			/**
			 * Creates a new BlockData instance for the specified Material, with
			 * all properties initialized to unspecified defaults, except for those
			 * provided in data.
			 */
			function createBlockData(material: (org.bukkit.Material | null), data: (string | null)): org.bukkit.block.data.BlockData;

			/**
			 * Gets a tag which has already been defined within the server. Plugins are
			 * suggested to use the concrete tags in Tag rather than this method
			 * which makes no guarantees about which tags are available, and may also be
			 * less performant due to lack of caching.
			 * 
			 * Tags will be searched for in an implementation specific manner, but a
			 * path consisting of namespace/tags/registry/key is expected.
			 * 
			 * Server implementations are allowed to handle only the registries
			 * indicated in Tag.
			 */
			function getTag<T = any>(registry: string, tag: org.bukkit.NamespacedKey, clazz: globalThis.java.lang.Class<T>): (org.bukkit.Tag<T> | null);

			/**
			 * Gets a all tags which have been defined within the server.
			 * 
			 * Server implementations are allowed to handle only the registries
			 * indicated in Tag.
			 * 
			 * No guarantees are made about the mutability of the returned iterator.
			 */
			function getTags<T = any>(registry: string, clazz: globalThis.java.lang.Class<T>): globalThis.java.lang.Iterable<org.bukkit.Tag<T>>;

			/**
			 * Gets the specified LootTable.
			 */
			function getLootTable(key: org.bukkit.NamespacedKey): (org.bukkit.loot.LootTable | null);

			/**
			 * Selects entities using the given Vanilla selector.
			 * 
			 * No guarantees are made about the selector format, other than they match
			 * the Vanilla format for the active Minecraft version.
			 * 
			 * Usually a selector will start with '@', unless selecting a Player in
			 * which case it may simply be the Player's name or UUID.
			 * 
			 * Note that in Vanilla, elevated permissions are usually required to use
			 * '@' selectors, but this method should not check such permissions from the
			 * sender.
			 */
			function selectEntities(sender: org.bukkit.command.CommandSender, selector: string): globalThis.java.util.List<org.bukkit.entity.Entity>;

			/**
			 * Gets the structure manager for loading and saving structures.
			 */
			function getStructureManager(): org.bukkit.structure.StructureManager;

			/**
			 * Returns the registry for the given class.
			 * 
			 * If no registry is present for the given class null will be returned.
			 * 
			 * Depending on the implementation not every registry present in
			 * Registry will be returned by this method.
			 */
			function getRegistry<T = any>(tClass: globalThis.java.lang.Class<T>): (org.bukkit.Registry<T> | null);

			function getUnsafe(): org.bukkit.UnsafeValues;

		}
		interface ChatColor {
			asBungee(): any /* net.md_5.bungee.api.ChatColor */;

			/**
			 * Gets the char value associated with this color
			 */
			getChar(): any /* char */;

			toString(): string;

			/**
			 * Checks if this code is a format code as opposed to a color code.
			 */
			isFormat(): boolean;

			/**
			 * Checks if this code is a color code as opposed to a format code.
			 */
			isColor(): boolean;

		}
		namespace ChatColor {
			/**
			 * Represents black
			 */
			const BLACK: org.bukkit.ChatColor;

			/**
			 * Represents dark blue
			 */
			const DARK_BLUE: org.bukkit.ChatColor;

			/**
			 * Represents dark green
			 */
			const DARK_GREEN: org.bukkit.ChatColor;

			/**
			 * Represents dark blue (aqua)
			 */
			const DARK_AQUA: org.bukkit.ChatColor;

			/**
			 * Represents dark red
			 */
			const DARK_RED: org.bukkit.ChatColor;

			/**
			 * Represents dark purple
			 */
			const DARK_PURPLE: org.bukkit.ChatColor;

			/**
			 * Represents gold
			 */
			const GOLD: org.bukkit.ChatColor;

			/**
			 * Represents gray
			 */
			const GRAY: org.bukkit.ChatColor;

			/**
			 * Represents dark gray
			 */
			const DARK_GRAY: org.bukkit.ChatColor;

			/**
			 * Represents blue
			 */
			const BLUE: org.bukkit.ChatColor;

			/**
			 * Represents green
			 */
			const GREEN: org.bukkit.ChatColor;

			/**
			 * Represents aqua
			 */
			const AQUA: org.bukkit.ChatColor;

			/**
			 * Represents red
			 */
			const RED: org.bukkit.ChatColor;

			/**
			 * Represents light purple
			 */
			const LIGHT_PURPLE: org.bukkit.ChatColor;

			/**
			 * Represents yellow
			 */
			const YELLOW: org.bukkit.ChatColor;

			/**
			 * Represents white
			 */
			const WHITE: org.bukkit.ChatColor;

			/**
			 * Represents magical characters that change around randomly
			 */
			const MAGIC: org.bukkit.ChatColor;

			/**
			 * Makes the text bold.
			 */
			const BOLD: org.bukkit.ChatColor;

			/**
			 * Makes a line appear through the text.
			 */
			const STRIKETHROUGH: org.bukkit.ChatColor;

			/**
			 * Makes the text appear underlined.
			 */
			const UNDERLINE: org.bukkit.ChatColor;

			/**
			 * Makes the text italic.
			 */
			const ITALIC: org.bukkit.ChatColor;

			/**
			 * Resets all previous chat colors or formats.
			 */
			const RESET: org.bukkit.ChatColor;

			/**
			 * The special character which prefixes all chat colour codes. Use this if
			 * you need to dynamically convert colour codes from your custom format.
			 */
			const COLOR_CHAR: any /* char */;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.ChatColor;

			/**
			 * Gets the color represented by the specified color code
			 */
			function getByChar(code: any /* char */): (org.bukkit.ChatColor | null);

			/**
			 * Gets the color represented by the specified color code
			 */
			function getByChar(code: string): (org.bukkit.ChatColor | null);

			/**
			 * Strips the given message of all color codes
			 */
			function stripColor(input: (string | null)): (string | null);

			/**
			 * Translates a string using an alternate color code character into a
			 * string that uses the internal ChatColor.COLOR_CODE color code
			 * character. The alternate color code character will only be replaced if
			 * it is immediately followed by 0-9, A-F, a-f, K-O, k-o, R or r.
			 */
			function translateAlternateColorCodes(altColorChar: any /* char */, textToTranslate: string): string;

			/**
			 * Gets the ChatColors used at the end of the given input string.
			 */
			function getLastColors(input: string): string;

		}
		interface Chunk extends Modify<org.bukkit.persistence.PersistentDataHolder, {
			/**
			 * Gets the X-coordinate of this chunk
			 */
			getX(): number;

			/**
			 * Gets the Z-coordinate of this chunk
			 */
			getZ(): number;

			/**
			 * Gets the world containing this chunk
			 */
			getWorld(): org.bukkit.World;

			/**
			 * Gets a block from this chunk
			 */
			getBlock(x: number, y: number, z: number): org.bukkit.block.Block;

			/**
			 * Capture thread-safe read-only snapshot of chunk data
			 */
			getChunkSnapshot(): org.bukkit.ChunkSnapshot;

			/**
			 * Capture thread-safe read-only snapshot of chunk data
			 */
			getChunkSnapshot(includeMaxblocky: boolean, includeBiome: boolean, includeBiomeTempRain: boolean): org.bukkit.ChunkSnapshot;

			/**
			 * Checks if entities in this chunk are loaded.
			 */
			isEntitiesLoaded(): boolean;

			/**
			 * Checks if the chunk is fully generated.
			 */
			isGenerated(): boolean;

			/**
			 * Checks if the chunk is loaded.
			 */
			isLoaded(): boolean;

			/**
			 * Loads the chunk.
			 */
			load(generate: boolean): boolean;

			/**
			 * Loads the chunk.
			 */
			load(): boolean;

			/**
			 * Unloads and optionally saves the Chunk
			 */
			unload(save: boolean): boolean;

			/**
			 * Unloads and optionally saves the Chunk
			 */
			unload(): boolean;

			/**
			 * Checks if this chunk can spawn slimes without being a swamp biome.
			 */
			isSlimeChunk(): boolean;

			/**
			 * Gets whether the chunk at the specified chunk coordinates is force
			 * loaded.
			 * 
			 * A force loaded chunk will not be unloaded due to lack of player activity.
			 */
			isForceLoaded(): boolean;

			/**
			 * Sets whether the chunk at the specified chunk coordinates is force
			 * loaded.
			 * 
			 * A force loaded chunk will not be unloaded due to lack of player activity.
			 */
			setForceLoaded(forced: boolean): void;

			/**
			 * Adds a plugin ticket for this chunk, loading this chunk if it is not
			 * already loaded.
			 * 
			 * A plugin ticket will prevent a chunk from unloading until it is
			 * explicitly removed. A plugin instance may only have one ticket per chunk,
			 * but each chunk can have multiple plugin tickets.
			 * 
			 */
			addPluginChunkTicket(plugin: org.bukkit.plugin.Plugin): boolean;

			/**
			 * Removes the specified plugin's ticket for this chunk
			 * 
			 * A plugin ticket will prevent a chunk from unloading until it is
			 * explicitly removed. A plugin instance may only have one ticket per chunk,
			 * but each chunk can have multiple plugin tickets.
			 * 
			 */
			removePluginChunkTicket(plugin: org.bukkit.plugin.Plugin): boolean;

			/**
			 * Retrieves a collection specifying which plugins have tickets for this
			 * chunk. This collection is not updated when plugin tickets are added or
			 * removed to this chunk.
			 * 
			 * A plugin ticket will prevent a chunk from unloading until it is
			 * explicitly removed. A plugin instance may only have one ticket per chunk,
			 * but each chunk can have multiple plugin tickets.
			 * 
			 */
			getPluginChunkTickets(): globalThis.java.util.Collection<org.bukkit.plugin.Plugin>;

			/**
			 * Gets the amount of time in ticks that this chunk has been inhabited.
			 * Note that the time is incremented once per tick per player within mob
			 * spawning distance of this chunk.
			 */
			getInhabitedTime(): number;

			/**
			 * Sets the amount of time in ticks that this chunk has been inhabited.
			 */
			setInhabitedTime(ticks: number): void;

			/**
			 * Tests if this chunk contains the specified block.
			 */
			contains(block: org.bukkit.block.data.BlockData): boolean;

			/**
			 * Tests if this chunk contains the specified biome.
			 */
			contains(biome: org.bukkit.block.Biome): boolean;

			/**
			 * Gets the load level of this chunk, which determines what game logic is
			 * processed.
			 */
			getLoadLevel(): org.bukkit.Chunk.LoadLevel;

			/**
			 * Gets all generated structures that intersect this chunk.
			 * If no structures are present an empty collection will be returned.
			 */
			getStructures(): globalThis.java.util.Collection<org.bukkit.generator.structure.GeneratedStructure>;

			/**
			 * Gets all generated structures of a given Structure that intersect
			 * this chunk.
			 * If no structures are present an empty collection will be returned.
			 */
			getStructures(structure: org.bukkit.generator.structure.Structure): globalThis.java.util.Collection<org.bukkit.generator.structure.GeneratedStructure>;

			/**
			 * Get a list of all players who are can view the chunk from their client
			 * 
			 * This list will be empty if no players are viewing the chunk, or the chunk
			 * is unloaded.
			 */
			getPlayersSeeingChunk(): globalThis.java.util.Collection<org.bukkit.entity.Player>;

		}> {}
		namespace Chunk {
			interface LoadLevel {}
			namespace LoadLevel {
				/**
				 * No game logic is processed, world generation may still occur.
				 */
				const INACCESSIBLE: org.bukkit.Chunk.LoadLevel;

				/**
				 * Most game logic is not processed, including entities and redstone.
				 */
				const BORDER: org.bukkit.Chunk.LoadLevel;

				/**
				 * All game logic except entities is processed.
				 */
				const TICKING: org.bukkit.Chunk.LoadLevel;

				/**
				 * All game logic is processed.
				 */
				const ENTITY_TICKING: org.bukkit.Chunk.LoadLevel;

				/**
				 * This chunk is not loaded.
				 */
				const UNLOADED: org.bukkit.Chunk.LoadLevel;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.Chunk.LoadLevel;

			}
		}
		interface ChunkSnapshot {
			/**
			 * Gets the X-coordinate of this chunk
			 */
			getX(): number;

			/**
			 * Gets the Z-coordinate of this chunk
			 */
			getZ(): number;

			/**
			 * Gets name of the world containing this chunk
			 */
			getWorldName(): string;

			/**
			 * Get block type for block at corresponding coordinate in the chunk
			 */
			getBlockType(x: number, y: number, z: number): org.bukkit.Material;

			/**
			 * Get block data for block at corresponding coordinate in the chunk
			 */
			getBlockData(x: number, y: number, z: number): org.bukkit.block.data.BlockData;

			/**
			 * Get block data for block at corresponding coordinate in the chunk
			 */
			getData(x: number, y: number, z: number): number;

			/**
			 * Get sky light level for block at corresponding coordinate in the chunk
			 */
			getBlockSkyLight(x: number, y: number, z: number): number;

			/**
			 * Get light level emitted by block at corresponding coordinate in the
			 * chunk
			 */
			getBlockEmittedLight(x: number, y: number, z: number): number;

			/**
			 * Gets the highest non-air coordinate at the given coordinates
			 */
			getHighestBlockYAt(x: number, z: number): number;

			/**
			 * Get biome at given coordinates
			 */
			getBiome(x: number, z: number): org.bukkit.block.Biome;

			/**
			 * Get biome at given coordinates
			 */
			getBiome(x: number, y: number, z: number): org.bukkit.block.Biome;

			/**
			 * Get raw biome temperature at given coordinates
			 */
			getRawBiomeTemperature(x: number, z: number): number;

			/**
			 * Get raw biome temperature at given coordinates
			 */
			getRawBiomeTemperature(x: number, y: number, z: number): number;

			/**
			 * Get world full time when chunk snapshot was captured
			 */
			getCaptureFullTime(): number;

			/**
			 * Test if section is empty
			 */
			isSectionEmpty(sy: number): boolean;

			/**
			 * Tests if this snapshot contains the specified block.
			 */
			contains(block: org.bukkit.block.data.BlockData): boolean;

			/**
			 * Tests if this chunk contains the specified biome.
			 */
			contains(biome: org.bukkit.block.Biome): boolean;

		}
		interface CoalType {
			/**
			 * Gets the associated data value representing this type of coal
			 */
			getData(): any /* byte */;

		}
		namespace CoalType {
			const COAL: org.bukkit.CoalType;

			const CHARCOAL: org.bukkit.CoalType;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.CoalType;

			/**
			 * Gets the type of coal with the given data value
			 */
			function getByData(data: any /* byte */): (org.bukkit.CoalType | null);

		}
		interface Color {
			/**
			 * Gets the alpha component
			 */
			getAlpha(): number;

			/**
			 * Creates a new Color object with specified component
			 */
			setAlpha(alpha: number): org.bukkit.Color;

			/**
			 * Gets the red component
			 */
			getRed(): number;

			/**
			 * Creates a new Color object with specified component
			 */
			setRed(red: number): org.bukkit.Color;

			/**
			 * Gets the green component
			 */
			getGreen(): number;

			/**
			 * Creates a new Color object with specified component
			 */
			setGreen(green: number): org.bukkit.Color;

			/**
			 * Gets the blue component
			 */
			getBlue(): number;

			/**
			 * Creates a new Color object with specified component
			 */
			setBlue(blue: number): org.bukkit.Color;

			/**
			 * Gets the color as an RGB integer.
			 */
			asRGB(): number;

			/**
			 * Gets the color as an ARGB integer.
			 */
			asARGB(): number;

			/**
			 * Gets the color as an BGR integer.
			 */
			asBGR(): number;

			/**
			 * Creates a new color with its RGB components changed as if it was dyed
			 * with the colors passed in, replicating vanilla workbench dyeing
			 */
			mixDyes(...colors: org.bukkit.DyeColor[]): org.bukkit.Color;

			/**
			 * Creates a new color with its RGB components changed as if it was dyed
			 * with the colors passed in, replicating vanilla workbench dyeing.
			 * Note that this method does not currently take into account alpha
			 * components.
			 */
			mixColors(...colors: org.bukkit.Color[]): org.bukkit.Color;

			equals(o: any): boolean;

			hashCode(): number;

			/**
			 * Description copied from interface:Â ConfigurationSerializable
			 */
			serialize(): globalThis.java.util.Map<string, any>;

			toString(): string;

		}
		namespace Color {
			/**
			 * White, or (0xFF,0xFF,0xFF) in (R,G,B)
			 */
			const WHITE: org.bukkit.Color;

			/**
			 * Silver, or (0xC0,0xC0,0xC0) in (R,G,B)
			 */
			const SILVER: org.bukkit.Color;

			/**
			 * Gray, or (0x80,0x80,0x80) in (R,G,B)
			 */
			const GRAY: org.bukkit.Color;

			/**
			 * Black, or (0x00,0x00,0x00) in (R,G,B)
			 */
			const BLACK: org.bukkit.Color;

			/**
			 * Red, or (0xFF,0x00,0x00) in (R,G,B)
			 */
			const RED: org.bukkit.Color;

			/**
			 * Maroon, or (0x80,0x00,0x00) in (R,G,B)
			 */
			const MAROON: org.bukkit.Color;

			/**
			 * Yellow, or (0xFF,0xFF,0x00) in (R,G,B)
			 */
			const YELLOW: org.bukkit.Color;

			/**
			 * Olive, or (0x80,0x80,0x00) in (R,G,B)
			 */
			const OLIVE: org.bukkit.Color;

			/**
			 * Lime, or (0x00,0xFF,0x00) in (R,G,B)
			 */
			const LIME: org.bukkit.Color;

			/**
			 * Green, or (0x00,0x80,0x00) in (R,G,B)
			 */
			const GREEN: org.bukkit.Color;

			/**
			 * Aqua, or (0x00,0xFF,0xFF) in (R,G,B)
			 */
			const AQUA: org.bukkit.Color;

			/**
			 * Teal, or (0x00,0x80,0x80) in (R,G,B)
			 */
			const TEAL: org.bukkit.Color;

			/**
			 * Blue, or (0x00,0x00,0xFF) in (R,G,B)
			 */
			const BLUE: org.bukkit.Color;

			/**
			 * Navy, or (0x00,0x00,0x80) in (R,G,B)
			 */
			const NAVY: org.bukkit.Color;

			/**
			 * Fuchsia, or (0xFF,0x00,0xFF) in (R,G,B)
			 */
			const FUCHSIA: org.bukkit.Color;

			/**
			 * Purple, or (0x80,0x00,0x80) in (R,G,B)
			 */
			const PURPLE: org.bukkit.Color;

			/**
			 * Orange, or (0xFF,0xA5,0x00) in (R,G,B)
			 */
			const ORANGE: org.bukkit.Color;

			/**
			 * Creates a new Color object from an alpha, red, green, and blue
			 */
			function fromARGB(alpha: number, red: number, green: number, blue: number): org.bukkit.Color;

			/**
			 * Creates a new Color object from a red, green, and blue
			 */
			function fromRGB(red: number, green: number, blue: number): org.bukkit.Color;

			/**
			 * Creates a new Color object from a blue, green, and red
			 */
			function fromBGR(blue: number, green: number, red: number): org.bukkit.Color;

			/**
			 * Creates a new color object from an integer that contains the red,
			 * green, and blue bytes in the lowest order 24 bits.
			 */
			function fromRGB(rgb: number): org.bukkit.Color;

			/**
			 * Creates a new color object from an integer that contains the alpha, red,
			 * green, and blue bytes.
			 */
			function fromARGB(argb: number): org.bukkit.Color;

			/**
			 * Creates a new color object from an integer that contains the blue,
			 * green, and red bytes in the lowest order 24 bits.
			 */
			function fromBGR(bgr: number): org.bukkit.Color;

			function deserialize(map: globalThis.java.util.Map<string, any>): org.bukkit.Color;

		}
		interface CropState {
			/**
			 * Gets the associated data value representing this growth state
			 */
			getData(): any /* byte */;

		}
		namespace CropState {
			/**
			 * State when first seeded
			 */
			const SEEDED: org.bukkit.CropState;

			/**
			 * First growth stage
			 */
			const GERMINATED: org.bukkit.CropState;

			/**
			 * Second growth stage
			 */
			const VERY_SMALL: org.bukkit.CropState;

			/**
			 * Third growth stage
			 */
			const SMALL: org.bukkit.CropState;

			/**
			 * Fourth growth stage
			 */
			const MEDIUM: org.bukkit.CropState;

			/**
			 * Fifth growth stage
			 */
			const TALL: org.bukkit.CropState;

			/**
			 * Almost ripe stage
			 */
			const VERY_TALL: org.bukkit.CropState;

			/**
			 * Ripe stage
			 */
			const RIPE: org.bukkit.CropState;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.CropState;

			/**
			 * Gets the CropState with the given data value
			 */
			function getByData(data: any /* byte */): (org.bukkit.CropState | null);

		}
		interface Difficulty {
			/**
			 * Gets the difficulty value associated with this Difficulty.
			 */
			getValue(): number;

		}
		namespace Difficulty {
			/**
			 * Players regain health over time, hostile mobs don't spawn, the hunger
			 * bar does not deplete.
			 */
			const PEACEFUL: org.bukkit.Difficulty;

			/**
			 * Hostile mobs spawn, enemies deal less damage than on normal difficulty,
			 * the hunger bar does deplete and starving deals up to 5 hearts of
			 * damage. (Default value)
			 */
			const EASY: org.bukkit.Difficulty;

			/**
			 * Hostile mobs spawn, enemies deal normal amounts of damage, the hunger
			 * bar does deplete and starving deals up to 9.5 hearts of damage.
			 */
			const NORMAL: org.bukkit.Difficulty;

			/**
			 * Hostile mobs spawn, enemies deal greater damage than on normal
			 * difficulty, the hunger bar does deplete and starving can kill players.
			 */
			const HARD: org.bukkit.Difficulty;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.Difficulty;

			/**
			 * Gets the Difficulty represented by the specified value
			 */
			function getByValue(value: number): (org.bukkit.Difficulty | null);

		}
		interface DyeColor {
			/**
			 * Gets the associated wool data value representing this color.
			 */
			getWoolData(): any /* byte */;

			/**
			 * Gets the associated dye data value representing this color.
			 */
			getDyeData(): any /* byte */;

			/**
			 * Gets the color that this dye represents.
			 */
			getColor(): org.bukkit.Color;

			/**
			 * Gets the firework color that this dye represents.
			 */
			getFireworkColor(): org.bukkit.Color;

		}
		namespace DyeColor {
			/**
			 * Represents white dye.
			 */
			const WHITE: org.bukkit.DyeColor;

			/**
			 * Represents orange dye.
			 */
			const ORANGE: org.bukkit.DyeColor;

			/**
			 * Represents magenta dye.
			 */
			const MAGENTA: org.bukkit.DyeColor;

			/**
			 * Represents light blue dye.
			 */
			const LIGHT_BLUE: org.bukkit.DyeColor;

			/**
			 * Represents yellow dye.
			 */
			const YELLOW: org.bukkit.DyeColor;

			/**
			 * Represents lime dye.
			 */
			const LIME: org.bukkit.DyeColor;

			/**
			 * Represents pink dye.
			 */
			const PINK: org.bukkit.DyeColor;

			/**
			 * Represents gray dye.
			 */
			const GRAY: org.bukkit.DyeColor;

			/**
			 * Represents light gray dye.
			 */
			const LIGHT_GRAY: org.bukkit.DyeColor;

			/**
			 * Represents cyan dye.
			 */
			const CYAN: org.bukkit.DyeColor;

			/**
			 * Represents purple dye.
			 */
			const PURPLE: org.bukkit.DyeColor;

			/**
			 * Represents blue dye.
			 */
			const BLUE: org.bukkit.DyeColor;

			/**
			 * Represents brown dye.
			 */
			const BROWN: org.bukkit.DyeColor;

			/**
			 * Represents green dye.
			 */
			const GREEN: org.bukkit.DyeColor;

			/**
			 * Represents red dye.
			 */
			const RED: org.bukkit.DyeColor;

			/**
			 * Represents black dye.
			 */
			const BLACK: org.bukkit.DyeColor;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.DyeColor;

			/**
			 * Gets the DyeColor with the given wool data value.
			 */
			function getByWoolData(data: any /* byte */): (org.bukkit.DyeColor | null);

			/**
			 * Gets the DyeColor with the given dye data value.
			 */
			function getByDyeData(data: any /* byte */): (org.bukkit.DyeColor | null);

			/**
			 * Gets the DyeColor with the given color value.
			 */
			function getByColor(color: org.bukkit.Color): (org.bukkit.DyeColor | null);

			/**
			 * Gets the DyeColor with the given firework color value.
			 */
			function getByFireworkColor(color: org.bukkit.Color): (org.bukkit.DyeColor | null);

			/**
			 * Gets the DyeColor for the given name, possibly doing legacy transformations.
			 */
			function legacyValueOf(name: (string | null)): org.bukkit.DyeColor;

		}
		interface Effect {
			/**
			 * Gets the ID for this effect.
			 */
			getId(): number;

			getType(): org.bukkit.Effect.Type;

			getData(): (globalThis.java.lang.Class | null);

		}
		namespace Effect {
			/**
			 * An alternate click sound.
			 */
			const CLICK2: org.bukkit.Effect;

			/**
			 * A click sound.
			 */
			const CLICK1: org.bukkit.Effect;

			/**
			 * Sound of a bow firing.
			 */
			const BOW_FIRE: org.bukkit.Effect;

			/**
			 * Sound of a door opening.
			 */
			const DOOR_TOGGLE: org.bukkit.Effect;

			/**
			 * Sound of a door opening.
			 */
			const IRON_DOOR_TOGGLE: org.bukkit.Effect;

			/**
			 * Sound of a trapdoor opening.
			 */
			const TRAPDOOR_TOGGLE: org.bukkit.Effect;

			/**
			 * Sound of a door opening.
			 */
			const IRON_TRAPDOOR_TOGGLE: org.bukkit.Effect;

			/**
			 * Sound of a door opening.
			 */
			const FENCE_GATE_TOGGLE: org.bukkit.Effect;

			/**
			 * Sound of a door closing.
			 */
			const DOOR_CLOSE: org.bukkit.Effect;

			/**
			 * Sound of a door closing.
			 */
			const IRON_DOOR_CLOSE: org.bukkit.Effect;

			/**
			 * Sound of a trapdoor closing.
			 */
			const TRAPDOOR_CLOSE: org.bukkit.Effect;

			/**
			 * Sound of a door closing.
			 */
			const IRON_TRAPDOOR_CLOSE: org.bukkit.Effect;

			/**
			 * Sound of a door closing.
			 */
			const FENCE_GATE_CLOSE: org.bukkit.Effect;

			/**
			 * Sound of fire being extinguished.
			 */
			const EXTINGUISH: org.bukkit.Effect;

			/**
			 * A song from a record. Needs the record item ID as additional info
			 */
			const RECORD_PLAY: org.bukkit.Effect;

			/**
			 * Sound of ghast shrieking.
			 */
			const GHAST_SHRIEK: org.bukkit.Effect;

			/**
			 * Sound of ghast firing.
			 */
			const GHAST_SHOOT: org.bukkit.Effect;

			/**
			 * Sound of blaze firing.
			 */
			const BLAZE_SHOOT: org.bukkit.Effect;

			/**
			 * Sound of zombies chewing on wooden doors.
			 */
			const ZOMBIE_CHEW_WOODEN_DOOR: org.bukkit.Effect;

			/**
			 * Sound of zombies chewing on iron doors.
			 */
			const ZOMBIE_CHEW_IRON_DOOR: org.bukkit.Effect;

			/**
			 * Sound of zombies destroying a door.
			 */
			const ZOMBIE_DESTROY_DOOR: org.bukkit.Effect;

			/**
			 * A visual smoke effect. Needs direction as additional info.
			 */
			const SMOKE: org.bukkit.Effect;

			/**
			 * Sound of a block breaking. Needs block ID as additional info.
			 */
			const STEP_SOUND: org.bukkit.Effect;

			/**
			 * Visual effect of a splash potion breaking. Needs potion data value as
			 * additional info.
			 */
			const POTION_BREAK: org.bukkit.Effect;

			/**
			 * Visual effect of an instant splash potion breaking. Needs color data
			 * value as additional info.
			 */
			const INSTANT_POTION_BREAK: org.bukkit.Effect;

			/**
			 * An ender eye signal; a visual effect.
			 */
			const ENDER_SIGNAL: org.bukkit.Effect;

			/**
			 * The flames seen on a mobspawner; a visual effect.
			 */
			const MOBSPAWNER_FLAMES: org.bukkit.Effect;

			/**
			 * The sound played by brewing stands when brewing
			 */
			const BREWING_STAND_BREW: org.bukkit.Effect;

			/**
			 * The sound played when a chorus flower grows
			 */
			const CHORUS_FLOWER_GROW: org.bukkit.Effect;

			/**
			 * The sound played when a chorus flower dies
			 */
			const CHORUS_FLOWER_DEATH: org.bukkit.Effect;

			/**
			 * The sound played when traveling through a portal
			 */
			const PORTAL_TRAVEL: org.bukkit.Effect;

			/**
			 * The sound played when launching an endereye
			 */
			const ENDEREYE_LAUNCH: org.bukkit.Effect;

			/**
			 * The sound played when launching a firework
			 */
			const FIREWORK_SHOOT: org.bukkit.Effect;

			/**
			 * Particles displayed when a villager grows a plant, data
			 * is the number of particles
			 */
			const VILLAGER_PLANT_GROW: org.bukkit.Effect;

			/**
			 * The sound/particles used by the enderdragon's breath
			 * attack.
			 */
			const DRAGON_BREATH: org.bukkit.Effect;

			/**
			 * The sound played when an anvil breaks
			 */
			const ANVIL_BREAK: org.bukkit.Effect;

			/**
			 * The sound played when an anvil is used
			 */
			const ANVIL_USE: org.bukkit.Effect;

			/**
			 * The sound played when an anvil lands after
			 * falling
			 */
			const ANVIL_LAND: org.bukkit.Effect;

			/**
			 * Sound of an enderdragon firing
			 */
			const ENDERDRAGON_SHOOT: org.bukkit.Effect;

			/**
			 * The sound played when a wither breaks a block
			 */
			const WITHER_BREAK_BLOCK: org.bukkit.Effect;

			/**
			 * Sound of a wither shooting
			 */
			const WITHER_SHOOT: org.bukkit.Effect;

			/**
			 * The sound played when a zombie infects a target
			 */
			const ZOMBIE_INFECT: org.bukkit.Effect;

			/**
			 * The sound played when a villager is converted by
			 * a zombie
			 */
			const ZOMBIE_CONVERTED_VILLAGER: org.bukkit.Effect;

			/**
			 * Sound played by a bat taking off
			 */
			const BAT_TAKEOFF: org.bukkit.Effect;

			/**
			 * The sound/particles caused by a end gateway spawning
			 */
			const END_GATEWAY_SPAWN: org.bukkit.Effect;

			/**
			 * The sound of an enderdragon growling
			 */
			const ENDERDRAGON_GROWL: org.bukkit.Effect;

			/**
			 * The sound played when phantom bites.
			 */
			const PHANTOM_BITE: org.bukkit.Effect;

			/**
			 * The sound played when a zombie converts to a drowned.
			 */
			const ZOMBIE_CONVERTED_TO_DROWNED: org.bukkit.Effect;

			/**
			 * The sound played when a husk converts to a zombie.
			 */
			const HUSK_CONVERTED_TO_ZOMBIE: org.bukkit.Effect;

			/**
			 * The sound played when a grindstone is being used.
			 */
			const GRINDSTONE_USE: org.bukkit.Effect;

			/**
			 * The sound played when a book page is being turned.
			 */
			const BOOK_PAGE_TURN: org.bukkit.Effect;

			/**
			 * The sound played when a smithing table is being used.
			 */
			const SMITHING_TABLE_USE: org.bukkit.Effect;

			/**
			 * The sound played when a pointed dripstone hits the surface.
			 */
			const POINTED_DRIPSTONE_LAND: org.bukkit.Effect;

			/**
			 * The sound played when a pointed dripstone drips lava into a cauldron.
			 */
			const POINTED_DRIPSTONE_DRIP_LAVA_INTO_CAULDRON: org.bukkit.Effect;

			/**
			 * The sound played when a pointed dripstone drips water into a cauldron.
			 */
			const POINTED_DRIPSTONE_DRIP_WATER_INTO_CAULDRON: org.bukkit.Effect;

			/**
			 * The sound played when a skeleton converts to a stray.
			 */
			const SKELETON_CONVERTED_TO_STRAY: org.bukkit.Effect;

			/**
			 * The sound played / particles shown when a composter is being attempted to
			 * fill.
			 * True for a successful attempt false for an unsuccessful attempt.
			 */
			const COMPOSTER_FILL_ATTEMPT: org.bukkit.Effect;

			/**
			 * The sound played / particles shown when lava interacts with the world.
			 * For example by forming stone, obsidian, basalt or destroying blocks such
			 * as torches.
			 */
			const LAVA_INTERACT: org.bukkit.Effect;

			/**
			 * The sound played / particles shown when a redstone torch burns out.
			 */
			const REDSTONE_TORCH_BURNOUT: org.bukkit.Effect;

			/**
			 * The sound played / particles shown when an eye of ender is placed into an
			 * ender portal frame.
			 */
			const END_PORTAL_FRAME_FILL: org.bukkit.Effect;

			/**
			 * The particles shown when a dripstone drips lava or water.
			 * This effect requires a dripstone at the location as well as lava or water
			 * at the root of the dripstone.
			 */
			const DRIPPING_DRIPSTONE: org.bukkit.Effect;

			/**
			 * The sound played / particles shown when bone meal is used to grow a
			 * plant.
			 * Data is the number of particles.
			 */
			const BONE_MEAL_USE: org.bukkit.Effect;

			/**
			 * The particles shown when an ender dragon destroys blocks.
			 */
			const ENDER_DRAGON_DESTROY_BLOCK: org.bukkit.Effect;

			/**
			 * The particles shown when a sponge dries in an ultra warm world (nether).
			 */
			const SPONGE_DRY: org.bukkit.Effect;

			/**
			 * The particles shown when a lightning hits a lightning rod or oxidized
			 * copper.
			 * Data is the axis at which the particle should be shown. If no data is
			 * provided it will show the particles at the block faces.
			 */
			const ELECTRIC_SPARK: org.bukkit.Effect;

			/**
			 * The sound played / particles shown when wax is applied to a copper block.
			 */
			const COPPER_WAX_ON: org.bukkit.Effect;

			/**
			 * The particles shown when wax is removed from a copper block.
			 */
			const COPPER_WAX_OFF: org.bukkit.Effect;

			/**
			 * The particles shown when oxidation is scraped of an oxidized copper
			 * block.
			 */
			const OXIDISED_COPPER_SCRAPE: org.bukkit.Effect;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.Effect;

			/**
			 * Gets the Effect associated with the given ID.
			 */
			function getById(id: number): (org.bukkit.Effect | null);

		}
		namespace Effect {
			interface Type {}
			namespace Type {
				const SOUND: org.bukkit.Effect.Type;

				const VISUAL: org.bukkit.Effect.Type;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.Effect.Type;

			}
		}
		interface EntityEffect {
			/**
			 * Gets the data value of this EntityEffect, may not be unique.
			 */
			getData(): any /* byte */;

			/**
			 * Gets entity superclass which this affect is applicable to.
			 */
			getApplicable(): globalThis.java.lang.Class<org.bukkit.entity.Entity>;

			/**
			 * Checks if this effect is applicable to the given entity.
			 */
			isApplicableTo(entity: org.bukkit.entity.Entity): boolean;

			/**
			 * Checks if this effect is applicable to the given entity class.
			 */
			isApplicableTo(clazz: globalThis.java.lang.Class<org.bukkit.entity.Entity>): boolean;

		}
		namespace EntityEffect {
			/**
			 * Colored particles from a tipped arrow.
			 */
			const ARROW_PARTICLES: org.bukkit.EntityEffect;

			/**
			 * Rabbit jumping.
			 */
			const RABBIT_JUMP: org.bukkit.EntityEffect;

			/**
			 * Resets a spawner minecart's delay to 200. Does not effect actual spawning
			 * delay, only the speed at which the entity in the spawner spins
			 */
			const RESET_SPAWNER_MINECART_DELAY: org.bukkit.EntityEffect;

			/**
			 * When mobs get hurt.
			 */
			const HURT: org.bukkit.EntityEffect;

			/**
			 * When a mob dies.
			 * 
			 * This will cause client-glitches!
			 */
			const DEATH: org.bukkit.EntityEffect;

			/**
			 * Spawns the egg breaking particles
			 */
			const EGG_BREAK: org.bukkit.EntityEffect;

			/**
			 * Spawns the snowball breaking particles
			 */
			const SNOWBALL_BREAK: org.bukkit.EntityEffect;

			/**
			 * Plays the entity death sound and animation
			 * 
			 * This will cause client-glitches!
			 */
			const ENTITY_DEATH: org.bukkit.EntityEffect;

			/**
			 * Plays the fang attack animation
			 */
			const FANG_ATTACK: org.bukkit.EntityEffect;

			/**
			 * Plays the hoglin attack animation
			 */
			const HOGLIN_ATTACK: org.bukkit.EntityEffect;

			/**
			 * Plays the iron golem attack animation
			 */
			const IRON_GOLEN_ATTACK: org.bukkit.EntityEffect;

			/**
			 * Plays the ravager attack animation
			 */
			const RAVAGER_ATTACK: org.bukkit.EntityEffect;

			/**
			 * Plays the warden attack animation
			 */
			const WARDEN_ATTACK: org.bukkit.EntityEffect;

			/**
			 * Plays the zoglin attack animation
			 */
			const ZOGLIN_ATTACK: org.bukkit.EntityEffect;

			/**
			 * The smoke when taming an entity fails.
			 */
			const WOLF_SMOKE: org.bukkit.EntityEffect;

			/**
			 * The hearts when taming an entity succeeds.
			 */
			const WOLF_HEARTS: org.bukkit.EntityEffect;

			/**
			 * When a wolf shakes (after being wet).
			 */
			const WOLF_SHAKE: org.bukkit.EntityEffect;

			/**
			 * When an entity eats a LONG_GRASS block.
			 */
			const SHEEP_EAT: org.bukkit.EntityEffect;

			/**
			 * Plays the sheep eating grass animation
			 */
			const SHEEP_EAT_GRASS: org.bukkit.EntityEffect;

			/**
			 * Causes the TNT minecart to ignite, does not play the ignition sound
			 * 
			 * This will cause client-glitches!
			 */
			const TNT_MINECART_IGNITE: org.bukkit.EntityEffect;

			/**
			 * When an Iron Golem gives a rose.
			 */
			const IRON_GOLEM_ROSE: org.bukkit.EntityEffect;

			/**
			 * Hearts from a villager.
			 */
			const VILLAGER_HEART: org.bukkit.EntityEffect;

			/**
			 * When a villager is angry.
			 */
			const VILLAGER_ANGRY: org.bukkit.EntityEffect;

			/**
			 * Happy particles from a villager.
			 */
			const VILLAGER_HAPPY: org.bukkit.EntityEffect;

			/**
			 * Magic particles from a witch.
			 */
			const WITCH_MAGIC: org.bukkit.EntityEffect;

			/**
			 * When a zombie transforms into a villager by shaking violently.
			 */
			const ZOMBIE_TRANSFORM: org.bukkit.EntityEffect;

			/**
			 * When a firework explodes.
			 */
			const FIREWORK_EXPLODE: org.bukkit.EntityEffect;

			/**
			 * Hearts from a breeding entity.
			 */
			const LOVE_HEARTS: org.bukkit.EntityEffect;

			/**
			 * Resets squid rotation.
			 */
			const SQUID_ROTATE: org.bukkit.EntityEffect;

			/**
			 * Silverfish entering block, spawner spawning.
			 */
			const ENTITY_POOF: org.bukkit.EntityEffect;

			/**
			 * Guardian plays the attack sound effect.
			 */
			const GUARDIAN_TARGET: org.bukkit.EntityEffect;

			/**
			 * Shield blocks attack.
			 */
			const SHIELD_BLOCK: org.bukkit.EntityEffect;

			/**
			 * Shield breaks.
			 */
			const SHIELD_BREAK: org.bukkit.EntityEffect;

			/**
			 * Armor stand is hit.
			 */
			const ARMOR_STAND_HIT: org.bukkit.EntityEffect;

			/**
			 * Entity hurt by thorns attack.
			 */
			const THORNS_HURT: org.bukkit.EntityEffect;

			/**
			 * Iron golem puts away rose.
			 */
			const IRON_GOLEM_SHEATH: org.bukkit.EntityEffect;

			/**
			 * Totem prevents entity death.
			 */
			const TOTEM_RESURRECT: org.bukkit.EntityEffect;

			/**
			 * Entity hurt due to drowning damage.
			 */
			const HURT_DROWN: org.bukkit.EntityEffect;

			/**
			 * Entity hurt due to explosion damage.
			 */
			const HURT_EXPLOSION: org.bukkit.EntityEffect;

			/**
			 * Dolphin has been fed and is locating a structure.
			 */
			const DOLPHIN_FED: org.bukkit.EntityEffect;

			/**
			 * Ravager has been stunned for 40 ticks.
			 */
			const RAVAGER_STUNNED: org.bukkit.EntityEffect;

			/**
			 * Cat taming failed.
			 */
			const CAT_TAME_FAIL: org.bukkit.EntityEffect;

			/**
			 * Cat taming succeeded.
			 */
			const CAT_TAME_SUCCESS: org.bukkit.EntityEffect;

			/**
			 * Villager splashes particles during a raid.
			 */
			const VILLAGER_SPLASH: org.bukkit.EntityEffect;

			/**
			 * Player's bad omen effect removed to start or increase raid difficult.
			 */
			const PLAYER_BAD_OMEN_RAID: org.bukkit.EntityEffect;

			/**
			 * Entity hurt due to berry bush. Prickly!
			 */
			const HURT_BERRY_BUSH: org.bukkit.EntityEffect;

			/**
			 * Fox chews the food in its mouth
			 */
			const FOX_CHEW: org.bukkit.EntityEffect;

			/**
			 * Entity teleported as a result of chorus fruit or as an enderman
			 */
			const TELEPORT_ENDER: org.bukkit.EntityEffect;

			/**
			 * Entity breaks item in main hand
			 */
			const BREAK_EQUIPMENT_MAIN_HAND: org.bukkit.EntityEffect;

			/**
			 * Entity breaks item in off hand
			 */
			const BREAK_EQUIPMENT_OFF_HAND: org.bukkit.EntityEffect;

			/**
			 * Entity breaks item in helmet slot
			 */
			const BREAK_EQUIPMENT_HELMET: org.bukkit.EntityEffect;

			/**
			 * Entity breaks item in chestplate slot
			 */
			const BREAK_EQUIPMENT_CHESTPLATE: org.bukkit.EntityEffect;

			/**
			 * Entity breaks item in legging slot
			 */
			const BREAK_EQUIPMENT_LEGGINGS: org.bukkit.EntityEffect;

			/**
			 * Entity breaks item in boot slot
			 */
			const BREAK_EQUIPMENT_BOOTS: org.bukkit.EntityEffect;

			/**
			 * Spawns honey block slide particles at the entity's feet
			 */
			const HONEY_BLOCK_SLIDE_PARTICLES: org.bukkit.EntityEffect;

			/**
			 * Spawns honey block fall particles at the entity's feet
			 */
			const HONEY_BLOCK_FALL_PARTICLES: org.bukkit.EntityEffect;

			/**
			 * Entity swaps the items in their hand and offhand
			 */
			const SWAP_HAND_ITEMS: org.bukkit.EntityEffect;

			/**
			 * Stops a wolf that is currently shaking
			 */
			const WOLF_SHAKE_STOP: org.bukkit.EntityEffect;

			/**
			 * Goat lowers its head for ramming
			 */
			const GOAT_LOWER_HEAD: org.bukkit.EntityEffect;

			/**
			 * Goat raises its head
			 */
			const GOAT_RAISE_HEAD: org.bukkit.EntityEffect;

			/**
			 * Spawns death smoke particles
			 */
			const SPAWN_DEATH_SMOKE: org.bukkit.EntityEffect;

			/**
			 * Warden shakes its tendrils
			 */
			const WARDEN_TENDRIL_SHAKE: org.bukkit.EntityEffect;

			/**
			 * Warden performs sonic attack animation
			 * Does not play the sound or fire the beam
			 */
			const WARDEN_SONIC_ATTACK: org.bukkit.EntityEffect;

			/**
			 * Plays sniffer digging sound
			 * Sniffer must have a target and be in Sniffer.State.SEARCHING or
			 * Sniffer.State.DIGGING
			 */
			const SNIFFER_DIG: org.bukkit.EntityEffect;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.EntityEffect;

		}
		interface FeatureFlag extends Modify<org.bukkit.Keyed, {}> {}
		namespace FeatureFlag {
			const VANILLA: org.bukkit.FeatureFlag;

			const BUNDLE: org.bukkit.FeatureFlag;

			/**
			 * AVAILABLE BETWEEN VERSIONS: 1.19 - 1.19.4
			 */
			const UPDATE_1_20: org.bukkit.FeatureFlag;

			const TRADE_REBALANCE: org.bukkit.FeatureFlag;

			/**
			 * AVAILABLE BETWEEN VERSIONS: 1.20.5 - 1.20.6
			 */
			const UPDATE_121: org.bukkit.FeatureFlag;

		}
		interface FireworkEffect {
			/**
			 * Get whether the firework effect flickers.
			 */
			hasFlicker(): boolean;

			/**
			 * Get whether the firework effect has a trail.
			 */
			hasTrail(): boolean;

			/**
			 * Get the primary colors of the firework effect.
			 */
			getColors(): globalThis.java.util.List<org.bukkit.Color>;

			/**
			 * Get the fade colors of the firework effect.
			 */
			getFadeColors(): globalThis.java.util.List<org.bukkit.Color>;

			/**
			 * Get the type of the firework effect.
			 */
			getType(): org.bukkit.FireworkEffect.Type;

			/**
			 * Description copied from interface:Â ConfigurationSerializable
			 */
			serialize(): globalThis.java.util.Map<string, any>;

			toString(): string;

			hashCode(): number;

			equals(obj: any): boolean;

		}
		namespace FireworkEffect {
			/**
			 * Construct a firework effect.
			 */
			function builder(): org.bukkit.FireworkEffect.Builder;

			function deserialize(map: globalThis.java.util.Map<string, any>): org.bukkit.configuration.serialization.ConfigurationSerializable;

		}
		namespace FireworkEffect {
			interface Builder {
				/**
				 * Specify the type of the firework effect.
				 */
				with(type: org.bukkit.FireworkEffect.Type): org.bukkit.FireworkEffect.Builder;

				/**
				 * Add a flicker to the firework effect.
				 */
				withFlicker(): org.bukkit.FireworkEffect.Builder;

				/**
				 * Set whether the firework effect should flicker.
				 */
				flicker(flicker: boolean): org.bukkit.FireworkEffect.Builder;

				/**
				 * Add a trail to the firework effect.
				 */
				withTrail(): org.bukkit.FireworkEffect.Builder;

				/**
				 * Set whether the firework effect should have a trail.
				 */
				trail(trail: boolean): org.bukkit.FireworkEffect.Builder;

				/**
				 * Add a primary color to the firework effect.
				 */
				withColor(color: org.bukkit.Color): org.bukkit.FireworkEffect.Builder;

				/**
				 * Add several primary colors to the firework effect.
				 */
				withColor(...colors: org.bukkit.Color[]): org.bukkit.FireworkEffect.Builder;

				/**
				 * Add several primary colors to the firework effect.
				 */
				withColor(colors: globalThis.java.lang.Iterable): org.bukkit.FireworkEffect.Builder;

				/**
				 * Add a fade color to the firework effect.
				 */
				withFade(color: org.bukkit.Color): org.bukkit.FireworkEffect.Builder;

				/**
				 * Add several fade colors to the firework effect.
				 */
				withFade(...colors: org.bukkit.Color[]): org.bukkit.FireworkEffect.Builder;

				/**
				 * Add several fade colors to the firework effect.
				 */
				withFade(colors: globalThis.java.lang.Iterable): org.bukkit.FireworkEffect.Builder;

				/**
				 * Create a FireworkEffect from the current contents of this
				 * builder.
				 * 
				 * To successfully build, you must have specified at least one color.
				 */
				build(): org.bukkit.FireworkEffect;

			}
		}
		namespace FireworkEffect {
			interface Type {}
			namespace Type {
				/**
				 * A small ball effect.
				 */
				const BALL: org.bukkit.FireworkEffect.Type;

				/**
				 * A large ball effect.
				 */
				const BALL_LARGE: org.bukkit.FireworkEffect.Type;

				/**
				 * A star-shaped effect.
				 */
				const STAR: org.bukkit.FireworkEffect.Type;

				/**
				 * A burst effect.
				 */
				const BURST: org.bukkit.FireworkEffect.Type;

				/**
				 * A creeper-face effect.
				 */
				const CREEPER: org.bukkit.FireworkEffect.Type;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.FireworkEffect.Type;

			}
		}
		interface Fluid {
			/**
			 * Description copied from interface:Â Keyed
			 */
			getKey(): org.bukkit.NamespacedKey;

		}
		namespace Fluid {
			/**
			 * Stationary water.
			 */
			const WATER: org.bukkit.Fluid;

			/**
			 * Flowing water.
			 */
			const FLOWING_WATER: org.bukkit.Fluid;

			/**
			 * Stationary lava.
			 */
			const LAVA: org.bukkit.Fluid;

			/**
			 * Flowing lava.
			 */
			const FLOWING_LAVA: org.bukkit.Fluid;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.Fluid;

		}
		interface FluidCollisionMode {}
		namespace FluidCollisionMode {
			/**
			 * Ignore fluids.
			 */
			const NEVER: org.bukkit.FluidCollisionMode;

			/**
			 * Only collide with source fluid blocks.
			 */
			const SOURCE_ONLY: org.bukkit.FluidCollisionMode;

			/**
			 * Collide with all fluids.
			 */
			const ALWAYS: org.bukkit.FluidCollisionMode;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.FluidCollisionMode;

		}
		interface GameEvent {
		}
		class GameEvent {
			constructor();

		}
		namespace GameEvent {
			const BLOCK_ACTIVATE: org.bukkit.GameEvent;

			const BLOCK_ATTACH: org.bukkit.GameEvent;

			const BLOCK_CHANGE: org.bukkit.GameEvent;

			const BLOCK_CLOSE: org.bukkit.GameEvent;

			const BLOCK_DEACTIVATE: org.bukkit.GameEvent;

			const BLOCK_DESTROY: org.bukkit.GameEvent;

			const BLOCK_DETACH: org.bukkit.GameEvent;

			const BLOCK_OPEN: org.bukkit.GameEvent;

			const BLOCK_PLACE: org.bukkit.GameEvent;

			const BLOCK_PRESS: org.bukkit.GameEvent;

			const BLOCK_SWITCH: org.bukkit.GameEvent;

			const BLOCK_UNPRESS: org.bukkit.GameEvent;

			const BLOCK_UNSWITCH: org.bukkit.GameEvent;

			const CONTAINER_CLOSE: org.bukkit.GameEvent;

			const CONTAINER_OPEN: org.bukkit.GameEvent;

			const DISPENSE_FAIL: org.bukkit.GameEvent;

			const DRINK: org.bukkit.GameEvent;

			const DRINKING_FINISH: org.bukkit.GameEvent;

			const EAT: org.bukkit.GameEvent;

			const ELYTRA_FREE_FALL: org.bukkit.GameEvent;

			const ELYTRA_GLIDE: org.bukkit.GameEvent;

			const ENTITY_DAMAGE: org.bukkit.GameEvent;

			const ENTITY_DAMAGED: org.bukkit.GameEvent;

			const ENTITY_DIE: org.bukkit.GameEvent;

			const ENTITY_DISMOUNT: org.bukkit.GameEvent;

			const ENTITY_DYING: org.bukkit.GameEvent;

			const ENTITY_INTERACT: org.bukkit.GameEvent;

			const ENTITY_MOUNT: org.bukkit.GameEvent;

			const ENTITY_KILLED: org.bukkit.GameEvent;

			const ENTITY_PLACE: org.bukkit.GameEvent;

			const ENTITY_ACTION: org.bukkit.GameEvent;

			const ENTITY_ROAR: org.bukkit.GameEvent;

			const ENTITY_SHAKE: org.bukkit.GameEvent;

			const EQUIP: org.bukkit.GameEvent;

			const EXPLODE: org.bukkit.GameEvent;

			const FLAP: org.bukkit.GameEvent;

			const FLUID_PICKUP: org.bukkit.GameEvent;

			const FLUID_PLACE: org.bukkit.GameEvent;

			const HIT_GROUND: org.bukkit.GameEvent;

			const INSTRUMENT_PLAY: org.bukkit.GameEvent;

			const ITEM_INTERACT_FINISH: org.bukkit.GameEvent;

			const ITEM_INTERACT_START: org.bukkit.GameEvent;

			const JUKEBOX_PLAY: org.bukkit.GameEvent;

			const JUKEBOX_STOP_PLAY: org.bukkit.GameEvent;

			const LIGHTNING_STRIKE: org.bukkit.GameEvent;

			const MOB_INTERACT: org.bukkit.GameEvent;

			const NOTE_BLOCK_PLAY: org.bukkit.GameEvent;

			const PISTON_CONTRACT: org.bukkit.GameEvent;

			const PISTON_EXTEND: org.bukkit.GameEvent;

			const PRIME_FUSE: org.bukkit.GameEvent;

			const PROJECTILE_LAND: org.bukkit.GameEvent;

			const PROJECTILE_SHOOT: org.bukkit.GameEvent;

			const RAVAGER_ROAR: org.bukkit.GameEvent;

			const RING_BELL: org.bukkit.GameEvent;

			const SCULK_SENSOR_TENDRILS_CLICKING: org.bukkit.GameEvent;

			const SHEAR: org.bukkit.GameEvent;

			const SHRIEK: org.bukkit.GameEvent;

			const SHULKER_CLOSE: org.bukkit.GameEvent;

			const SHULKER_OPEN: org.bukkit.GameEvent;

			const SPLASH: org.bukkit.GameEvent;

			const STEP: org.bukkit.GameEvent;

			const SWIM: org.bukkit.GameEvent;

			const TELEPORT: org.bukkit.GameEvent;

			const UNEQUIP: org.bukkit.GameEvent;

			const WOLF_SHAKING: org.bukkit.GameEvent;

			const RESONATE_1: org.bukkit.GameEvent;

			const RESONATE_2: org.bukkit.GameEvent;

			const RESONATE_3: org.bukkit.GameEvent;

			const RESONATE_4: org.bukkit.GameEvent;

			const RESONATE_5: org.bukkit.GameEvent;

			const RESONATE_6: org.bukkit.GameEvent;

			const RESONATE_7: org.bukkit.GameEvent;

			const RESONATE_8: org.bukkit.GameEvent;

			const RESONATE_9: org.bukkit.GameEvent;

			const RESONATE_10: org.bukkit.GameEvent;

			const RESONATE_11: org.bukkit.GameEvent;

			const RESONATE_12: org.bukkit.GameEvent;

			const RESONATE_13: org.bukkit.GameEvent;

			const RESONATE_14: org.bukkit.GameEvent;

			const RESONATE_15: org.bukkit.GameEvent;

			/**
			 * Returns a GameEvent by a NamespacedKey.
			 */
			function getByKey(namespacedKey: org.bukkit.NamespacedKey): (org.bukkit.GameEvent | null);

			/**
			 * Returns the set of all GameEvents.
			 */
			function values(): globalThis.java.util.Collection<org.bukkit.GameEvent>;

		}
		interface GameMode {
			/**
			 * Gets the mode value associated with this GameMode
			 */
			getValue(): number;

		}
		namespace GameMode {
			/**
			 * Creative mode may fly, build instantly, become invulnerable and create
			 * free items.
			 */
			const CREATIVE: org.bukkit.GameMode;

			/**
			 * Survival mode is the "normal" gameplay type, with no special features.
			 */
			const SURVIVAL: org.bukkit.GameMode;

			/**
			 * Adventure mode cannot break blocks without the correct tools.
			 */
			const ADVENTURE: org.bukkit.GameMode;

			/**
			 * Spectator mode cannot interact with the world in anyway and is
			 * invisible to normal players. This grants the player the
			 * ability to no-clip through the world.
			 */
			const SPECTATOR: org.bukkit.GameMode;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.GameMode;

			/**
			 * Gets the GameMode represented by the specified value
			 */
			function getByValue(value: number): (org.bukkit.GameMode | null);

		}
		interface GameRule<T = any> {
			/**
			 * Get the name of this GameRule.
			 */
			getName(): string;

			/**
			 * Get the type of this rule.
			 */
			getType(): globalThis.java.lang.Class<T>;

			equals(obj: any): boolean;

			toString(): string;

		}
		namespace GameRule {
			/**
			 * Toggles the announcing of advancements.
			 */
			const ANNOUNCE_ADVANCEMENTS: org.bukkit.GameRule<boolean>;

			/**
			 * Whether command blocks should notify admins when they perform commands.
			 */
			const COMMAND_BLOCK_OUTPUT: org.bukkit.GameRule<boolean>;

			/**
			 * Whether the server should skip checking player speed when the player is
			 * wearing elytra.
			 */
			const DISABLE_ELYTRA_MOVEMENT_CHECK: org.bukkit.GameRule<boolean>;

			/**
			 * Whether time progresses from the current moment.
			 */
			const DO_DAYLIGHT_CYCLE: org.bukkit.GameRule<boolean>;

			/**
			 * Whether entities that are not mobs should have drops.
			 */
			const DO_ENTITY_DROPS: org.bukkit.GameRule<boolean>;

			/**
			 * Whether fire should spread and naturally extinguish.
			 */
			const DO_FIRE_TICK: org.bukkit.GameRule<boolean>;

			/**
			 * Whether players should only be able to craft recipes they've unlocked
			 * first.
			 */
			const DO_LIMITED_CRAFTING: org.bukkit.GameRule<boolean>;

			/**
			 * Whether mobs should drop items.
			 */
			const DO_MOB_LOOT: org.bukkit.GameRule<boolean>;

			/**
			 * Whether projectiles can break blocks.
			 */
			const PROJECTILES_CAN_BREAK_BLOCKS: org.bukkit.GameRule<boolean>;

			/**
			 * Whether mobs should naturally spawn.
			 */
			const DO_MOB_SPAWNING: org.bukkit.GameRule<boolean>;

			/**
			 * Whether blocks should have drops.
			 */
			const DO_TILE_DROPS: org.bukkit.GameRule<boolean>;

			/**
			 * Whether the weather will change from the current moment.
			 */
			const DO_WEATHER_CYCLE: org.bukkit.GameRule<boolean>;

			/**
			 * Whether the player should keep items in their inventory after death.
			 */
			const KEEP_INVENTORY: org.bukkit.GameRule<boolean>;

			/**
			 * Whether to log admin commands to server log.
			 */
			const LOG_ADMIN_COMMANDS: org.bukkit.GameRule<boolean>;

			/**
			 * Whether mobs can pick up items or change blocks.
			 */
			const MOB_GRIEFING: org.bukkit.GameRule<boolean>;

			/**
			 * Whether players can regenerate health naturally through their hunger bar.
			 */
			const NATURAL_REGENERATION: org.bukkit.GameRule<boolean>;

			/**
			 * Whether the debug screen shows all or reduced information.
			 */
			const REDUCED_DEBUG_INFO: org.bukkit.GameRule<boolean>;

			/**
			 * Whether the feedback from commands executed by a player should show up in
			 * chat. Also affects the default behavior of whether command blocks store
			 * their output text.
			 */
			const SEND_COMMAND_FEEDBACK: org.bukkit.GameRule<boolean>;

			/**
			 * Whether a message appears in chat when a player dies.
			 */
			const SHOW_DEATH_MESSAGES: org.bukkit.GameRule<boolean>;

			/**
			 * Whether players in spectator mode can generate chunks.
			 */
			const SPECTATORS_GENERATE_CHUNKS: org.bukkit.GameRule<boolean>;

			/**
			 * Whether pillager raids are enabled or not.
			 */
			const DISABLE_RAIDS: org.bukkit.GameRule<boolean>;

			/**
			 * Whether phantoms will appear without sleeping or not.
			 */
			const DO_INSOMNIA: org.bukkit.GameRule<boolean>;

			/**
			 * Whether clients will respawn immediately after death or not.
			 */
			const DO_IMMEDIATE_RESPAWN: org.bukkit.GameRule<boolean>;

			/**
			 * Whether drowning damage is enabled or not.
			 */
			const DROWNING_DAMAGE: org.bukkit.GameRule<boolean>;

			/**
			 * Whether fall damage is enabled or not.
			 */
			const FALL_DAMAGE: org.bukkit.GameRule<boolean>;

			/**
			 * Whether fire damage is enabled or not.
			 */
			const FIRE_DAMAGE: org.bukkit.GameRule<boolean>;

			/**
			 * Whether freeze damage is enabled or not.
			 */
			const FREEZE_DAMAGE: org.bukkit.GameRule<boolean>;

			/**
			 * Whether patrols should naturally spawn.
			 */
			const DO_PATROL_SPAWNING: org.bukkit.GameRule<boolean>;

			/**
			 * Whether traders should naturally spawn.
			 */
			const DO_TRADER_SPAWNING: org.bukkit.GameRule<boolean>;

			/**
			 * Whether wardens should naturally spawn.
			 */
			const DO_WARDEN_SPAWNING: org.bukkit.GameRule<boolean>;

			/**
			 * Whether mobs should cease being angry at a player once they die.
			 */
			const FORGIVE_DEAD_PLAYERS: org.bukkit.GameRule<boolean>;

			/**
			 * Whether mobs will target all player entities once angered.
			 */
			const UNIVERSAL_ANGER: org.bukkit.GameRule<boolean>;

			/**
			 * Whether block explosions will destroy dropped items.
			 */
			const BLOCK_EXPLOSION_DROP_DECAY: org.bukkit.GameRule<boolean>;

			/**
			 * * Whether mob explosions will destroy dropped items.
			 */
			const MOB_EXPLOSION_DROP_DECAY: org.bukkit.GameRule<boolean>;

			/**
			 * Whether tnt explosions will destroy dropped items.
			 */
			const TNT_EXPLOSION_DROP_DECAY: org.bukkit.GameRule<boolean>;

			/**
			 * Whether water blocks can convert into water source blocks.
			 */
			const WATER_SOURCE_CONVERSION: org.bukkit.GameRule<boolean>;

			/**
			 * Whether lava blocks can convert into lava source blocks.
			 */
			const LAVA_SOURCE_CONVERSION: org.bukkit.GameRule<boolean>;

			/**
			 * Whether global level events such as ender dragon, wither, and completed
			 * end portal effects will propagate across the entire server.
			 */
			const GLOBAL_SOUND_EVENTS: org.bukkit.GameRule<boolean>;

			/**
			 * Whether vines will spread.
			 */
			const DO_VINES_SPREAD: org.bukkit.GameRule<boolean>;

			/**
			 * Whether ender pearls will vanish on player death.
			 */
			const ENDER_PEARLS_VANISH_ON_DEATH: org.bukkit.GameRule<boolean>;

			/**
			 * How often a random block tick occurs (such as plant growth, leaf decay,
			 * etc.) per chunk section per game tick. 0 will disable random ticks,
			 * higher numbers will increase random ticks.
			 */
			const RANDOM_TICK_SPEED: org.bukkit.GameRule<number>;

			/**
			 * The number of blocks outward from the world spawn coordinates that a
			 * player will spawn in when first joining a server or when dying without a
			 * spawnpoint.
			 */
			const SPAWN_RADIUS: org.bukkit.GameRule<number>;

			/**
			 * The maximum number of other pushable entities a mob or player can push,
			 * before taking suffocation damage.
			 * 
			 * Setting to 0 disables this rule.
			 */
			const MAX_ENTITY_CRAMMING: org.bukkit.GameRule<number>;

			/**
			 * Determines the number at which the chain of command blocks act as a
			 * "chain."
			 * 
			 * This is the maximum amount of command blocks that can be activated in a
			 * single tick from a single chain.
			 */
			const MAX_COMMAND_CHAIN_LENGTH: org.bukkit.GameRule<number>;

			/**
			 * Determines the number of different commands/functions which execute
			 * commands can fork into.
			 */
			const MAX_COMMAND_FORK_COUNT: org.bukkit.GameRule<number>;

			/**
			 * Determines the maximum number of blocks which a command can modify.
			 */
			const COMMAND_MODIFICATION_BLOCK_LIMIT: org.bukkit.GameRule<number>;

			/**
			 * The percentage of online players which must be sleeping for the night to
			 * advance.
			 */
			const PLAYERS_SLEEPING_PERCENTAGE: org.bukkit.GameRule<number>;

			const SNOW_ACCUMULATION_HEIGHT: org.bukkit.GameRule<number>;

			/**
			 * The amount of time a player must stand in a nether portal before the
			 * portal activates.
			 */
			const PLAYERS_NETHER_PORTAL_DEFAULT_DELAY: org.bukkit.GameRule<number>;

			/**
			 * The amount of time a player in creative mode must stand in a nether
			 * portal before the portal activates.
			 */
			const PLAYERS_NETHER_PORTAL_CREATIVE_DELAY: org.bukkit.GameRule<number>;

			/**
			 * The number of chunks around spawn which will be kept loaded at all times.
			 */
			const SPAWN_CHUNK_RADIUS: org.bukkit.GameRule<number>;

			/**
			 * Get a GameRule by its name.
			 */
			function getByName(rule: string): (org.bukkit.GameRule | null);

		}
		interface GrassSpecies {
			/**
			 * Gets the associated data value representing this species
			 */
			getData(): any /* byte */;

		}
		namespace GrassSpecies {
			/**
			 * Represents the dead looking grass.
			 */
			const DEAD: org.bukkit.GrassSpecies;

			/**
			 * Represents the normal grass species.
			 */
			const NORMAL: org.bukkit.GrassSpecies;

			/**
			 * Represents the fern-looking grass species.
			 */
			const FERN_LIKE: org.bukkit.GrassSpecies;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.GrassSpecies;

			/**
			 * Gets the GrassSpecies with the given data value
			 */
			function getByData(data: any /* byte */): (org.bukkit.GrassSpecies | null);

		}
		interface HeightMap {}
		namespace HeightMap {
			/**
			 * The highest block that blocks motion or contains a fluid.
			 */
			const MOTION_BLOCKING: org.bukkit.HeightMap;

			/**
			 * The highest block that blocks motion or contains a fluid or is in the
			 * Tag.LEAVES.
			 */
			const MOTION_BLOCKING_NO_LEAVES: org.bukkit.HeightMap;

			/**
			 * The highest non-air block, solid block.
			 */
			const OCEAN_FLOOR: org.bukkit.HeightMap;

			/**
			 * The highest block that is neither air nor contains a fluid, for worldgen.
			 */
			const OCEAN_FLOOR_WG: org.bukkit.HeightMap;

			/**
			 * The highest non-air block.
			 */
			const WORLD_SURFACE: org.bukkit.HeightMap;

			/**
			 * The highest non-air block, for worldgen.
			 */
			const WORLD_SURFACE_WG: org.bukkit.HeightMap;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.HeightMap;

		}
		interface Instrument {
			/**
			 * Gets the sound associated with this instrument.
			 * Will be null for CUSTOM_HEAD
			 */
			getSound(): (org.bukkit.Sound | null);

			getType(): any /* byte */;

		}
		namespace Instrument {
			/**
			 * Piano is the standard instrument for a note block.
			 */
			const PIANO: org.bukkit.Instrument;

			/**
			 * Bass drum is normally played when a note block is on top of a
			 * stone-like block.
			 */
			const BASS_DRUM: org.bukkit.Instrument;

			/**
			 * Snare drum is normally played when a note block is on top of a sandy
			 * block.
			 */
			const SNARE_DRUM: org.bukkit.Instrument;

			/**
			 * Sticks are normally played when a note block is on top of a glass
			 * block.
			 */
			const STICKS: org.bukkit.Instrument;

			/**
			 * Bass guitar is normally played when a note block is on top of a wooden
			 * block.
			 */
			const BASS_GUITAR: org.bukkit.Instrument;

			/**
			 * Flute is normally played when a note block is on top of a clay block.
			 */
			const FLUTE: org.bukkit.Instrument;

			/**
			 * Bell is normally played when a note block is on top of a gold block.
			 */
			const BELL: org.bukkit.Instrument;

			/**
			 * Guitar is normally played when a note block is on top of a woolen block.
			 */
			const GUITAR: org.bukkit.Instrument;

			/**
			 * Chime is normally played when a note block is on top of a packed ice
			 * block.
			 */
			const CHIME: org.bukkit.Instrument;

			/**
			 * Xylophone is normally played when a note block is on top of a bone block.
			 */
			const XYLOPHONE: org.bukkit.Instrument;

			/**
			 * Iron Xylophone is normally played when a note block is on top of a iron block.
			 */
			const IRON_XYLOPHONE: org.bukkit.Instrument;

			/**
			 * Cow Bell is normally played when a note block is on top of a soul sand block.
			 */
			const COW_BELL: org.bukkit.Instrument;

			/**
			 * Didgeridoo is normally played when a note block is on top of a pumpkin block.
			 */
			const DIDGERIDOO: org.bukkit.Instrument;

			/**
			 * Bit is normally played when a note block is on top of a emerald block.
			 */
			const BIT: org.bukkit.Instrument;

			/**
			 * Banjo is normally played when a note block is on top of a hay block.
			 */
			const BANJO: org.bukkit.Instrument;

			/**
			 * Pling is normally played when a note block is on top of a glowstone block.
			 */
			const PLING: org.bukkit.Instrument;

			/**
			 * Zombie is normally played when a Zombie Head is on top of the note block.
			 */
			const ZOMBIE: org.bukkit.Instrument;

			/**
			 * Skeleton is normally played when a Skeleton Head is on top of the note block.
			 */
			const SKELETON: org.bukkit.Instrument;

			/**
			 * Creeper is normally played when a Creeper Head is on top of the note block.
			 */
			const CREEPER: org.bukkit.Instrument;

			/**
			 * Dragon is normally played when a Dragon Head is on top of the note block.
			 */
			const DRAGON: org.bukkit.Instrument;

			/**
			 * Wither Skeleton is normally played when a Wither Skeleton Head is on top of the note block.
			 */
			const WITHER_SKELETON: org.bukkit.Instrument;

			/**
			 * Piglin is normally played when a Piglin Head is on top of the note block.
			 */
			const PIGLIN: org.bukkit.Instrument;

			/**
			 * Custom Sound is normally played when a Player Head with the required data is on top of the note block.
			 */
			const CUSTOM_HEAD: org.bukkit.Instrument;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.Instrument;

			/**
			 * Get an instrument by its type ID.
			 */
			function getByType(type: any /* byte */): (org.bukkit.Instrument | null);

		}
		interface JukeboxSong extends Modify<org.bukkit.Keyed & org.bukkit.Translatable, {}> {}
		namespace JukeboxSong {
			const THIRTEEN: org.bukkit.JukeboxSong;

			const CAT: org.bukkit.JukeboxSong;

			const BLOCKS: org.bukkit.JukeboxSong;

			const CHIRP: org.bukkit.JukeboxSong;

			const FAR: org.bukkit.JukeboxSong;

			const MALL: org.bukkit.JukeboxSong;

			const MELLOHI: org.bukkit.JukeboxSong;

			const STAL: org.bukkit.JukeboxSong;

			const STRAD: org.bukkit.JukeboxSong;

			const WARD: org.bukkit.JukeboxSong;

			const ELEVEN: org.bukkit.JukeboxSong;

			const WAIT: org.bukkit.JukeboxSong;

			const PIGSTEP: org.bukkit.JukeboxSong;

			const OTHERSIDE: org.bukkit.JukeboxSong;

			const FIVE: org.bukkit.JukeboxSong;

			const RELIC: org.bukkit.JukeboxSong;

			const PRECIPICE: org.bukkit.JukeboxSong;

			const CREATOR: org.bukkit.JukeboxSong;

			const CREATOR_MUSIC_BOX: org.bukkit.JukeboxSong;

		}
		interface Keyed {
			/**
			 * Return the namespaced identifier for this object.
			 */
			getKey(): org.bukkit.NamespacedKey;

		}
		interface Location {
			/**
			 * Sets the world that this location resides in
			 */
			setWorld(world: (org.bukkit.World | null)): void;

			/**
			 * Checks if world in this location is present and loaded.
			 */
			isWorldLoaded(): boolean;

			/**
			 * Gets the world that this location resides in
			 */
			getWorld(): (org.bukkit.World | null);

			/**
			 * Gets the chunk at the represented location
			 */
			getChunk(): org.bukkit.Chunk;

			/**
			 * Gets the block at the represented location
			 */
			getBlock(): org.bukkit.block.Block;

			/**
			 * Sets the x-coordinate of this location
			 */
			setX(x: number): void;

			/**
			 * Gets the x-coordinate of this location
			 */
			getX(): number;

			/**
			 * Gets the floored value of the X component, indicating the block that
			 * this location is contained with.
			 */
			getBlockX(): number;

			/**
			 * Sets the y-coordinate of this location
			 */
			setY(y: number): void;

			/**
			 * Gets the y-coordinate of this location
			 */
			getY(): number;

			/**
			 * Gets the floored value of the Y component, indicating the block that
			 * this location is contained with.
			 */
			getBlockY(): number;

			/**
			 * Sets the z-coordinate of this location
			 */
			setZ(z: number): void;

			/**
			 * Gets the z-coordinate of this location
			 */
			getZ(): number;

			/**
			 * Gets the floored value of the Z component, indicating the block that
			 * this location is contained with.
			 */
			getBlockZ(): number;

			/**
			 * Sets the yaw of this location, measured in degrees.
			 * 
			 * A yaw of 0 or 360 represents the positive z direction.
			 * A yaw of 180 represents the negative z direction.
			 * A yaw of 90 represents the negative x direction.
			 * A yaw of 270 represents the positive x direction.
			 * 
			 * Increasing yaw values are the equivalent of turning to your
			 * right-facing, increasing the scale of the next respective axis, and
			 * decreasing the scale of the previous axis.
			 */
			setYaw(yaw: number): void;

			/**
			 * Gets the yaw of this location, measured in degrees.
			 * 
			 * A yaw of 0 or 360 represents the positive z direction.
			 * A yaw of 180 represents the negative z direction.
			 * A yaw of 90 represents the negative x direction.
			 * A yaw of 270 represents the positive x direction.
			 * 
			 * Increasing yaw values are the equivalent of turning to your
			 * right-facing, increasing the scale of the next respective axis, and
			 * decreasing the scale of the previous axis.
			 */
			getYaw(): number;

			/**
			 * Sets the pitch of this location, measured in degrees.
			 * 
			 * A pitch of 0 represents level forward facing.
			 * A pitch of 90 represents downward facing, or negative y
			 * direction.
			 * A pitch of -90 represents upward facing, or positive y direction.
			 * 
			 * Increasing pitch values the equivalent of looking down.
			 */
			setPitch(pitch: number): void;

			/**
			 * Gets the pitch of this location, measured in degrees.
			 * 
			 * A pitch of 0 represents level forward facing.
			 * A pitch of 90 represents downward facing, or negative y
			 * direction.
			 * A pitch of -90 represents upward facing, or positive y direction.
			 * 
			 * Increasing pitch values the equivalent of looking down.
			 */
			getPitch(): number;

			/**
			 * Gets a unit-vector pointing in the direction that this Location is
			 * facing.
			 */
			getDirection(): org.bukkit.util.Vector;

			/**
			 * Sets the yaw and pitch to point
			 * in the direction of the vector.
			 */
			setDirection(vector: org.bukkit.util.Vector): org.bukkit.Location;

			/**
			 * Adds the location by another.
			 */
			add(vec: org.bukkit.Location): org.bukkit.Location;

			/**
			 * Adds the location by a vector.
			 */
			add(vec: org.bukkit.util.Vector): org.bukkit.Location;

			/**
			 * Adds the location by another. Not world-aware.
			 */
			add(x: number, y: number, z: number): org.bukkit.Location;

			/**
			 * Subtracts the location by another.
			 */
			subtract(vec: org.bukkit.Location): org.bukkit.Location;

			/**
			 * Subtracts the location by a vector.
			 */
			subtract(vec: org.bukkit.util.Vector): org.bukkit.Location;

			/**
			 * Subtracts the location by another. Not world-aware and
			 * orientation independent.
			 */
			subtract(x: number, y: number, z: number): org.bukkit.Location;

			/**
			 * Gets the magnitude of the location, defined as sqrt(x^2+y^2+z^2). The
			 * value of this method is not cached and uses a costly square-root
			 * function, so do not repeatedly call this method to get the location's
			 * magnitude. NaN will be returned if the inner result of the sqrt()
			 * function overflows, which will be caused if the length is too long. Not
			 * world-aware and orientation independent.
			 */
			length(): number;

			/**
			 * Gets the magnitude of the location squared. Not world-aware and
			 * orientation independent.
			 */
			lengthSquared(): number;

			/**
			 * Get the distance between this location and another. The value of this
			 * method is not cached and uses a costly square-root function, so do not
			 * repeatedly call this method to get the location's magnitude. NaN will
			 * be returned if the inner result of the sqrt() function overflows, which
			 * will be caused if the distance is too long.
			 */
			distance(o: org.bukkit.Location): number;

			/**
			 * Get the squared distance between this location and another.
			 */
			distanceSquared(o: org.bukkit.Location): number;

			/**
			 * Performs scalar multiplication, multiplying all components with a
			 * scalar. Not world-aware.
			 */
			multiply(m: number): org.bukkit.Location;

			/**
			 * Zero this location's components. Not world-aware.
			 */
			zero(): org.bukkit.Location;

			equals(obj: any): boolean;

			hashCode(): number;

			toString(): string;

			/**
			 * Constructs a new Vector based on this Location
			 */
			toVector(): org.bukkit.util.Vector;

			clone(): org.bukkit.Location;

			/**
			 * Check if each component of this Location is finite.
			 */
			checkFinite(): void;

			/**
			 * Description copied from interface:Â ConfigurationSerializable
			 */
			serialize(): globalThis.java.util.Map<string, any>;

		}
		class Location {
			/**
			 * Constructs a new Location with the given coordinates
			 */
			constructor(world: (org.bukkit.World | null), x: number, y: number, z: number);

			/**
			 * Constructs a new Location with the given coordinates and direction
			 */
			constructor(world: (org.bukkit.World | null), x: number, y: number, z: number, yaw: number, pitch: number);

		}
		namespace Location {
			/**
			 * Safely converts a double (location coordinate) to an int (block
			 * coordinate)
			 */
			function locToBlock(loc: number): number;

			/**
			 * Required method for deserialization
			 */
			function deserialize(args: globalThis.java.util.Map<string, any>): org.bukkit.Location;

			/**
			 * Normalizes the given yaw angle to a value between +/-180
			 * degrees.
			 */
			function normalizeYaw(yaw: number): number;

			/**
			 * Normalizes the given pitch angle to a value between +/-90
			 * degrees.
			 */
			function normalizePitch(pitch: number): number;

		}
		interface Material {
			readonly data: globalThis.java.lang.Class;

			/**
			 * Do not use for any reason.
			 */
			getId(): number;

			/**
			 * Do not use for any reason.
			 */
			isLegacy(): boolean;

			/**
			 * Description copied from interface:Â Keyed
			 */
			getKey(): org.bukkit.NamespacedKey;

			/**
			 * Gets the maximum amount of this material that can be held in a stack.
			 * 
			 * Note that this is the default maximum size for this Material.
			 * ItemStacks are able to change their maximum stack size per
			 * stack with ItemMeta.setMaxStackSize(Integer). If an ItemStack instance
			 * is available, ItemStack.getMaxStackSize() may be preferred.
			 */
			getMaxStackSize(): number;

			/**
			 * Gets the maximum durability of this material
			 */
			getMaxDurability(): number;

			/**
			 * Creates a new BlockData instance for this Material, with all
			 * properties initialized to unspecified defaults.
			 */
			createBlockData(): org.bukkit.block.data.BlockData;

			/**
			 * Creates a new BlockData instance for this Material, with
			 * all properties initialized to unspecified defaults.
			 */
			createBlockData(consumer: ((value: org.bukkit.block.data.BlockData) => void | null)): org.bukkit.block.data.BlockData;

			/**
			 * Creates a new BlockData instance for this Material, with all
			 * properties initialized to unspecified defaults, except for those provided
			 * in data.
			 */
			createBlockData(data: (string | null)): org.bukkit.block.data.BlockData;

			/**
			 * Gets the MaterialData class associated with this Material
			 */
			getData(): globalThis.java.lang.Class<org.bukkit.material.MaterialData>;

			/**
			 * Constructs a new MaterialData relevant for this Material, with the
			 * given initial data
			 */
			getNewData(raw: any /* byte */): org.bukkit.material.MaterialData;

			/**
			 * Checks if this Material is a placable block
			 */
			isBlock(): boolean;

			/**
			 * Checks if this Material is edible.
			 */
			isEdible(): boolean;

			isRecord(): boolean;

			/**
			 * Check if the material is a block and solid (can be built upon)
			 */
			isSolid(): boolean;

			/**
			 * Check if the material is an air block.
			 */
			isAir(): boolean;

			/**
			 * Check if the material is a block and does not block any light
			 */
			isTransparent(): boolean;

			/**
			 * Check if the material is a block and can catch fire
			 */
			isFlammable(): boolean;

			/**
			 * Check if the material is a block and can burn away
			 */
			isBurnable(): boolean;

			/**
			 * Checks if this Material can be used as fuel in a Furnace
			 */
			isFuel(): boolean;

			/**
			 * Check if the material is a block and occludes light in the lighting engine.
			 * 
			 * Generally speaking, most full blocks will occlude light. Non-full blocks are
			 * not occluding (e.g. anvils, chests, tall grass, stairs, etc.), nor are specific
			 * full blocks such as barriers or spawners which block light despite their texture.
			 * 
			 * An occluding block will have the following effects:
			 * 
			 * Chests cannot be opened if an occluding block is above it.
			 * Mobs cannot spawn inside of occluding blocks.
			 * Only occluding blocks can be "powered" (Block.isBlockPowered()).
			 * 
			 * This list may be inconclusive. For a full list of the side effects of an occluding
			 * block, see the Minecraft Wiki.
			 */
			isOccluding(): boolean;

			hasGravity(): boolean;

			/**
			 * Checks if this Material is an obtainable item.
			 */
			isItem(): boolean;

			/**
			 * Checks if this Material can be interacted with.
			 * Interactable materials include those with functionality when they are
			 * interacted with by a player such as chests, furnaces, etc.
			 * Some blocks such as piston heads and stairs are considered interactable
			 * though may not perform any additional functionality.
			 * Note that the interactability of some materials may be dependant on their
			 * state as well. This method will return true if there is at least one
			 * state in which additional interact handling is performed for the
			 * material.
			 */
			isInteractable(): boolean;

			/**
			 * Obtains the block's hardness level (also known as "strength").
			 * 
			 * This number is used to calculate the time required to break each block.
			 * 
			 * Only available when isBlock() is true.
			 */
			getHardness(): number;

			/**
			 * Obtains the blast resistance value (also known as block "durability").
			 * 
			 * This value is used in explosions to calculate whether a block should be
			 * broken or not.
			 * 
			 * Only available when isBlock() is true.
			 */
			getBlastResistance(): number;

			/**
			 * Returns a value that represents how 'slippery' the block is.
			 * Blocks with higher slipperiness, like ICE can be slid on
			 * further by the player and other entities.
			 * Most blocks have a default slipperiness of 0.6f.
			 * Only available when isBlock() is true.
			 */
			getSlipperiness(): number;

			/**
			 * Determines the remaining item in a crafting grid after crafting with this
			 * ingredient.
			 * 
			 * Only available when isItem() is true.
			 */
			getCraftingRemainingItem(): (org.bukkit.Material | null);

			/**
			 * Get the best suitable slot for this Material.
			 * For most items this will be EquipmentSlot.HAND.
			 */
			getEquipmentSlot(): org.bukkit.inventory.EquipmentSlot;

			/**
			 * Return an immutable copy of all default Attributes and their
			 * AttributeModifiers for a given EquipmentSlot.
			 * Default attributes are those that are always preset on some items, such
			 * as the attack damage on weapons or the armor value on armor.
			 * Only available when isItem() is true.
			 */
			getDefaultAttributeModifiers(slot: org.bukkit.inventory.EquipmentSlot): any /* com.google.common.collect.Multimap */;

			/**
			 * Get the CreativeCategory to which this material belongs.
			 */
			getCreativeCategory(): (org.bukkit.inventory.CreativeCategory | null);

			/**
			 * Get the translation key of the item or block associated with this
			 * material.
			 * If this material has both an item and a block form, the item form is
			 * used.
			 */
			getTranslationKey(): string;

			/**
			 * Get the translation key of the block associated with this material, or
			 * null if this material does not have an associated block.
			 */
			getBlockTranslationKey(): (string | null);

			/**
			 * Get the translation key of the item associated with this material, or
			 * null if this material does not have an associated item.
			 */
			getItemTranslationKey(): (string | null);

			/**
			 * Gets if the Material is enabled by the features in a world.
			 */
			isEnabledByFeature(world: org.bukkit.World): boolean;

			/**
			 * Checks whether this material is compostable (can be inserted into a
			 * composter).
			 */
			isCompostable(): boolean;

			/**
			 * Get the chance that this material will successfully compost. The returned
			 * value is between 0 and 1 (inclusive).
			 * Materials with a compost chance of 1 will always raise the composter's
			 * level, while materials with a compost chance of 0 will never raise it.
			 * Plugins should check that isCompostable() returns true before
			 * calling this method.
			 */
			getCompostChance(): number;

			/**
			 * Tries to convert this Material to an item type
			 */
			asItemType(): (org.bukkit.inventory.ItemType | null);

			/**
			 * Tries to convert this Material to a block type
			 */
			asBlockType(): (org.bukkit.block.BlockType | null);

		}
		namespace Material {
			const AIR: org.bukkit.Material;

			const STONE: org.bukkit.Material;

			const GRANITE: org.bukkit.Material;

			const POLISHED_GRANITE: org.bukkit.Material;

			const DIORITE: org.bukkit.Material;

			const POLISHED_DIORITE: org.bukkit.Material;

			const ANDESITE: org.bukkit.Material;

			const POLISHED_ANDESITE: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const DEEPSLATE: org.bukkit.Material;

			const COBBLED_DEEPSLATE: org.bukkit.Material;

			const POLISHED_DEEPSLATE: org.bukkit.Material;

			const CALCITE: org.bukkit.Material;

			const TUFF: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const TUFF_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const TUFF_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const TUFF_WALL: org.bukkit.Material;

			const CHISELED_TUFF: org.bukkit.Material;

			const POLISHED_TUFF: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const POLISHED_TUFF_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const POLISHED_TUFF_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const POLISHED_TUFF_WALL: org.bukkit.Material;

			const TUFF_BRICKS: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const TUFF_BRICK_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const TUFF_BRICK_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const TUFF_BRICK_WALL: org.bukkit.Material;

			const CHISELED_TUFF_BRICKS: org.bukkit.Material;

			const DRIPSTONE_BLOCK: org.bukkit.Material;

			/**
			 * BlockData: Snowable
			 */
			const GRASS_BLOCK: org.bukkit.Material;

			const DIRT: org.bukkit.Material;

			const COARSE_DIRT: org.bukkit.Material;

			/**
			 * BlockData: Snowable
			 */
			const PODZOL: org.bukkit.Material;

			const ROOTED_DIRT: org.bukkit.Material;

			const MUD: org.bukkit.Material;

			const CRIMSON_NYLIUM: org.bukkit.Material;

			const WARPED_NYLIUM: org.bukkit.Material;

			const COBBLESTONE: org.bukkit.Material;

			const OAK_PLANKS: org.bukkit.Material;

			const SPRUCE_PLANKS: org.bukkit.Material;

			const BIRCH_PLANKS: org.bukkit.Material;

			const JUNGLE_PLANKS: org.bukkit.Material;

			const ACACIA_PLANKS: org.bukkit.Material;

			const CHERRY_PLANKS: org.bukkit.Material;

			const DARK_OAK_PLANKS: org.bukkit.Material;

			const MANGROVE_PLANKS: org.bukkit.Material;

			const BAMBOO_PLANKS: org.bukkit.Material;

			const CRIMSON_PLANKS: org.bukkit.Material;

			const WARPED_PLANKS: org.bukkit.Material;

			const BAMBOO_MOSAIC: org.bukkit.Material;

			/**
			 * BlockData: Sapling
			 */
			const OAK_SAPLING: org.bukkit.Material;

			/**
			 * BlockData: Sapling
			 */
			const SPRUCE_SAPLING: org.bukkit.Material;

			/**
			 * BlockData: Sapling
			 */
			const BIRCH_SAPLING: org.bukkit.Material;

			/**
			 * BlockData: Sapling
			 */
			const JUNGLE_SAPLING: org.bukkit.Material;

			/**
			 * BlockData: Sapling
			 */
			const ACACIA_SAPLING: org.bukkit.Material;

			/**
			 * BlockData: Sapling
			 */
			const CHERRY_SAPLING: org.bukkit.Material;

			/**
			 * BlockData: Sapling
			 */
			const DARK_OAK_SAPLING: org.bukkit.Material;

			/**
			 * BlockData: MangrovePropagule
			 */
			const MANGROVE_PROPAGULE: org.bukkit.Material;

			const BEDROCK: org.bukkit.Material;

			const SAND: org.bukkit.Material;

			/**
			 * BlockData: Brushable
			 */
			const SUSPICIOUS_SAND: org.bukkit.Material;

			/**
			 * BlockData: Brushable
			 */
			const SUSPICIOUS_GRAVEL: org.bukkit.Material;

			const RED_SAND: org.bukkit.Material;

			const GRAVEL: org.bukkit.Material;

			const COAL_ORE: org.bukkit.Material;

			const DEEPSLATE_COAL_ORE: org.bukkit.Material;

			const IRON_ORE: org.bukkit.Material;

			const DEEPSLATE_IRON_ORE: org.bukkit.Material;

			const COPPER_ORE: org.bukkit.Material;

			const DEEPSLATE_COPPER_ORE: org.bukkit.Material;

			const GOLD_ORE: org.bukkit.Material;

			const DEEPSLATE_GOLD_ORE: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const REDSTONE_ORE: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const DEEPSLATE_REDSTONE_ORE: org.bukkit.Material;

			const EMERALD_ORE: org.bukkit.Material;

			const DEEPSLATE_EMERALD_ORE: org.bukkit.Material;

			const LAPIS_ORE: org.bukkit.Material;

			const DEEPSLATE_LAPIS_ORE: org.bukkit.Material;

			const DIAMOND_ORE: org.bukkit.Material;

			const DEEPSLATE_DIAMOND_ORE: org.bukkit.Material;

			const NETHER_GOLD_ORE: org.bukkit.Material;

			const NETHER_QUARTZ_ORE: org.bukkit.Material;

			const ANCIENT_DEBRIS: org.bukkit.Material;

			const COAL_BLOCK: org.bukkit.Material;

			const RAW_IRON_BLOCK: org.bukkit.Material;

			const RAW_COPPER_BLOCK: org.bukkit.Material;

			const RAW_GOLD_BLOCK: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const HEAVY_CORE: org.bukkit.Material;

			const AMETHYST_BLOCK: org.bukkit.Material;

			const BUDDING_AMETHYST: org.bukkit.Material;

			const IRON_BLOCK: org.bukkit.Material;

			const COPPER_BLOCK: org.bukkit.Material;

			const GOLD_BLOCK: org.bukkit.Material;

			const DIAMOND_BLOCK: org.bukkit.Material;

			const NETHERITE_BLOCK: org.bukkit.Material;

			const EXPOSED_COPPER: org.bukkit.Material;

			const WEATHERED_COPPER: org.bukkit.Material;

			const OXIDIZED_COPPER: org.bukkit.Material;

			const CHISELED_COPPER: org.bukkit.Material;

			const EXPOSED_CHISELED_COPPER: org.bukkit.Material;

			const WEATHERED_CHISELED_COPPER: org.bukkit.Material;

			const OXIDIZED_CHISELED_COPPER: org.bukkit.Material;

			const CUT_COPPER: org.bukkit.Material;

			const EXPOSED_CUT_COPPER: org.bukkit.Material;

			const WEATHERED_CUT_COPPER: org.bukkit.Material;

			const OXIDIZED_CUT_COPPER: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const CUT_COPPER_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const EXPOSED_CUT_COPPER_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const WEATHERED_CUT_COPPER_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const OXIDIZED_CUT_COPPER_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const CUT_COPPER_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const EXPOSED_CUT_COPPER_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const WEATHERED_CUT_COPPER_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const OXIDIZED_CUT_COPPER_SLAB: org.bukkit.Material;

			const WAXED_COPPER_BLOCK: org.bukkit.Material;

			const WAXED_EXPOSED_COPPER: org.bukkit.Material;

			const WAXED_WEATHERED_COPPER: org.bukkit.Material;

			const WAXED_OXIDIZED_COPPER: org.bukkit.Material;

			const WAXED_CHISELED_COPPER: org.bukkit.Material;

			const WAXED_EXPOSED_CHISELED_COPPER: org.bukkit.Material;

			const WAXED_WEATHERED_CHISELED_COPPER: org.bukkit.Material;

			const WAXED_OXIDIZED_CHISELED_COPPER: org.bukkit.Material;

			const WAXED_CUT_COPPER: org.bukkit.Material;

			const WAXED_EXPOSED_CUT_COPPER: org.bukkit.Material;

			const WAXED_WEATHERED_CUT_COPPER: org.bukkit.Material;

			const WAXED_OXIDIZED_CUT_COPPER: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const WAXED_CUT_COPPER_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const WAXED_EXPOSED_CUT_COPPER_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const WAXED_WEATHERED_CUT_COPPER_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const WAXED_OXIDIZED_CUT_COPPER_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const WAXED_CUT_COPPER_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const WAXED_EXPOSED_CUT_COPPER_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const WAXED_WEATHERED_CUT_COPPER_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const WAXED_OXIDIZED_CUT_COPPER_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const OAK_LOG: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const SPRUCE_LOG: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const BIRCH_LOG: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const JUNGLE_LOG: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const ACACIA_LOG: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const CHERRY_LOG: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const DARK_OAK_LOG: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const MANGROVE_LOG: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const MANGROVE_ROOTS: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const MUDDY_MANGROVE_ROOTS: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const CRIMSON_STEM: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const WARPED_STEM: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const BAMBOO_BLOCK: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_OAK_LOG: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_SPRUCE_LOG: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_BIRCH_LOG: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_JUNGLE_LOG: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_ACACIA_LOG: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_CHERRY_LOG: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_DARK_OAK_LOG: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_MANGROVE_LOG: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_CRIMSON_STEM: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_WARPED_STEM: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_OAK_WOOD: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_SPRUCE_WOOD: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_BIRCH_WOOD: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_JUNGLE_WOOD: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_ACACIA_WOOD: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_CHERRY_WOOD: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_DARK_OAK_WOOD: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_MANGROVE_WOOD: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_CRIMSON_HYPHAE: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_WARPED_HYPHAE: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_BAMBOO_BLOCK: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const OAK_WOOD: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const SPRUCE_WOOD: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const BIRCH_WOOD: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const JUNGLE_WOOD: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const ACACIA_WOOD: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const CHERRY_WOOD: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const DARK_OAK_WOOD: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const MANGROVE_WOOD: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const CRIMSON_HYPHAE: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const WARPED_HYPHAE: org.bukkit.Material;

			/**
			 * BlockData: Leaves
			 */
			const OAK_LEAVES: org.bukkit.Material;

			/**
			 * BlockData: Leaves
			 */
			const SPRUCE_LEAVES: org.bukkit.Material;

			/**
			 * BlockData: Leaves
			 */
			const BIRCH_LEAVES: org.bukkit.Material;

			/**
			 * BlockData: Leaves
			 */
			const JUNGLE_LEAVES: org.bukkit.Material;

			/**
			 * BlockData: Leaves
			 */
			const ACACIA_LEAVES: org.bukkit.Material;

			/**
			 * BlockData: Leaves
			 */
			const CHERRY_LEAVES: org.bukkit.Material;

			/**
			 * BlockData: Leaves
			 */
			const DARK_OAK_LEAVES: org.bukkit.Material;

			/**
			 * BlockData: Leaves
			 */
			const MANGROVE_LEAVES: org.bukkit.Material;

			/**
			 * BlockData: Leaves
			 */
			const AZALEA_LEAVES: org.bukkit.Material;

			/**
			 * BlockData: Leaves
			 */
			const FLOWERING_AZALEA_LEAVES: org.bukkit.Material;

			const SPONGE: org.bukkit.Material;

			const WET_SPONGE: org.bukkit.Material;

			const GLASS: org.bukkit.Material;

			const TINTED_GLASS: org.bukkit.Material;

			const LAPIS_BLOCK: org.bukkit.Material;

			const SANDSTONE: org.bukkit.Material;

			const CHISELED_SANDSTONE: org.bukkit.Material;

			const CUT_SANDSTONE: org.bukkit.Material;

			const COBWEB: org.bukkit.Material;

			const SHORT_GRASS: org.bukkit.Material;

			const FERN: org.bukkit.Material;

			const AZALEA: org.bukkit.Material;

			const FLOWERING_AZALEA: org.bukkit.Material;

			const DEAD_BUSH: org.bukkit.Material;

			const SEAGRASS: org.bukkit.Material;

			/**
			 * BlockData: SeaPickle
			 */
			const SEA_PICKLE: org.bukkit.Material;

			const WHITE_WOOL: org.bukkit.Material;

			const ORANGE_WOOL: org.bukkit.Material;

			const MAGENTA_WOOL: org.bukkit.Material;

			const LIGHT_BLUE_WOOL: org.bukkit.Material;

			const YELLOW_WOOL: org.bukkit.Material;

			const LIME_WOOL: org.bukkit.Material;

			const PINK_WOOL: org.bukkit.Material;

			const GRAY_WOOL: org.bukkit.Material;

			const LIGHT_GRAY_WOOL: org.bukkit.Material;

			const CYAN_WOOL: org.bukkit.Material;

			const PURPLE_WOOL: org.bukkit.Material;

			const BLUE_WOOL: org.bukkit.Material;

			const BROWN_WOOL: org.bukkit.Material;

			const GREEN_WOOL: org.bukkit.Material;

			const RED_WOOL: org.bukkit.Material;

			const BLACK_WOOL: org.bukkit.Material;

			const DANDELION: org.bukkit.Material;

			const POPPY: org.bukkit.Material;

			const BLUE_ORCHID: org.bukkit.Material;

			const ALLIUM: org.bukkit.Material;

			const AZURE_BLUET: org.bukkit.Material;

			const RED_TULIP: org.bukkit.Material;

			const ORANGE_TULIP: org.bukkit.Material;

			const WHITE_TULIP: org.bukkit.Material;

			const PINK_TULIP: org.bukkit.Material;

			const OXEYE_DAISY: org.bukkit.Material;

			const CORNFLOWER: org.bukkit.Material;

			const LILY_OF_THE_VALLEY: org.bukkit.Material;

			const WITHER_ROSE: org.bukkit.Material;

			const TORCHFLOWER: org.bukkit.Material;

			/**
			 * BlockData: Bisected
			 */
			const PITCHER_PLANT: org.bukkit.Material;

			const SPORE_BLOSSOM: org.bukkit.Material;

			const BROWN_MUSHROOM: org.bukkit.Material;

			const RED_MUSHROOM: org.bukkit.Material;

			const CRIMSON_FUNGUS: org.bukkit.Material;

			const WARPED_FUNGUS: org.bukkit.Material;

			const CRIMSON_ROOTS: org.bukkit.Material;

			const WARPED_ROOTS: org.bukkit.Material;

			const NETHER_SPROUTS: org.bukkit.Material;

			/**
			 * BlockData: Ageable
			 */
			const WEEPING_VINES: org.bukkit.Material;

			/**
			 * BlockData: Ageable
			 */
			const TWISTING_VINES: org.bukkit.Material;

			/**
			 * BlockData: Ageable
			 */
			const SUGAR_CANE: org.bukkit.Material;

			/**
			 * BlockData: Ageable
			 */
			const KELP: org.bukkit.Material;

			const MOSS_CARPET: org.bukkit.Material;

			/**
			 * BlockData: PinkPetals
			 */
			const PINK_PETALS: org.bukkit.Material;

			const MOSS_BLOCK: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const HANGING_ROOTS: org.bukkit.Material;

			/**
			 * BlockData: BigDripleaf
			 */
			const BIG_DRIPLEAF: org.bukkit.Material;

			/**
			 * BlockData: SmallDripleaf
			 */
			const SMALL_DRIPLEAF: org.bukkit.Material;

			/**
			 * BlockData: Bamboo
			 */
			const BAMBOO: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const OAK_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const SPRUCE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const BIRCH_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const JUNGLE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const ACACIA_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const CHERRY_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const DARK_OAK_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const MANGROVE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const BAMBOO_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const BAMBOO_MOSAIC_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const CRIMSON_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const WARPED_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const STONE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const SMOOTH_STONE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const SANDSTONE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const CUT_SANDSTONE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const PETRIFIED_OAK_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const COBBLESTONE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const BRICK_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const STONE_BRICK_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const MUD_BRICK_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const NETHER_BRICK_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const QUARTZ_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const RED_SANDSTONE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const CUT_RED_SANDSTONE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const PURPUR_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const PRISMARINE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const PRISMARINE_BRICK_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const DARK_PRISMARINE_SLAB: org.bukkit.Material;

			const SMOOTH_QUARTZ: org.bukkit.Material;

			const SMOOTH_RED_SANDSTONE: org.bukkit.Material;

			const SMOOTH_SANDSTONE: org.bukkit.Material;

			const SMOOTH_STONE: org.bukkit.Material;

			const BRICKS: org.bukkit.Material;

			const BOOKSHELF: org.bukkit.Material;

			/**
			 * BlockData: ChiseledBookshelf
			 */
			const CHISELED_BOOKSHELF: org.bukkit.Material;

			/**
			 * BlockData: DecoratedPot
			 */
			const DECORATED_POT: org.bukkit.Material;

			const MOSSY_COBBLESTONE: org.bukkit.Material;

			const OBSIDIAN: org.bukkit.Material;

			const TORCH: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const END_ROD: org.bukkit.Material;

			/**
			 * BlockData: MultipleFacing
			 */
			const CHORUS_PLANT: org.bukkit.Material;

			/**
			 * BlockData: Ageable
			 */
			const CHORUS_FLOWER: org.bukkit.Material;

			const PURPUR_BLOCK: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const PURPUR_PILLAR: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const PURPUR_STAIRS: org.bukkit.Material;

			const SPAWNER: org.bukkit.Material;

			/**
			 * BlockData: Chest
			 */
			const CHEST: org.bukkit.Material;

			const CRAFTING_TABLE: org.bukkit.Material;

			/**
			 * BlockData: Farmland
			 */
			const FARMLAND: org.bukkit.Material;

			/**
			 * BlockData: Furnace
			 */
			const FURNACE: org.bukkit.Material;

			/**
			 * BlockData: Ladder
			 */
			const LADDER: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const COBBLESTONE_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Snow
			 */
			const SNOW: org.bukkit.Material;

			const ICE: org.bukkit.Material;

			const SNOW_BLOCK: org.bukkit.Material;

			/**
			 * BlockData: Ageable
			 */
			const CACTUS: org.bukkit.Material;

			const CLAY: org.bukkit.Material;

			/**
			 * BlockData: Jukebox
			 */
			const JUKEBOX: org.bukkit.Material;

			/**
			 * BlockData: Fence
			 */
			const OAK_FENCE: org.bukkit.Material;

			/**
			 * BlockData: Fence
			 */
			const SPRUCE_FENCE: org.bukkit.Material;

			/**
			 * BlockData: Fence
			 */
			const BIRCH_FENCE: org.bukkit.Material;

			/**
			 * BlockData: Fence
			 */
			const JUNGLE_FENCE: org.bukkit.Material;

			/**
			 * BlockData: Fence
			 */
			const ACACIA_FENCE: org.bukkit.Material;

			/**
			 * BlockData: Fence
			 */
			const CHERRY_FENCE: org.bukkit.Material;

			/**
			 * BlockData: Fence
			 */
			const DARK_OAK_FENCE: org.bukkit.Material;

			/**
			 * BlockData: Fence
			 */
			const MANGROVE_FENCE: org.bukkit.Material;

			/**
			 * BlockData: Fence
			 */
			const BAMBOO_FENCE: org.bukkit.Material;

			/**
			 * BlockData: Fence
			 */
			const CRIMSON_FENCE: org.bukkit.Material;

			/**
			 * BlockData: Fence
			 */
			const WARPED_FENCE: org.bukkit.Material;

			const PUMPKIN: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const CARVED_PUMPKIN: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const JACK_O_LANTERN: org.bukkit.Material;

			const NETHERRACK: org.bukkit.Material;

			const SOUL_SAND: org.bukkit.Material;

			const SOUL_SOIL: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const BASALT: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const POLISHED_BASALT: org.bukkit.Material;

			const SMOOTH_BASALT: org.bukkit.Material;

			const SOUL_TORCH: org.bukkit.Material;

			const GLOWSTONE: org.bukkit.Material;

			const INFESTED_STONE: org.bukkit.Material;

			const INFESTED_COBBLESTONE: org.bukkit.Material;

			const INFESTED_STONE_BRICKS: org.bukkit.Material;

			const INFESTED_MOSSY_STONE_BRICKS: org.bukkit.Material;

			const INFESTED_CRACKED_STONE_BRICKS: org.bukkit.Material;

			const INFESTED_CHISELED_STONE_BRICKS: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const INFESTED_DEEPSLATE: org.bukkit.Material;

			const STONE_BRICKS: org.bukkit.Material;

			const MOSSY_STONE_BRICKS: org.bukkit.Material;

			const CRACKED_STONE_BRICKS: org.bukkit.Material;

			const CHISELED_STONE_BRICKS: org.bukkit.Material;

			const PACKED_MUD: org.bukkit.Material;

			const MUD_BRICKS: org.bukkit.Material;

			const DEEPSLATE_BRICKS: org.bukkit.Material;

			const CRACKED_DEEPSLATE_BRICKS: org.bukkit.Material;

			const DEEPSLATE_TILES: org.bukkit.Material;

			const CRACKED_DEEPSLATE_TILES: org.bukkit.Material;

			const CHISELED_DEEPSLATE: org.bukkit.Material;

			const REINFORCED_DEEPSLATE: org.bukkit.Material;

			/**
			 * BlockData: MultipleFacing
			 */
			const BROWN_MUSHROOM_BLOCK: org.bukkit.Material;

			/**
			 * BlockData: MultipleFacing
			 */
			const RED_MUSHROOM_BLOCK: org.bukkit.Material;

			/**
			 * BlockData: MultipleFacing
			 */
			const MUSHROOM_STEM: org.bukkit.Material;

			/**
			 * BlockData: Fence
			 */
			const IRON_BARS: org.bukkit.Material;

			/**
			 * BlockData: Chain
			 */
			const CHAIN: org.bukkit.Material;

			/**
			 * BlockData: Fence
			 */
			const GLASS_PANE: org.bukkit.Material;

			const MELON: org.bukkit.Material;

			/**
			 * BlockData: MultipleFacing
			 */
			const VINE: org.bukkit.Material;

			/**
			 * BlockData: GlowLichen
			 */
			const GLOW_LICHEN: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const BRICK_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const STONE_BRICK_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const MUD_BRICK_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Snowable
			 */
			const MYCELIUM: org.bukkit.Material;

			const LILY_PAD: org.bukkit.Material;

			const NETHER_BRICKS: org.bukkit.Material;

			const CRACKED_NETHER_BRICKS: org.bukkit.Material;

			const CHISELED_NETHER_BRICKS: org.bukkit.Material;

			/**
			 * BlockData: Fence
			 */
			const NETHER_BRICK_FENCE: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const NETHER_BRICK_STAIRS: org.bukkit.Material;

			const SCULK: org.bukkit.Material;

			/**
			 * BlockData: SculkVein
			 */
			const SCULK_VEIN: org.bukkit.Material;

			/**
			 * BlockData: SculkCatalyst
			 */
			const SCULK_CATALYST: org.bukkit.Material;

			/**
			 * BlockData: SculkShrieker
			 */
			const SCULK_SHRIEKER: org.bukkit.Material;

			const ENCHANTING_TABLE: org.bukkit.Material;

			/**
			 * BlockData: EndPortalFrame
			 */
			const END_PORTAL_FRAME: org.bukkit.Material;

			const END_STONE: org.bukkit.Material;

			const END_STONE_BRICKS: org.bukkit.Material;

			const DRAGON_EGG: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const SANDSTONE_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: EnderChest
			 */
			const ENDER_CHEST: org.bukkit.Material;

			const EMERALD_BLOCK: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const OAK_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const SPRUCE_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const BIRCH_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const JUNGLE_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const ACACIA_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const CHERRY_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const DARK_OAK_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const MANGROVE_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const BAMBOO_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const BAMBOO_MOSAIC_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const CRIMSON_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const WARPED_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: CommandBlock
			 */
			const COMMAND_BLOCK: org.bukkit.Material;

			const BEACON: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const COBBLESTONE_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const MOSSY_COBBLESTONE_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const BRICK_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const PRISMARINE_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const RED_SANDSTONE_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const MOSSY_STONE_BRICK_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const GRANITE_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const STONE_BRICK_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const MUD_BRICK_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const NETHER_BRICK_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const ANDESITE_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const RED_NETHER_BRICK_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const SANDSTONE_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const END_STONE_BRICK_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const DIORITE_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const BLACKSTONE_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const POLISHED_BLACKSTONE_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const POLISHED_BLACKSTONE_BRICK_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const COBBLED_DEEPSLATE_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const POLISHED_DEEPSLATE_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const DEEPSLATE_BRICK_WALL: org.bukkit.Material;

			/**
			 * BlockData: Wall
			 */
			const DEEPSLATE_TILE_WALL: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const ANVIL: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const CHIPPED_ANVIL: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const DAMAGED_ANVIL: org.bukkit.Material;

			const CHISELED_QUARTZ_BLOCK: org.bukkit.Material;

			const QUARTZ_BLOCK: org.bukkit.Material;

			const QUARTZ_BRICKS: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const QUARTZ_PILLAR: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const QUARTZ_STAIRS: org.bukkit.Material;

			const WHITE_TERRACOTTA: org.bukkit.Material;

			const ORANGE_TERRACOTTA: org.bukkit.Material;

			const MAGENTA_TERRACOTTA: org.bukkit.Material;

			const LIGHT_BLUE_TERRACOTTA: org.bukkit.Material;

			const YELLOW_TERRACOTTA: org.bukkit.Material;

			const LIME_TERRACOTTA: org.bukkit.Material;

			const PINK_TERRACOTTA: org.bukkit.Material;

			const GRAY_TERRACOTTA: org.bukkit.Material;

			const LIGHT_GRAY_TERRACOTTA: org.bukkit.Material;

			const CYAN_TERRACOTTA: org.bukkit.Material;

			const PURPLE_TERRACOTTA: org.bukkit.Material;

			const BLUE_TERRACOTTA: org.bukkit.Material;

			const BROWN_TERRACOTTA: org.bukkit.Material;

			const GREEN_TERRACOTTA: org.bukkit.Material;

			const RED_TERRACOTTA: org.bukkit.Material;

			const BLACK_TERRACOTTA: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const BARRIER: org.bukkit.Material;

			/**
			 * BlockData: Light
			 */
			const LIGHT: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const HAY_BLOCK: org.bukkit.Material;

			const WHITE_CARPET: org.bukkit.Material;

			const ORANGE_CARPET: org.bukkit.Material;

			const MAGENTA_CARPET: org.bukkit.Material;

			const LIGHT_BLUE_CARPET: org.bukkit.Material;

			const YELLOW_CARPET: org.bukkit.Material;

			const LIME_CARPET: org.bukkit.Material;

			const PINK_CARPET: org.bukkit.Material;

			const GRAY_CARPET: org.bukkit.Material;

			const LIGHT_GRAY_CARPET: org.bukkit.Material;

			const CYAN_CARPET: org.bukkit.Material;

			const PURPLE_CARPET: org.bukkit.Material;

			const BLUE_CARPET: org.bukkit.Material;

			const BROWN_CARPET: org.bukkit.Material;

			const GREEN_CARPET: org.bukkit.Material;

			const RED_CARPET: org.bukkit.Material;

			const BLACK_CARPET: org.bukkit.Material;

			const TERRACOTTA: org.bukkit.Material;

			const PACKED_ICE: org.bukkit.Material;

			const DIRT_PATH: org.bukkit.Material;

			/**
			 * BlockData: Bisected
			 */
			const SUNFLOWER: org.bukkit.Material;

			/**
			 * BlockData: Bisected
			 */
			const LILAC: org.bukkit.Material;

			/**
			 * BlockData: Bisected
			 */
			const ROSE_BUSH: org.bukkit.Material;

			/**
			 * BlockData: Bisected
			 */
			const PEONY: org.bukkit.Material;

			/**
			 * BlockData: Bisected
			 */
			const TALL_GRASS: org.bukkit.Material;

			/**
			 * BlockData: Bisected
			 */
			const LARGE_FERN: org.bukkit.Material;

			const WHITE_STAINED_GLASS: org.bukkit.Material;

			const ORANGE_STAINED_GLASS: org.bukkit.Material;

			const MAGENTA_STAINED_GLASS: org.bukkit.Material;

			const LIGHT_BLUE_STAINED_GLASS: org.bukkit.Material;

			const YELLOW_STAINED_GLASS: org.bukkit.Material;

			const LIME_STAINED_GLASS: org.bukkit.Material;

			const PINK_STAINED_GLASS: org.bukkit.Material;

			const GRAY_STAINED_GLASS: org.bukkit.Material;

			const LIGHT_GRAY_STAINED_GLASS: org.bukkit.Material;

			const CYAN_STAINED_GLASS: org.bukkit.Material;

			const PURPLE_STAINED_GLASS: org.bukkit.Material;

			const BLUE_STAINED_GLASS: org.bukkit.Material;

			const BROWN_STAINED_GLASS: org.bukkit.Material;

			const GREEN_STAINED_GLASS: org.bukkit.Material;

			const RED_STAINED_GLASS: org.bukkit.Material;

			const BLACK_STAINED_GLASS: org.bukkit.Material;

			/**
			 * BlockData: GlassPane
			 */
			const WHITE_STAINED_GLASS_PANE: org.bukkit.Material;

			/**
			 * BlockData: GlassPane
			 */
			const ORANGE_STAINED_GLASS_PANE: org.bukkit.Material;

			/**
			 * BlockData: GlassPane
			 */
			const MAGENTA_STAINED_GLASS_PANE: org.bukkit.Material;

			/**
			 * BlockData: GlassPane
			 */
			const LIGHT_BLUE_STAINED_GLASS_PANE: org.bukkit.Material;

			/**
			 * BlockData: GlassPane
			 */
			const YELLOW_STAINED_GLASS_PANE: org.bukkit.Material;

			/**
			 * BlockData: GlassPane
			 */
			const LIME_STAINED_GLASS_PANE: org.bukkit.Material;

			/**
			 * BlockData: GlassPane
			 */
			const PINK_STAINED_GLASS_PANE: org.bukkit.Material;

			/**
			 * BlockData: GlassPane
			 */
			const GRAY_STAINED_GLASS_PANE: org.bukkit.Material;

			/**
			 * BlockData: GlassPane
			 */
			const LIGHT_GRAY_STAINED_GLASS_PANE: org.bukkit.Material;

			/**
			 * BlockData: GlassPane
			 */
			const CYAN_STAINED_GLASS_PANE: org.bukkit.Material;

			/**
			 * BlockData: GlassPane
			 */
			const PURPLE_STAINED_GLASS_PANE: org.bukkit.Material;

			/**
			 * BlockData: GlassPane
			 */
			const BLUE_STAINED_GLASS_PANE: org.bukkit.Material;

			/**
			 * BlockData: GlassPane
			 */
			const BROWN_STAINED_GLASS_PANE: org.bukkit.Material;

			/**
			 * BlockData: GlassPane
			 */
			const GREEN_STAINED_GLASS_PANE: org.bukkit.Material;

			/**
			 * BlockData: GlassPane
			 */
			const RED_STAINED_GLASS_PANE: org.bukkit.Material;

			/**
			 * BlockData: GlassPane
			 */
			const BLACK_STAINED_GLASS_PANE: org.bukkit.Material;

			const PRISMARINE: org.bukkit.Material;

			const PRISMARINE_BRICKS: org.bukkit.Material;

			const DARK_PRISMARINE: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const PRISMARINE_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const PRISMARINE_BRICK_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const DARK_PRISMARINE_STAIRS: org.bukkit.Material;

			const SEA_LANTERN: org.bukkit.Material;

			const RED_SANDSTONE: org.bukkit.Material;

			const CHISELED_RED_SANDSTONE: org.bukkit.Material;

			const CUT_RED_SANDSTONE: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const RED_SANDSTONE_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: CommandBlock
			 */
			const REPEATING_COMMAND_BLOCK: org.bukkit.Material;

			/**
			 * BlockData: CommandBlock
			 */
			const CHAIN_COMMAND_BLOCK: org.bukkit.Material;

			const MAGMA_BLOCK: org.bukkit.Material;

			const NETHER_WART_BLOCK: org.bukkit.Material;

			const WARPED_WART_BLOCK: org.bukkit.Material;

			const RED_NETHER_BRICKS: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const BONE_BLOCK: org.bukkit.Material;

			const STRUCTURE_VOID: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const SHULKER_BOX: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const WHITE_SHULKER_BOX: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const ORANGE_SHULKER_BOX: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const MAGENTA_SHULKER_BOX: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const LIGHT_BLUE_SHULKER_BOX: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const YELLOW_SHULKER_BOX: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const LIME_SHULKER_BOX: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const PINK_SHULKER_BOX: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const GRAY_SHULKER_BOX: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const LIGHT_GRAY_SHULKER_BOX: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const CYAN_SHULKER_BOX: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const PURPLE_SHULKER_BOX: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const BLUE_SHULKER_BOX: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const BROWN_SHULKER_BOX: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const GREEN_SHULKER_BOX: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const RED_SHULKER_BOX: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const BLACK_SHULKER_BOX: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const WHITE_GLAZED_TERRACOTTA: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const ORANGE_GLAZED_TERRACOTTA: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const MAGENTA_GLAZED_TERRACOTTA: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const LIGHT_BLUE_GLAZED_TERRACOTTA: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const YELLOW_GLAZED_TERRACOTTA: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const LIME_GLAZED_TERRACOTTA: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const PINK_GLAZED_TERRACOTTA: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const GRAY_GLAZED_TERRACOTTA: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const LIGHT_GRAY_GLAZED_TERRACOTTA: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const CYAN_GLAZED_TERRACOTTA: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const PURPLE_GLAZED_TERRACOTTA: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const BLUE_GLAZED_TERRACOTTA: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const BROWN_GLAZED_TERRACOTTA: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const GREEN_GLAZED_TERRACOTTA: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const RED_GLAZED_TERRACOTTA: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const BLACK_GLAZED_TERRACOTTA: org.bukkit.Material;

			const WHITE_CONCRETE: org.bukkit.Material;

			const ORANGE_CONCRETE: org.bukkit.Material;

			const MAGENTA_CONCRETE: org.bukkit.Material;

			const LIGHT_BLUE_CONCRETE: org.bukkit.Material;

			const YELLOW_CONCRETE: org.bukkit.Material;

			const LIME_CONCRETE: org.bukkit.Material;

			const PINK_CONCRETE: org.bukkit.Material;

			const GRAY_CONCRETE: org.bukkit.Material;

			const LIGHT_GRAY_CONCRETE: org.bukkit.Material;

			const CYAN_CONCRETE: org.bukkit.Material;

			const PURPLE_CONCRETE: org.bukkit.Material;

			const BLUE_CONCRETE: org.bukkit.Material;

			const BROWN_CONCRETE: org.bukkit.Material;

			const GREEN_CONCRETE: org.bukkit.Material;

			const RED_CONCRETE: org.bukkit.Material;

			const BLACK_CONCRETE: org.bukkit.Material;

			const WHITE_CONCRETE_POWDER: org.bukkit.Material;

			const ORANGE_CONCRETE_POWDER: org.bukkit.Material;

			const MAGENTA_CONCRETE_POWDER: org.bukkit.Material;

			const LIGHT_BLUE_CONCRETE_POWDER: org.bukkit.Material;

			const YELLOW_CONCRETE_POWDER: org.bukkit.Material;

			const LIME_CONCRETE_POWDER: org.bukkit.Material;

			const PINK_CONCRETE_POWDER: org.bukkit.Material;

			const GRAY_CONCRETE_POWDER: org.bukkit.Material;

			const LIGHT_GRAY_CONCRETE_POWDER: org.bukkit.Material;

			const CYAN_CONCRETE_POWDER: org.bukkit.Material;

			const PURPLE_CONCRETE_POWDER: org.bukkit.Material;

			const BLUE_CONCRETE_POWDER: org.bukkit.Material;

			const BROWN_CONCRETE_POWDER: org.bukkit.Material;

			const GREEN_CONCRETE_POWDER: org.bukkit.Material;

			const RED_CONCRETE_POWDER: org.bukkit.Material;

			const BLACK_CONCRETE_POWDER: org.bukkit.Material;

			/**
			 * BlockData: TurtleEgg
			 */
			const TURTLE_EGG: org.bukkit.Material;

			/**
			 * BlockData: Hatchable
			 */
			const SNIFFER_EGG: org.bukkit.Material;

			const DEAD_TUBE_CORAL_BLOCK: org.bukkit.Material;

			const DEAD_BRAIN_CORAL_BLOCK: org.bukkit.Material;

			const DEAD_BUBBLE_CORAL_BLOCK: org.bukkit.Material;

			const DEAD_FIRE_CORAL_BLOCK: org.bukkit.Material;

			const DEAD_HORN_CORAL_BLOCK: org.bukkit.Material;

			const TUBE_CORAL_BLOCK: org.bukkit.Material;

			const BRAIN_CORAL_BLOCK: org.bukkit.Material;

			const BUBBLE_CORAL_BLOCK: org.bukkit.Material;

			const FIRE_CORAL_BLOCK: org.bukkit.Material;

			const HORN_CORAL_BLOCK: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const TUBE_CORAL: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const BRAIN_CORAL: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const BUBBLE_CORAL: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const FIRE_CORAL: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const HORN_CORAL: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const DEAD_BRAIN_CORAL: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const DEAD_BUBBLE_CORAL: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const DEAD_FIRE_CORAL: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const DEAD_HORN_CORAL: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const DEAD_TUBE_CORAL: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const TUBE_CORAL_FAN: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const BRAIN_CORAL_FAN: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const BUBBLE_CORAL_FAN: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const FIRE_CORAL_FAN: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const HORN_CORAL_FAN: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const DEAD_TUBE_CORAL_FAN: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const DEAD_BRAIN_CORAL_FAN: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const DEAD_BUBBLE_CORAL_FAN: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const DEAD_FIRE_CORAL_FAN: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const DEAD_HORN_CORAL_FAN: org.bukkit.Material;

			const BLUE_ICE: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const CONDUIT: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const POLISHED_GRANITE_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const SMOOTH_RED_SANDSTONE_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const MOSSY_STONE_BRICK_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const POLISHED_DIORITE_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const MOSSY_COBBLESTONE_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const END_STONE_BRICK_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const STONE_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const SMOOTH_SANDSTONE_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const SMOOTH_QUARTZ_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const GRANITE_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const ANDESITE_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const RED_NETHER_BRICK_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const POLISHED_ANDESITE_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const DIORITE_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const COBBLED_DEEPSLATE_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const POLISHED_DEEPSLATE_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const DEEPSLATE_BRICK_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const DEEPSLATE_TILE_STAIRS: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const POLISHED_GRANITE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const SMOOTH_RED_SANDSTONE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const MOSSY_STONE_BRICK_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const POLISHED_DIORITE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const MOSSY_COBBLESTONE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const END_STONE_BRICK_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const SMOOTH_SANDSTONE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const SMOOTH_QUARTZ_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const GRANITE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const ANDESITE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const RED_NETHER_BRICK_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const POLISHED_ANDESITE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const DIORITE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const COBBLED_DEEPSLATE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const POLISHED_DEEPSLATE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const DEEPSLATE_BRICK_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const DEEPSLATE_TILE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Scaffolding
			 */
			const SCAFFOLDING: org.bukkit.Material;

			const REDSTONE: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const REDSTONE_TORCH: org.bukkit.Material;

			const REDSTONE_BLOCK: org.bukkit.Material;

			/**
			 * BlockData: Repeater
			 */
			const REPEATER: org.bukkit.Material;

			/**
			 * BlockData: Comparator
			 */
			const COMPARATOR: org.bukkit.Material;

			/**
			 * BlockData: Piston
			 */
			const PISTON: org.bukkit.Material;

			/**
			 * BlockData: Piston
			 */
			const STICKY_PISTON: org.bukkit.Material;

			const SLIME_BLOCK: org.bukkit.Material;

			const HONEY_BLOCK: org.bukkit.Material;

			/**
			 * BlockData: Observer
			 */
			const OBSERVER: org.bukkit.Material;

			/**
			 * BlockData: Hopper
			 */
			const HOPPER: org.bukkit.Material;

			/**
			 * BlockData: Dispenser
			 */
			const DISPENSER: org.bukkit.Material;

			/**
			 * BlockData: Dispenser
			 */
			const DROPPER: org.bukkit.Material;

			/**
			 * BlockData: Lectern
			 */
			const LECTERN: org.bukkit.Material;

			/**
			 * BlockData: AnaloguePowerable
			 */
			const TARGET: org.bukkit.Material;

			/**
			 * BlockData: Switch
			 */
			const LEVER: org.bukkit.Material;

			/**
			 * BlockData: LightningRod
			 */
			const LIGHTNING_ROD: org.bukkit.Material;

			/**
			 * BlockData: DaylightDetector
			 */
			const DAYLIGHT_DETECTOR: org.bukkit.Material;

			/**
			 * BlockData: SculkSensor
			 */
			const SCULK_SENSOR: org.bukkit.Material;

			/**
			 * BlockData: CalibratedSculkSensor
			 */
			const CALIBRATED_SCULK_SENSOR: org.bukkit.Material;

			/**
			 * BlockData: TripwireHook
			 */
			const TRIPWIRE_HOOK: org.bukkit.Material;

			/**
			 * BlockData: Chest
			 */
			const TRAPPED_CHEST: org.bukkit.Material;

			/**
			 * BlockData: TNT
			 */
			const TNT: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const REDSTONE_LAMP: org.bukkit.Material;

			/**
			 * BlockData: NoteBlock
			 */
			const NOTE_BLOCK: org.bukkit.Material;

			/**
			 * BlockData: Switch
			 */
			const STONE_BUTTON: org.bukkit.Material;

			/**
			 * BlockData: Switch
			 */
			const POLISHED_BLACKSTONE_BUTTON: org.bukkit.Material;

			/**
			 * BlockData: Switch
			 */
			const OAK_BUTTON: org.bukkit.Material;

			/**
			 * BlockData: Switch
			 */
			const SPRUCE_BUTTON: org.bukkit.Material;

			/**
			 * BlockData: Switch
			 */
			const BIRCH_BUTTON: org.bukkit.Material;

			/**
			 * BlockData: Switch
			 */
			const JUNGLE_BUTTON: org.bukkit.Material;

			/**
			 * BlockData: Switch
			 */
			const ACACIA_BUTTON: org.bukkit.Material;

			/**
			 * BlockData: Switch
			 */
			const CHERRY_BUTTON: org.bukkit.Material;

			/**
			 * BlockData: Switch
			 */
			const DARK_OAK_BUTTON: org.bukkit.Material;

			/**
			 * BlockData: Switch
			 */
			const MANGROVE_BUTTON: org.bukkit.Material;

			/**
			 * BlockData: Switch
			 */
			const BAMBOO_BUTTON: org.bukkit.Material;

			/**
			 * BlockData: Switch
			 */
			const CRIMSON_BUTTON: org.bukkit.Material;

			/**
			 * BlockData: Switch
			 */
			const WARPED_BUTTON: org.bukkit.Material;

			/**
			 * BlockData: Powerable
			 */
			const STONE_PRESSURE_PLATE: org.bukkit.Material;

			/**
			 * BlockData: Powerable
			 */
			const POLISHED_BLACKSTONE_PRESSURE_PLATE: org.bukkit.Material;

			/**
			 * BlockData: AnaloguePowerable
			 */
			const LIGHT_WEIGHTED_PRESSURE_PLATE: org.bukkit.Material;

			/**
			 * BlockData: AnaloguePowerable
			 */
			const HEAVY_WEIGHTED_PRESSURE_PLATE: org.bukkit.Material;

			/**
			 * BlockData: Powerable
			 */
			const OAK_PRESSURE_PLATE: org.bukkit.Material;

			/**
			 * BlockData: Powerable
			 */
			const SPRUCE_PRESSURE_PLATE: org.bukkit.Material;

			/**
			 * BlockData: Powerable
			 */
			const BIRCH_PRESSURE_PLATE: org.bukkit.Material;

			/**
			 * BlockData: Powerable
			 */
			const JUNGLE_PRESSURE_PLATE: org.bukkit.Material;

			/**
			 * BlockData: Powerable
			 */
			const ACACIA_PRESSURE_PLATE: org.bukkit.Material;

			/**
			 * BlockData: Powerable
			 */
			const CHERRY_PRESSURE_PLATE: org.bukkit.Material;

			/**
			 * BlockData: Powerable
			 */
			const DARK_OAK_PRESSURE_PLATE: org.bukkit.Material;

			/**
			 * BlockData: Powerable
			 */
			const MANGROVE_PRESSURE_PLATE: org.bukkit.Material;

			/**
			 * BlockData: Powerable
			 */
			const BAMBOO_PRESSURE_PLATE: org.bukkit.Material;

			/**
			 * BlockData: Powerable
			 */
			const CRIMSON_PRESSURE_PLATE: org.bukkit.Material;

			/**
			 * BlockData: Powerable
			 */
			const WARPED_PRESSURE_PLATE: org.bukkit.Material;

			/**
			 * BlockData: Door
			 */
			const IRON_DOOR: org.bukkit.Material;

			/**
			 * BlockData: Door
			 */
			const OAK_DOOR: org.bukkit.Material;

			/**
			 * BlockData: Door
			 */
			const SPRUCE_DOOR: org.bukkit.Material;

			/**
			 * BlockData: Door
			 */
			const BIRCH_DOOR: org.bukkit.Material;

			/**
			 * BlockData: Door
			 */
			const JUNGLE_DOOR: org.bukkit.Material;

			/**
			 * BlockData: Door
			 */
			const ACACIA_DOOR: org.bukkit.Material;

			/**
			 * BlockData: Door
			 */
			const CHERRY_DOOR: org.bukkit.Material;

			/**
			 * BlockData: Door
			 */
			const DARK_OAK_DOOR: org.bukkit.Material;

			/**
			 * BlockData: Door
			 */
			const MANGROVE_DOOR: org.bukkit.Material;

			/**
			 * BlockData: Door
			 */
			const BAMBOO_DOOR: org.bukkit.Material;

			/**
			 * BlockData: Door
			 */
			const CRIMSON_DOOR: org.bukkit.Material;

			/**
			 * BlockData: Door
			 */
			const WARPED_DOOR: org.bukkit.Material;

			/**
			 * BlockData: Door
			 */
			const COPPER_DOOR: org.bukkit.Material;

			/**
			 * BlockData: Door
			 */
			const EXPOSED_COPPER_DOOR: org.bukkit.Material;

			/**
			 * BlockData: Door
			 */
			const WEATHERED_COPPER_DOOR: org.bukkit.Material;

			/**
			 * BlockData: Door
			 */
			const OXIDIZED_COPPER_DOOR: org.bukkit.Material;

			/**
			 * BlockData: Door
			 */
			const WAXED_COPPER_DOOR: org.bukkit.Material;

			/**
			 * BlockData: Door
			 */
			const WAXED_EXPOSED_COPPER_DOOR: org.bukkit.Material;

			/**
			 * BlockData: Door
			 */
			const WAXED_WEATHERED_COPPER_DOOR: org.bukkit.Material;

			/**
			 * BlockData: Door
			 */
			const WAXED_OXIDIZED_COPPER_DOOR: org.bukkit.Material;

			/**
			 * BlockData: TrapDoor
			 */
			const IRON_TRAPDOOR: org.bukkit.Material;

			/**
			 * BlockData: TrapDoor
			 */
			const OAK_TRAPDOOR: org.bukkit.Material;

			/**
			 * BlockData: TrapDoor
			 */
			const SPRUCE_TRAPDOOR: org.bukkit.Material;

			/**
			 * BlockData: TrapDoor
			 */
			const BIRCH_TRAPDOOR: org.bukkit.Material;

			/**
			 * BlockData: TrapDoor
			 */
			const JUNGLE_TRAPDOOR: org.bukkit.Material;

			/**
			 * BlockData: TrapDoor
			 */
			const ACACIA_TRAPDOOR: org.bukkit.Material;

			/**
			 * BlockData: TrapDoor
			 */
			const CHERRY_TRAPDOOR: org.bukkit.Material;

			/**
			 * BlockData: TrapDoor
			 */
			const DARK_OAK_TRAPDOOR: org.bukkit.Material;

			/**
			 * BlockData: TrapDoor
			 */
			const MANGROVE_TRAPDOOR: org.bukkit.Material;

			/**
			 * BlockData: TrapDoor
			 */
			const BAMBOO_TRAPDOOR: org.bukkit.Material;

			/**
			 * BlockData: TrapDoor
			 */
			const CRIMSON_TRAPDOOR: org.bukkit.Material;

			/**
			 * BlockData: TrapDoor
			 */
			const WARPED_TRAPDOOR: org.bukkit.Material;

			/**
			 * BlockData: TrapDoor
			 */
			const COPPER_TRAPDOOR: org.bukkit.Material;

			/**
			 * BlockData: TrapDoor
			 */
			const EXPOSED_COPPER_TRAPDOOR: org.bukkit.Material;

			/**
			 * BlockData: TrapDoor
			 */
			const WEATHERED_COPPER_TRAPDOOR: org.bukkit.Material;

			/**
			 * BlockData: TrapDoor
			 */
			const OXIDIZED_COPPER_TRAPDOOR: org.bukkit.Material;

			/**
			 * BlockData: TrapDoor
			 */
			const WAXED_COPPER_TRAPDOOR: org.bukkit.Material;

			/**
			 * BlockData: TrapDoor
			 */
			const WAXED_EXPOSED_COPPER_TRAPDOOR: org.bukkit.Material;

			/**
			 * BlockData: TrapDoor
			 */
			const WAXED_WEATHERED_COPPER_TRAPDOOR: org.bukkit.Material;

			/**
			 * BlockData: TrapDoor
			 */
			const WAXED_OXIDIZED_COPPER_TRAPDOOR: org.bukkit.Material;

			/**
			 * BlockData: Gate
			 */
			const OAK_FENCE_GATE: org.bukkit.Material;

			/**
			 * BlockData: Gate
			 */
			const SPRUCE_FENCE_GATE: org.bukkit.Material;

			/**
			 * BlockData: Gate
			 */
			const BIRCH_FENCE_GATE: org.bukkit.Material;

			/**
			 * BlockData: Gate
			 */
			const JUNGLE_FENCE_GATE: org.bukkit.Material;

			/**
			 * BlockData: Gate
			 */
			const ACACIA_FENCE_GATE: org.bukkit.Material;

			/**
			 * BlockData: Gate
			 */
			const CHERRY_FENCE_GATE: org.bukkit.Material;

			/**
			 * BlockData: Gate
			 */
			const DARK_OAK_FENCE_GATE: org.bukkit.Material;

			/**
			 * BlockData: Gate
			 */
			const MANGROVE_FENCE_GATE: org.bukkit.Material;

			/**
			 * BlockData: Gate
			 */
			const BAMBOO_FENCE_GATE: org.bukkit.Material;

			/**
			 * BlockData: Gate
			 */
			const CRIMSON_FENCE_GATE: org.bukkit.Material;

			/**
			 * BlockData: Gate
			 */
			const WARPED_FENCE_GATE: org.bukkit.Material;

			/**
			 * BlockData: RedstoneRail
			 */
			const POWERED_RAIL: org.bukkit.Material;

			/**
			 * BlockData: RedstoneRail
			 */
			const DETECTOR_RAIL: org.bukkit.Material;

			/**
			 * BlockData: Rail
			 */
			const RAIL: org.bukkit.Material;

			/**
			 * BlockData: RedstoneRail
			 */
			const ACTIVATOR_RAIL: org.bukkit.Material;

			const SADDLE: org.bukkit.Material;

			const MINECART: org.bukkit.Material;

			const CHEST_MINECART: org.bukkit.Material;

			const FURNACE_MINECART: org.bukkit.Material;

			const TNT_MINECART: org.bukkit.Material;

			const HOPPER_MINECART: org.bukkit.Material;

			const CARROT_ON_A_STICK: org.bukkit.Material;

			const WARPED_FUNGUS_ON_A_STICK: org.bukkit.Material;

			const ELYTRA: org.bukkit.Material;

			const OAK_BOAT: org.bukkit.Material;

			const OAK_CHEST_BOAT: org.bukkit.Material;

			const SPRUCE_BOAT: org.bukkit.Material;

			const SPRUCE_CHEST_BOAT: org.bukkit.Material;

			const BIRCH_BOAT: org.bukkit.Material;

			const BIRCH_CHEST_BOAT: org.bukkit.Material;

			const JUNGLE_BOAT: org.bukkit.Material;

			const JUNGLE_CHEST_BOAT: org.bukkit.Material;

			const ACACIA_BOAT: org.bukkit.Material;

			const ACACIA_CHEST_BOAT: org.bukkit.Material;

			const CHERRY_BOAT: org.bukkit.Material;

			const CHERRY_CHEST_BOAT: org.bukkit.Material;

			const DARK_OAK_BOAT: org.bukkit.Material;

			const DARK_OAK_CHEST_BOAT: org.bukkit.Material;

			const MANGROVE_BOAT: org.bukkit.Material;

			const MANGROVE_CHEST_BOAT: org.bukkit.Material;

			const BAMBOO_RAFT: org.bukkit.Material;

			const BAMBOO_CHEST_RAFT: org.bukkit.Material;

			/**
			 * BlockData: StructureBlock
			 */
			const STRUCTURE_BLOCK: org.bukkit.Material;

			/**
			 * BlockData: Jigsaw
			 */
			const JIGSAW: org.bukkit.Material;

			const TURTLE_HELMET: org.bukkit.Material;

			const TURTLE_SCUTE: org.bukkit.Material;

			const ARMADILLO_SCUTE: org.bukkit.Material;

			const WOLF_ARMOR: org.bukkit.Material;

			const FLINT_AND_STEEL: org.bukkit.Material;

			const BOWL: org.bukkit.Material;

			const APPLE: org.bukkit.Material;

			const BOW: org.bukkit.Material;

			const ARROW: org.bukkit.Material;

			const COAL: org.bukkit.Material;

			const CHARCOAL: org.bukkit.Material;

			const DIAMOND: org.bukkit.Material;

			const EMERALD: org.bukkit.Material;

			const LAPIS_LAZULI: org.bukkit.Material;

			const QUARTZ: org.bukkit.Material;

			const AMETHYST_SHARD: org.bukkit.Material;

			const RAW_IRON: org.bukkit.Material;

			const IRON_INGOT: org.bukkit.Material;

			const RAW_COPPER: org.bukkit.Material;

			const COPPER_INGOT: org.bukkit.Material;

			const RAW_GOLD: org.bukkit.Material;

			const GOLD_INGOT: org.bukkit.Material;

			const NETHERITE_INGOT: org.bukkit.Material;

			const NETHERITE_SCRAP: org.bukkit.Material;

			const WOODEN_SWORD: org.bukkit.Material;

			const WOODEN_SHOVEL: org.bukkit.Material;

			const WOODEN_PICKAXE: org.bukkit.Material;

			const WOODEN_AXE: org.bukkit.Material;

			const WOODEN_HOE: org.bukkit.Material;

			const STONE_SWORD: org.bukkit.Material;

			const STONE_SHOVEL: org.bukkit.Material;

			const STONE_PICKAXE: org.bukkit.Material;

			const STONE_AXE: org.bukkit.Material;

			const STONE_HOE: org.bukkit.Material;

			const GOLDEN_SWORD: org.bukkit.Material;

			const GOLDEN_SHOVEL: org.bukkit.Material;

			const GOLDEN_PICKAXE: org.bukkit.Material;

			const GOLDEN_AXE: org.bukkit.Material;

			const GOLDEN_HOE: org.bukkit.Material;

			const IRON_SWORD: org.bukkit.Material;

			const IRON_SHOVEL: org.bukkit.Material;

			const IRON_PICKAXE: org.bukkit.Material;

			const IRON_AXE: org.bukkit.Material;

			const IRON_HOE: org.bukkit.Material;

			const DIAMOND_SWORD: org.bukkit.Material;

			const DIAMOND_SHOVEL: org.bukkit.Material;

			const DIAMOND_PICKAXE: org.bukkit.Material;

			const DIAMOND_AXE: org.bukkit.Material;

			const DIAMOND_HOE: org.bukkit.Material;

			const NETHERITE_SWORD: org.bukkit.Material;

			const NETHERITE_SHOVEL: org.bukkit.Material;

			const NETHERITE_PICKAXE: org.bukkit.Material;

			const NETHERITE_AXE: org.bukkit.Material;

			const NETHERITE_HOE: org.bukkit.Material;

			const STICK: org.bukkit.Material;

			const MUSHROOM_STEW: org.bukkit.Material;

			const STRING: org.bukkit.Material;

			const FEATHER: org.bukkit.Material;

			const GUNPOWDER: org.bukkit.Material;

			const WHEAT_SEEDS: org.bukkit.Material;

			/**
			 * BlockData: Ageable
			 */
			const WHEAT: org.bukkit.Material;

			const BREAD: org.bukkit.Material;

			const LEATHER_HELMET: org.bukkit.Material;

			const LEATHER_CHESTPLATE: org.bukkit.Material;

			const LEATHER_LEGGINGS: org.bukkit.Material;

			const LEATHER_BOOTS: org.bukkit.Material;

			const CHAINMAIL_HELMET: org.bukkit.Material;

			const CHAINMAIL_CHESTPLATE: org.bukkit.Material;

			const CHAINMAIL_LEGGINGS: org.bukkit.Material;

			const CHAINMAIL_BOOTS: org.bukkit.Material;

			const IRON_HELMET: org.bukkit.Material;

			const IRON_CHESTPLATE: org.bukkit.Material;

			const IRON_LEGGINGS: org.bukkit.Material;

			const IRON_BOOTS: org.bukkit.Material;

			const DIAMOND_HELMET: org.bukkit.Material;

			const DIAMOND_CHESTPLATE: org.bukkit.Material;

			const DIAMOND_LEGGINGS: org.bukkit.Material;

			const DIAMOND_BOOTS: org.bukkit.Material;

			const GOLDEN_HELMET: org.bukkit.Material;

			const GOLDEN_CHESTPLATE: org.bukkit.Material;

			const GOLDEN_LEGGINGS: org.bukkit.Material;

			const GOLDEN_BOOTS: org.bukkit.Material;

			const NETHERITE_HELMET: org.bukkit.Material;

			const NETHERITE_CHESTPLATE: org.bukkit.Material;

			const NETHERITE_LEGGINGS: org.bukkit.Material;

			const NETHERITE_BOOTS: org.bukkit.Material;

			const FLINT: org.bukkit.Material;

			const PORKCHOP: org.bukkit.Material;

			const COOKED_PORKCHOP: org.bukkit.Material;

			const PAINTING: org.bukkit.Material;

			const GOLDEN_APPLE: org.bukkit.Material;

			const ENCHANTED_GOLDEN_APPLE: org.bukkit.Material;

			/**
			 * BlockData: Sign
			 */
			const OAK_SIGN: org.bukkit.Material;

			/**
			 * BlockData: Sign
			 */
			const SPRUCE_SIGN: org.bukkit.Material;

			/**
			 * BlockData: Sign
			 */
			const BIRCH_SIGN: org.bukkit.Material;

			/**
			 * BlockData: Sign
			 */
			const JUNGLE_SIGN: org.bukkit.Material;

			/**
			 * BlockData: Sign
			 */
			const ACACIA_SIGN: org.bukkit.Material;

			/**
			 * BlockData: Sign
			 */
			const CHERRY_SIGN: org.bukkit.Material;

			/**
			 * BlockData: Sign
			 */
			const DARK_OAK_SIGN: org.bukkit.Material;

			/**
			 * BlockData: Sign
			 */
			const MANGROVE_SIGN: org.bukkit.Material;

			/**
			 * BlockData: Sign
			 */
			const BAMBOO_SIGN: org.bukkit.Material;

			/**
			 * BlockData: Sign
			 */
			const CRIMSON_SIGN: org.bukkit.Material;

			/**
			 * BlockData: Sign
			 */
			const WARPED_SIGN: org.bukkit.Material;

			/**
			 * BlockData: HangingSign
			 */
			const OAK_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: HangingSign
			 */
			const SPRUCE_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: HangingSign
			 */
			const BIRCH_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: HangingSign
			 */
			const JUNGLE_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: HangingSign
			 */
			const ACACIA_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: HangingSign
			 */
			const CHERRY_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: HangingSign
			 */
			const DARK_OAK_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: HangingSign
			 */
			const MANGROVE_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: HangingSign
			 */
			const BAMBOO_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: HangingSign
			 */
			const CRIMSON_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: HangingSign
			 */
			const WARPED_HANGING_SIGN: org.bukkit.Material;

			const BUCKET: org.bukkit.Material;

			const WATER_BUCKET: org.bukkit.Material;

			const LAVA_BUCKET: org.bukkit.Material;

			const POWDER_SNOW_BUCKET: org.bukkit.Material;

			const SNOWBALL: org.bukkit.Material;

			const LEATHER: org.bukkit.Material;

			const MILK_BUCKET: org.bukkit.Material;

			const PUFFERFISH_BUCKET: org.bukkit.Material;

			const SALMON_BUCKET: org.bukkit.Material;

			const COD_BUCKET: org.bukkit.Material;

			const TROPICAL_FISH_BUCKET: org.bukkit.Material;

			const AXOLOTL_BUCKET: org.bukkit.Material;

			const TADPOLE_BUCKET: org.bukkit.Material;

			const BRICK: org.bukkit.Material;

			const CLAY_BALL: org.bukkit.Material;

			const DRIED_KELP_BLOCK: org.bukkit.Material;

			const PAPER: org.bukkit.Material;

			const BOOK: org.bukkit.Material;

			const SLIME_BALL: org.bukkit.Material;

			const EGG: org.bukkit.Material;

			const COMPASS: org.bukkit.Material;

			const RECOVERY_COMPASS: org.bukkit.Material;

			const BUNDLE: org.bukkit.Material;

			const FISHING_ROD: org.bukkit.Material;

			const CLOCK: org.bukkit.Material;

			const SPYGLASS: org.bukkit.Material;

			const GLOWSTONE_DUST: org.bukkit.Material;

			const COD: org.bukkit.Material;

			const SALMON: org.bukkit.Material;

			const TROPICAL_FISH: org.bukkit.Material;

			const PUFFERFISH: org.bukkit.Material;

			const COOKED_COD: org.bukkit.Material;

			const COOKED_SALMON: org.bukkit.Material;

			const INK_SAC: org.bukkit.Material;

			const GLOW_INK_SAC: org.bukkit.Material;

			const COCOA_BEANS: org.bukkit.Material;

			const WHITE_DYE: org.bukkit.Material;

			const ORANGE_DYE: org.bukkit.Material;

			const MAGENTA_DYE: org.bukkit.Material;

			const LIGHT_BLUE_DYE: org.bukkit.Material;

			const YELLOW_DYE: org.bukkit.Material;

			const LIME_DYE: org.bukkit.Material;

			const PINK_DYE: org.bukkit.Material;

			const GRAY_DYE: org.bukkit.Material;

			const LIGHT_GRAY_DYE: org.bukkit.Material;

			const CYAN_DYE: org.bukkit.Material;

			const PURPLE_DYE: org.bukkit.Material;

			const BLUE_DYE: org.bukkit.Material;

			const BROWN_DYE: org.bukkit.Material;

			const GREEN_DYE: org.bukkit.Material;

			const RED_DYE: org.bukkit.Material;

			const BLACK_DYE: org.bukkit.Material;

			const BONE_MEAL: org.bukkit.Material;

			const BONE: org.bukkit.Material;

			const SUGAR: org.bukkit.Material;

			/**
			 * BlockData: Cake
			 */
			const CAKE: org.bukkit.Material;

			/**
			 * BlockData: Bed
			 */
			const WHITE_BED: org.bukkit.Material;

			/**
			 * BlockData: Bed
			 */
			const ORANGE_BED: org.bukkit.Material;

			/**
			 * BlockData: Bed
			 */
			const MAGENTA_BED: org.bukkit.Material;

			/**
			 * BlockData: Bed
			 */
			const LIGHT_BLUE_BED: org.bukkit.Material;

			/**
			 * BlockData: Bed
			 */
			const YELLOW_BED: org.bukkit.Material;

			/**
			 * BlockData: Bed
			 */
			const LIME_BED: org.bukkit.Material;

			/**
			 * BlockData: Bed
			 */
			const PINK_BED: org.bukkit.Material;

			/**
			 * BlockData: Bed
			 */
			const GRAY_BED: org.bukkit.Material;

			/**
			 * BlockData: Bed
			 */
			const LIGHT_GRAY_BED: org.bukkit.Material;

			/**
			 * BlockData: Bed
			 */
			const CYAN_BED: org.bukkit.Material;

			/**
			 * BlockData: Bed
			 */
			const PURPLE_BED: org.bukkit.Material;

			/**
			 * BlockData: Bed
			 */
			const BLUE_BED: org.bukkit.Material;

			/**
			 * BlockData: Bed
			 */
			const BROWN_BED: org.bukkit.Material;

			/**
			 * BlockData: Bed
			 */
			const GREEN_BED: org.bukkit.Material;

			/**
			 * BlockData: Bed
			 */
			const RED_BED: org.bukkit.Material;

			/**
			 * BlockData: Bed
			 */
			const BLACK_BED: org.bukkit.Material;

			const COOKIE: org.bukkit.Material;

			/**
			 * BlockData: Crafter
			 */
			const CRAFTER: org.bukkit.Material;

			const FILLED_MAP: org.bukkit.Material;

			const SHEARS: org.bukkit.Material;

			const MELON_SLICE: org.bukkit.Material;

			const DRIED_KELP: org.bukkit.Material;

			const PUMPKIN_SEEDS: org.bukkit.Material;

			const MELON_SEEDS: org.bukkit.Material;

			const BEEF: org.bukkit.Material;

			const COOKED_BEEF: org.bukkit.Material;

			const CHICKEN: org.bukkit.Material;

			const COOKED_CHICKEN: org.bukkit.Material;

			const ROTTEN_FLESH: org.bukkit.Material;

			const ENDER_PEARL: org.bukkit.Material;

			const BLAZE_ROD: org.bukkit.Material;

			const GHAST_TEAR: org.bukkit.Material;

			const GOLD_NUGGET: org.bukkit.Material;

			/**
			 * BlockData: Ageable
			 */
			const NETHER_WART: org.bukkit.Material;

			const POTION: org.bukkit.Material;

			const GLASS_BOTTLE: org.bukkit.Material;

			const SPIDER_EYE: org.bukkit.Material;

			const FERMENTED_SPIDER_EYE: org.bukkit.Material;

			const BLAZE_POWDER: org.bukkit.Material;

			const MAGMA_CREAM: org.bukkit.Material;

			/**
			 * BlockData: BrewingStand
			 */
			const BREWING_STAND: org.bukkit.Material;

			const CAULDRON: org.bukkit.Material;

			const ENDER_EYE: org.bukkit.Material;

			const GLISTERING_MELON_SLICE: org.bukkit.Material;

			const ARMADILLO_SPAWN_EGG: org.bukkit.Material;

			const ALLAY_SPAWN_EGG: org.bukkit.Material;

			const AXOLOTL_SPAWN_EGG: org.bukkit.Material;

			const BAT_SPAWN_EGG: org.bukkit.Material;

			const BEE_SPAWN_EGG: org.bukkit.Material;

			const BLAZE_SPAWN_EGG: org.bukkit.Material;

			const BOGGED_SPAWN_EGG: org.bukkit.Material;

			const BREEZE_SPAWN_EGG: org.bukkit.Material;

			const CAT_SPAWN_EGG: org.bukkit.Material;

			const CAMEL_SPAWN_EGG: org.bukkit.Material;

			const CAVE_SPIDER_SPAWN_EGG: org.bukkit.Material;

			const CHICKEN_SPAWN_EGG: org.bukkit.Material;

			const COD_SPAWN_EGG: org.bukkit.Material;

			const COW_SPAWN_EGG: org.bukkit.Material;

			const CREEPER_SPAWN_EGG: org.bukkit.Material;

			const DOLPHIN_SPAWN_EGG: org.bukkit.Material;

			const DONKEY_SPAWN_EGG: org.bukkit.Material;

			const DROWNED_SPAWN_EGG: org.bukkit.Material;

			const ELDER_GUARDIAN_SPAWN_EGG: org.bukkit.Material;

			const ENDER_DRAGON_SPAWN_EGG: org.bukkit.Material;

			const ENDERMAN_SPAWN_EGG: org.bukkit.Material;

			const ENDERMITE_SPAWN_EGG: org.bukkit.Material;

			const EVOKER_SPAWN_EGG: org.bukkit.Material;

			const FOX_SPAWN_EGG: org.bukkit.Material;

			const FROG_SPAWN_EGG: org.bukkit.Material;

			const GHAST_SPAWN_EGG: org.bukkit.Material;

			const GLOW_SQUID_SPAWN_EGG: org.bukkit.Material;

			const GOAT_SPAWN_EGG: org.bukkit.Material;

			const GUARDIAN_SPAWN_EGG: org.bukkit.Material;

			const HOGLIN_SPAWN_EGG: org.bukkit.Material;

			const HORSE_SPAWN_EGG: org.bukkit.Material;

			const HUSK_SPAWN_EGG: org.bukkit.Material;

			const IRON_GOLEM_SPAWN_EGG: org.bukkit.Material;

			const LLAMA_SPAWN_EGG: org.bukkit.Material;

			const MAGMA_CUBE_SPAWN_EGG: org.bukkit.Material;

			const MOOSHROOM_SPAWN_EGG: org.bukkit.Material;

			const MULE_SPAWN_EGG: org.bukkit.Material;

			const OCELOT_SPAWN_EGG: org.bukkit.Material;

			const PANDA_SPAWN_EGG: org.bukkit.Material;

			const PARROT_SPAWN_EGG: org.bukkit.Material;

			const PHANTOM_SPAWN_EGG: org.bukkit.Material;

			const PIG_SPAWN_EGG: org.bukkit.Material;

			const PIGLIN_SPAWN_EGG: org.bukkit.Material;

			const PIGLIN_BRUTE_SPAWN_EGG: org.bukkit.Material;

			const PILLAGER_SPAWN_EGG: org.bukkit.Material;

			const POLAR_BEAR_SPAWN_EGG: org.bukkit.Material;

			const PUFFERFISH_SPAWN_EGG: org.bukkit.Material;

			const RABBIT_SPAWN_EGG: org.bukkit.Material;

			const RAVAGER_SPAWN_EGG: org.bukkit.Material;

			const SALMON_SPAWN_EGG: org.bukkit.Material;

			const SHEEP_SPAWN_EGG: org.bukkit.Material;

			const SHULKER_SPAWN_EGG: org.bukkit.Material;

			const SILVERFISH_SPAWN_EGG: org.bukkit.Material;

			const SKELETON_SPAWN_EGG: org.bukkit.Material;

			const SKELETON_HORSE_SPAWN_EGG: org.bukkit.Material;

			const SLIME_SPAWN_EGG: org.bukkit.Material;

			const SNIFFER_SPAWN_EGG: org.bukkit.Material;

			const SNOW_GOLEM_SPAWN_EGG: org.bukkit.Material;

			const SPIDER_SPAWN_EGG: org.bukkit.Material;

			const SQUID_SPAWN_EGG: org.bukkit.Material;

			const STRAY_SPAWN_EGG: org.bukkit.Material;

			const STRIDER_SPAWN_EGG: org.bukkit.Material;

			const TADPOLE_SPAWN_EGG: org.bukkit.Material;

			const TRADER_LLAMA_SPAWN_EGG: org.bukkit.Material;

			const TROPICAL_FISH_SPAWN_EGG: org.bukkit.Material;

			const TURTLE_SPAWN_EGG: org.bukkit.Material;

			const VEX_SPAWN_EGG: org.bukkit.Material;

			const VILLAGER_SPAWN_EGG: org.bukkit.Material;

			const VINDICATOR_SPAWN_EGG: org.bukkit.Material;

			const WANDERING_TRADER_SPAWN_EGG: org.bukkit.Material;

			const WARDEN_SPAWN_EGG: org.bukkit.Material;

			const WITCH_SPAWN_EGG: org.bukkit.Material;

			const WITHER_SPAWN_EGG: org.bukkit.Material;

			const WITHER_SKELETON_SPAWN_EGG: org.bukkit.Material;

			const WOLF_SPAWN_EGG: org.bukkit.Material;

			const ZOGLIN_SPAWN_EGG: org.bukkit.Material;

			const ZOMBIE_SPAWN_EGG: org.bukkit.Material;

			const ZOMBIE_HORSE_SPAWN_EGG: org.bukkit.Material;

			const ZOMBIE_VILLAGER_SPAWN_EGG: org.bukkit.Material;

			const ZOMBIFIED_PIGLIN_SPAWN_EGG: org.bukkit.Material;

			const EXPERIENCE_BOTTLE: org.bukkit.Material;

			const FIRE_CHARGE: org.bukkit.Material;

			const WIND_CHARGE: org.bukkit.Material;

			const WRITABLE_BOOK: org.bukkit.Material;

			const WRITTEN_BOOK: org.bukkit.Material;

			const MACE: org.bukkit.Material;

			const ITEM_FRAME: org.bukkit.Material;

			const GLOW_ITEM_FRAME: org.bukkit.Material;

			const FLOWER_POT: org.bukkit.Material;

			const CARROT: org.bukkit.Material;

			const POTATO: org.bukkit.Material;

			const BAKED_POTATO: org.bukkit.Material;

			const POISONOUS_POTATO: org.bukkit.Material;

			const MAP: org.bukkit.Material;

			const GOLDEN_CARROT: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const SKELETON_SKULL: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const WITHER_SKELETON_SKULL: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const PLAYER_HEAD: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const ZOMBIE_HEAD: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const CREEPER_HEAD: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const DRAGON_HEAD: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const PIGLIN_HEAD: org.bukkit.Material;

			const NETHER_STAR: org.bukkit.Material;

			const PUMPKIN_PIE: org.bukkit.Material;

			const FIREWORK_ROCKET: org.bukkit.Material;

			const FIREWORK_STAR: org.bukkit.Material;

			const ENCHANTED_BOOK: org.bukkit.Material;

			const NETHER_BRICK: org.bukkit.Material;

			const PRISMARINE_SHARD: org.bukkit.Material;

			const PRISMARINE_CRYSTALS: org.bukkit.Material;

			const RABBIT: org.bukkit.Material;

			const COOKED_RABBIT: org.bukkit.Material;

			const RABBIT_STEW: org.bukkit.Material;

			const RABBIT_FOOT: org.bukkit.Material;

			const RABBIT_HIDE: org.bukkit.Material;

			const ARMOR_STAND: org.bukkit.Material;

			const IRON_HORSE_ARMOR: org.bukkit.Material;

			const GOLDEN_HORSE_ARMOR: org.bukkit.Material;

			const DIAMOND_HORSE_ARMOR: org.bukkit.Material;

			const LEATHER_HORSE_ARMOR: org.bukkit.Material;

			const LEAD: org.bukkit.Material;

			const NAME_TAG: org.bukkit.Material;

			const COMMAND_BLOCK_MINECART: org.bukkit.Material;

			const MUTTON: org.bukkit.Material;

			const COOKED_MUTTON: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const WHITE_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const ORANGE_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const MAGENTA_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const LIGHT_BLUE_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const YELLOW_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const LIME_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const PINK_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const GRAY_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const LIGHT_GRAY_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const CYAN_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const PURPLE_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const BLUE_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const BROWN_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const GREEN_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const RED_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Rotatable
			 */
			const BLACK_BANNER: org.bukkit.Material;

			const END_CRYSTAL: org.bukkit.Material;

			const CHORUS_FRUIT: org.bukkit.Material;

			const POPPED_CHORUS_FRUIT: org.bukkit.Material;

			const TORCHFLOWER_SEEDS: org.bukkit.Material;

			const PITCHER_POD: org.bukkit.Material;

			const BEETROOT: org.bukkit.Material;

			const BEETROOT_SEEDS: org.bukkit.Material;

			const BEETROOT_SOUP: org.bukkit.Material;

			const DRAGON_BREATH: org.bukkit.Material;

			const SPLASH_POTION: org.bukkit.Material;

			const SPECTRAL_ARROW: org.bukkit.Material;

			const TIPPED_ARROW: org.bukkit.Material;

			const LINGERING_POTION: org.bukkit.Material;

			const SHIELD: org.bukkit.Material;

			const TOTEM_OF_UNDYING: org.bukkit.Material;

			const SHULKER_SHELL: org.bukkit.Material;

			const IRON_NUGGET: org.bukkit.Material;

			const KNOWLEDGE_BOOK: org.bukkit.Material;

			const DEBUG_STICK: org.bukkit.Material;

			const MUSIC_DISC_13: org.bukkit.Material;

			const MUSIC_DISC_CAT: org.bukkit.Material;

			const MUSIC_DISC_BLOCKS: org.bukkit.Material;

			const MUSIC_DISC_CHIRP: org.bukkit.Material;

			const MUSIC_DISC_CREATOR: org.bukkit.Material;

			const MUSIC_DISC_CREATOR_MUSIC_BOX: org.bukkit.Material;

			const MUSIC_DISC_FAR: org.bukkit.Material;

			const MUSIC_DISC_MALL: org.bukkit.Material;

			const MUSIC_DISC_MELLOHI: org.bukkit.Material;

			const MUSIC_DISC_STAL: org.bukkit.Material;

			const MUSIC_DISC_STRAD: org.bukkit.Material;

			const MUSIC_DISC_WARD: org.bukkit.Material;

			const MUSIC_DISC_11: org.bukkit.Material;

			const MUSIC_DISC_WAIT: org.bukkit.Material;

			const MUSIC_DISC_OTHERSIDE: org.bukkit.Material;

			const MUSIC_DISC_RELIC: org.bukkit.Material;

			const MUSIC_DISC_5: org.bukkit.Material;

			const MUSIC_DISC_PIGSTEP: org.bukkit.Material;

			const MUSIC_DISC_PRECIPICE: org.bukkit.Material;

			const DISC_FRAGMENT_5: org.bukkit.Material;

			const TRIDENT: org.bukkit.Material;

			const PHANTOM_MEMBRANE: org.bukkit.Material;

			const NAUTILUS_SHELL: org.bukkit.Material;

			const HEART_OF_THE_SEA: org.bukkit.Material;

			const CROSSBOW: org.bukkit.Material;

			const SUSPICIOUS_STEW: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const LOOM: org.bukkit.Material;

			const FLOWER_BANNER_PATTERN: org.bukkit.Material;

			const CREEPER_BANNER_PATTERN: org.bukkit.Material;

			const SKULL_BANNER_PATTERN: org.bukkit.Material;

			const MOJANG_BANNER_PATTERN: org.bukkit.Material;

			const GLOBE_BANNER_PATTERN: org.bukkit.Material;

			const PIGLIN_BANNER_PATTERN: org.bukkit.Material;

			const FLOW_BANNER_PATTERN: org.bukkit.Material;

			const GUSTER_BANNER_PATTERN: org.bukkit.Material;

			const GOAT_HORN: org.bukkit.Material;

			/**
			 * BlockData: Levelled
			 */
			const COMPOSTER: org.bukkit.Material;

			/**
			 * BlockData: Barrel
			 */
			const BARREL: org.bukkit.Material;

			/**
			 * BlockData: Furnace
			 */
			const SMOKER: org.bukkit.Material;

			/**
			 * BlockData: Furnace
			 */
			const BLAST_FURNACE: org.bukkit.Material;

			const CARTOGRAPHY_TABLE: org.bukkit.Material;

			const FLETCHING_TABLE: org.bukkit.Material;

			/**
			 * BlockData: Grindstone
			 */
			const GRINDSTONE: org.bukkit.Material;

			const SMITHING_TABLE: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const STONECUTTER: org.bukkit.Material;

			/**
			 * BlockData: Bell
			 */
			const BELL: org.bukkit.Material;

			/**
			 * BlockData: Lantern
			 */
			const LANTERN: org.bukkit.Material;

			/**
			 * BlockData: Lantern
			 */
			const SOUL_LANTERN: org.bukkit.Material;

			const SWEET_BERRIES: org.bukkit.Material;

			const GLOW_BERRIES: org.bukkit.Material;

			/**
			 * BlockData: Campfire
			 */
			const CAMPFIRE: org.bukkit.Material;

			/**
			 * BlockData: Campfire
			 */
			const SOUL_CAMPFIRE: org.bukkit.Material;

			const SHROOMLIGHT: org.bukkit.Material;

			const HONEYCOMB: org.bukkit.Material;

			/**
			 * BlockData: Beehive
			 */
			const BEE_NEST: org.bukkit.Material;

			/**
			 * BlockData: Beehive
			 */
			const BEEHIVE: org.bukkit.Material;

			const HONEY_BOTTLE: org.bukkit.Material;

			const HONEYCOMB_BLOCK: org.bukkit.Material;

			const LODESTONE: org.bukkit.Material;

			const CRYING_OBSIDIAN: org.bukkit.Material;

			const BLACKSTONE: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const BLACKSTONE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const BLACKSTONE_STAIRS: org.bukkit.Material;

			const GILDED_BLACKSTONE: org.bukkit.Material;

			const POLISHED_BLACKSTONE: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const POLISHED_BLACKSTONE_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const POLISHED_BLACKSTONE_STAIRS: org.bukkit.Material;

			const CHISELED_POLISHED_BLACKSTONE: org.bukkit.Material;

			const POLISHED_BLACKSTONE_BRICKS: org.bukkit.Material;

			/**
			 * BlockData: Slab
			 */
			const POLISHED_BLACKSTONE_BRICK_SLAB: org.bukkit.Material;

			/**
			 * BlockData: Stairs
			 */
			const POLISHED_BLACKSTONE_BRICK_STAIRS: org.bukkit.Material;

			const CRACKED_POLISHED_BLACKSTONE_BRICKS: org.bukkit.Material;

			/**
			 * BlockData: RespawnAnchor
			 */
			const RESPAWN_ANCHOR: org.bukkit.Material;

			/**
			 * BlockData: Candle
			 */
			const CANDLE: org.bukkit.Material;

			/**
			 * BlockData: Candle
			 */
			const WHITE_CANDLE: org.bukkit.Material;

			/**
			 * BlockData: Candle
			 */
			const ORANGE_CANDLE: org.bukkit.Material;

			/**
			 * BlockData: Candle
			 */
			const MAGENTA_CANDLE: org.bukkit.Material;

			/**
			 * BlockData: Candle
			 */
			const LIGHT_BLUE_CANDLE: org.bukkit.Material;

			/**
			 * BlockData: Candle
			 */
			const YELLOW_CANDLE: org.bukkit.Material;

			/**
			 * BlockData: Candle
			 */
			const LIME_CANDLE: org.bukkit.Material;

			/**
			 * BlockData: Candle
			 */
			const PINK_CANDLE: org.bukkit.Material;

			/**
			 * BlockData: Candle
			 */
			const GRAY_CANDLE: org.bukkit.Material;

			/**
			 * BlockData: Candle
			 */
			const LIGHT_GRAY_CANDLE: org.bukkit.Material;

			/**
			 * BlockData: Candle
			 */
			const CYAN_CANDLE: org.bukkit.Material;

			/**
			 * BlockData: Candle
			 */
			const PURPLE_CANDLE: org.bukkit.Material;

			/**
			 * BlockData: Candle
			 */
			const BLUE_CANDLE: org.bukkit.Material;

			/**
			 * BlockData: Candle
			 */
			const BROWN_CANDLE: org.bukkit.Material;

			/**
			 * BlockData: Candle
			 */
			const GREEN_CANDLE: org.bukkit.Material;

			/**
			 * BlockData: Candle
			 */
			const RED_CANDLE: org.bukkit.Material;

			/**
			 * BlockData: Candle
			 */
			const BLACK_CANDLE: org.bukkit.Material;

			/**
			 * BlockData: AmethystCluster
			 */
			const SMALL_AMETHYST_BUD: org.bukkit.Material;

			/**
			 * BlockData: AmethystCluster
			 */
			const MEDIUM_AMETHYST_BUD: org.bukkit.Material;

			/**
			 * BlockData: AmethystCluster
			 */
			const LARGE_AMETHYST_BUD: org.bukkit.Material;

			/**
			 * BlockData: AmethystCluster
			 */
			const AMETHYST_CLUSTER: org.bukkit.Material;

			/**
			 * BlockData: PointedDripstone
			 */
			const POINTED_DRIPSTONE: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const OCHRE_FROGLIGHT: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const VERDANT_FROGLIGHT: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const PEARLESCENT_FROGLIGHT: org.bukkit.Material;

			const FROGSPAWN: org.bukkit.Material;

			const ECHO_SHARD: org.bukkit.Material;

			const BRUSH: org.bukkit.Material;

			const NETHERITE_UPGRADE_SMITHING_TEMPLATE: org.bukkit.Material;

			const SENTRY_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.Material;

			const DUNE_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.Material;

			const COAST_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.Material;

			const WILD_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.Material;

			const WARD_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.Material;

			const EYE_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.Material;

			const VEX_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.Material;

			const TIDE_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.Material;

			const SNOUT_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.Material;

			const RIB_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.Material;

			const SPIRE_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.Material;

			const WAYFINDER_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.Material;

			const SHAPER_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.Material;

			const SILENCE_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.Material;

			const RAISER_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.Material;

			const HOST_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.Material;

			const FLOW_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.Material;

			const BOLT_ARMOR_TRIM_SMITHING_TEMPLATE: org.bukkit.Material;

			const ANGLER_POTTERY_SHERD: org.bukkit.Material;

			const ARCHER_POTTERY_SHERD: org.bukkit.Material;

			const ARMS_UP_POTTERY_SHERD: org.bukkit.Material;

			const BLADE_POTTERY_SHERD: org.bukkit.Material;

			const BREWER_POTTERY_SHERD: org.bukkit.Material;

			const BURN_POTTERY_SHERD: org.bukkit.Material;

			const DANGER_POTTERY_SHERD: org.bukkit.Material;

			const EXPLORER_POTTERY_SHERD: org.bukkit.Material;

			const FLOW_POTTERY_SHERD: org.bukkit.Material;

			const FRIEND_POTTERY_SHERD: org.bukkit.Material;

			const GUSTER_POTTERY_SHERD: org.bukkit.Material;

			const HEART_POTTERY_SHERD: org.bukkit.Material;

			const HEARTBREAK_POTTERY_SHERD: org.bukkit.Material;

			const HOWL_POTTERY_SHERD: org.bukkit.Material;

			const MINER_POTTERY_SHERD: org.bukkit.Material;

			const MOURNER_POTTERY_SHERD: org.bukkit.Material;

			const PLENTY_POTTERY_SHERD: org.bukkit.Material;

			const PRIZE_POTTERY_SHERD: org.bukkit.Material;

			const SCRAPE_POTTERY_SHERD: org.bukkit.Material;

			const SHEAF_POTTERY_SHERD: org.bukkit.Material;

			const SHELTER_POTTERY_SHERD: org.bukkit.Material;

			const SKULL_POTTERY_SHERD: org.bukkit.Material;

			const SNORT_POTTERY_SHERD: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const COPPER_GRATE: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const EXPOSED_COPPER_GRATE: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const WEATHERED_COPPER_GRATE: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const OXIDIZED_COPPER_GRATE: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const WAXED_COPPER_GRATE: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const WAXED_EXPOSED_COPPER_GRATE: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const WAXED_WEATHERED_COPPER_GRATE: org.bukkit.Material;

			/**
			 * BlockData: Waterlogged
			 */
			const WAXED_OXIDIZED_COPPER_GRATE: org.bukkit.Material;

			/**
			 * BlockData: CopperBulb
			 */
			const COPPER_BULB: org.bukkit.Material;

			/**
			 * BlockData: CopperBulb
			 */
			const EXPOSED_COPPER_BULB: org.bukkit.Material;

			/**
			 * BlockData: CopperBulb
			 */
			const WEATHERED_COPPER_BULB: org.bukkit.Material;

			/**
			 * BlockData: CopperBulb
			 */
			const OXIDIZED_COPPER_BULB: org.bukkit.Material;

			/**
			 * BlockData: CopperBulb
			 */
			const WAXED_COPPER_BULB: org.bukkit.Material;

			/**
			 * BlockData: CopperBulb
			 */
			const WAXED_EXPOSED_COPPER_BULB: org.bukkit.Material;

			/**
			 * BlockData: CopperBulb
			 */
			const WAXED_WEATHERED_COPPER_BULB: org.bukkit.Material;

			/**
			 * BlockData: CopperBulb
			 */
			const WAXED_OXIDIZED_COPPER_BULB: org.bukkit.Material;

			/**
			 * BlockData: TrialSpawner
			 */
			const TRIAL_SPAWNER: org.bukkit.Material;

			const TRIAL_KEY: org.bukkit.Material;

			const OMINOUS_TRIAL_KEY: org.bukkit.Material;

			/**
			 * BlockData: Vault
			 */
			const VAULT: org.bukkit.Material;

			const OMINOUS_BOTTLE: org.bukkit.Material;

			const BREEZE_ROD: org.bukkit.Material;

			/**
			 * BlockData: Levelled
			 */
			const WATER: org.bukkit.Material;

			/**
			 * BlockData: Levelled
			 */
			const LAVA: org.bukkit.Material;

			/**
			 * BlockData: Bisected
			 */
			const TALL_SEAGRASS: org.bukkit.Material;

			/**
			 * BlockData: PistonHead
			 */
			const PISTON_HEAD: org.bukkit.Material;

			/**
			 * BlockData: TechnicalPiston
			 */
			const MOVING_PISTON: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const WALL_TORCH: org.bukkit.Material;

			/**
			 * BlockData: Fire
			 */
			const FIRE: org.bukkit.Material;

			const SOUL_FIRE: org.bukkit.Material;

			/**
			 * BlockData: RedstoneWire
			 */
			const REDSTONE_WIRE: org.bukkit.Material;

			/**
			 * BlockData: WallSign
			 */
			const OAK_WALL_SIGN: org.bukkit.Material;

			/**
			 * BlockData: WallSign
			 */
			const SPRUCE_WALL_SIGN: org.bukkit.Material;

			/**
			 * BlockData: WallSign
			 */
			const BIRCH_WALL_SIGN: org.bukkit.Material;

			/**
			 * BlockData: WallSign
			 */
			const ACACIA_WALL_SIGN: org.bukkit.Material;

			/**
			 * BlockData: WallSign
			 */
			const CHERRY_WALL_SIGN: org.bukkit.Material;

			/**
			 * BlockData: WallSign
			 */
			const JUNGLE_WALL_SIGN: org.bukkit.Material;

			/**
			 * BlockData: WallSign
			 */
			const DARK_OAK_WALL_SIGN: org.bukkit.Material;

			/**
			 * BlockData: WallSign
			 */
			const MANGROVE_WALL_SIGN: org.bukkit.Material;

			/**
			 * BlockData: WallSign
			 */
			const BAMBOO_WALL_SIGN: org.bukkit.Material;

			/**
			 * BlockData: WallHangingSign
			 */
			const OAK_WALL_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: WallHangingSign
			 */
			const SPRUCE_WALL_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: WallHangingSign
			 */
			const BIRCH_WALL_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: WallHangingSign
			 */
			const ACACIA_WALL_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: WallHangingSign
			 */
			const CHERRY_WALL_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: WallHangingSign
			 */
			const JUNGLE_WALL_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: WallHangingSign
			 */
			const DARK_OAK_WALL_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: WallHangingSign
			 */
			const MANGROVE_WALL_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: WallHangingSign
			 */
			const CRIMSON_WALL_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: WallHangingSign
			 */
			const WARPED_WALL_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: WallHangingSign
			 */
			const BAMBOO_WALL_HANGING_SIGN: org.bukkit.Material;

			/**
			 * BlockData: RedstoneWallTorch
			 */
			const REDSTONE_WALL_TORCH: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const SOUL_WALL_TORCH: org.bukkit.Material;

			/**
			 * BlockData: Orientable
			 */
			const NETHER_PORTAL: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const ATTACHED_PUMPKIN_STEM: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const ATTACHED_MELON_STEM: org.bukkit.Material;

			/**
			 * BlockData: Ageable
			 */
			const PUMPKIN_STEM: org.bukkit.Material;

			/**
			 * BlockData: Ageable
			 */
			const MELON_STEM: org.bukkit.Material;

			/**
			 * BlockData: Levelled
			 */
			const WATER_CAULDRON: org.bukkit.Material;

			const LAVA_CAULDRON: org.bukkit.Material;

			/**
			 * BlockData: Levelled
			 */
			const POWDER_SNOW_CAULDRON: org.bukkit.Material;

			const END_PORTAL: org.bukkit.Material;

			/**
			 * BlockData: Cocoa
			 */
			const COCOA: org.bukkit.Material;

			/**
			 * BlockData: Tripwire
			 */
			const TRIPWIRE: org.bukkit.Material;

			const POTTED_TORCHFLOWER: org.bukkit.Material;

			const POTTED_OAK_SAPLING: org.bukkit.Material;

			const POTTED_SPRUCE_SAPLING: org.bukkit.Material;

			const POTTED_BIRCH_SAPLING: org.bukkit.Material;

			const POTTED_JUNGLE_SAPLING: org.bukkit.Material;

			const POTTED_ACACIA_SAPLING: org.bukkit.Material;

			const POTTED_CHERRY_SAPLING: org.bukkit.Material;

			const POTTED_DARK_OAK_SAPLING: org.bukkit.Material;

			const POTTED_MANGROVE_PROPAGULE: org.bukkit.Material;

			const POTTED_FERN: org.bukkit.Material;

			const POTTED_DANDELION: org.bukkit.Material;

			const POTTED_POPPY: org.bukkit.Material;

			const POTTED_BLUE_ORCHID: org.bukkit.Material;

			const POTTED_ALLIUM: org.bukkit.Material;

			const POTTED_AZURE_BLUET: org.bukkit.Material;

			const POTTED_RED_TULIP: org.bukkit.Material;

			const POTTED_ORANGE_TULIP: org.bukkit.Material;

			const POTTED_WHITE_TULIP: org.bukkit.Material;

			const POTTED_PINK_TULIP: org.bukkit.Material;

			const POTTED_OXEYE_DAISY: org.bukkit.Material;

			const POTTED_CORNFLOWER: org.bukkit.Material;

			const POTTED_LILY_OF_THE_VALLEY: org.bukkit.Material;

			const POTTED_WITHER_ROSE: org.bukkit.Material;

			const POTTED_RED_MUSHROOM: org.bukkit.Material;

			const POTTED_BROWN_MUSHROOM: org.bukkit.Material;

			const POTTED_DEAD_BUSH: org.bukkit.Material;

			const POTTED_CACTUS: org.bukkit.Material;

			/**
			 * BlockData: Ageable
			 */
			const CARROTS: org.bukkit.Material;

			/**
			 * BlockData: Ageable
			 */
			const POTATOES: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const SKELETON_WALL_SKULL: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const WITHER_SKELETON_WALL_SKULL: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const ZOMBIE_WALL_HEAD: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const PLAYER_WALL_HEAD: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const CREEPER_WALL_HEAD: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const DRAGON_WALL_HEAD: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const PIGLIN_WALL_HEAD: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const WHITE_WALL_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const ORANGE_WALL_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const MAGENTA_WALL_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const LIGHT_BLUE_WALL_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const YELLOW_WALL_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const LIME_WALL_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const PINK_WALL_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const GRAY_WALL_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const LIGHT_GRAY_WALL_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const CYAN_WALL_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const PURPLE_WALL_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const BLUE_WALL_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const BROWN_WALL_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const GREEN_WALL_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const RED_WALL_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Directional
			 */
			const BLACK_WALL_BANNER: org.bukkit.Material;

			/**
			 * BlockData: Ageable
			 */
			const TORCHFLOWER_CROP: org.bukkit.Material;

			/**
			 * BlockData: PitcherCrop
			 */
			const PITCHER_CROP: org.bukkit.Material;

			/**
			 * BlockData: Ageable
			 */
			const BEETROOTS: org.bukkit.Material;

			const END_GATEWAY: org.bukkit.Material;

			/**
			 * BlockData: Ageable
			 */
			const FROSTED_ICE: org.bukkit.Material;

			const KELP_PLANT: org.bukkit.Material;

			/**
			 * BlockData: CoralWallFan
			 */
			const DEAD_TUBE_CORAL_WALL_FAN: org.bukkit.Material;

			/**
			 * BlockData: CoralWallFan
			 */
			const DEAD_BRAIN_CORAL_WALL_FAN: org.bukkit.Material;

			/**
			 * BlockData: CoralWallFan
			 */
			const DEAD_BUBBLE_CORAL_WALL_FAN: org.bukkit.Material;

			/**
			 * BlockData: CoralWallFan
			 */
			const DEAD_FIRE_CORAL_WALL_FAN: org.bukkit.Material;

			/**
			 * BlockData: CoralWallFan
			 */
			const DEAD_HORN_CORAL_WALL_FAN: org.bukkit.Material;

			/**
			 * BlockData: CoralWallFan
			 */
			const TUBE_CORAL_WALL_FAN: org.bukkit.Material;

			/**
			 * BlockData: CoralWallFan
			 */
			const BRAIN_CORAL_WALL_FAN: org.bukkit.Material;

			/**
			 * BlockData: CoralWallFan
			 */
			const BUBBLE_CORAL_WALL_FAN: org.bukkit.Material;

			/**
			 * BlockData: CoralWallFan
			 */
			const FIRE_CORAL_WALL_FAN: org.bukkit.Material;

			/**
			 * BlockData: CoralWallFan
			 */
			const HORN_CORAL_WALL_FAN: org.bukkit.Material;

			const BAMBOO_SAPLING: org.bukkit.Material;

			const POTTED_BAMBOO: org.bukkit.Material;

			const VOID_AIR: org.bukkit.Material;

			const CAVE_AIR: org.bukkit.Material;

			/**
			 * BlockData: BubbleColumn
			 */
			const BUBBLE_COLUMN: org.bukkit.Material;

			/**
			 * BlockData: Ageable
			 */
			const SWEET_BERRY_BUSH: org.bukkit.Material;

			const WEEPING_VINES_PLANT: org.bukkit.Material;

			const TWISTING_VINES_PLANT: org.bukkit.Material;

			/**
			 * BlockData: WallSign
			 */
			const CRIMSON_WALL_SIGN: org.bukkit.Material;

			/**
			 * BlockData: WallSign
			 */
			const WARPED_WALL_SIGN: org.bukkit.Material;

			const POTTED_CRIMSON_FUNGUS: org.bukkit.Material;

			const POTTED_WARPED_FUNGUS: org.bukkit.Material;

			const POTTED_CRIMSON_ROOTS: org.bukkit.Material;

			const POTTED_WARPED_ROOTS: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const CANDLE_CAKE: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const WHITE_CANDLE_CAKE: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const ORANGE_CANDLE_CAKE: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const MAGENTA_CANDLE_CAKE: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const LIGHT_BLUE_CANDLE_CAKE: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const YELLOW_CANDLE_CAKE: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const LIME_CANDLE_CAKE: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const PINK_CANDLE_CAKE: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const GRAY_CANDLE_CAKE: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const LIGHT_GRAY_CANDLE_CAKE: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const CYAN_CANDLE_CAKE: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const PURPLE_CANDLE_CAKE: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const BLUE_CANDLE_CAKE: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const BROWN_CANDLE_CAKE: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const GREEN_CANDLE_CAKE: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const RED_CANDLE_CAKE: org.bukkit.Material;

			/**
			 * BlockData: Lightable
			 */
			const BLACK_CANDLE_CAKE: org.bukkit.Material;

			const POWDER_SNOW: org.bukkit.Material;

			/**
			 * BlockData: CaveVines
			 */
			const CAVE_VINES: org.bukkit.Material;

			/**
			 * BlockData: CaveVinesPlant
			 */
			const CAVE_VINES_PLANT: org.bukkit.Material;

			/**
			 * BlockData: Dripleaf
			 */
			const BIG_DRIPLEAF_STEM: org.bukkit.Material;

			const POTTED_AZALEA_BUSH: org.bukkit.Material;

			const POTTED_FLOWERING_AZALEA_BUSH: org.bukkit.Material;

			const LEGACY_AIR: org.bukkit.Material;

			const LEGACY_STONE: org.bukkit.Material;

			const LEGACY_GRASS: org.bukkit.Material;

			const LEGACY_DIRT: org.bukkit.Material;

			const LEGACY_COBBLESTONE: org.bukkit.Material;

			const LEGACY_WOOD: org.bukkit.Material;

			const LEGACY_SAPLING: org.bukkit.Material;

			const LEGACY_BEDROCK: org.bukkit.Material;

			const LEGACY_WATER: org.bukkit.Material;

			const LEGACY_STATIONARY_WATER: org.bukkit.Material;

			const LEGACY_LAVA: org.bukkit.Material;

			const LEGACY_STATIONARY_LAVA: org.bukkit.Material;

			const LEGACY_SAND: org.bukkit.Material;

			const LEGACY_GRAVEL: org.bukkit.Material;

			const LEGACY_GOLD_ORE: org.bukkit.Material;

			const LEGACY_IRON_ORE: org.bukkit.Material;

			const LEGACY_COAL_ORE: org.bukkit.Material;

			const LEGACY_LOG: org.bukkit.Material;

			const LEGACY_LEAVES: org.bukkit.Material;

			const LEGACY_SPONGE: org.bukkit.Material;

			const LEGACY_GLASS: org.bukkit.Material;

			const LEGACY_LAPIS_ORE: org.bukkit.Material;

			const LEGACY_LAPIS_BLOCK: org.bukkit.Material;

			const LEGACY_DISPENSER: org.bukkit.Material;

			const LEGACY_SANDSTONE: org.bukkit.Material;

			const LEGACY_NOTE_BLOCK: org.bukkit.Material;

			const LEGACY_BED_BLOCK: org.bukkit.Material;

			const LEGACY_POWERED_RAIL: org.bukkit.Material;

			const LEGACY_DETECTOR_RAIL: org.bukkit.Material;

			const LEGACY_PISTON_STICKY_BASE: org.bukkit.Material;

			const LEGACY_WEB: org.bukkit.Material;

			const LEGACY_LONG_GRASS: org.bukkit.Material;

			const LEGACY_DEAD_BUSH: org.bukkit.Material;

			const LEGACY_PISTON_BASE: org.bukkit.Material;

			const LEGACY_PISTON_EXTENSION: org.bukkit.Material;

			const LEGACY_WOOL: org.bukkit.Material;

			const LEGACY_PISTON_MOVING_PIECE: org.bukkit.Material;

			const LEGACY_YELLOW_FLOWER: org.bukkit.Material;

			const LEGACY_RED_ROSE: org.bukkit.Material;

			const LEGACY_BROWN_MUSHROOM: org.bukkit.Material;

			const LEGACY_RED_MUSHROOM: org.bukkit.Material;

			const LEGACY_GOLD_BLOCK: org.bukkit.Material;

			const LEGACY_IRON_BLOCK: org.bukkit.Material;

			const LEGACY_DOUBLE_STEP: org.bukkit.Material;

			const LEGACY_STEP: org.bukkit.Material;

			const LEGACY_BRICK: org.bukkit.Material;

			const LEGACY_TNT: org.bukkit.Material;

			const LEGACY_BOOKSHELF: org.bukkit.Material;

			const LEGACY_MOSSY_COBBLESTONE: org.bukkit.Material;

			const LEGACY_OBSIDIAN: org.bukkit.Material;

			const LEGACY_TORCH: org.bukkit.Material;

			const LEGACY_FIRE: org.bukkit.Material;

			const LEGACY_MOB_SPAWNER: org.bukkit.Material;

			const LEGACY_WOOD_STAIRS: org.bukkit.Material;

			const LEGACY_CHEST: org.bukkit.Material;

			const LEGACY_REDSTONE_WIRE: org.bukkit.Material;

			const LEGACY_DIAMOND_ORE: org.bukkit.Material;

			const LEGACY_DIAMOND_BLOCK: org.bukkit.Material;

			const LEGACY_WORKBENCH: org.bukkit.Material;

			const LEGACY_CROPS: org.bukkit.Material;

			const LEGACY_SOIL: org.bukkit.Material;

			const LEGACY_FURNACE: org.bukkit.Material;

			const LEGACY_BURNING_FURNACE: org.bukkit.Material;

			const LEGACY_SIGN_POST: org.bukkit.Material;

			const LEGACY_WOODEN_DOOR: org.bukkit.Material;

			const LEGACY_LADDER: org.bukkit.Material;

			const LEGACY_RAILS: org.bukkit.Material;

			const LEGACY_COBBLESTONE_STAIRS: org.bukkit.Material;

			const LEGACY_WALL_SIGN: org.bukkit.Material;

			const LEGACY_LEVER: org.bukkit.Material;

			const LEGACY_STONE_PLATE: org.bukkit.Material;

			const LEGACY_IRON_DOOR_BLOCK: org.bukkit.Material;

			const LEGACY_WOOD_PLATE: org.bukkit.Material;

			const LEGACY_REDSTONE_ORE: org.bukkit.Material;

			const LEGACY_GLOWING_REDSTONE_ORE: org.bukkit.Material;

			const LEGACY_REDSTONE_TORCH_OFF: org.bukkit.Material;

			const LEGACY_REDSTONE_TORCH_ON: org.bukkit.Material;

			const LEGACY_STONE_BUTTON: org.bukkit.Material;

			const LEGACY_SNOW: org.bukkit.Material;

			const LEGACY_ICE: org.bukkit.Material;

			const LEGACY_SNOW_BLOCK: org.bukkit.Material;

			const LEGACY_CACTUS: org.bukkit.Material;

			const LEGACY_CLAY: org.bukkit.Material;

			const LEGACY_SUGAR_CANE_BLOCK: org.bukkit.Material;

			const LEGACY_JUKEBOX: org.bukkit.Material;

			const LEGACY_FENCE: org.bukkit.Material;

			const LEGACY_PUMPKIN: org.bukkit.Material;

			const LEGACY_NETHERRACK: org.bukkit.Material;

			const LEGACY_SOUL_SAND: org.bukkit.Material;

			const LEGACY_GLOWSTONE: org.bukkit.Material;

			const LEGACY_PORTAL: org.bukkit.Material;

			const LEGACY_JACK_O_LANTERN: org.bukkit.Material;

			const LEGACY_CAKE_BLOCK: org.bukkit.Material;

			const LEGACY_DIODE_BLOCK_OFF: org.bukkit.Material;

			const LEGACY_DIODE_BLOCK_ON: org.bukkit.Material;

			const LEGACY_STAINED_GLASS: org.bukkit.Material;

			const LEGACY_TRAP_DOOR: org.bukkit.Material;

			const LEGACY_MONSTER_EGGS: org.bukkit.Material;

			const LEGACY_SMOOTH_BRICK: org.bukkit.Material;

			const LEGACY_HUGE_MUSHROOM_1: org.bukkit.Material;

			const LEGACY_HUGE_MUSHROOM_2: org.bukkit.Material;

			const LEGACY_IRON_FENCE: org.bukkit.Material;

			const LEGACY_THIN_GLASS: org.bukkit.Material;

			const LEGACY_MELON_BLOCK: org.bukkit.Material;

			const LEGACY_PUMPKIN_STEM: org.bukkit.Material;

			const LEGACY_MELON_STEM: org.bukkit.Material;

			const LEGACY_VINE: org.bukkit.Material;

			const LEGACY_FENCE_GATE: org.bukkit.Material;

			const LEGACY_BRICK_STAIRS: org.bukkit.Material;

			const LEGACY_SMOOTH_STAIRS: org.bukkit.Material;

			const LEGACY_MYCEL: org.bukkit.Material;

			const LEGACY_WATER_LILY: org.bukkit.Material;

			const LEGACY_NETHER_BRICK: org.bukkit.Material;

			const LEGACY_NETHER_FENCE: org.bukkit.Material;

			const LEGACY_NETHER_BRICK_STAIRS: org.bukkit.Material;

			const LEGACY_NETHER_WARTS: org.bukkit.Material;

			const LEGACY_ENCHANTMENT_TABLE: org.bukkit.Material;

			const LEGACY_BREWING_STAND: org.bukkit.Material;

			const LEGACY_CAULDRON: org.bukkit.Material;

			const LEGACY_ENDER_PORTAL: org.bukkit.Material;

			const LEGACY_ENDER_PORTAL_FRAME: org.bukkit.Material;

			const LEGACY_ENDER_STONE: org.bukkit.Material;

			const LEGACY_DRAGON_EGG: org.bukkit.Material;

			const LEGACY_REDSTONE_LAMP_OFF: org.bukkit.Material;

			const LEGACY_REDSTONE_LAMP_ON: org.bukkit.Material;

			const LEGACY_WOOD_DOUBLE_STEP: org.bukkit.Material;

			const LEGACY_WOOD_STEP: org.bukkit.Material;

			const LEGACY_COCOA: org.bukkit.Material;

			const LEGACY_SANDSTONE_STAIRS: org.bukkit.Material;

			const LEGACY_EMERALD_ORE: org.bukkit.Material;

			const LEGACY_ENDER_CHEST: org.bukkit.Material;

			const LEGACY_TRIPWIRE_HOOK: org.bukkit.Material;

			const LEGACY_TRIPWIRE: org.bukkit.Material;

			const LEGACY_EMERALD_BLOCK: org.bukkit.Material;

			const LEGACY_SPRUCE_WOOD_STAIRS: org.bukkit.Material;

			const LEGACY_BIRCH_WOOD_STAIRS: org.bukkit.Material;

			const LEGACY_JUNGLE_WOOD_STAIRS: org.bukkit.Material;

			const LEGACY_COMMAND: org.bukkit.Material;

			const LEGACY_BEACON: org.bukkit.Material;

			const LEGACY_COBBLE_WALL: org.bukkit.Material;

			const LEGACY_FLOWER_POT: org.bukkit.Material;

			const LEGACY_CARROT: org.bukkit.Material;

			const LEGACY_POTATO: org.bukkit.Material;

			const LEGACY_WOOD_BUTTON: org.bukkit.Material;

			const LEGACY_SKULL: org.bukkit.Material;

			const LEGACY_ANVIL: org.bukkit.Material;

			const LEGACY_TRAPPED_CHEST: org.bukkit.Material;

			const LEGACY_GOLD_PLATE: org.bukkit.Material;

			const LEGACY_IRON_PLATE: org.bukkit.Material;

			const LEGACY_REDSTONE_COMPARATOR_OFF: org.bukkit.Material;

			const LEGACY_REDSTONE_COMPARATOR_ON: org.bukkit.Material;

			const LEGACY_DAYLIGHT_DETECTOR: org.bukkit.Material;

			const LEGACY_REDSTONE_BLOCK: org.bukkit.Material;

			const LEGACY_QUARTZ_ORE: org.bukkit.Material;

			const LEGACY_HOPPER: org.bukkit.Material;

			const LEGACY_QUARTZ_BLOCK: org.bukkit.Material;

			const LEGACY_QUARTZ_STAIRS: org.bukkit.Material;

			const LEGACY_ACTIVATOR_RAIL: org.bukkit.Material;

			const LEGACY_DROPPER: org.bukkit.Material;

			const LEGACY_STAINED_CLAY: org.bukkit.Material;

			const LEGACY_STAINED_GLASS_PANE: org.bukkit.Material;

			const LEGACY_LEAVES_2: org.bukkit.Material;

			const LEGACY_LOG_2: org.bukkit.Material;

			const LEGACY_ACACIA_STAIRS: org.bukkit.Material;

			const LEGACY_DARK_OAK_STAIRS: org.bukkit.Material;

			const LEGACY_SLIME_BLOCK: org.bukkit.Material;

			const LEGACY_BARRIER: org.bukkit.Material;

			const LEGACY_IRON_TRAPDOOR: org.bukkit.Material;

			const LEGACY_PRISMARINE: org.bukkit.Material;

			const LEGACY_SEA_LANTERN: org.bukkit.Material;

			const LEGACY_HAY_BLOCK: org.bukkit.Material;

			const LEGACY_CARPET: org.bukkit.Material;

			const LEGACY_HARD_CLAY: org.bukkit.Material;

			const LEGACY_COAL_BLOCK: org.bukkit.Material;

			const LEGACY_PACKED_ICE: org.bukkit.Material;

			const LEGACY_DOUBLE_PLANT: org.bukkit.Material;

			const LEGACY_STANDING_BANNER: org.bukkit.Material;

			const LEGACY_WALL_BANNER: org.bukkit.Material;

			const LEGACY_DAYLIGHT_DETECTOR_INVERTED: org.bukkit.Material;

			const LEGACY_RED_SANDSTONE: org.bukkit.Material;

			const LEGACY_RED_SANDSTONE_STAIRS: org.bukkit.Material;

			const LEGACY_DOUBLE_STONE_SLAB2: org.bukkit.Material;

			const LEGACY_STONE_SLAB2: org.bukkit.Material;

			const LEGACY_SPRUCE_FENCE_GATE: org.bukkit.Material;

			const LEGACY_BIRCH_FENCE_GATE: org.bukkit.Material;

			const LEGACY_JUNGLE_FENCE_GATE: org.bukkit.Material;

			const LEGACY_DARK_OAK_FENCE_GATE: org.bukkit.Material;

			const LEGACY_ACACIA_FENCE_GATE: org.bukkit.Material;

			const LEGACY_SPRUCE_FENCE: org.bukkit.Material;

			const LEGACY_BIRCH_FENCE: org.bukkit.Material;

			const LEGACY_JUNGLE_FENCE: org.bukkit.Material;

			const LEGACY_DARK_OAK_FENCE: org.bukkit.Material;

			const LEGACY_ACACIA_FENCE: org.bukkit.Material;

			const LEGACY_SPRUCE_DOOR: org.bukkit.Material;

			const LEGACY_BIRCH_DOOR: org.bukkit.Material;

			const LEGACY_JUNGLE_DOOR: org.bukkit.Material;

			const LEGACY_ACACIA_DOOR: org.bukkit.Material;

			const LEGACY_DARK_OAK_DOOR: org.bukkit.Material;

			const LEGACY_END_ROD: org.bukkit.Material;

			const LEGACY_CHORUS_PLANT: org.bukkit.Material;

			const LEGACY_CHORUS_FLOWER: org.bukkit.Material;

			const LEGACY_PURPUR_BLOCK: org.bukkit.Material;

			const LEGACY_PURPUR_PILLAR: org.bukkit.Material;

			const LEGACY_PURPUR_STAIRS: org.bukkit.Material;

			const LEGACY_PURPUR_DOUBLE_SLAB: org.bukkit.Material;

			const LEGACY_PURPUR_SLAB: org.bukkit.Material;

			const LEGACY_END_BRICKS: org.bukkit.Material;

			const LEGACY_BEETROOT_BLOCK: org.bukkit.Material;

			const LEGACY_GRASS_PATH: org.bukkit.Material;

			const LEGACY_END_GATEWAY: org.bukkit.Material;

			const LEGACY_COMMAND_REPEATING: org.bukkit.Material;

			const LEGACY_COMMAND_CHAIN: org.bukkit.Material;

			const LEGACY_FROSTED_ICE: org.bukkit.Material;

			const LEGACY_MAGMA: org.bukkit.Material;

			const LEGACY_NETHER_WART_BLOCK: org.bukkit.Material;

			const LEGACY_RED_NETHER_BRICK: org.bukkit.Material;

			const LEGACY_BONE_BLOCK: org.bukkit.Material;

			const LEGACY_STRUCTURE_VOID: org.bukkit.Material;

			const LEGACY_OBSERVER: org.bukkit.Material;

			const LEGACY_WHITE_SHULKER_BOX: org.bukkit.Material;

			const LEGACY_ORANGE_SHULKER_BOX: org.bukkit.Material;

			const LEGACY_MAGENTA_SHULKER_BOX: org.bukkit.Material;

			const LEGACY_LIGHT_BLUE_SHULKER_BOX: org.bukkit.Material;

			const LEGACY_YELLOW_SHULKER_BOX: org.bukkit.Material;

			const LEGACY_LIME_SHULKER_BOX: org.bukkit.Material;

			const LEGACY_PINK_SHULKER_BOX: org.bukkit.Material;

			const LEGACY_GRAY_SHULKER_BOX: org.bukkit.Material;

			const LEGACY_SILVER_SHULKER_BOX: org.bukkit.Material;

			const LEGACY_CYAN_SHULKER_BOX: org.bukkit.Material;

			const LEGACY_PURPLE_SHULKER_BOX: org.bukkit.Material;

			const LEGACY_BLUE_SHULKER_BOX: org.bukkit.Material;

			const LEGACY_BROWN_SHULKER_BOX: org.bukkit.Material;

			const LEGACY_GREEN_SHULKER_BOX: org.bukkit.Material;

			const LEGACY_RED_SHULKER_BOX: org.bukkit.Material;

			const LEGACY_BLACK_SHULKER_BOX: org.bukkit.Material;

			const LEGACY_WHITE_GLAZED_TERRACOTTA: org.bukkit.Material;

			const LEGACY_ORANGE_GLAZED_TERRACOTTA: org.bukkit.Material;

			const LEGACY_MAGENTA_GLAZED_TERRACOTTA: org.bukkit.Material;

			const LEGACY_LIGHT_BLUE_GLAZED_TERRACOTTA: org.bukkit.Material;

			const LEGACY_YELLOW_GLAZED_TERRACOTTA: org.bukkit.Material;

			const LEGACY_LIME_GLAZED_TERRACOTTA: org.bukkit.Material;

			const LEGACY_PINK_GLAZED_TERRACOTTA: org.bukkit.Material;

			const LEGACY_GRAY_GLAZED_TERRACOTTA: org.bukkit.Material;

			const LEGACY_SILVER_GLAZED_TERRACOTTA: org.bukkit.Material;

			const LEGACY_CYAN_GLAZED_TERRACOTTA: org.bukkit.Material;

			const LEGACY_PURPLE_GLAZED_TERRACOTTA: org.bukkit.Material;

			const LEGACY_BLUE_GLAZED_TERRACOTTA: org.bukkit.Material;

			const LEGACY_BROWN_GLAZED_TERRACOTTA: org.bukkit.Material;

			const LEGACY_GREEN_GLAZED_TERRACOTTA: org.bukkit.Material;

			const LEGACY_RED_GLAZED_TERRACOTTA: org.bukkit.Material;

			const LEGACY_BLACK_GLAZED_TERRACOTTA: org.bukkit.Material;

			const LEGACY_CONCRETE: org.bukkit.Material;

			const LEGACY_CONCRETE_POWDER: org.bukkit.Material;

			const LEGACY_STRUCTURE_BLOCK: org.bukkit.Material;

			const LEGACY_IRON_SPADE: org.bukkit.Material;

			const LEGACY_IRON_PICKAXE: org.bukkit.Material;

			const LEGACY_IRON_AXE: org.bukkit.Material;

			const LEGACY_FLINT_AND_STEEL: org.bukkit.Material;

			const LEGACY_APPLE: org.bukkit.Material;

			const LEGACY_BOW: org.bukkit.Material;

			const LEGACY_ARROW: org.bukkit.Material;

			const LEGACY_COAL: org.bukkit.Material;

			const LEGACY_DIAMOND: org.bukkit.Material;

			const LEGACY_IRON_INGOT: org.bukkit.Material;

			const LEGACY_GOLD_INGOT: org.bukkit.Material;

			const LEGACY_IRON_SWORD: org.bukkit.Material;

			const LEGACY_WOOD_SWORD: org.bukkit.Material;

			const LEGACY_WOOD_SPADE: org.bukkit.Material;

			const LEGACY_WOOD_PICKAXE: org.bukkit.Material;

			const LEGACY_WOOD_AXE: org.bukkit.Material;

			const LEGACY_STONE_SWORD: org.bukkit.Material;

			const LEGACY_STONE_SPADE: org.bukkit.Material;

			const LEGACY_STONE_PICKAXE: org.bukkit.Material;

			const LEGACY_STONE_AXE: org.bukkit.Material;

			const LEGACY_DIAMOND_SWORD: org.bukkit.Material;

			const LEGACY_DIAMOND_SPADE: org.bukkit.Material;

			const LEGACY_DIAMOND_PICKAXE: org.bukkit.Material;

			const LEGACY_DIAMOND_AXE: org.bukkit.Material;

			const LEGACY_STICK: org.bukkit.Material;

			const LEGACY_BOWL: org.bukkit.Material;

			const LEGACY_MUSHROOM_SOUP: org.bukkit.Material;

			const LEGACY_GOLD_SWORD: org.bukkit.Material;

			const LEGACY_GOLD_SPADE: org.bukkit.Material;

			const LEGACY_GOLD_PICKAXE: org.bukkit.Material;

			const LEGACY_GOLD_AXE: org.bukkit.Material;

			const LEGACY_STRING: org.bukkit.Material;

			const LEGACY_FEATHER: org.bukkit.Material;

			const LEGACY_SULPHUR: org.bukkit.Material;

			const LEGACY_WOOD_HOE: org.bukkit.Material;

			const LEGACY_STONE_HOE: org.bukkit.Material;

			const LEGACY_IRON_HOE: org.bukkit.Material;

			const LEGACY_DIAMOND_HOE: org.bukkit.Material;

			const LEGACY_GOLD_HOE: org.bukkit.Material;

			const LEGACY_SEEDS: org.bukkit.Material;

			const LEGACY_WHEAT: org.bukkit.Material;

			const LEGACY_BREAD: org.bukkit.Material;

			const LEGACY_LEATHER_HELMET: org.bukkit.Material;

			const LEGACY_LEATHER_CHESTPLATE: org.bukkit.Material;

			const LEGACY_LEATHER_LEGGINGS: org.bukkit.Material;

			const LEGACY_LEATHER_BOOTS: org.bukkit.Material;

			const LEGACY_CHAINMAIL_HELMET: org.bukkit.Material;

			const LEGACY_CHAINMAIL_CHESTPLATE: org.bukkit.Material;

			const LEGACY_CHAINMAIL_LEGGINGS: org.bukkit.Material;

			const LEGACY_CHAINMAIL_BOOTS: org.bukkit.Material;

			const LEGACY_IRON_HELMET: org.bukkit.Material;

			const LEGACY_IRON_CHESTPLATE: org.bukkit.Material;

			const LEGACY_IRON_LEGGINGS: org.bukkit.Material;

			const LEGACY_IRON_BOOTS: org.bukkit.Material;

			const LEGACY_DIAMOND_HELMET: org.bukkit.Material;

			const LEGACY_DIAMOND_CHESTPLATE: org.bukkit.Material;

			const LEGACY_DIAMOND_LEGGINGS: org.bukkit.Material;

			const LEGACY_DIAMOND_BOOTS: org.bukkit.Material;

			const LEGACY_GOLD_HELMET: org.bukkit.Material;

			const LEGACY_GOLD_CHESTPLATE: org.bukkit.Material;

			const LEGACY_GOLD_LEGGINGS: org.bukkit.Material;

			const LEGACY_GOLD_BOOTS: org.bukkit.Material;

			const LEGACY_FLINT: org.bukkit.Material;

			const LEGACY_PORK: org.bukkit.Material;

			const LEGACY_GRILLED_PORK: org.bukkit.Material;

			const LEGACY_PAINTING: org.bukkit.Material;

			const LEGACY_GOLDEN_APPLE: org.bukkit.Material;

			const LEGACY_SIGN: org.bukkit.Material;

			const LEGACY_WOOD_DOOR: org.bukkit.Material;

			const LEGACY_BUCKET: org.bukkit.Material;

			const LEGACY_WATER_BUCKET: org.bukkit.Material;

			const LEGACY_LAVA_BUCKET: org.bukkit.Material;

			const LEGACY_MINECART: org.bukkit.Material;

			const LEGACY_SADDLE: org.bukkit.Material;

			const LEGACY_IRON_DOOR: org.bukkit.Material;

			const LEGACY_REDSTONE: org.bukkit.Material;

			const LEGACY_SNOW_BALL: org.bukkit.Material;

			const LEGACY_BOAT: org.bukkit.Material;

			const LEGACY_LEATHER: org.bukkit.Material;

			const LEGACY_MILK_BUCKET: org.bukkit.Material;

			const LEGACY_CLAY_BRICK: org.bukkit.Material;

			const LEGACY_CLAY_BALL: org.bukkit.Material;

			const LEGACY_SUGAR_CANE: org.bukkit.Material;

			const LEGACY_PAPER: org.bukkit.Material;

			const LEGACY_BOOK: org.bukkit.Material;

			const LEGACY_SLIME_BALL: org.bukkit.Material;

			const LEGACY_STORAGE_MINECART: org.bukkit.Material;

			const LEGACY_POWERED_MINECART: org.bukkit.Material;

			const LEGACY_EGG: org.bukkit.Material;

			const LEGACY_COMPASS: org.bukkit.Material;

			const LEGACY_FISHING_ROD: org.bukkit.Material;

			const LEGACY_WATCH: org.bukkit.Material;

			const LEGACY_GLOWSTONE_DUST: org.bukkit.Material;

			const LEGACY_RAW_FISH: org.bukkit.Material;

			const LEGACY_COOKED_FISH: org.bukkit.Material;

			const LEGACY_INK_SACK: org.bukkit.Material;

			const LEGACY_BONE: org.bukkit.Material;

			const LEGACY_SUGAR: org.bukkit.Material;

			const LEGACY_CAKE: org.bukkit.Material;

			const LEGACY_BED: org.bukkit.Material;

			const LEGACY_DIODE: org.bukkit.Material;

			const LEGACY_COOKIE: org.bukkit.Material;

			const LEGACY_MAP: org.bukkit.Material;

			const LEGACY_SHEARS: org.bukkit.Material;

			const LEGACY_MELON: org.bukkit.Material;

			const LEGACY_PUMPKIN_SEEDS: org.bukkit.Material;

			const LEGACY_MELON_SEEDS: org.bukkit.Material;

			const LEGACY_RAW_BEEF: org.bukkit.Material;

			const LEGACY_COOKED_BEEF: org.bukkit.Material;

			const LEGACY_RAW_CHICKEN: org.bukkit.Material;

			const LEGACY_COOKED_CHICKEN: org.bukkit.Material;

			const LEGACY_ROTTEN_FLESH: org.bukkit.Material;

			const LEGACY_ENDER_PEARL: org.bukkit.Material;

			const LEGACY_BLAZE_ROD: org.bukkit.Material;

			const LEGACY_GHAST_TEAR: org.bukkit.Material;

			const LEGACY_GOLD_NUGGET: org.bukkit.Material;

			const LEGACY_NETHER_STALK: org.bukkit.Material;

			const LEGACY_POTION: org.bukkit.Material;

			const LEGACY_GLASS_BOTTLE: org.bukkit.Material;

			const LEGACY_SPIDER_EYE: org.bukkit.Material;

			const LEGACY_FERMENTED_SPIDER_EYE: org.bukkit.Material;

			const LEGACY_BLAZE_POWDER: org.bukkit.Material;

			const LEGACY_MAGMA_CREAM: org.bukkit.Material;

			const LEGACY_BREWING_STAND_ITEM: org.bukkit.Material;

			const LEGACY_CAULDRON_ITEM: org.bukkit.Material;

			const LEGACY_EYE_OF_ENDER: org.bukkit.Material;

			const LEGACY_SPECKLED_MELON: org.bukkit.Material;

			const LEGACY_MONSTER_EGG: org.bukkit.Material;

			const LEGACY_EXP_BOTTLE: org.bukkit.Material;

			const LEGACY_FIREBALL: org.bukkit.Material;

			const LEGACY_BOOK_AND_QUILL: org.bukkit.Material;

			const LEGACY_WRITTEN_BOOK: org.bukkit.Material;

			const LEGACY_EMERALD: org.bukkit.Material;

			const LEGACY_ITEM_FRAME: org.bukkit.Material;

			const LEGACY_FLOWER_POT_ITEM: org.bukkit.Material;

			const LEGACY_CARROT_ITEM: org.bukkit.Material;

			const LEGACY_POTATO_ITEM: org.bukkit.Material;

			const LEGACY_BAKED_POTATO: org.bukkit.Material;

			const LEGACY_POISONOUS_POTATO: org.bukkit.Material;

			const LEGACY_EMPTY_MAP: org.bukkit.Material;

			const LEGACY_GOLDEN_CARROT: org.bukkit.Material;

			const LEGACY_SKULL_ITEM: org.bukkit.Material;

			const LEGACY_CARROT_STICK: org.bukkit.Material;

			const LEGACY_NETHER_STAR: org.bukkit.Material;

			const LEGACY_PUMPKIN_PIE: org.bukkit.Material;

			const LEGACY_FIREWORK: org.bukkit.Material;

			const LEGACY_FIREWORK_CHARGE: org.bukkit.Material;

			const LEGACY_ENCHANTED_BOOK: org.bukkit.Material;

			const LEGACY_REDSTONE_COMPARATOR: org.bukkit.Material;

			const LEGACY_NETHER_BRICK_ITEM: org.bukkit.Material;

			const LEGACY_QUARTZ: org.bukkit.Material;

			const LEGACY_EXPLOSIVE_MINECART: org.bukkit.Material;

			const LEGACY_HOPPER_MINECART: org.bukkit.Material;

			const LEGACY_PRISMARINE_SHARD: org.bukkit.Material;

			const LEGACY_PRISMARINE_CRYSTALS: org.bukkit.Material;

			const LEGACY_RABBIT: org.bukkit.Material;

			const LEGACY_COOKED_RABBIT: org.bukkit.Material;

			const LEGACY_RABBIT_STEW: org.bukkit.Material;

			const LEGACY_RABBIT_FOOT: org.bukkit.Material;

			const LEGACY_RABBIT_HIDE: org.bukkit.Material;

			const LEGACY_ARMOR_STAND: org.bukkit.Material;

			const LEGACY_IRON_BARDING: org.bukkit.Material;

			const LEGACY_GOLD_BARDING: org.bukkit.Material;

			const LEGACY_DIAMOND_BARDING: org.bukkit.Material;

			const LEGACY_LEASH: org.bukkit.Material;

			const LEGACY_NAME_TAG: org.bukkit.Material;

			const LEGACY_COMMAND_MINECART: org.bukkit.Material;

			const LEGACY_MUTTON: org.bukkit.Material;

			const LEGACY_COOKED_MUTTON: org.bukkit.Material;

			const LEGACY_BANNER: org.bukkit.Material;

			const LEGACY_END_CRYSTAL: org.bukkit.Material;

			const LEGACY_SPRUCE_DOOR_ITEM: org.bukkit.Material;

			const LEGACY_BIRCH_DOOR_ITEM: org.bukkit.Material;

			const LEGACY_JUNGLE_DOOR_ITEM: org.bukkit.Material;

			const LEGACY_ACACIA_DOOR_ITEM: org.bukkit.Material;

			const LEGACY_DARK_OAK_DOOR_ITEM: org.bukkit.Material;

			const LEGACY_CHORUS_FRUIT: org.bukkit.Material;

			const LEGACY_CHORUS_FRUIT_POPPED: org.bukkit.Material;

			const LEGACY_BEETROOT: org.bukkit.Material;

			const LEGACY_BEETROOT_SEEDS: org.bukkit.Material;

			const LEGACY_BEETROOT_SOUP: org.bukkit.Material;

			const LEGACY_DRAGONS_BREATH: org.bukkit.Material;

			const LEGACY_SPLASH_POTION: org.bukkit.Material;

			const LEGACY_SPECTRAL_ARROW: org.bukkit.Material;

			const LEGACY_TIPPED_ARROW: org.bukkit.Material;

			const LEGACY_LINGERING_POTION: org.bukkit.Material;

			const LEGACY_SHIELD: org.bukkit.Material;

			const LEGACY_ELYTRA: org.bukkit.Material;

			const LEGACY_BOAT_SPRUCE: org.bukkit.Material;

			const LEGACY_BOAT_BIRCH: org.bukkit.Material;

			const LEGACY_BOAT_JUNGLE: org.bukkit.Material;

			const LEGACY_BOAT_ACACIA: org.bukkit.Material;

			const LEGACY_BOAT_DARK_OAK: org.bukkit.Material;

			const LEGACY_TOTEM: org.bukkit.Material;

			const LEGACY_SHULKER_SHELL: org.bukkit.Material;

			const LEGACY_IRON_NUGGET: org.bukkit.Material;

			const LEGACY_KNOWLEDGE_BOOK: org.bukkit.Material;

			const LEGACY_GOLD_RECORD: org.bukkit.Material;

			const LEGACY_GREEN_RECORD: org.bukkit.Material;

			const LEGACY_RECORD_3: org.bukkit.Material;

			const LEGACY_RECORD_4: org.bukkit.Material;

			const LEGACY_RECORD_5: org.bukkit.Material;

			const LEGACY_RECORD_6: org.bukkit.Material;

			const LEGACY_RECORD_7: org.bukkit.Material;

			const LEGACY_RECORD_8: org.bukkit.Material;

			const LEGACY_RECORD_9: org.bukkit.Material;

			const LEGACY_RECORD_10: org.bukkit.Material;

			const LEGACY_RECORD_11: org.bukkit.Material;

			const LEGACY_RECORD_12: org.bukkit.Material;

			const LEGACY_PREFIX: string;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.Material;

			/**
			 * Attempts to get the Material with the given name.
			 * 
			 * This is a normal lookup, names must be the precise name they are given
			 * in the enum.
			 */
			function getMaterial(name: string): (org.bukkit.Material | null);

			/**
			 * Attempts to get the Material with the given name.
			 * 
			 * This is a normal lookup, names must be the precise name they are given in
			 * the enum (but optionally including the LEGACY_PREFIX if legacyName is
			 * true).
			 * 
			 * If legacyName is true, then the lookup will be against legacy materials,
			 * but the returned Material will be a modern material (ie this method is
			 * useful for updating stored data).
			 */
			function getMaterial(name: string, legacyName: boolean): (org.bukkit.Material | null);

			/**
			 * Attempts to match the Material with the given name.
			 * 
			 * This is a match lookup; names will be stripped of the "minecraft:"
			 * namespace, converted to uppercase, then stripped of special characters in
			 * an attempt to format it like the enum.
			 */
			function matchMaterial(name: string): (org.bukkit.Material | null);

			/**
			 * Attempts to match the Material with the given name.
			 * 
			 * This is a match lookup; names will be stripped of the "minecraft:"
			 * namespace, converted to uppercase, then stripped of special characters in
			 * an attempt to format it like the enum.
			 */
			function matchMaterial(name: string, legacyName: boolean): (org.bukkit.Material | null);

		}
		interface MinecraftExperimental {}
		namespace MinecraftExperimental {
			interface Requires {}
			namespace Requires {
				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.MinecraftExperimental.Requires;

			}
		}
		interface MusicInstrument {
		}
		class MusicInstrument {
			constructor();

		}
		namespace MusicInstrument {
			const PONDER_GOAT_HORN: org.bukkit.MusicInstrument;

			const SING_GOAT_HORN: org.bukkit.MusicInstrument;

			const SEEK_GOAT_HORN: org.bukkit.MusicInstrument;

			const FEEL_GOAT_HORN: org.bukkit.MusicInstrument;

			const ADMIRE_GOAT_HORN: org.bukkit.MusicInstrument;

			const CALL_GOAT_HORN: org.bukkit.MusicInstrument;

			const YEARN_GOAT_HORN: org.bukkit.MusicInstrument;

			const DREAM_GOAT_HORN: org.bukkit.MusicInstrument;

			/**
			 * Returns a MusicInstrument by a NamespacedKey.
			 */
			function getByKey(namespacedKey: org.bukkit.NamespacedKey): (org.bukkit.MusicInstrument | null);

			/**
			 * Returns all known MusicInstruments.
			 */
			function values(): globalThis.java.util.Collection<org.bukkit.MusicInstrument>;

		}
		interface Nameable {
			/**
			 * Gets the custom name on a mob or block. If there is no name this method
			 * will return null.
			 * 
			 * This value has no effect on players, they will always use their real
			 * name.
			 */
			getCustomName(): (string | null);

			/**
			 * Sets a custom name on a mob or block. This name will be used in death
			 * messages and can be sent to the client as a nameplate over the mob.
			 * 
			 * Setting the name to null or an empty string will clear it.
			 * 
			 * This value has no effect on players, they will always use their real
			 * name.
			 */
			setCustomName(name: (string | null)): void;

		}
		interface NamespacedKey {
			getNamespace(): string;

			getKey(): string;

			hashCode(): number;

			equals(obj: any): boolean;

			toString(): string;

		}
		class NamespacedKey {
			/**
			 * Create a key in a specific namespace.
			 */
			constructor(namespace: string, key: string);

			/**
			 * Create a key in the plugin's namespace.
			 * 
			 * Namespaces may only contain lowercase alphanumeric characters, periods,
			 * underscores, and hyphens.
			 * 
			 * Keys may only contain lowercase alphanumeric characters, periods,
			 * underscores, hyphens, and forward slashes.
			 */
			constructor(plugin: org.bukkit.plugin.Plugin, key: string);

		}
		namespace NamespacedKey {
			/**
			 * The namespace representing all inbuilt keys.
			 */
			const MINECRAFT: string;

			/**
			 * The namespace representing all keys generated by Bukkit for backwards
			 * compatibility measures.
			 */
			const BUKKIT: string;

			/**
			 * Return a new random key in the BUKKIT namespace.
			 */
			function randomKey(): org.bukkit.NamespacedKey;

			/**
			 * Get a key in the Minecraft namespace.
			 */
			function minecraft(key: string): org.bukkit.NamespacedKey;

			/**
			 * Get a NamespacedKey from the supplied string with a default namespace if
			 * a namespace is not defined. This is a utility method meant to fetch a
			 * NamespacedKey from user input. Please note that casing does matter and
			 * any instance of uppercase characters will be considered invalid. The
			 * input contract is as follows:
			 * fromString("foo", plugin) -> "plugin:foo"
			 * fromString("foo:bar", plugin) -> "foo:bar"
			 * fromString(":foo", null) -> "minecraft:foo"
			 * fromString("foo", null) -> "minecraft:foo"
			 * fromString("Foo", plugin) -> null
			 * fromString(":Foo", plugin) -> null
			 * fromString("foo:bar:bazz", plugin) -> null
			 * fromString("", plugin) -> null
			 * 
			 */
			function fromString(string: string, defaultNamespace: (org.bukkit.plugin.Plugin | null)): (org.bukkit.NamespacedKey | null);

			/**
			 * Get a NamespacedKey from the supplied string.
			 * The default namespace will be Minecraft's (i.e.
			 * minecraft(String)).
			 */
			function fromString(key: string): (org.bukkit.NamespacedKey | null);

		}
		interface NetherWartsState {}
		namespace NetherWartsState {
			/**
			 * State when first seeded
			 */
			const SEEDED: org.bukkit.NetherWartsState;

			/**
			 * First growth stage
			 */
			const STAGE_ONE: org.bukkit.NetherWartsState;

			/**
			 * Second growth stage
			 */
			const STAGE_TWO: org.bukkit.NetherWartsState;

			/**
			 * Ready to harvest
			 */
			const RIPE: org.bukkit.NetherWartsState;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.NetherWartsState;

		}
		interface Note {
			sharped(): org.bukkit.Note;

			flattened(): org.bukkit.Note;

			/**
			 * Returns the internal id of this note.
			 */
			getId(): any /* byte */;

			/**
			 * Returns the octave of this note.
			 */
			getOctave(): number;

			/**
			 * Returns the tone of this note.
			 */
			getTone(): org.bukkit.Note.Tone;

			/**
			 * Returns if this note is sharped.
			 */
			isSharped(): boolean;

			/**
			 * Gets the pitch of this note. This is the value used with
			 * World.playSound(org.bukkit.Location, org.bukkit.Sound, float, float) or the /playsound command.
			 */
			getPitch(): number;

			hashCode(): number;

			equals(obj: any): boolean;

			toString(): string;

		}
		class Note {
			/**
			 * Creates a new note.
			 */
			constructor(note: number);

			/**
			 * Creates a new note.
			 */
			constructor(octave: number, tone: org.bukkit.Note.Tone, sharped: boolean);

		}
		namespace Note {
			/**
			 * Creates a new note for a flat tone, such as A-flat.
			 */
			function flat(octave: number, tone: org.bukkit.Note.Tone): org.bukkit.Note;

			/**
			 * Creates a new note for a sharp tone, such as A-sharp.
			 */
			function sharp(octave: number, tone: org.bukkit.Note.Tone): org.bukkit.Note;

			/**
			 * Creates a new note for a natural tone, such as A-natural.
			 */
			function natural(octave: number, tone: org.bukkit.Note.Tone): org.bukkit.Note;

		}
		namespace Note {
			interface Tone {
				/**
				 * Returns the not sharped id of this tone.
				 */
				getId(): any /* byte */;

				/**
				 * Returns the id of this tone. These method allows to return the
				 * sharped id of the tone. If the tone couldn't be sharped it always
				 * return the not sharped id of this tone.
				 */
				getId(sharped: boolean): any /* byte */;

				/**
				 * Returns if this tone could be sharped.
				 */
				isSharpable(): boolean;

				/**
				 * Returns if this tone id is the sharped id of the tone.
				 */
				isSharped(id: any /* byte */): boolean;

			}
			namespace Tone {
				const G: org.bukkit.Note.Tone;

				const A: org.bukkit.Note.Tone;

				const B: org.bukkit.Note.Tone;

				const C: org.bukkit.Note.Tone;

				const D: org.bukkit.Note.Tone;

				const E: org.bukkit.Note.Tone;

				const F: org.bukkit.Note.Tone;

				/**
				 * The number of tones including sharped tones.
				 */
				const TONES_COUNT: any /* byte */;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.Note.Tone;

				/**
				 * Returns the tone to id. Also returning the semitones.
				 */
				function getById(id: any /* byte */): (org.bukkit.Note.Tone | null);

			}
		}
		interface OfflinePlayer extends Modify<org.bukkit.permissions.ServerOperator & org.bukkit.entity.AnimalTamer & org.bukkit.configuration.serialization.ConfigurationSerializable, {
			/**
			 * Checks if this player is currently online
			 */
			isOnline(): boolean;

			/**
			 * Returns the name of this player
			 * 
			 * Names are no longer unique past a single game session. For persistent storage
			 * it is recommended that you use getUniqueId() instead.
			 */
			getName(): (string | null);

			/**
			 * Returns the UUID of this player
			 */
			getUniqueId(): globalThis.java.util.UUID;

			/**
			 * Gets a copy of the player's profile.
			 * 
			 * If the player is online, the returned profile will be complete.
			 * Otherwise, only the unique id is guaranteed to be present. You can use
			 * PlayerProfile.update() to complete the returned profile.
			 */
			getPlayerProfile(): org.bukkit.profile.PlayerProfile;

			/**
			 * Checks if this player has had their profile banned.
			 */
			isBanned(): boolean;

			/**
			 * Adds this user to the ProfileBanList. If a previous ban exists, this will
			 * update the entry.
			 */
			ban(reason: (string | null), expires: (globalThis.java.util.Date | null), source: (string | null)): (org.bukkit.BanEntry<org.bukkit.profile.PlayerProfile> | null);

			/**
			 * Adds this user to the ProfileBanList. If a previous ban exists, this will
			 * update the entry.
			 */
			ban(reason: (string | null), expires: (any /* java.time.Instant */ | null), source: (string | null)): (org.bukkit.BanEntry<org.bukkit.profile.PlayerProfile> | null);

			/**
			 * Adds this user to the ProfileBanList. If a previous ban exists, this will
			 * update the entry.
			 */
			ban(reason: (string | null), duration: (any /* java.time.Duration */ | null), source: (string | null)): (org.bukkit.BanEntry<org.bukkit.profile.PlayerProfile> | null);

			/**
			 * Checks if this player is whitelisted or not
			 */
			isWhitelisted(): boolean;

			/**
			 * Sets if this player is whitelisted or not
			 */
			setWhitelisted(value: boolean): void;

			/**
			 * Gets a Player object that this represents, if there is one
			 * 
			 * If the player is online, this will return that player. Otherwise,
			 * it will return null.
			 */
			getPlayer(): (org.bukkit.entity.Player | null);

			/**
			 * Gets the first date and time that this player was witnessed on this
			 * server.
			 * 
			 * If the player has never played before, this will return 0. Otherwise,
			 * it will be the amount of milliseconds since midnight, January 1, 1970
			 * UTC.
			 */
			getFirstPlayed(): number;

			/**
			 * Gets the last date and time that this player was witnessed on this
			 * server.
			 * 
			 * If the player has never played before, this will return 0. Otherwise,
			 * it will be the amount of milliseconds since midnight, January 1, 1970
			 * UTC.
			 */
			getLastPlayed(): number;

			/**
			 * Checks if this player has played on this server before.
			 */
			hasPlayedBefore(): boolean;

			/**
			 * Gets the Location where the player will spawn at their bed, null if
			 * they have not slept in one or their current bed spawn is invalid.
			 */
			getBedSpawnLocation(): (org.bukkit.Location | null);

			/**
			 * Gets the Location where the player will spawn at, null if they
			 * don't have a valid respawn point.
			 */
			getRespawnLocation(): (org.bukkit.Location | null);

			/**
			 * Increments the given statistic for this player.
			 * 
			 * This is equivalent to the following code:
			 * incrementStatistic(Statistic, 1)
			 */
			incrementStatistic(statistic: org.bukkit.Statistic): void;

			/**
			 * Decrements the given statistic for this player.
			 * 
			 * This is equivalent to the following code:
			 * decrementStatistic(Statistic, 1)
			 */
			decrementStatistic(statistic: org.bukkit.Statistic): void;

			/**
			 * Increments the given statistic for this player.
			 */
			incrementStatistic(statistic: org.bukkit.Statistic, amount: number): void;

			/**
			 * Decrements the given statistic for this player.
			 */
			decrementStatistic(statistic: org.bukkit.Statistic, amount: number): void;

			/**
			 * Sets the given statistic for this player.
			 */
			setStatistic(statistic: org.bukkit.Statistic, newValue: number): void;

			/**
			 * Gets the value of the given statistic for this player.
			 */
			getStatistic(statistic: org.bukkit.Statistic): number;

			/**
			 * Increments the given statistic for this player for the given material.
			 * 
			 * This is equivalent to the following code:
			 * incrementStatistic(Statistic, Material, 1)
			 */
			incrementStatistic(statistic: org.bukkit.Statistic, material: org.bukkit.Material): void;

			/**
			 * Decrements the given statistic for this player for the given material.
			 * 
			 * This is equivalent to the following code:
			 * decrementStatistic(Statistic, Material, 1)
			 */
			decrementStatistic(statistic: org.bukkit.Statistic, material: org.bukkit.Material): void;

			/**
			 * Gets the value of the given statistic for this player.
			 */
			getStatistic(statistic: org.bukkit.Statistic, material: org.bukkit.Material): number;

			/**
			 * Increments the given statistic for this player for the given material.
			 */
			incrementStatistic(statistic: org.bukkit.Statistic, material: org.bukkit.Material, amount: number): void;

			/**
			 * Decrements the given statistic for this player for the given material.
			 */
			decrementStatistic(statistic: org.bukkit.Statistic, material: org.bukkit.Material, amount: number): void;

			/**
			 * Sets the given statistic for this player for the given material.
			 */
			setStatistic(statistic: org.bukkit.Statistic, material: org.bukkit.Material, newValue: number): void;

			/**
			 * Increments the given statistic for this player for the given entity.
			 * 
			 * This is equivalent to the following code:
			 * incrementStatistic(Statistic, EntityType, 1)
			 */
			incrementStatistic(statistic: org.bukkit.Statistic, entityType: org.bukkit.entity.EntityType): void;

			/**
			 * Decrements the given statistic for this player for the given entity.
			 * 
			 * This is equivalent to the following code:
			 * decrementStatistic(Statistic, EntityType, 1)
			 */
			decrementStatistic(statistic: org.bukkit.Statistic, entityType: org.bukkit.entity.EntityType): void;

			/**
			 * Gets the value of the given statistic for this player.
			 */
			getStatistic(statistic: org.bukkit.Statistic, entityType: org.bukkit.entity.EntityType): number;

			/**
			 * Increments the given statistic for this player for the given entity.
			 */
			incrementStatistic(statistic: org.bukkit.Statistic, entityType: org.bukkit.entity.EntityType, amount: number): void;

			/**
			 * Decrements the given statistic for this player for the given entity.
			 */
			decrementStatistic(statistic: org.bukkit.Statistic, entityType: org.bukkit.entity.EntityType, amount: number): void;

			/**
			 * Sets the given statistic for this player for the given entity.
			 */
			setStatistic(statistic: org.bukkit.Statistic, entityType: org.bukkit.entity.EntityType, newValue: number): void;

			/**
			 * Gets the player's last death location.
			 */
			getLastDeathLocation(): (org.bukkit.Location | null);

			/**
			 * Gets the player's current location.
			 */
			getLocation(): (org.bukkit.Location | null);

		}> {}
		interface Particle {
			/**
			 * Returns the required data type for the particle
			 */
			getDataType(): globalThis.java.lang.Class;

			/**
			 * Description copied from interface:Â Keyed
			 */
			getKey(): org.bukkit.NamespacedKey;

		}
		namespace Particle {
			const POOF: org.bukkit.Particle;

			const EXPLOSION: org.bukkit.Particle;

			const EXPLOSION_EMITTER: org.bukkit.Particle;

			const FIREWORK: org.bukkit.Particle;

			const BUBBLE: org.bukkit.Particle;

			const SPLASH: org.bukkit.Particle;

			const FISHING: org.bukkit.Particle;

			const UNDERWATER: org.bukkit.Particle;

			const CRIT: org.bukkit.Particle;

			const ENCHANTED_HIT: org.bukkit.Particle;

			const SMOKE: org.bukkit.Particle;

			const LARGE_SMOKE: org.bukkit.Particle;

			const EFFECT: org.bukkit.Particle;

			const INSTANT_EFFECT: org.bukkit.Particle;

			/**
			 * Uses Color as DataType
			 */
			const ENTITY_EFFECT: org.bukkit.Particle;

			const WITCH: org.bukkit.Particle;

			const DRIPPING_WATER: org.bukkit.Particle;

			const DRIPPING_LAVA: org.bukkit.Particle;

			const ANGRY_VILLAGER: org.bukkit.Particle;

			const HAPPY_VILLAGER: org.bukkit.Particle;

			const MYCELIUM: org.bukkit.Particle;

			const NOTE: org.bukkit.Particle;

			const PORTAL: org.bukkit.Particle;

			const ENCHANT: org.bukkit.Particle;

			const FLAME: org.bukkit.Particle;

			const LAVA: org.bukkit.Particle;

			const CLOUD: org.bukkit.Particle;

			/**
			 * Uses Particle.DustOptions as DataType
			 */
			const DUST: org.bukkit.Particle;

			const ITEM_SNOWBALL: org.bukkit.Particle;

			const ITEM_SLIME: org.bukkit.Particle;

			const HEART: org.bukkit.Particle;

			/**
			 * Uses ItemStack as DataType
			 */
			const ITEM: org.bukkit.Particle;

			/**
			 * Uses BlockData as DataType
			 */
			const BLOCK: org.bukkit.Particle;

			const RAIN: org.bukkit.Particle;

			const ELDER_GUARDIAN: org.bukkit.Particle;

			const DRAGON_BREATH: org.bukkit.Particle;

			const END_ROD: org.bukkit.Particle;

			const DAMAGE_INDICATOR: org.bukkit.Particle;

			const SWEEP_ATTACK: org.bukkit.Particle;

			/**
			 * Uses BlockData as DataType
			 */
			const FALLING_DUST: org.bukkit.Particle;

			const TOTEM_OF_UNDYING: org.bukkit.Particle;

			const SPIT: org.bukkit.Particle;

			const SQUID_INK: org.bukkit.Particle;

			const BUBBLE_POP: org.bukkit.Particle;

			const CURRENT_DOWN: org.bukkit.Particle;

			const BUBBLE_COLUMN_UP: org.bukkit.Particle;

			const NAUTILUS: org.bukkit.Particle;

			const DOLPHIN: org.bukkit.Particle;

			const SNEEZE: org.bukkit.Particle;

			const CAMPFIRE_COSY_SMOKE: org.bukkit.Particle;

			const CAMPFIRE_SIGNAL_SMOKE: org.bukkit.Particle;

			const COMPOSTER: org.bukkit.Particle;

			const FLASH: org.bukkit.Particle;

			const FALLING_LAVA: org.bukkit.Particle;

			const LANDING_LAVA: org.bukkit.Particle;

			const FALLING_WATER: org.bukkit.Particle;

			const DRIPPING_HONEY: org.bukkit.Particle;

			const FALLING_HONEY: org.bukkit.Particle;

			const LANDING_HONEY: org.bukkit.Particle;

			const FALLING_NECTAR: org.bukkit.Particle;

			const SOUL_FIRE_FLAME: org.bukkit.Particle;

			const ASH: org.bukkit.Particle;

			const CRIMSON_SPORE: org.bukkit.Particle;

			const WARPED_SPORE: org.bukkit.Particle;

			const SOUL: org.bukkit.Particle;

			const DRIPPING_OBSIDIAN_TEAR: org.bukkit.Particle;

			const FALLING_OBSIDIAN_TEAR: org.bukkit.Particle;

			const LANDING_OBSIDIAN_TEAR: org.bukkit.Particle;

			const REVERSE_PORTAL: org.bukkit.Particle;

			const WHITE_ASH: org.bukkit.Particle;

			/**
			 * Uses Particle.DustTransition as DataType
			 */
			const DUST_COLOR_TRANSITION: org.bukkit.Particle;

			/**
			 * Uses Vibration as DataType
			 */
			const VIBRATION: org.bukkit.Particle;

			const FALLING_SPORE_BLOSSOM: org.bukkit.Particle;

			const SPORE_BLOSSOM_AIR: org.bukkit.Particle;

			const SMALL_FLAME: org.bukkit.Particle;

			const SNOWFLAKE: org.bukkit.Particle;

			const DRIPPING_DRIPSTONE_LAVA: org.bukkit.Particle;

			const FALLING_DRIPSTONE_LAVA: org.bukkit.Particle;

			const DRIPPING_DRIPSTONE_WATER: org.bukkit.Particle;

			const FALLING_DRIPSTONE_WATER: org.bukkit.Particle;

			const GLOW_SQUID_INK: org.bukkit.Particle;

			const GLOW: org.bukkit.Particle;

			const WAX_ON: org.bukkit.Particle;

			const WAX_OFF: org.bukkit.Particle;

			const ELECTRIC_SPARK: org.bukkit.Particle;

			const SCRAPE: org.bukkit.Particle;

			const SONIC_BOOM: org.bukkit.Particle;

			const SCULK_SOUL: org.bukkit.Particle;

			/**
			 * Use Float as DataType
			 */
			const SCULK_CHARGE: org.bukkit.Particle;

			const SCULK_CHARGE_POP: org.bukkit.Particle;

			/**
			 * Use Integer as DataType
			 */
			const SHRIEK: org.bukkit.Particle;

			const CHERRY_LEAVES: org.bukkit.Particle;

			const EGG_CRACK: org.bukkit.Particle;

			const DUST_PLUME: org.bukkit.Particle;

			const WHITE_SMOKE: org.bukkit.Particle;

			const GUST: org.bukkit.Particle;

			const SMALL_GUST: org.bukkit.Particle;

			const GUST_EMITTER_LARGE: org.bukkit.Particle;

			const GUST_EMITTER_SMALL: org.bukkit.Particle;

			const TRIAL_SPAWNER_DETECTION: org.bukkit.Particle;

			const TRIAL_SPAWNER_DETECTION_OMINOUS: org.bukkit.Particle;

			const VAULT_CONNECTION: org.bukkit.Particle;

			const INFESTED: org.bukkit.Particle;

			const ITEM_COBWEB: org.bukkit.Particle;

			/**
			 * Uses BlockData as DataType
			 */
			const DUST_PILLAR: org.bukkit.Particle;

			const OMINOUS_SPAWNING: org.bukkit.Particle;

			const RAID_OMEN: org.bukkit.Particle;

			const TRIAL_OMEN: org.bukkit.Particle;

			/**
			 * Uses BlockData as DataType
			 */
			const BLOCK_MARKER: org.bukkit.Particle;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.Particle;

		}
		namespace Particle {
			interface DustOptions {
				/**
				 * The color of the particles to be displayed.
				 */
				getColor(): org.bukkit.Color;

				/**
				 * Relative size of the particle.
				 */
				getSize(): number;

			}
			class DustOptions {
				constructor(color: org.bukkit.Color, size: number);

			}
		}
		namespace Particle {
			interface DustTransition extends Modify<org.bukkit.Particle.DustOptions, {
				/**
				 * The final of the particles to be displayed.
				 */
				getToColor(): org.bukkit.Color;

			}> {}
			class DustTransition {
				constructor(fromColor: org.bukkit.Color, toColor: org.bukkit.Color, size: number);

			}
		}
		interface PortalType {}
		namespace PortalType {
			/**
			 * This is a Nether portal, made of obsidian.
			 */
			const NETHER: org.bukkit.PortalType;

			/**
			 * This is an Ender portal.
			 */
			const ENDER: org.bukkit.PortalType;

			/**
			 * This is a custom Plugin portal.
			 */
			const CUSTOM: org.bukkit.PortalType;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.PortalType;

		}
		interface Raid {
			/**
			 * Get whether this raid started.
			 */
			isStarted(): boolean;

			/**
			 * Gets the amount of ticks this raid has existed.
			 */
			getActiveTicks(): number;

			/**
			 * Gets the Bad Omen level of this raid.
			 */
			getBadOmenLevel(): number;

			/**
			 * Sets the Bad Omen level.
			 * 
			 * If the level is higher than 1, there will be an additional wave that as
			 * strong as the final wave.
			 */
			setBadOmenLevel(badOmenLevel: number): void;

			/**
			 * Gets the center location where the raid occurs.
			 */
			getLocation(): org.bukkit.Location;

			/**
			 * Gets the current status of the raid.
			 * 
			 * Do not use this method to check if the raid has been started, call
			 * isStarted() instead.
			 */
			getStatus(): org.bukkit.Raid.RaidStatus;

			/**
			 * Gets the number of raider groups which have spawned.
			 */
			getSpawnedGroups(): number;

			/**
			 * Gets the number of raider groups which would spawn.
			 * 
			 * This also includes the group which spawns in the additional wave (if
			 * present).
			 */
			getTotalGroups(): number;

			/**
			 * Gets the number of waves in this raid (exclude the additional wave).
			 */
			getTotalWaves(): number;

			/**
			 * Gets the sum of all raider's health.
			 */
			getTotalHealth(): number;

			/**
			 * Get the UUID of all heroes in this raid.
			 */
			getHeroes(): globalThis.java.util.Set<globalThis.java.util.UUID>;

			/**
			 * Gets all remaining Raider in the present wave.
			 */
			getRaiders(): globalThis.java.util.List<org.bukkit.entity.Raider>;

		}
		namespace Raid {
			interface RaidStatus {}
			namespace RaidStatus {
				/**
				 * The raid is in progress.
				 */
				const ONGOING: org.bukkit.Raid.RaidStatus;

				/**
				 * The raid was beaten by heroes.
				 */
				const VICTORY: org.bukkit.Raid.RaidStatus;

				/**
				 * The village has fallen (i.e. all villagers died).
				 */
				const LOSS: org.bukkit.Raid.RaidStatus;

				/**
				 * The raid was terminated.
				 */
				const STOPPED: org.bukkit.Raid.RaidStatus;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.Raid.RaidStatus;

			}
		}
		interface RegionAccessor {
			/**
			 * Gets the Biome at the given Location.
			 */
			getBiome(location: org.bukkit.Location): org.bukkit.block.Biome;

			/**
			 * Gets the Biome at the given coordinates.
			 */
			getBiome(x: number, y: number, z: number): org.bukkit.block.Biome;

			/**
			 * Sets the Biome at the given Location.
			 */
			setBiome(location: org.bukkit.Location, biome: org.bukkit.block.Biome): void;

			/**
			 * Sets the Biome for the given block coordinates
			 */
			setBiome(x: number, y: number, z: number, biome: org.bukkit.block.Biome): void;

			/**
			 * Gets the BlockState at the given Location.
			 */
			getBlockState(location: org.bukkit.Location): org.bukkit.block.BlockState;

			/**
			 * Gets the BlockState at the given coordinates.
			 */
			getBlockState(x: number, y: number, z: number): org.bukkit.block.BlockState;

			/**
			 * Gets the BlockData at the given Location.
			 */
			getBlockData(location: org.bukkit.Location): org.bukkit.block.data.BlockData;

			/**
			 * Gets the BlockData at the given coordinates.
			 */
			getBlockData(x: number, y: number, z: number): org.bukkit.block.data.BlockData;

			/**
			 * Gets the type of the block at the given Location.
			 */
			getType(location: org.bukkit.Location): org.bukkit.Material;

			/**
			 * Gets the type of the block at the given coordinates.
			 */
			getType(x: number, y: number, z: number): org.bukkit.Material;

			/**
			 * Sets the BlockData at the given Location.
			 */
			setBlockData(location: org.bukkit.Location, blockData: org.bukkit.block.data.BlockData): void;

			/**
			 * Sets the BlockData at the given coordinates.
			 */
			setBlockData(x: number, y: number, z: number, blockData: org.bukkit.block.data.BlockData): void;

			/**
			 * Sets the Material at the given Location.
			 */
			setType(location: org.bukkit.Location, material: org.bukkit.Material): void;

			/**
			 * Sets the Material at the given coordinates.
			 */
			setType(x: number, y: number, z: number, material: org.bukkit.Material): void;

			/**
			 * Creates a tree at the given Location
			 */
			generateTree(location: org.bukkit.Location, random: globalThis.java.util.Random, type: org.bukkit.TreeType): boolean;

			/**
			 * Creates a tree at the given Location
			 * 
			 * The provided consumer gets called for every block which gets changed
			 * as a result of the tree generation. When the consumer gets called no
			 * modifications to the world are done yet. Which means, that calling
			 * getBlockState(Location) in the consumer while return the state
			 * of the block before the generation.
			 * 
			 * Modifications done to the BlockState in the consumer are respected,
			 * which means that it is not necessary to call BlockState.update()
			 */
			generateTree(location: org.bukkit.Location, random: globalThis.java.util.Random, type: org.bukkit.TreeType, stateConsumer: ((value: org.bukkit.block.BlockState) => void | null)): boolean;

			/**
			 * Creates a tree at the given Location
			 * 
			 * The provided predicate gets called for every block which gets changed
			 * as a result of the tree generation. When the predicate gets called no
			 * modifications to the world are done yet. Which means, that calling
			 * getBlockState(Location) in the predicate will return the state
			 * of the block before the generation.
			 * 
			 * If the predicate returns true the block gets set in the world.
			 * If it returns false the block won't get set in the world.
			 */
			generateTree(location: org.bukkit.Location, random: globalThis.java.util.Random, type: org.bukkit.TreeType, statePredicate: ((value: org.bukkit.block.BlockState) => boolean | null)): boolean;

			/**
			 * Creates a entity at the given Location
			 */
			spawnEntity(location: org.bukkit.Location, type: org.bukkit.entity.EntityType): org.bukkit.entity.Entity;

			/**
			 * Creates a new entity at the given Location.
			 */
			spawnEntity(loc: org.bukkit.Location, type: org.bukkit.entity.EntityType, randomizeData: boolean): org.bukkit.entity.Entity;

			/**
			 * Get a list of all entities in this RegionAccessor
			 */
			getEntities(): globalThis.java.util.List<org.bukkit.entity.Entity>;

			/**
			 * Get a list of all living entities in this RegionAccessor
			 */
			getLivingEntities(): globalThis.java.util.List<org.bukkit.entity.LivingEntity>;

			/**
			 * Get a collection of all entities in this RegionAccessor matching the given
			 * class/interface
			 */
			getEntitiesByClass<T = any>(cls: globalThis.java.lang.Class<T>): globalThis.java.util.Collection<T>;

			/**
			 * Get a collection of all entities in this RegionAccessor matching any of the
			 * given classes/interfaces
			 */
			getEntitiesByClasses(...classes: globalThis.java.lang.Class[]): globalThis.java.util.Collection<org.bukkit.entity.Entity>;

			/**
			 * Creates an entity of a specific class at the given Location but
			 * does not spawn it in the world.
			 * 
			 * Note: The created entity keeps a reference to the world it was
			 * created in, care should be taken that the entity does not outlive the
			 * world instance as this will lead to memory leaks.
			 */
			createEntity<T = any>(location: org.bukkit.Location, clazz: globalThis.java.lang.Class<T>): T;

			/**
			 * Spawn an entity of a specific class at the given Location
			 */
			spawn<T = any>(location: org.bukkit.Location, clazz: globalThis.java.lang.Class<T>): T;

			/**
			 * Spawn an entity of a specific class at the given Location, with
			 * the supplied function run before the entity is added to the world.
			 * 
			 * Note that when the function is run, the entity will not be actually in
			 * the world. Any operation involving such as teleporting the entity is undefined
			 * until after this function returns.
			 */
			spawn<T = any>(location: org.bukkit.Location, clazz: globalThis.java.lang.Class<T>, func: ((value: T) => void | null)): T;

			/**
			 * Creates a new entity at the given Location with the supplied
			 * function run before the entity is added to the world.
			 * 
			 * Note that when the function is run, the entity will not be actually in
			 * the world. Any operation involving such as teleporting the entity is undefined
			 * until after this function returns.
			 * The passed function however is run after the potential entity's spawn
			 * randomization and hence already allows access to the values of the mob,
			 * whether or not those were randomized, such as attributes or the entity
			 * equipment.
			 */
			spawn<T = any>(location: org.bukkit.Location, clazz: globalThis.java.lang.Class<T>, randomizeData: boolean, func: ((value: T) => void | null)): T;

			/**
			 * Gets the highest non-empty (impassable) coordinate at the given
			 * coordinates.
			 */
			getHighestBlockYAt(x: number, z: number): number;

			/**
			 * Gets the highest non-empty (impassable) coordinate at the given
			 * Location.
			 */
			getHighestBlockYAt(location: org.bukkit.Location): number;

			/**
			 * Gets the highest coordinate corresponding to the HeightMap at the
			 * given coordinates.
			 */
			getHighestBlockYAt(x: number, z: number, heightMap: org.bukkit.HeightMap): number;

			/**
			 * Gets the highest coordinate corresponding to the HeightMap at the
			 * given Location.
			 */
			getHighestBlockYAt(location: org.bukkit.Location, heightMap: org.bukkit.HeightMap): number;

			/**
			 * Spawns a previously created entity in the world.
			 * The provided entity must not have already been spawned in a world.
			 */
			addEntity<T = any>(entity: T): T;

		}
		interface Registry<T = any> {
			/**
			 * Get the object by its key.
			 */
			get(key: org.bukkit.NamespacedKey): (T | null);

			/**
			 * Returns a new stream, which contains all registry items, which are registered to the registry.
			 */
			stream(): globalThis.java.util.stream.Stream<T>;

			/**
			 * Attempts to match the registered object with the given key.
			 * 
			 * This will attempt to find a reasonable match based on the provided input
			 * and may do so through unspecified means.
			 */
			match(input: string): (T | null);

		}
		namespace Registry {
			/**
			 * Server advancements.
			 */
			const ADVANCEMENT: org.bukkit.Registry<org.bukkit.advancement.Advancement>;

			/**
			 * Server art.
			 */
			const ART: org.bukkit.Registry<org.bukkit.Art>;

			/**
			 * Attribute.
			 */
			const ATTRIBUTE: org.bukkit.Registry<org.bukkit.attribute.Attribute>;

			/**
			 * Server banner patterns.
			 */
			const BANNER_PATTERN: org.bukkit.Registry<org.bukkit.block.banner.PatternType>;

			/**
			 * Server biomes.
			 */
			const BIOME: org.bukkit.Registry<org.bukkit.block.Biome>;

			/**
			 * Server block types.
			 */
			const BLOCK: org.bukkit.Registry<org.bukkit.block.BlockType>;

			/**
			 * Custom boss bars.
			 */
			const BOSS_BARS: org.bukkit.Registry<org.bukkit.boss.KeyedBossBar>;

			/**
			 * Server cat types.
			 */
			const CAT_VARIANT: org.bukkit.Registry<org.bukkit.entity.Cat.Type>;

			/**
			 * Server enchantments.
			 */
			const ENCHANTMENT: org.bukkit.Registry<org.bukkit.enchantments.Enchantment>;

			/**
			 * Server entity types.
			 */
			const ENTITY_TYPE: org.bukkit.Registry<org.bukkit.entity.EntityType>;

			/**
			 * Server instruments.
			 */
			const INSTRUMENT: org.bukkit.Registry<org.bukkit.MusicInstrument>;

			/**
			 * Server item types.
			 */
			const ITEM: org.bukkit.Registry<org.bukkit.inventory.ItemType>;

			/**
			 * Default server loot tables.
			 */
			const LOOT_TABLES: org.bukkit.Registry<org.bukkit.loot.LootTables>;

			/**
			 * Server materials.
			 */
			const MATERIAL: org.bukkit.Registry<org.bukkit.Material>;

			/**
			 * Server mob effects.
			 */
			const EFFECT: org.bukkit.Registry<org.bukkit.potion.PotionEffectType>;

			/**
			 * Server particles.
			 */
			const PARTICLE_TYPE: org.bukkit.Registry<org.bukkit.Particle>;

			/**
			 * Server potions.
			 */
			const POTION: org.bukkit.Registry<org.bukkit.potion.PotionType>;

			/**
			 * Server statistics.
			 */
			const STATISTIC: org.bukkit.Registry<org.bukkit.Statistic>;

			/**
			 * Server structures.
			 */
			const STRUCTURE: org.bukkit.Registry<org.bukkit.generator.structure.Structure>;

			/**
			 * Server structure types.
			 */
			const STRUCTURE_TYPE: org.bukkit.Registry<org.bukkit.generator.structure.StructureType>;

			/**
			 * Sound keys.
			 */
			const SOUNDS: org.bukkit.Registry<org.bukkit.Sound>;

			/**
			 * Trim materials.
			 */
			const TRIM_MATERIAL: org.bukkit.Registry<org.bukkit.inventory.meta.trim.TrimMaterial>;

			/**
			 * Trim patterns.
			 */
			const TRIM_PATTERN: org.bukkit.Registry<org.bukkit.inventory.meta.trim.TrimPattern>;

			/**
			 * Damage types.
			 */
			const DAMAGE_TYPE: org.bukkit.Registry<org.bukkit.damage.DamageType>;

			/**
			 * Jukebox songs.
			 */
			const JUKEBOX_SONG: org.bukkit.Registry<org.bukkit.JukeboxSong>;

			/**
			 * Villager profession.
			 */
			const VILLAGER_PROFESSION: org.bukkit.Registry<org.bukkit.entity.Villager.Profession>;

			/**
			 * Villager type.
			 */
			const VILLAGER_TYPE: org.bukkit.Registry<org.bukkit.entity.Villager.Type>;

			/**
			 * Memory Keys.
			 */
			const MEMORY_MODULE_TYPE: org.bukkit.Registry<org.bukkit.entity.memory.MemoryKey>;

			/**
			 * Server fluids.
			 */
			const FLUID: org.bukkit.Registry<org.bukkit.Fluid>;

			/**
			 * Frog variants.
			 */
			const FROG_VARIANT: org.bukkit.Registry<org.bukkit.entity.Frog.Variant>;

			/**
			 * Wolf variants.
			 */
			const WOLF_VARIANT: org.bukkit.Registry<org.bukkit.entity.Wolf.Variant>;

			/**
			 * Map cursor types.
			 */
			const MAP_DECORATION_TYPE: org.bukkit.Registry<org.bukkit.map.MapCursor.Type>;

			/**
			 * Game events.
			 */
			const GAME_EVENT: org.bukkit.Registry<org.bukkit.GameEvent>;

		}
		namespace Registry {
			interface SimpleRegistry<T = any> {
				/**
				 * Description copied from interface:Â Registry
				 */
				get(key: org.bukkit.NamespacedKey): (T | null);

				/**
				 * Description copied from interface:Â Registry
				 */
				stream(): globalThis.java.util.stream.Stream<T>;

				iterator(): globalThis.java.util.Iterator<T>;

				getType(): globalThis.java.lang.Class<T>;

			}
		}
		interface Rotation {
			/**
			 * Rotate clockwise by 90 degrees.
			 */
			rotateClockwise(): org.bukkit.Rotation;

			/**
			 * Rotate counter-clockwise by 90 degrees.
			 */
			rotateCounterClockwise(): org.bukkit.Rotation;

		}
		namespace Rotation {
			/**
			 * No rotation
			 */
			const NONE: org.bukkit.Rotation;

			/**
			 * Rotated clockwise by 45 degrees
			 */
			const CLOCKWISE_45: org.bukkit.Rotation;

			/**
			 * Rotated clockwise by 90 degrees
			 */
			const CLOCKWISE: org.bukkit.Rotation;

			/**
			 * Rotated clockwise by 135 degrees
			 */
			const CLOCKWISE_135: org.bukkit.Rotation;

			/**
			 * Flipped upside-down, a 180 degree rotation
			 */
			const FLIPPED: org.bukkit.Rotation;

			/**
			 * Flipped upside-down + 45 degree rotation
			 */
			const FLIPPED_45: org.bukkit.Rotation;

			/**
			 * Rotated counter-clockwise by 90 degrees
			 */
			const COUNTER_CLOCKWISE: org.bukkit.Rotation;

			/**
			 * Rotated counter-clockwise by 45 degrees
			 */
			const COUNTER_CLOCKWISE_45: org.bukkit.Rotation;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.Rotation;

		}
		interface SandstoneType {
			/**
			 * Gets the associated data value representing this type of sandstone
			 */
			getData(): any /* byte */;

		}
		namespace SandstoneType {
			const CRACKED: org.bukkit.SandstoneType;

			const GLYPHED: org.bukkit.SandstoneType;

			const SMOOTH: org.bukkit.SandstoneType;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.SandstoneType;

			/**
			 * Gets the type of sandstone with the given data value
			 */
			function getByData(data: any /* byte */): (org.bukkit.SandstoneType | null);

		}
		interface Server extends Modify<org.bukkit.plugin.messaging.PluginMessageRecipient, {
			/**
			 * Gets the name of this server implementation.
			 */
			getName(): string;

			/**
			 * Gets the version string of this server implementation.
			 */
			getVersion(): string;

			/**
			 * Gets the Bukkit version that this server is running.
			 */
			getBukkitVersion(): string;

			/**
			 * Gets a view of all currently logged in players. This view is a reused
			 * object, making some operations like Collection.size()
			 * zero-allocation.
			 * 
			 * The collection is a view backed by the internal representation, such
			 * that, changes to the internal state of the server will be reflected
			 * immediately. However, the reuse of the returned collection (identity)
			 * is not strictly guaranteed for future or all implementations. Casting
			 * the collection, or relying on interface implementations (like Serializable or List), is deprecated.
			 * 
			 * Iteration behavior is undefined outside of self-contained main-thread
			 * uses. Normal and immediate iterator use without consequences that
			 * affect the collection are fully supported. The effects following
			 * (non-exhaustive) teleportation,
			 * death, and kicking are undefined. Any use of this collection from
			 * asynchronous threads is unsafe.
			 * 
			 * For safe consequential iteration or mimicking the old array behavior,
			 * using Collection.toArray(Object[]) is recommended. For making
			 * snapshots, ImmutableList.copyOf(Collection) is recommended.
			 */
			getOnlinePlayers(): globalThis.java.util.Collection<org.bukkit.entity.Player>;

			/**
			 * Get the maximum amount of players which can login to this server.
			 */
			getMaxPlayers(): number;

			/**
			 * Set the maximum amount of players allowed to be logged in at once.
			 */
			setMaxPlayers(maxPlayers: number): void;

			/**
			 * Get the game port that the server runs on.
			 */
			getPort(): number;

			/**
			 * Get the view distance from this server.
			 */
			getViewDistance(): number;

			/**
			 * Get the simulation distance from this server.
			 */
			getSimulationDistance(): number;

			/**
			 * Get the IP that this server is bound to, or empty string if not
			 * specified.
			 */
			getIp(): string;

			/**
			 * Get world type (level-type setting) for default world.
			 */
			getWorldType(): string;

			/**
			 * Get generate-structures setting.
			 */
			getGenerateStructures(): boolean;

			/**
			 * Get max world size.
			 */
			getMaxWorldSize(): number;

			/**
			 * Gets whether this server allows the End or not.
			 */
			getAllowEnd(): boolean;

			/**
			 * Gets whether this server allows the Nether or not.
			 */
			getAllowNether(): boolean;

			/**
			 * Gets whether the server is logging the IP addresses of players.
			 */
			isLoggingIPs(): boolean;

			/**
			 * Gets a list of packs to be enabled.
			 */
			getInitialEnabledPacks(): globalThis.java.util.List<string>;

			/**
			 * Gets a list of packs that will not be enabled automatically.
			 */
			getInitialDisabledPacks(): globalThis.java.util.List<string>;

			/**
			 * Get the DataPack Manager.
			 */
			getDataPackManager(): org.bukkit.packs.DataPackManager;

			/**
			 * Get the ServerTick Manager.
			 */
			getServerTickManager(): org.bukkit.ServerTickManager;

			/**
			 * Gets the resource pack configured to be sent to clients by the server.
			 */
			getServerResourcePack(): (org.bukkit.packs.ResourcePack | null);

			/**
			 * Gets the server resource pack uri, or empty string if not specified.
			 */
			getResourcePack(): string;

			/**
			 * Gets the SHA-1 digest of the server resource pack, or empty string if
			 * not specified.
			 */
			getResourcePackHash(): string;

			/**
			 * Gets the custom prompt message to be shown when the server resource
			 * pack is required, or empty string if not specified.
			 */
			getResourcePackPrompt(): string;

			/**
			 * Gets whether the server resource pack is enforced.
			 */
			isResourcePackRequired(): boolean;

			/**
			 * Gets whether this server has a whitelist or not.
			 */
			hasWhitelist(): boolean;

			/**
			 * Sets if the server is whitelisted.
			 */
			setWhitelist(value: boolean): void;

			/**
			 * Gets whether the server whitelist is enforced.
			 * If the whitelist is enforced, non-whitelisted players will be
			 * disconnected when the server whitelist is reloaded.
			 */
			isWhitelistEnforced(): boolean;

			/**
			 * Sets if the server whitelist is enforced.
			 * If the whitelist is enforced, non-whitelisted players will be
			 * disconnected when the server whitelist is reloaded.
			 */
			setWhitelistEnforced(value: boolean): void;

			/**
			 * Gets a list of whitelisted players.
			 */
			getWhitelistedPlayers(): globalThis.java.util.Set<org.bukkit.OfflinePlayer>;

			/**
			 * Reloads the whitelist from disk.
			 */
			reloadWhitelist(): void;

			/**
			 * Broadcast a message to all players.
			 * 
			 * This is the same as calling broadcast(java.lang.String, java.lang.String) to BROADCAST_CHANNEL_USERS
			 */
			broadcastMessage(message: string): number;

			/**
			 * Gets the name of the update folder. The update folder is used to safely
			 * update plugins at the right moment on a plugin load.
			 * 
			 * The update folder name is relative to the plugins folder.
			 */
			getUpdateFolder(): string;

			/**
			 * Gets the update folder. The update folder is used to safely update
			 * plugins at the right moment on a plugin load.
			 */
			getUpdateFolderFile(): any /* java.io.File */;

			/**
			 * Gets the value of the connection throttle setting.
			 */
			getConnectionThrottle(): number;

			/**
			 * Gets default ticks per animal spawns value.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn monsters
			 * every tick.
			 * A value of 400 will mean the server will attempt to spawn monsters
			 * every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note: If set to 0, animal spawning will be disabled. We
			 * recommend using spawn-animals to control this instead.
			 * 
			 * Minecraft default: 400.
			 */
			getTicksPerAnimalSpawns(): number;

			/**
			 * Gets the default ticks per monster spawns value.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn monsters
			 * every tick.
			 * A value of 400 will mean the server will attempt to spawn monsters
			 * every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note: If set to 0, monsters spawning will be disabled. We
			 * recommend using spawn-monsters to control this instead.
			 * 
			 * Minecraft default: 1.
			 */
			getTicksPerMonsterSpawns(): number;

			/**
			 * Gets the default ticks per water mob spawns value.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn water mobs
			 * every tick.
			 * A value of 400 will mean the server will attempt to spawn water mobs
			 * every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note: If set to 0, water mobs spawning will be disabled.
			 * 
			 * Minecraft default: 1.
			 */
			getTicksPerWaterSpawns(): number;

			/**
			 * Gets the default ticks per water ambient mob spawns value.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn water ambient mobs
			 * every tick.
			 * A value of 400 will mean the server will attempt to spawn water ambient mobs
			 * every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note: If set to 0, ambient mobs spawning will be disabled.
			 * 
			 * Minecraft default: 1.
			 */
			getTicksPerWaterAmbientSpawns(): number;

			/**
			 * Gets the default ticks per water underground creature spawns value.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn water underground creature
			 * every tick.
			 * A value of 400 will mean the server will attempt to spawn water underground creature
			 * every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note: If set to 0, water underground creature spawning will be disabled.
			 * 
			 * Minecraft default: 1.
			 */
			getTicksPerWaterUndergroundCreatureSpawns(): number;

			/**
			 * Gets the default ticks per ambient mob spawns value.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn ambient mobs
			 * every tick.
			 * A value of 400 will mean the server will attempt to spawn ambient mobs
			 * every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note: If set to 0, ambient mobs spawning will be disabled.
			 * 
			 * Minecraft default: 1.
			 */
			getTicksPerAmbientSpawns(): number;

			/**
			 * Gets the default ticks per SpawnCategory spawns value.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn SpawnCategory mobs
			 * every tick.
			 * A value of 400 will mean the server will attempt to spawn SpawnCategory mobs
			 * every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note: If set to 0, SpawnCategory mobs spawning will be disabled.
			 * 
			 * Minecraft default: 1.
			 * 
			 * Note:  the SpawnCategory.MISC are not consider.
			 */
			getTicksPerSpawns(spawnCategory: org.bukkit.entity.SpawnCategory): number;

			/**
			 * Gets a player object by the given username.
			 * 
			 * This method may not return objects for offline players.
			 */
			getPlayer(name: string): (org.bukkit.entity.Player | null);

			/**
			 * Gets the player with the exact given name, case insensitive.
			 */
			getPlayerExact(name: string): (org.bukkit.entity.Player | null);

			/**
			 * Attempts to match any players with the given name, and returns a list
			 * of all possibly matches.
			 * 
			 * This list is not sorted in any particular order. If an exact match is
			 * found, the returned list will only contain a single result.
			 */
			matchPlayer(name: string): globalThis.java.util.List<org.bukkit.entity.Player>;

			/**
			 * Gets the player with the given UUID.
			 */
			getPlayer(id: globalThis.java.util.UUID): (org.bukkit.entity.Player | null);

			/**
			 * Gets the plugin manager for interfacing with plugins.
			 */
			getPluginManager(): org.bukkit.plugin.PluginManager;

			/**
			 * Gets the scheduler for managing scheduled events.
			 */
			getScheduler(): org.bukkit.scheduler.BukkitScheduler;

			/**
			 * Gets a services manager.
			 */
			getServicesManager(): org.bukkit.plugin.ServicesManager;

			/**
			 * Gets a list of all worlds on this server.
			 */
			getWorlds(): globalThis.java.util.List<org.bukkit.World>;

			/**
			 * Creates or loads a world with the given name using the specified
			 * options.
			 * 
			 * If the world is already loaded, it will just return the equivalent of
			 * getWorld(creator.name()).
			 */
			createWorld(creator: org.bukkit.WorldCreator): (org.bukkit.World | null);

			/**
			 * Unloads a world with the given name.
			 */
			unloadWorld(name: string, save: boolean): boolean;

			/**
			 * Unloads the given world.
			 */
			unloadWorld(world: org.bukkit.World, save: boolean): boolean;

			/**
			 * Gets the world with the given name.
			 */
			getWorld(name: string): (org.bukkit.World | null);

			/**
			 * Gets the world from the given Unique ID.
			 */
			getWorld(uid: globalThis.java.util.UUID): (org.bukkit.World | null);

			/**
			 * Create a new virtual WorldBorder.
			 * 
			 * Note that world borders created by the server will not respect any world
			 * scaling effects (i.e. coordinates are not divided by 8 in the nether).
			 */
			createWorldBorder(): org.bukkit.WorldBorder;

			/**
			 * Gets the map from the given item ID.
			 */
			getMap(id: number): (org.bukkit.map.MapView | null);

			/**
			 * Create a new map with an automatically assigned ID.
			 */
			createMap(world: org.bukkit.World): org.bukkit.map.MapView;

			/**
			 * Create a new explorer map targeting the closest nearby structure of a
			 * given StructureType.
			 * 
			 * This method uses implementation default values for radius and
			 * findUnexplored (usually 100, true).
			 */
			createExplorerMap(world: org.bukkit.World, location: org.bukkit.Location, structureType: org.bukkit.StructureType): org.bukkit.inventory.ItemStack;

			/**
			 * Create a new explorer map targeting the closest nearby structure of a
			 * given StructureType.
			 * 
			 * This method uses implementation default values for radius and
			 * findUnexplored (usually 100, true).
			 */
			createExplorerMap(world: org.bukkit.World, location: org.bukkit.Location, structureType: org.bukkit.StructureType, radius: number, findUnexplored: boolean): org.bukkit.inventory.ItemStack;

			/**
			 * Reloads the server, refreshing settings and plugin information.
			 */
			reload(): void;

			/**
			 * Reload only the Minecraft data for the server. This includes custom
			 * advancements and loot tables.
			 */
			reloadData(): void;

			/**
			 * Returns the primary logger associated with this server instance.
			 */
			getLogger(): globalThis.java.util.logging.Logger;

			/**
			 * Gets a PluginCommand with the given name or alias.
			 */
			getPluginCommand(name: string): (org.bukkit.command.PluginCommand | null);

			/**
			 * Writes loaded players to disk.
			 */
			savePlayers(): void;

			/**
			 * Dispatches a command on this server, and executes it if found.
			 */
			dispatchCommand(sender: org.bukkit.command.CommandSender, commandLine: string): boolean;

			/**
			 * Adds a recipe to the crafting manager.
			 */
			addRecipe(recipe: (org.bukkit.inventory.Recipe | null)): boolean;

			/**
			 * Get a list of all recipes for a given item. The stack size is ignored
			 * in comparisons. If the durability is -1, it will match any data value.
			 */
			getRecipesFor(result: org.bukkit.inventory.ItemStack): globalThis.java.util.List<org.bukkit.inventory.Recipe>;

			/**
			 * Get the Recipe for the given key.
			 */
			getRecipe(recipeKey: org.bukkit.NamespacedKey): (org.bukkit.inventory.Recipe | null);

			/**
			 * Get the Recipe for the list of ItemStacks provided.
			 * The list is formatted as a crafting matrix where the index follow
			 * the pattern below:
			 * [ 0 1 2 ]
			 * [ 3 4 5 ]
			 * [ 6 7 8 ]
			 * 
			 * NOTE: This method will not modify the provided ItemStack array, for that, use
			 * craftItem(ItemStack[], World, Player).
			 */
			getCraftingRecipe(craftingMatrix: org.bukkit.inventory.ItemStack[], world: org.bukkit.World): (org.bukkit.inventory.Recipe | null);

			/**
			 * Get the crafted item using the list of ItemStack provided.
			 * The list is formatted as a crafting matrix where the index follow
			 * the pattern below:
			 * [ 0 1 2 ]
			 * [ 3 4 5 ]
			 * [ 6 7 8 ]
			 * 
			 * The World and Player arguments are required to fulfill the Bukkit Crafting
			 * events.
			 * Calls PrepareItemCraftEvent to imitate the Player
			 * initiating the crafting event.
			 */
			craftItem(craftingMatrix: org.bukkit.inventory.ItemStack[], world: org.bukkit.World, player: org.bukkit.entity.Player): org.bukkit.inventory.ItemStack;

			/**
			 * Get the crafted item using the list of ItemStack provided.
			 * The list is formatted as a crafting matrix where the index follow
			 * the pattern below:
			 * [ 0 1 2 ]
			 * [ 3 4 5 ]
			 * [ 6 7 8 ]
			 * 
			 */
			craftItem(craftingMatrix: org.bukkit.inventory.ItemStack[], world: org.bukkit.World): org.bukkit.inventory.ItemStack;

			/**
			 * Get the crafted item using the list of ItemStack provided.
			 * The list is formatted as a crafting matrix where the index follow
			 * the pattern below:
			 * [ 0 1 2 ]
			 * [ 3 4 5 ]
			 * [ 6 7 8 ]
			 * 
			 * The World and Player arguments are required to fulfill the Bukkit Crafting
			 * events.
			 * Calls PrepareItemCraftEvent to imitate the Player
			 * initiating the crafting event.
			 */
			craftItemResult(craftingMatrix: org.bukkit.inventory.ItemStack[], world: org.bukkit.World, player: org.bukkit.entity.Player): org.bukkit.inventory.ItemCraftResult;

			/**
			 * Get the crafted item using the list of ItemStack provided.
			 * The list is formatted as a crafting matrix where the index follow
			 * the pattern below:
			 * [ 0 1 2 ]
			 * [ 3 4 5 ]
			 * [ 6 7 8 ]
			 * 
			 */
			craftItemResult(craftingMatrix: org.bukkit.inventory.ItemStack[], world: org.bukkit.World): org.bukkit.inventory.ItemCraftResult;

			/**
			 * Get an iterator through the list of crafting recipes.
			 */
			recipeIterator(): globalThis.java.util.Iterator<org.bukkit.inventory.Recipe>;

			/**
			 * Clears the list of crafting recipes.
			 */
			clearRecipes(): void;

			/**
			 * Resets the list of crafting recipes to the default.
			 */
			resetRecipes(): void;

			/**
			 * Remove a recipe from the server.
			 * Note that removing a recipe may cause permanent loss of data
			 * associated with that recipe (eg whether it has been discovered by
			 * players).
			 */
			removeRecipe(key: org.bukkit.NamespacedKey): boolean;

			/**
			 * Gets a list of command aliases defined in the server properties.
			 */
			getCommandAliases(): globalThis.java.util.Map<string>;

			/**
			 * Gets the radius, in blocks, around each worlds spawn point to protect.
			 */
			getSpawnRadius(): number;

			/**
			 * Sets the radius, in blocks, around each worlds spawn point to protect.
			 */
			setSpawnRadius(value: number): void;

			/**
			 * Gets whether the server should send a preview of the player's chat
			 * message to the client when the player types a message
			 */
			shouldSendChatPreviews(): boolean;

			/**
			 * Gets whether the server only allow players with Mojang-signed public key
			 * to join
			 */
			isEnforcingSecureProfiles(): boolean;

			/**
			 * Gets whether this server is allowing connections transferred from other
			 * servers.
			 */
			isAcceptingTransfers(): boolean;

			/**
			 * Gets whether the Server hide online players in server status.
			 */
			getHideOnlinePlayers(): boolean;

			/**
			 * Gets whether the Server is in online mode or not.
			 */
			getOnlineMode(): boolean;

			/**
			 * Gets whether this server allows flying or not.
			 */
			getAllowFlight(): boolean;

			/**
			 * Gets whether the server is in hardcore mode or not.
			 */
			isHardcore(): boolean;

			/**
			 * Shutdowns the server, stopping everything.
			 */
			shutdown(): void;

			/**
			 * Broadcasts the specified message to every user with the given
			 * permission name.
			 */
			broadcast(message: string, permission: string): number;

			/**
			 * Gets the player by the given name, regardless if they are offline or
			 * online.
			 * 
			 * This method may involve a blocking web request to get the UUID for the
			 * given name.
			 * 
			 * This will return an object even if the player does not exist. To this
			 * method, all players will exist.
			 */
			getOfflinePlayer(name: string): org.bukkit.OfflinePlayer;

			/**
			 * Gets the player by the given UUID, regardless if they are offline or
			 * online.
			 * 
			 * This will return an object even if the player does not exist. To this
			 * method, all players will exist.
			 */
			getOfflinePlayer(id: globalThis.java.util.UUID): org.bukkit.OfflinePlayer;

			/**
			 * Creates a new PlayerProfile.
			 */
			createPlayerProfile(uniqueId: (globalThis.java.util.UUID | null), name: (string | null)): org.bukkit.profile.PlayerProfile;

			/**
			 * Creates a new PlayerProfile.
			 */
			createPlayerProfile(uniqueId: globalThis.java.util.UUID): org.bukkit.profile.PlayerProfile;

			/**
			 * Creates a new PlayerProfile.
			 */
			createPlayerProfile(name: string): org.bukkit.profile.PlayerProfile;

			/**
			 * Gets a set containing all current IPs that are banned.
			 */
			getIPBans(): globalThis.java.util.Set<string>;

			/**
			 * Bans the specified address from the server.
			 */
			banIP(address: string): void;

			/**
			 * Unbans the specified address from the server.
			 */
			unbanIP(address: string): void;

			/**
			 * Bans the specified address from the server.
			 */
			banIP(address: any /* java.net.InetAddress */): void;

			/**
			 * Unbans the specified address from the server.
			 */
			unbanIP(address: any /* java.net.InetAddress */): void;

			/**
			 * Gets a set containing all banned players.
			 */
			getBannedPlayers(): globalThis.java.util.Set<org.bukkit.OfflinePlayer>;

			/**
			 * Gets a ban list for the supplied type.
			 */
			getBanList<T = any>(type: org.bukkit.BanList.Type): T;

			/**
			 * Gets a set containing all player operators.
			 */
			getOperators(): globalThis.java.util.Set<org.bukkit.OfflinePlayer>;

			/**
			 * Gets the default GameMode for new players.
			 */
			getDefaultGameMode(): org.bukkit.GameMode;

			/**
			 * Sets the default GameMode for new players.
			 */
			setDefaultGameMode(mode: org.bukkit.GameMode): void;

			/**
			 * Gets a ConsoleCommandSender that may be used as an input source
			 * for this server.
			 */
			getConsoleSender(): org.bukkit.command.ConsoleCommandSender;

			/**
			 * Gets the folder that contains all of the various Worlds.
			 */
			getWorldContainer(): any /* java.io.File */;

			/**
			 * Gets the Messenger responsible for this server.
			 */
			getMessenger(): org.bukkit.plugin.messaging.Messenger;

			/**
			 * Gets the HelpMap providing help topics for this server.
			 */
			getHelpMap(): org.bukkit.help.HelpMap;

			/**
			 * Creates an empty inventory with the specified type. If the type
			 * is InventoryType.CHEST, the new inventory has a size of 27;
			 * otherwise the new inventory has the normal size for its type.
			 * 
			 * InventoryType.WORKBENCH will not process crafting recipes if
			 * created with this method. Use
			 * HumanEntity.openWorkbench(Location, boolean) instead.
			 * 
			 * InventoryType.ENCHANTING will not process ItemStacks
			 * for possible enchanting results. Use
			 * HumanEntity.openEnchanting(Location, boolean) instead.
			 */
			createInventory(owner: (org.bukkit.inventory.InventoryHolder | null), type: org.bukkit.event.inventory.InventoryType): org.bukkit.inventory.Inventory;

			/**
			 * Creates an empty inventory with the specified type and title. If the type
			 * is InventoryType.CHEST, the new inventory has a size of 27;
			 * otherwise the new inventory has the normal size for its type.
			 * It should be noted that some inventory types do not support titles and
			 * may not render with said titles on the Minecraft client.
			 * 
			 * InventoryType.WORKBENCH will not process crafting recipes if
			 * created with this method. Use
			 * HumanEntity.openWorkbench(Location, boolean) instead.
			 * 
			 * InventoryType.ENCHANTING will not process ItemStacks
			 * for possible enchanting results. Use
			 * HumanEntity.openEnchanting(Location, boolean) instead.
			 */
			createInventory(owner: (org.bukkit.inventory.InventoryHolder | null), type: org.bukkit.event.inventory.InventoryType, title: string): org.bukkit.inventory.Inventory;

			/**
			 * Creates an empty inventory of type InventoryType.CHEST with the
			 * specified size.
			 */
			createInventory(owner: (org.bukkit.inventory.InventoryHolder | null), size: number): org.bukkit.inventory.Inventory;

			/**
			 * Creates an empty inventory of type InventoryType.CHEST with the
			 * specified size and title.
			 */
			createInventory(owner: (org.bukkit.inventory.InventoryHolder | null), size: number, title: string): org.bukkit.inventory.Inventory;

			/**
			 * Creates an empty merchant.
			 */
			createMerchant(title: (string | null)): org.bukkit.inventory.Merchant;

			/**
			 * Gets the amount of consecutive neighbor updates before skipping
			 * additional ones.
			 */
			getMaxChainedNeighborUpdates(): number;

			/**
			 * Gets user-specified limit for number of monsters that can spawn in a
			 * chunk.
			 */
			getMonsterSpawnLimit(): number;

			/**
			 * Gets user-specified limit for number of animals that can spawn in a
			 * chunk.
			 */
			getAnimalSpawnLimit(): number;

			/**
			 * Gets user-specified limit for number of water animals that can spawn in
			 * a chunk.
			 */
			getWaterAnimalSpawnLimit(): number;

			/**
			 * Gets user-specified limit for number of water ambient mobs that can spawn
			 * in a chunk.
			 */
			getWaterAmbientSpawnLimit(): number;

			/**
			 * Get user-specified limit for number of water creature underground that can spawn
			 * in a chunk.
			 */
			getWaterUndergroundCreatureSpawnLimit(): number;

			/**
			 * Gets user-specified limit for number of ambient mobs that can spawn in
			 * a chunk.
			 */
			getAmbientSpawnLimit(): number;

			/**
			 * Gets user-specified limit for number of SpawnCategory mobs that can spawn in
			 * a chunk.
			 * Note: the SpawnCategory.MISC are not consider.
			 */
			getSpawnLimit(spawnCategory: org.bukkit.entity.SpawnCategory): number;

			/**
			 * Checks the current thread against the expected primary thread for the
			 * server.
			 * 
			 * Note: this method should not be used to indicate the current
			 * synchronized state of the runtime. A current thread matching the main
			 * thread indicates that it is synchronized, but a mismatch does not
			 * preclude the same assumption.
			 */
			isPrimaryThread(): boolean;

			/**
			 * Gets the message that is displayed on the server list.
			 */
			getMotd(): string;

			/**
			 * Set the message that is displayed on the server list.
			 */
			setMotd(motd: string): void;

			/**
			 * Gets the server links which will be sent to clients
			 */
			getServerLinks(): org.bukkit.ServerLinks;

			/**
			 * Gets the default message that is displayed when the server is stopped.
			 */
			getShutdownMessage(): (string | null);

			/**
			 * Gets the current warning state for the server.
			 */
			getWarningState(): org.bukkit.Warning.WarningState;

			/**
			 * Gets the instance of the item factory (for ItemMeta).
			 */
			getItemFactory(): org.bukkit.inventory.ItemFactory;

			/**
			 * Gets the instance of the entity factory (for EntitySnapshot).
			 */
			getEntityFactory(): org.bukkit.entity.EntityFactory;

			/**
			 * Gets the instance of the scoreboard manager.
			 * 
			 * This will only exist after the first world has loaded.
			 */
			getScoreboardManager(): (org.bukkit.scoreboard.ScoreboardManager | null);

			/**
			 * Get (or create) a new Criteria by its name.
			 */
			getScoreboardCriteria(name: string): org.bukkit.scoreboard.Criteria;

			/**
			 * Gets an instance of the server's default server-icon.
			 */
			getServerIcon(): (org.bukkit.util.CachedServerIcon | null);

			/**
			 * Loads an image from a file, and returns a cached image for the specific
			 * server-icon.
			 * 
			 * Size and type are implementation defined. An incompatible file is
			 * guaranteed to throw an implementation-defined Exception.
			 */
			loadServerIcon(file: any /* java.io.File */): org.bukkit.util.CachedServerIcon;

			/**
			 * Creates a cached server-icon for the specific image.
			 * 
			 * Size and type are implementation defined. An incompatible file is
			 * guaranteed to throw an implementation-defined Exception.
			 */
			loadServerIcon(image: any /* java.awt.image.BufferedImage */): org.bukkit.util.CachedServerIcon;

			/**
			 * Set the idle kick timeout. Any players idle for the specified amount of
			 * time will be automatically kicked.
			 * 
			 * A value of 0 will disable the idle kick timeout.
			 */
			setIdleTimeout(threshold: number): void;

			/**
			 * Gets the idle kick timeout.
			 */
			getIdleTimeout(): number;

			/**
			 * Create a ChunkData for use in a generator.
			 * See ChunkGenerator.generateChunkData(org.bukkit.World, java.util.Random, int, int, org.bukkit.generator.ChunkGenerator.BiomeGrid)
			 */
			createChunkData(world: org.bukkit.World): org.bukkit.generator.ChunkGenerator.ChunkData;

			/**
			 * Creates a boss bar instance to display to players. The progress
			 * defaults to 1.0
			 */
			createBossBar(title: (string | null), color: org.bukkit.boss.BarColor, style: org.bukkit.boss.BarStyle, ...flags: org.bukkit.boss.BarFlag[]): org.bukkit.boss.BossBar;

			/**
			 * Creates a boss bar instance to display to players. The progress defaults
			 * to 1.0.
			 * 
			 * This instance is added to the persistent storage of the server and will
			 * be editable by commands and restored after restart.
			 */
			createBossBar(key: org.bukkit.NamespacedKey, title: (string | null), color: org.bukkit.boss.BarColor, style: org.bukkit.boss.BarStyle, ...flags: org.bukkit.boss.BarFlag[]): org.bukkit.boss.KeyedBossBar;

			/**
			 * Gets an unmodifiable iterator through all persistent bossbars.
			 * 
			 * not bound to a Boss
			 * 
			 * not created using
			 * createBossBar(String, BarColor, BarStyle, BarFlag...)
			 * 
			 * 
			 * e.g. bossbars created using the bossbar command
			 */
			getBossBars(): globalThis.java.util.Iterator<org.bukkit.boss.KeyedBossBar>;

			/**
			 * Gets the KeyedBossBar specified by this key.
			 * 
			 * not bound to a Boss
			 * 
			 * not created using
			 * createBossBar(String, BarColor, BarStyle, BarFlag...)
			 * 
			 * 
			 * e.g. bossbars created using the bossbar command
			 */
			getBossBar(key: org.bukkit.NamespacedKey): (org.bukkit.boss.KeyedBossBar | null);

			/**
			 * Removes a KeyedBossBar specified by this key.
			 * 
			 * not bound to a Boss
			 * 
			 * not created using
			 * createBossBar(String, BarColor, BarStyle, BarFlag...)
			 * 
			 * 
			 * e.g. bossbars created using the bossbar command
			 */
			removeBossBar(key: org.bukkit.NamespacedKey): boolean;

			/**
			 * Gets an entity on the server by its UUID
			 */
			getEntity(uuid: globalThis.java.util.UUID): (org.bukkit.entity.Entity | null);

			/**
			 * Get the advancement specified by this key.
			 */
			getAdvancement(key: org.bukkit.NamespacedKey): (org.bukkit.advancement.Advancement | null);

			/**
			 * Get an iterator through all advancements. Advancements cannot be removed
			 * from this iterator,
			 */
			advancementIterator(): globalThis.java.util.Iterator<org.bukkit.advancement.Advancement>;

			/**
			 * Creates a new BlockData instance for the specified Material, with
			 * all properties initialized to unspecified defaults.
			 */
			createBlockData(material: org.bukkit.Material): org.bukkit.block.data.BlockData;

			/**
			 * Creates a new BlockData instance for the specified Material, with
			 * all properties initialized to unspecified defaults.
			 */
			createBlockData(material: org.bukkit.Material, consumer: ((value: org.bukkit.block.data.BlockData) => void | null)): org.bukkit.block.data.BlockData;

			/**
			 * Creates a new BlockData instance with material and properties
			 * parsed from provided data.
			 */
			createBlockData(data: string): org.bukkit.block.data.BlockData;

			/**
			 * Creates a new BlockData instance for the specified Material, with
			 * all properties initialized to unspecified defaults, except for those
			 * provided in data.
			 * 
			 * If material is specified, then the data string must not also
			 * contain the material.
			 */
			createBlockData(material: (org.bukkit.Material | null), data: (string | null)): org.bukkit.block.data.BlockData;

			/**
			 * Gets a tag which has already been defined within the server. Plugins are
			 * suggested to use the concrete tags in Tag rather than this method
			 * which makes no guarantees about which tags are available, and may also be
			 * less performant due to lack of caching.
			 * 
			 * Tags will be searched for in an implementation specific manner, but a
			 * path consisting of namespace/tags/registry/key is expected.
			 * 
			 * Server implementations are allowed to handle only the registries
			 * indicated in Tag.
			 */
			getTag<T = any>(registry: string, tag: org.bukkit.NamespacedKey, clazz: globalThis.java.lang.Class<T>): (org.bukkit.Tag<T> | null);

			/**
			 * Gets a all tags which have been defined within the server.
			 * 
			 * Server implementations are allowed to handle only the registries
			 * indicated in Tag.
			 * 
			 * No guarantees are made about the mutability of the returned iterator.
			 */
			getTags<T = any>(registry: string, clazz: globalThis.java.lang.Class<T>): globalThis.java.lang.Iterable<org.bukkit.Tag<T>>;

			/**
			 * Gets the specified LootTable.
			 */
			getLootTable(key: org.bukkit.NamespacedKey): (org.bukkit.loot.LootTable | null);

			/**
			 * Selects entities using the given Vanilla selector.
			 * 
			 * No guarantees are made about the selector format, other than they match
			 * the Vanilla format for the active Minecraft version.
			 * 
			 * Usually a selector will start with '@', unless selecting a Player in
			 * which case it may simply be the Player's name or UUID.
			 * 
			 * Note that in Vanilla, elevated permissions are usually required to use
			 * '@' selectors, but this method should not check such permissions from the
			 * sender.
			 */
			selectEntities(sender: org.bukkit.command.CommandSender, selector: string): globalThis.java.util.List<org.bukkit.entity.Entity>;

			/**
			 * Gets the structure manager for loading and saving structures.
			 */
			getStructureManager(): org.bukkit.structure.StructureManager;

			/**
			 * Returns the registry for the given class.
			 * 
			 * If no registry is present for the given class null will be returned.
			 * 
			 * Depending on the implementation not every registry present in
			 * Registry will be returned by this method.
			 */
			getRegistry<T = any>(tClass: globalThis.java.lang.Class<T>): (org.bukkit.Registry<T> | null);

			getUnsafe(): org.bukkit.UnsafeValues;

		}> {}
		namespace Server {
			/**
			 * Used for all administrative messages, such as an operator using a
			 * command.
			 * 
			 * For use in broadcast(java.lang.String, java.lang.String).
			 */
			const BROADCAST_CHANNEL_ADMINISTRATIVE: string;

			/**
			 * Used for all announcement messages, such as informing users that a
			 * player has joined.
			 * 
			 * For use in broadcast(java.lang.String, java.lang.String).
			 */
			const BROADCAST_CHANNEL_USERS: string;

		}
		interface ServerLinks {
			/**
			 * Gets the link of a given type, if it exists.
			 */
			getLink(type: org.bukkit.ServerLinks.Type): (org.bukkit.ServerLinks.ServerLink | null);

			/**
			 * Gets an immutable list of all links.
			 */
			getLinks(): globalThis.java.util.List<org.bukkit.ServerLinks.ServerLink>;

			/**
			 * Adds the given link, overwriting the first link of the same type if
			 * already set.
			 */
			setLink(type: org.bukkit.ServerLinks.Type, url: any /* java.net.URI */): org.bukkit.ServerLinks.ServerLink;

			/**
			 * Adds the given link to the list of links.
			 */
			addLink(type: org.bukkit.ServerLinks.Type, url: any /* java.net.URI */): org.bukkit.ServerLinks.ServerLink;

			/**
			 * Adds the given link to the list of links.
			 */
			addLink(displayName: string, url: any /* java.net.URI */): org.bukkit.ServerLinks.ServerLink;

			/**
			 * Removes the given link.
			 */
			removeLink(link: org.bukkit.ServerLinks.ServerLink): boolean;

			/**
			 * Returns a copy of this link collection, unassociated from the server.
			 */
			copy(): org.bukkit.ServerLinks;

		}
		namespace ServerLinks {
			interface ServerLink {
				/**
				 * Gets the type of this link if it is a known special type.
				 */
				getType(): (org.bukkit.ServerLinks.Type | null);

				/**
				 * Gets the display name/text of this link.
				 */
				getDisplayName(): string;

				/**
				 * Gets the url of this link.
				 */
				getUrl(): any /* java.net.URI */;

			}
		}
		namespace ServerLinks {
			interface Type {}
			namespace Type {
				/**
				 * Bug report links which may appear on disconnect/crash screens.
				 */
				const REPORT_BUG: org.bukkit.ServerLinks.Type;

				const COMMUNITY_GUIDELINES: org.bukkit.ServerLinks.Type;

				const SUPPORT: org.bukkit.ServerLinks.Type;

				const STATUS: org.bukkit.ServerLinks.Type;

				const FEEDBACK: org.bukkit.ServerLinks.Type;

				const COMMUNITY: org.bukkit.ServerLinks.Type;

				const WEBSITE: org.bukkit.ServerLinks.Type;

				const FORUMS: org.bukkit.ServerLinks.Type;

				const NEWS: org.bukkit.ServerLinks.Type;

				const ANNOUNCEMENTS: org.bukkit.ServerLinks.Type;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.ServerLinks.Type;

			}
		}
		interface ServerTickManager {
			/**
			 * Checks if the server is running normally.
			 * 
			 * When the server is running normally it indicates that the server is not
			 * currently frozen.
			 */
			isRunningNormally(): boolean;

			/**
			 * Checks if the server is currently stepping.
			 */
			isStepping(): boolean;

			/**
			 * Checks if the server is currently sprinting.
			 */
			isSprinting(): boolean;

			/**
			 * Checks if the server is currently frozen.
			 */
			isFrozen(): boolean;

			/**
			 * Gets the current tick rate of the server.
			 */
			getTickRate(): number;

			/**
			 * Sets the tick rate of the server.
			 * 
			 * The normal tick rate of the server is 20. No tick rate below 1.0F or
			 * above 10,000 can be applied to the server.
			 */
			setTickRate(tick: number): void;

			/**
			 * Sets the server to a frozen state that does not tick most things.
			 */
			setFrozen(frozen: boolean): void;

			/**
			 * Steps the game a certain amount of ticks if the server is currently
			 * frozen.
			 * 
			 * Steps occur when the server is in a frozen state which can be started by
			 * either using the in game /tick freeze command or the
			 * setFrozen(boolean) method.
			 */
			stepGameIfFrozen(ticks: number): boolean;

			/**
			 * Stops the current stepping if stepping is occurring.
			 */
			stopStepping(): boolean;

			/**
			 * Attempts to initiate a sprint, which executes all server ticks at a
			 * faster rate then normal.
			 */
			requestGameToSprint(ticks: number): boolean;

			/**
			 * Stops the current sprint if one is currently happening.
			 */
			stopSprinting(): boolean;

			/**
			 * Checks if a given entity is frozen.
			 */
			isFrozen(entity: org.bukkit.entity.Entity): boolean;

			/**
			 * Gets the amount of frozen ticks left to run.
			 */
			getFrozenTicksToRun(): number;

		}
		interface SkullType {}
		namespace SkullType {
			const SKELETON: org.bukkit.SkullType;

			const WITHER: org.bukkit.SkullType;

			const ZOMBIE: org.bukkit.SkullType;

			const PLAYER: org.bukkit.SkullType;

			const CREEPER: org.bukkit.SkullType;

			const DRAGON: org.bukkit.SkullType;

			const PIGLIN: org.bukkit.SkullType;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.SkullType;

		}
		interface Sound {
			/**
			 * Description copied from interface:Â Keyed
			 */
			getKey(): org.bukkit.NamespacedKey;

		}
		namespace Sound {
			const AMBIENT_BASALT_DELTAS_ADDITIONS: org.bukkit.Sound;

			const AMBIENT_BASALT_DELTAS_LOOP: org.bukkit.Sound;

			const AMBIENT_BASALT_DELTAS_MOOD: org.bukkit.Sound;

			const AMBIENT_CAVE: org.bukkit.Sound;

			const AMBIENT_CRIMSON_FOREST_ADDITIONS: org.bukkit.Sound;

			const AMBIENT_CRIMSON_FOREST_LOOP: org.bukkit.Sound;

			const AMBIENT_CRIMSON_FOREST_MOOD: org.bukkit.Sound;

			const AMBIENT_NETHER_WASTES_ADDITIONS: org.bukkit.Sound;

			const AMBIENT_NETHER_WASTES_LOOP: org.bukkit.Sound;

			const AMBIENT_NETHER_WASTES_MOOD: org.bukkit.Sound;

			const AMBIENT_SOUL_SAND_VALLEY_ADDITIONS: org.bukkit.Sound;

			const AMBIENT_SOUL_SAND_VALLEY_LOOP: org.bukkit.Sound;

			const AMBIENT_SOUL_SAND_VALLEY_MOOD: org.bukkit.Sound;

			const AMBIENT_UNDERWATER_ENTER: org.bukkit.Sound;

			const AMBIENT_UNDERWATER_EXIT: org.bukkit.Sound;

			const AMBIENT_UNDERWATER_LOOP: org.bukkit.Sound;

			const AMBIENT_UNDERWATER_LOOP_ADDITIONS: org.bukkit.Sound;

			const AMBIENT_UNDERWATER_LOOP_ADDITIONS_RARE: org.bukkit.Sound;

			const AMBIENT_UNDERWATER_LOOP_ADDITIONS_ULTRA_RARE: org.bukkit.Sound;

			const AMBIENT_WARPED_FOREST_ADDITIONS: org.bukkit.Sound;

			const AMBIENT_WARPED_FOREST_LOOP: org.bukkit.Sound;

			const AMBIENT_WARPED_FOREST_MOOD: org.bukkit.Sound;

			const BLOCK_AMETHYST_BLOCK_BREAK: org.bukkit.Sound;

			const BLOCK_AMETHYST_BLOCK_CHIME: org.bukkit.Sound;

			const BLOCK_AMETHYST_BLOCK_FALL: org.bukkit.Sound;

			const BLOCK_AMETHYST_BLOCK_HIT: org.bukkit.Sound;

			const BLOCK_AMETHYST_BLOCK_PLACE: org.bukkit.Sound;

			const BLOCK_AMETHYST_BLOCK_RESONATE: org.bukkit.Sound;

			const BLOCK_AMETHYST_BLOCK_STEP: org.bukkit.Sound;

			const BLOCK_AMETHYST_CLUSTER_BREAK: org.bukkit.Sound;

			const BLOCK_AMETHYST_CLUSTER_FALL: org.bukkit.Sound;

			const BLOCK_AMETHYST_CLUSTER_HIT: org.bukkit.Sound;

			const BLOCK_AMETHYST_CLUSTER_PLACE: org.bukkit.Sound;

			const BLOCK_AMETHYST_CLUSTER_STEP: org.bukkit.Sound;

			const BLOCK_ANCIENT_DEBRIS_BREAK: org.bukkit.Sound;

			const BLOCK_ANCIENT_DEBRIS_FALL: org.bukkit.Sound;

			const BLOCK_ANCIENT_DEBRIS_HIT: org.bukkit.Sound;

			const BLOCK_ANCIENT_DEBRIS_PLACE: org.bukkit.Sound;

			const BLOCK_ANCIENT_DEBRIS_STEP: org.bukkit.Sound;

			const BLOCK_ANVIL_BREAK: org.bukkit.Sound;

			const BLOCK_ANVIL_DESTROY: org.bukkit.Sound;

			const BLOCK_ANVIL_FALL: org.bukkit.Sound;

			const BLOCK_ANVIL_HIT: org.bukkit.Sound;

			const BLOCK_ANVIL_LAND: org.bukkit.Sound;

			const BLOCK_ANVIL_PLACE: org.bukkit.Sound;

			const BLOCK_ANVIL_STEP: org.bukkit.Sound;

			const BLOCK_ANVIL_USE: org.bukkit.Sound;

			const BLOCK_AZALEA_BREAK: org.bukkit.Sound;

			const BLOCK_AZALEA_FALL: org.bukkit.Sound;

			const BLOCK_AZALEA_HIT: org.bukkit.Sound;

			const BLOCK_AZALEA_LEAVES_BREAK: org.bukkit.Sound;

			const BLOCK_AZALEA_LEAVES_FALL: org.bukkit.Sound;

			const BLOCK_AZALEA_LEAVES_HIT: org.bukkit.Sound;

			const BLOCK_AZALEA_LEAVES_PLACE: org.bukkit.Sound;

			const BLOCK_AZALEA_LEAVES_STEP: org.bukkit.Sound;

			const BLOCK_AZALEA_PLACE: org.bukkit.Sound;

			const BLOCK_AZALEA_STEP: org.bukkit.Sound;

			const BLOCK_BAMBOO_BREAK: org.bukkit.Sound;

			const BLOCK_BAMBOO_FALL: org.bukkit.Sound;

			const BLOCK_BAMBOO_HIT: org.bukkit.Sound;

			const BLOCK_BAMBOO_PLACE: org.bukkit.Sound;

			const BLOCK_BAMBOO_SAPLING_BREAK: org.bukkit.Sound;

			const BLOCK_BAMBOO_SAPLING_HIT: org.bukkit.Sound;

			const BLOCK_BAMBOO_SAPLING_PLACE: org.bukkit.Sound;

			const BLOCK_BAMBOO_STEP: org.bukkit.Sound;

			const BLOCK_BAMBOO_WOOD_BREAK: org.bukkit.Sound;

			const BLOCK_BAMBOO_WOOD_BUTTON_CLICK_OFF: org.bukkit.Sound;

			const BLOCK_BAMBOO_WOOD_BUTTON_CLICK_ON: org.bukkit.Sound;

			const BLOCK_BAMBOO_WOOD_DOOR_CLOSE: org.bukkit.Sound;

			const BLOCK_BAMBOO_WOOD_DOOR_OPEN: org.bukkit.Sound;

			const BLOCK_BAMBOO_WOOD_FALL: org.bukkit.Sound;

			const BLOCK_BAMBOO_WOOD_FENCE_GATE_CLOSE: org.bukkit.Sound;

			const BLOCK_BAMBOO_WOOD_FENCE_GATE_OPEN: org.bukkit.Sound;

			const BLOCK_BAMBOO_WOOD_HANGING_SIGN_BREAK: org.bukkit.Sound;

			const BLOCK_BAMBOO_WOOD_HANGING_SIGN_FALL: org.bukkit.Sound;

			const BLOCK_BAMBOO_WOOD_HANGING_SIGN_HIT: org.bukkit.Sound;

			const BLOCK_BAMBOO_WOOD_HANGING_SIGN_PLACE: org.bukkit.Sound;

			const BLOCK_BAMBOO_WOOD_HANGING_SIGN_STEP: org.bukkit.Sound;

			const BLOCK_BAMBOO_WOOD_HIT: org.bukkit.Sound;

			const BLOCK_BAMBOO_WOOD_PLACE: org.bukkit.Sound;

			const BLOCK_BAMBOO_WOOD_PRESSURE_PLATE_CLICK_OFF: org.bukkit.Sound;

			const BLOCK_BAMBOO_WOOD_PRESSURE_PLATE_CLICK_ON: org.bukkit.Sound;

			const BLOCK_BAMBOO_WOOD_STEP: org.bukkit.Sound;

			const BLOCK_BAMBOO_WOOD_TRAPDOOR_CLOSE: org.bukkit.Sound;

			const BLOCK_BAMBOO_WOOD_TRAPDOOR_OPEN: org.bukkit.Sound;

			const BLOCK_BARREL_CLOSE: org.bukkit.Sound;

			const BLOCK_BARREL_OPEN: org.bukkit.Sound;

			const BLOCK_BASALT_BREAK: org.bukkit.Sound;

			const BLOCK_BASALT_FALL: org.bukkit.Sound;

			const BLOCK_BASALT_HIT: org.bukkit.Sound;

			const BLOCK_BASALT_PLACE: org.bukkit.Sound;

			const BLOCK_BASALT_STEP: org.bukkit.Sound;

			const BLOCK_BEACON_ACTIVATE: org.bukkit.Sound;

			const BLOCK_BEACON_AMBIENT: org.bukkit.Sound;

			const BLOCK_BEACON_DEACTIVATE: org.bukkit.Sound;

			const BLOCK_BEACON_POWER_SELECT: org.bukkit.Sound;

			const BLOCK_BEEHIVE_DRIP: org.bukkit.Sound;

			const BLOCK_BEEHIVE_ENTER: org.bukkit.Sound;

			const BLOCK_BEEHIVE_EXIT: org.bukkit.Sound;

			const BLOCK_BEEHIVE_SHEAR: org.bukkit.Sound;

			const BLOCK_BEEHIVE_WORK: org.bukkit.Sound;

			const BLOCK_BELL_RESONATE: org.bukkit.Sound;

			const BLOCK_BELL_USE: org.bukkit.Sound;

			const BLOCK_BIG_DRIPLEAF_BREAK: org.bukkit.Sound;

			const BLOCK_BIG_DRIPLEAF_FALL: org.bukkit.Sound;

			const BLOCK_BIG_DRIPLEAF_HIT: org.bukkit.Sound;

			const BLOCK_BIG_DRIPLEAF_PLACE: org.bukkit.Sound;

			const BLOCK_BIG_DRIPLEAF_STEP: org.bukkit.Sound;

			const BLOCK_BIG_DRIPLEAF_TILT_DOWN: org.bukkit.Sound;

			const BLOCK_BIG_DRIPLEAF_TILT_UP: org.bukkit.Sound;

			const BLOCK_BLASTFURNACE_FIRE_CRACKLE: org.bukkit.Sound;

			const BLOCK_BONE_BLOCK_BREAK: org.bukkit.Sound;

			const BLOCK_BONE_BLOCK_FALL: org.bukkit.Sound;

			const BLOCK_BONE_BLOCK_HIT: org.bukkit.Sound;

			const BLOCK_BONE_BLOCK_PLACE: org.bukkit.Sound;

			const BLOCK_BONE_BLOCK_STEP: org.bukkit.Sound;

			const BLOCK_BREWING_STAND_BREW: org.bukkit.Sound;

			const BLOCK_BUBBLE_COLUMN_BUBBLE_POP: org.bukkit.Sound;

			const BLOCK_BUBBLE_COLUMN_UPWARDS_AMBIENT: org.bukkit.Sound;

			const BLOCK_BUBBLE_COLUMN_UPWARDS_INSIDE: org.bukkit.Sound;

			const BLOCK_BUBBLE_COLUMN_WHIRLPOOL_AMBIENT: org.bukkit.Sound;

			const BLOCK_BUBBLE_COLUMN_WHIRLPOOL_INSIDE: org.bukkit.Sound;

			const BLOCK_CAKE_ADD_CANDLE: org.bukkit.Sound;

			const BLOCK_CALCITE_BREAK: org.bukkit.Sound;

			const BLOCK_CALCITE_FALL: org.bukkit.Sound;

			const BLOCK_CALCITE_HIT: org.bukkit.Sound;

			const BLOCK_CALCITE_PLACE: org.bukkit.Sound;

			const BLOCK_CALCITE_STEP: org.bukkit.Sound;

			const BLOCK_CAMPFIRE_CRACKLE: org.bukkit.Sound;

			const BLOCK_CANDLE_AMBIENT: org.bukkit.Sound;

			const BLOCK_CANDLE_BREAK: org.bukkit.Sound;

			const BLOCK_CANDLE_EXTINGUISH: org.bukkit.Sound;

			const BLOCK_CANDLE_FALL: org.bukkit.Sound;

			const BLOCK_CANDLE_HIT: org.bukkit.Sound;

			const BLOCK_CANDLE_PLACE: org.bukkit.Sound;

			const BLOCK_CANDLE_STEP: org.bukkit.Sound;

			const BLOCK_CAVE_VINES_BREAK: org.bukkit.Sound;

			const BLOCK_CAVE_VINES_FALL: org.bukkit.Sound;

			const BLOCK_CAVE_VINES_HIT: org.bukkit.Sound;

			const BLOCK_CAVE_VINES_PICK_BERRIES: org.bukkit.Sound;

			const BLOCK_CAVE_VINES_PLACE: org.bukkit.Sound;

			const BLOCK_CAVE_VINES_STEP: org.bukkit.Sound;

			const BLOCK_CHAIN_BREAK: org.bukkit.Sound;

			const BLOCK_CHAIN_FALL: org.bukkit.Sound;

			const BLOCK_CHAIN_HIT: org.bukkit.Sound;

			const BLOCK_CHAIN_PLACE: org.bukkit.Sound;

			const BLOCK_CHAIN_STEP: org.bukkit.Sound;

			const BLOCK_CHERRY_LEAVES_BREAK: org.bukkit.Sound;

			const BLOCK_CHERRY_LEAVES_FALL: org.bukkit.Sound;

			const BLOCK_CHERRY_LEAVES_HIT: org.bukkit.Sound;

			const BLOCK_CHERRY_LEAVES_PLACE: org.bukkit.Sound;

			const BLOCK_CHERRY_LEAVES_STEP: org.bukkit.Sound;

			const BLOCK_CHERRY_SAPLING_BREAK: org.bukkit.Sound;

			const BLOCK_CHERRY_SAPLING_FALL: org.bukkit.Sound;

			const BLOCK_CHERRY_SAPLING_HIT: org.bukkit.Sound;

			const BLOCK_CHERRY_SAPLING_PLACE: org.bukkit.Sound;

			const BLOCK_CHERRY_SAPLING_STEP: org.bukkit.Sound;

			const BLOCK_CHERRY_WOOD_BREAK: org.bukkit.Sound;

			const BLOCK_CHERRY_WOOD_BUTTON_CLICK_OFF: org.bukkit.Sound;

			const BLOCK_CHERRY_WOOD_BUTTON_CLICK_ON: org.bukkit.Sound;

			const BLOCK_CHERRY_WOOD_DOOR_CLOSE: org.bukkit.Sound;

			const BLOCK_CHERRY_WOOD_DOOR_OPEN: org.bukkit.Sound;

			const BLOCK_CHERRY_WOOD_FALL: org.bukkit.Sound;

			const BLOCK_CHERRY_WOOD_FENCE_GATE_CLOSE: org.bukkit.Sound;

			const BLOCK_CHERRY_WOOD_FENCE_GATE_OPEN: org.bukkit.Sound;

			const BLOCK_CHERRY_WOOD_HANGING_SIGN_BREAK: org.bukkit.Sound;

			const BLOCK_CHERRY_WOOD_HANGING_SIGN_FALL: org.bukkit.Sound;

			const BLOCK_CHERRY_WOOD_HANGING_SIGN_HIT: org.bukkit.Sound;

			const BLOCK_CHERRY_WOOD_HANGING_SIGN_PLACE: org.bukkit.Sound;

			const BLOCK_CHERRY_WOOD_HANGING_SIGN_STEP: org.bukkit.Sound;

			const BLOCK_CHERRY_WOOD_HIT: org.bukkit.Sound;

			const BLOCK_CHERRY_WOOD_PLACE: org.bukkit.Sound;

			const BLOCK_CHERRY_WOOD_PRESSURE_PLATE_CLICK_OFF: org.bukkit.Sound;

			const BLOCK_CHERRY_WOOD_PRESSURE_PLATE_CLICK_ON: org.bukkit.Sound;

			const BLOCK_CHERRY_WOOD_STEP: org.bukkit.Sound;

			const BLOCK_CHERRY_WOOD_TRAPDOOR_CLOSE: org.bukkit.Sound;

			const BLOCK_CHERRY_WOOD_TRAPDOOR_OPEN: org.bukkit.Sound;

			const BLOCK_CHEST_CLOSE: org.bukkit.Sound;

			const BLOCK_CHEST_LOCKED: org.bukkit.Sound;

			const BLOCK_CHEST_OPEN: org.bukkit.Sound;

			const BLOCK_CHISELED_BOOKSHELF_BREAK: org.bukkit.Sound;

			const BLOCK_CHISELED_BOOKSHELF_FALL: org.bukkit.Sound;

			const BLOCK_CHISELED_BOOKSHELF_HIT: org.bukkit.Sound;

			const BLOCK_CHISELED_BOOKSHELF_INSERT: org.bukkit.Sound;

			const BLOCK_CHISELED_BOOKSHELF_INSERT_ENCHANTED: org.bukkit.Sound;

			const BLOCK_CHISELED_BOOKSHELF_PICKUP: org.bukkit.Sound;

			const BLOCK_CHISELED_BOOKSHELF_PICKUP_ENCHANTED: org.bukkit.Sound;

			const BLOCK_CHISELED_BOOKSHELF_PLACE: org.bukkit.Sound;

			const BLOCK_CHISELED_BOOKSHELF_STEP: org.bukkit.Sound;

			const BLOCK_CHORUS_FLOWER_DEATH: org.bukkit.Sound;

			const BLOCK_CHORUS_FLOWER_GROW: org.bukkit.Sound;

			const BLOCK_COBWEB_BREAK: org.bukkit.Sound;

			const BLOCK_COBWEB_FALL: org.bukkit.Sound;

			const BLOCK_COBWEB_HIT: org.bukkit.Sound;

			const BLOCK_COBWEB_PLACE: org.bukkit.Sound;

			const BLOCK_COBWEB_STEP: org.bukkit.Sound;

			const BLOCK_COMPARATOR_CLICK: org.bukkit.Sound;

			const BLOCK_COMPOSTER_EMPTY: org.bukkit.Sound;

			const BLOCK_COMPOSTER_FILL: org.bukkit.Sound;

			const BLOCK_COMPOSTER_FILL_SUCCESS: org.bukkit.Sound;

			const BLOCK_COMPOSTER_READY: org.bukkit.Sound;

			const BLOCK_CONDUIT_ACTIVATE: org.bukkit.Sound;

			const BLOCK_CONDUIT_AMBIENT: org.bukkit.Sound;

			const BLOCK_CONDUIT_AMBIENT_SHORT: org.bukkit.Sound;

			const BLOCK_CONDUIT_ATTACK_TARGET: org.bukkit.Sound;

			const BLOCK_CONDUIT_DEACTIVATE: org.bukkit.Sound;

			const BLOCK_COPPER_BREAK: org.bukkit.Sound;

			const BLOCK_COPPER_BULB_BREAK: org.bukkit.Sound;

			const BLOCK_COPPER_BULB_FALL: org.bukkit.Sound;

			const BLOCK_COPPER_BULB_HIT: org.bukkit.Sound;

			const BLOCK_COPPER_BULB_PLACE: org.bukkit.Sound;

			const BLOCK_COPPER_BULB_STEP: org.bukkit.Sound;

			const BLOCK_COPPER_BULB_TURN_OFF: org.bukkit.Sound;

			const BLOCK_COPPER_BULB_TURN_ON: org.bukkit.Sound;

			const BLOCK_COPPER_DOOR_CLOSE: org.bukkit.Sound;

			const BLOCK_COPPER_DOOR_OPEN: org.bukkit.Sound;

			const BLOCK_COPPER_FALL: org.bukkit.Sound;

			const BLOCK_COPPER_GRATE_BREAK: org.bukkit.Sound;

			const BLOCK_COPPER_GRATE_FALL: org.bukkit.Sound;

			const BLOCK_COPPER_GRATE_HIT: org.bukkit.Sound;

			const BLOCK_COPPER_GRATE_PLACE: org.bukkit.Sound;

			const BLOCK_COPPER_GRATE_STEP: org.bukkit.Sound;

			const BLOCK_COPPER_HIT: org.bukkit.Sound;

			const BLOCK_COPPER_PLACE: org.bukkit.Sound;

			const BLOCK_COPPER_STEP: org.bukkit.Sound;

			const BLOCK_COPPER_TRAPDOOR_CLOSE: org.bukkit.Sound;

			const BLOCK_COPPER_TRAPDOOR_OPEN: org.bukkit.Sound;

			const BLOCK_CORAL_BLOCK_BREAK: org.bukkit.Sound;

			const BLOCK_CORAL_BLOCK_FALL: org.bukkit.Sound;

			const BLOCK_CORAL_BLOCK_HIT: org.bukkit.Sound;

			const BLOCK_CORAL_BLOCK_PLACE: org.bukkit.Sound;

			const BLOCK_CORAL_BLOCK_STEP: org.bukkit.Sound;

			const BLOCK_CRAFTER_CRAFT: org.bukkit.Sound;

			const BLOCK_CRAFTER_FAIL: org.bukkit.Sound;

			const BLOCK_CROP_BREAK: org.bukkit.Sound;

			const BLOCK_DECORATED_POT_BREAK: org.bukkit.Sound;

			const BLOCK_DECORATED_POT_FALL: org.bukkit.Sound;

			const BLOCK_DECORATED_POT_HIT: org.bukkit.Sound;

			const BLOCK_DECORATED_POT_INSERT: org.bukkit.Sound;

			const BLOCK_DECORATED_POT_INSERT_FAIL: org.bukkit.Sound;

			const BLOCK_DECORATED_POT_PLACE: org.bukkit.Sound;

			const BLOCK_DECORATED_POT_SHATTER: org.bukkit.Sound;

			const BLOCK_DECORATED_POT_STEP: org.bukkit.Sound;

			const BLOCK_DEEPSLATE_BREAK: org.bukkit.Sound;

			const BLOCK_DEEPSLATE_BRICKS_BREAK: org.bukkit.Sound;

			const BLOCK_DEEPSLATE_BRICKS_FALL: org.bukkit.Sound;

			const BLOCK_DEEPSLATE_BRICKS_HIT: org.bukkit.Sound;

			const BLOCK_DEEPSLATE_BRICKS_PLACE: org.bukkit.Sound;

			const BLOCK_DEEPSLATE_BRICKS_STEP: org.bukkit.Sound;

			const BLOCK_DEEPSLATE_FALL: org.bukkit.Sound;

			const BLOCK_DEEPSLATE_HIT: org.bukkit.Sound;

			const BLOCK_DEEPSLATE_PLACE: org.bukkit.Sound;

			const BLOCK_DEEPSLATE_STEP: org.bukkit.Sound;

			const BLOCK_DEEPSLATE_TILES_BREAK: org.bukkit.Sound;

			const BLOCK_DEEPSLATE_TILES_FALL: org.bukkit.Sound;

			const BLOCK_DEEPSLATE_TILES_HIT: org.bukkit.Sound;

			const BLOCK_DEEPSLATE_TILES_PLACE: org.bukkit.Sound;

			const BLOCK_DEEPSLATE_TILES_STEP: org.bukkit.Sound;

			const BLOCK_DISPENSER_DISPENSE: org.bukkit.Sound;

			const BLOCK_DISPENSER_FAIL: org.bukkit.Sound;

			const BLOCK_DISPENSER_LAUNCH: org.bukkit.Sound;

			const BLOCK_DRIPSTONE_BLOCK_BREAK: org.bukkit.Sound;

			const BLOCK_DRIPSTONE_BLOCK_FALL: org.bukkit.Sound;

			const BLOCK_DRIPSTONE_BLOCK_HIT: org.bukkit.Sound;

			const BLOCK_DRIPSTONE_BLOCK_PLACE: org.bukkit.Sound;

			const BLOCK_DRIPSTONE_BLOCK_STEP: org.bukkit.Sound;

			const BLOCK_ENCHANTMENT_TABLE_USE: org.bukkit.Sound;

			const BLOCK_ENDER_CHEST_CLOSE: org.bukkit.Sound;

			const BLOCK_ENDER_CHEST_OPEN: org.bukkit.Sound;

			const BLOCK_END_GATEWAY_SPAWN: org.bukkit.Sound;

			const BLOCK_END_PORTAL_FRAME_FILL: org.bukkit.Sound;

			const BLOCK_END_PORTAL_SPAWN: org.bukkit.Sound;

			const BLOCK_FENCE_GATE_CLOSE: org.bukkit.Sound;

			const BLOCK_FENCE_GATE_OPEN: org.bukkit.Sound;

			const BLOCK_FIRE_AMBIENT: org.bukkit.Sound;

			const BLOCK_FIRE_EXTINGUISH: org.bukkit.Sound;

			const BLOCK_FLOWERING_AZALEA_BREAK: org.bukkit.Sound;

			const BLOCK_FLOWERING_AZALEA_FALL: org.bukkit.Sound;

			const BLOCK_FLOWERING_AZALEA_HIT: org.bukkit.Sound;

			const BLOCK_FLOWERING_AZALEA_PLACE: org.bukkit.Sound;

			const BLOCK_FLOWERING_AZALEA_STEP: org.bukkit.Sound;

			const BLOCK_FROGLIGHT_BREAK: org.bukkit.Sound;

			const BLOCK_FROGLIGHT_FALL: org.bukkit.Sound;

			const BLOCK_FROGLIGHT_HIT: org.bukkit.Sound;

			const BLOCK_FROGLIGHT_PLACE: org.bukkit.Sound;

			const BLOCK_FROGLIGHT_STEP: org.bukkit.Sound;

			const BLOCK_FROGSPAWN_BREAK: org.bukkit.Sound;

			const BLOCK_FROGSPAWN_FALL: org.bukkit.Sound;

			const BLOCK_FROGSPAWN_HATCH: org.bukkit.Sound;

			const BLOCK_FROGSPAWN_HIT: org.bukkit.Sound;

			const BLOCK_FROGSPAWN_PLACE: org.bukkit.Sound;

			const BLOCK_FROGSPAWN_STEP: org.bukkit.Sound;

			const BLOCK_FUNGUS_BREAK: org.bukkit.Sound;

			const BLOCK_FUNGUS_FALL: org.bukkit.Sound;

			const BLOCK_FUNGUS_HIT: org.bukkit.Sound;

			const BLOCK_FUNGUS_PLACE: org.bukkit.Sound;

			const BLOCK_FUNGUS_STEP: org.bukkit.Sound;

			const BLOCK_FURNACE_FIRE_CRACKLE: org.bukkit.Sound;

			const BLOCK_GILDED_BLACKSTONE_BREAK: org.bukkit.Sound;

			const BLOCK_GILDED_BLACKSTONE_FALL: org.bukkit.Sound;

			const BLOCK_GILDED_BLACKSTONE_HIT: org.bukkit.Sound;

			const BLOCK_GILDED_BLACKSTONE_PLACE: org.bukkit.Sound;

			const BLOCK_GILDED_BLACKSTONE_STEP: org.bukkit.Sound;

			const BLOCK_GLASS_BREAK: org.bukkit.Sound;

			const BLOCK_GLASS_FALL: org.bukkit.Sound;

			const BLOCK_GLASS_HIT: org.bukkit.Sound;

			const BLOCK_GLASS_PLACE: org.bukkit.Sound;

			const BLOCK_GLASS_STEP: org.bukkit.Sound;

			const BLOCK_GRASS_BREAK: org.bukkit.Sound;

			const BLOCK_GRASS_FALL: org.bukkit.Sound;

			const BLOCK_GRASS_HIT: org.bukkit.Sound;

			const BLOCK_GRASS_PLACE: org.bukkit.Sound;

			const BLOCK_GRASS_STEP: org.bukkit.Sound;

			const BLOCK_GRAVEL_BREAK: org.bukkit.Sound;

			const BLOCK_GRAVEL_FALL: org.bukkit.Sound;

			const BLOCK_GRAVEL_HIT: org.bukkit.Sound;

			const BLOCK_GRAVEL_PLACE: org.bukkit.Sound;

			const BLOCK_GRAVEL_STEP: org.bukkit.Sound;

			const BLOCK_GRINDSTONE_USE: org.bukkit.Sound;

			const BLOCK_GROWING_PLANT_CROP: org.bukkit.Sound;

			const BLOCK_HANGING_ROOTS_BREAK: org.bukkit.Sound;

			const BLOCK_HANGING_ROOTS_FALL: org.bukkit.Sound;

			const BLOCK_HANGING_ROOTS_HIT: org.bukkit.Sound;

			const BLOCK_HANGING_ROOTS_PLACE: org.bukkit.Sound;

			const BLOCK_HANGING_ROOTS_STEP: org.bukkit.Sound;

			const BLOCK_HANGING_SIGN_BREAK: org.bukkit.Sound;

			const BLOCK_HANGING_SIGN_FALL: org.bukkit.Sound;

			const BLOCK_HANGING_SIGN_HIT: org.bukkit.Sound;

			const BLOCK_HANGING_SIGN_PLACE: org.bukkit.Sound;

			const BLOCK_HANGING_SIGN_STEP: org.bukkit.Sound;

			const BLOCK_HANGING_SIGN_WAXED_INTERACT_FAIL: org.bukkit.Sound;

			const BLOCK_HEAVY_CORE_BREAK: org.bukkit.Sound;

			const BLOCK_HEAVY_CORE_FALL: org.bukkit.Sound;

			const BLOCK_HEAVY_CORE_HIT: org.bukkit.Sound;

			const BLOCK_HEAVY_CORE_PLACE: org.bukkit.Sound;

			const BLOCK_HEAVY_CORE_STEP: org.bukkit.Sound;

			const BLOCK_HONEY_BLOCK_BREAK: org.bukkit.Sound;

			const BLOCK_HONEY_BLOCK_FALL: org.bukkit.Sound;

			const BLOCK_HONEY_BLOCK_HIT: org.bukkit.Sound;

			const BLOCK_HONEY_BLOCK_PLACE: org.bukkit.Sound;

			const BLOCK_HONEY_BLOCK_SLIDE: org.bukkit.Sound;

			const BLOCK_HONEY_BLOCK_STEP: org.bukkit.Sound;

			const BLOCK_IRON_DOOR_CLOSE: org.bukkit.Sound;

			const BLOCK_IRON_DOOR_OPEN: org.bukkit.Sound;

			const BLOCK_IRON_TRAPDOOR_CLOSE: org.bukkit.Sound;

			const BLOCK_IRON_TRAPDOOR_OPEN: org.bukkit.Sound;

			const BLOCK_LADDER_BREAK: org.bukkit.Sound;

			const BLOCK_LADDER_FALL: org.bukkit.Sound;

			const BLOCK_LADDER_HIT: org.bukkit.Sound;

			const BLOCK_LADDER_PLACE: org.bukkit.Sound;

			const BLOCK_LADDER_STEP: org.bukkit.Sound;

			const BLOCK_LANTERN_BREAK: org.bukkit.Sound;

			const BLOCK_LANTERN_FALL: org.bukkit.Sound;

			const BLOCK_LANTERN_HIT: org.bukkit.Sound;

			const BLOCK_LANTERN_PLACE: org.bukkit.Sound;

			const BLOCK_LANTERN_STEP: org.bukkit.Sound;

			const BLOCK_LARGE_AMETHYST_BUD_BREAK: org.bukkit.Sound;

			const BLOCK_LARGE_AMETHYST_BUD_PLACE: org.bukkit.Sound;

			const BLOCK_LAVA_AMBIENT: org.bukkit.Sound;

			const BLOCK_LAVA_EXTINGUISH: org.bukkit.Sound;

			const BLOCK_LAVA_POP: org.bukkit.Sound;

			const BLOCK_LEVER_CLICK: org.bukkit.Sound;

			const BLOCK_LILY_PAD_PLACE: org.bukkit.Sound;

			const BLOCK_LODESTONE_BREAK: org.bukkit.Sound;

			const BLOCK_LODESTONE_FALL: org.bukkit.Sound;

			const BLOCK_LODESTONE_HIT: org.bukkit.Sound;

			const BLOCK_LODESTONE_PLACE: org.bukkit.Sound;

			const BLOCK_LODESTONE_STEP: org.bukkit.Sound;

			const BLOCK_MANGROVE_ROOTS_BREAK: org.bukkit.Sound;

			const BLOCK_MANGROVE_ROOTS_FALL: org.bukkit.Sound;

			const BLOCK_MANGROVE_ROOTS_HIT: org.bukkit.Sound;

			const BLOCK_MANGROVE_ROOTS_PLACE: org.bukkit.Sound;

			const BLOCK_MANGROVE_ROOTS_STEP: org.bukkit.Sound;

			const BLOCK_MEDIUM_AMETHYST_BUD_BREAK: org.bukkit.Sound;

			const BLOCK_MEDIUM_AMETHYST_BUD_PLACE: org.bukkit.Sound;

			const BLOCK_METAL_BREAK: org.bukkit.Sound;

			const BLOCK_METAL_FALL: org.bukkit.Sound;

			const BLOCK_METAL_HIT: org.bukkit.Sound;

			const BLOCK_METAL_PLACE: org.bukkit.Sound;

			const BLOCK_METAL_PRESSURE_PLATE_CLICK_OFF: org.bukkit.Sound;

			const BLOCK_METAL_PRESSURE_PLATE_CLICK_ON: org.bukkit.Sound;

			const BLOCK_METAL_STEP: org.bukkit.Sound;

			const BLOCK_MOSS_BREAK: org.bukkit.Sound;

			const BLOCK_MOSS_CARPET_BREAK: org.bukkit.Sound;

			const BLOCK_MOSS_CARPET_FALL: org.bukkit.Sound;

			const BLOCK_MOSS_CARPET_HIT: org.bukkit.Sound;

			const BLOCK_MOSS_CARPET_PLACE: org.bukkit.Sound;

			const BLOCK_MOSS_CARPET_STEP: org.bukkit.Sound;

			const BLOCK_MOSS_FALL: org.bukkit.Sound;

			const BLOCK_MOSS_HIT: org.bukkit.Sound;

			const BLOCK_MOSS_PLACE: org.bukkit.Sound;

			const BLOCK_MOSS_STEP: org.bukkit.Sound;

			const BLOCK_MUDDY_MANGROVE_ROOTS_BREAK: org.bukkit.Sound;

			const BLOCK_MUDDY_MANGROVE_ROOTS_FALL: org.bukkit.Sound;

			const BLOCK_MUDDY_MANGROVE_ROOTS_HIT: org.bukkit.Sound;

			const BLOCK_MUDDY_MANGROVE_ROOTS_PLACE: org.bukkit.Sound;

			const BLOCK_MUDDY_MANGROVE_ROOTS_STEP: org.bukkit.Sound;

			const BLOCK_MUD_BREAK: org.bukkit.Sound;

			const BLOCK_MUD_BRICKS_BREAK: org.bukkit.Sound;

			const BLOCK_MUD_BRICKS_FALL: org.bukkit.Sound;

			const BLOCK_MUD_BRICKS_HIT: org.bukkit.Sound;

			const BLOCK_MUD_BRICKS_PLACE: org.bukkit.Sound;

			const BLOCK_MUD_BRICKS_STEP: org.bukkit.Sound;

			const BLOCK_MUD_FALL: org.bukkit.Sound;

			const BLOCK_MUD_HIT: org.bukkit.Sound;

			const BLOCK_MUD_PLACE: org.bukkit.Sound;

			const BLOCK_MUD_STEP: org.bukkit.Sound;

			const BLOCK_NETHERITE_BLOCK_BREAK: org.bukkit.Sound;

			const BLOCK_NETHERITE_BLOCK_FALL: org.bukkit.Sound;

			const BLOCK_NETHERITE_BLOCK_HIT: org.bukkit.Sound;

			const BLOCK_NETHERITE_BLOCK_PLACE: org.bukkit.Sound;

			const BLOCK_NETHERITE_BLOCK_STEP: org.bukkit.Sound;

			const BLOCK_NETHERRACK_BREAK: org.bukkit.Sound;

			const BLOCK_NETHERRACK_FALL: org.bukkit.Sound;

			const BLOCK_NETHERRACK_HIT: org.bukkit.Sound;

			const BLOCK_NETHERRACK_PLACE: org.bukkit.Sound;

			const BLOCK_NETHERRACK_STEP: org.bukkit.Sound;

			const BLOCK_NETHER_BRICKS_BREAK: org.bukkit.Sound;

			const BLOCK_NETHER_BRICKS_FALL: org.bukkit.Sound;

			const BLOCK_NETHER_BRICKS_HIT: org.bukkit.Sound;

			const BLOCK_NETHER_BRICKS_PLACE: org.bukkit.Sound;

			const BLOCK_NETHER_BRICKS_STEP: org.bukkit.Sound;

			const BLOCK_NETHER_GOLD_ORE_BREAK: org.bukkit.Sound;

			const BLOCK_NETHER_GOLD_ORE_FALL: org.bukkit.Sound;

			const BLOCK_NETHER_GOLD_ORE_HIT: org.bukkit.Sound;

			const BLOCK_NETHER_GOLD_ORE_PLACE: org.bukkit.Sound;

			const BLOCK_NETHER_GOLD_ORE_STEP: org.bukkit.Sound;

			const BLOCK_NETHER_ORE_BREAK: org.bukkit.Sound;

			const BLOCK_NETHER_ORE_FALL: org.bukkit.Sound;

			const BLOCK_NETHER_ORE_HIT: org.bukkit.Sound;

			const BLOCK_NETHER_ORE_PLACE: org.bukkit.Sound;

			const BLOCK_NETHER_ORE_STEP: org.bukkit.Sound;

			const BLOCK_NETHER_SPROUTS_BREAK: org.bukkit.Sound;

			const BLOCK_NETHER_SPROUTS_FALL: org.bukkit.Sound;

			const BLOCK_NETHER_SPROUTS_HIT: org.bukkit.Sound;

			const BLOCK_NETHER_SPROUTS_PLACE: org.bukkit.Sound;

			const BLOCK_NETHER_SPROUTS_STEP: org.bukkit.Sound;

			const BLOCK_NETHER_WART_BREAK: org.bukkit.Sound;

			const BLOCK_NETHER_WOOD_BREAK: org.bukkit.Sound;

			const BLOCK_NETHER_WOOD_BUTTON_CLICK_OFF: org.bukkit.Sound;

			const BLOCK_NETHER_WOOD_BUTTON_CLICK_ON: org.bukkit.Sound;

			const BLOCK_NETHER_WOOD_DOOR_CLOSE: org.bukkit.Sound;

			const BLOCK_NETHER_WOOD_DOOR_OPEN: org.bukkit.Sound;

			const BLOCK_NETHER_WOOD_FALL: org.bukkit.Sound;

			const BLOCK_NETHER_WOOD_FENCE_GATE_CLOSE: org.bukkit.Sound;

			const BLOCK_NETHER_WOOD_FENCE_GATE_OPEN: org.bukkit.Sound;

			const BLOCK_NETHER_WOOD_HANGING_SIGN_BREAK: org.bukkit.Sound;

			const BLOCK_NETHER_WOOD_HANGING_SIGN_FALL: org.bukkit.Sound;

			const BLOCK_NETHER_WOOD_HANGING_SIGN_HIT: org.bukkit.Sound;

			const BLOCK_NETHER_WOOD_HANGING_SIGN_PLACE: org.bukkit.Sound;

			const BLOCK_NETHER_WOOD_HANGING_SIGN_STEP: org.bukkit.Sound;

			const BLOCK_NETHER_WOOD_HIT: org.bukkit.Sound;

			const BLOCK_NETHER_WOOD_PLACE: org.bukkit.Sound;

			const BLOCK_NETHER_WOOD_PRESSURE_PLATE_CLICK_OFF: org.bukkit.Sound;

			const BLOCK_NETHER_WOOD_PRESSURE_PLATE_CLICK_ON: org.bukkit.Sound;

			const BLOCK_NETHER_WOOD_STEP: org.bukkit.Sound;

			const BLOCK_NETHER_WOOD_TRAPDOOR_CLOSE: org.bukkit.Sound;

			const BLOCK_NETHER_WOOD_TRAPDOOR_OPEN: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_BANJO: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_BASEDRUM: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_BASS: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_BELL: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_BIT: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_CHIME: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_COW_BELL: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_DIDGERIDOO: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_FLUTE: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_GUITAR: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_HARP: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_HAT: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_IMITATE_CREEPER: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_IMITATE_ENDER_DRAGON: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_IMITATE_PIGLIN: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_IMITATE_SKELETON: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_IMITATE_WITHER_SKELETON: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_IMITATE_ZOMBIE: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_IRON_XYLOPHONE: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_PLING: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_SNARE: org.bukkit.Sound;

			const BLOCK_NOTE_BLOCK_XYLOPHONE: org.bukkit.Sound;

			const BLOCK_NYLIUM_BREAK: org.bukkit.Sound;

			const BLOCK_NYLIUM_FALL: org.bukkit.Sound;

			const BLOCK_NYLIUM_HIT: org.bukkit.Sound;

			const BLOCK_NYLIUM_PLACE: org.bukkit.Sound;

			const BLOCK_NYLIUM_STEP: org.bukkit.Sound;

			const BLOCK_PACKED_MUD_BREAK: org.bukkit.Sound;

			const BLOCK_PACKED_MUD_FALL: org.bukkit.Sound;

			const BLOCK_PACKED_MUD_HIT: org.bukkit.Sound;

			const BLOCK_PACKED_MUD_PLACE: org.bukkit.Sound;

			const BLOCK_PACKED_MUD_STEP: org.bukkit.Sound;

			const BLOCK_PINK_PETALS_BREAK: org.bukkit.Sound;

			const BLOCK_PINK_PETALS_FALL: org.bukkit.Sound;

			const BLOCK_PINK_PETALS_HIT: org.bukkit.Sound;

			const BLOCK_PINK_PETALS_PLACE: org.bukkit.Sound;

			const BLOCK_PINK_PETALS_STEP: org.bukkit.Sound;

			const BLOCK_PISTON_CONTRACT: org.bukkit.Sound;

			const BLOCK_PISTON_EXTEND: org.bukkit.Sound;

			const BLOCK_POINTED_DRIPSTONE_BREAK: org.bukkit.Sound;

			const BLOCK_POINTED_DRIPSTONE_DRIP_LAVA: org.bukkit.Sound;

			const BLOCK_POINTED_DRIPSTONE_DRIP_LAVA_INTO_CAULDRON: org.bukkit.Sound;

			const BLOCK_POINTED_DRIPSTONE_DRIP_WATER: org.bukkit.Sound;

			const BLOCK_POINTED_DRIPSTONE_DRIP_WATER_INTO_CAULDRON: org.bukkit.Sound;

			const BLOCK_POINTED_DRIPSTONE_FALL: org.bukkit.Sound;

			const BLOCK_POINTED_DRIPSTONE_HIT: org.bukkit.Sound;

			const BLOCK_POINTED_DRIPSTONE_LAND: org.bukkit.Sound;

			const BLOCK_POINTED_DRIPSTONE_PLACE: org.bukkit.Sound;

			const BLOCK_POINTED_DRIPSTONE_STEP: org.bukkit.Sound;

			const BLOCK_POLISHED_DEEPSLATE_BREAK: org.bukkit.Sound;

			const BLOCK_POLISHED_DEEPSLATE_FALL: org.bukkit.Sound;

			const BLOCK_POLISHED_DEEPSLATE_HIT: org.bukkit.Sound;

			const BLOCK_POLISHED_DEEPSLATE_PLACE: org.bukkit.Sound;

			const BLOCK_POLISHED_DEEPSLATE_STEP: org.bukkit.Sound;

			const BLOCK_POLISHED_TUFF_BREAK: org.bukkit.Sound;

			const BLOCK_POLISHED_TUFF_FALL: org.bukkit.Sound;

			const BLOCK_POLISHED_TUFF_HIT: org.bukkit.Sound;

			const BLOCK_POLISHED_TUFF_PLACE: org.bukkit.Sound;

			const BLOCK_POLISHED_TUFF_STEP: org.bukkit.Sound;

			const BLOCK_PORTAL_AMBIENT: org.bukkit.Sound;

			const BLOCK_PORTAL_TRAVEL: org.bukkit.Sound;

			const BLOCK_PORTAL_TRIGGER: org.bukkit.Sound;

			const BLOCK_POWDER_SNOW_BREAK: org.bukkit.Sound;

			const BLOCK_POWDER_SNOW_FALL: org.bukkit.Sound;

			const BLOCK_POWDER_SNOW_HIT: org.bukkit.Sound;

			const BLOCK_POWDER_SNOW_PLACE: org.bukkit.Sound;

			const BLOCK_POWDER_SNOW_STEP: org.bukkit.Sound;

			const BLOCK_PUMPKIN_CARVE: org.bukkit.Sound;

			const BLOCK_REDSTONE_TORCH_BURNOUT: org.bukkit.Sound;

			const BLOCK_RESPAWN_ANCHOR_AMBIENT: org.bukkit.Sound;

			const BLOCK_RESPAWN_ANCHOR_CHARGE: org.bukkit.Sound;

			const BLOCK_RESPAWN_ANCHOR_DEPLETE: org.bukkit.Sound;

			const BLOCK_RESPAWN_ANCHOR_SET_SPAWN: org.bukkit.Sound;

			const BLOCK_ROOTED_DIRT_BREAK: org.bukkit.Sound;

			const BLOCK_ROOTED_DIRT_FALL: org.bukkit.Sound;

			const BLOCK_ROOTED_DIRT_HIT: org.bukkit.Sound;

			const BLOCK_ROOTED_DIRT_PLACE: org.bukkit.Sound;

			const BLOCK_ROOTED_DIRT_STEP: org.bukkit.Sound;

			const BLOCK_ROOTS_BREAK: org.bukkit.Sound;

			const BLOCK_ROOTS_FALL: org.bukkit.Sound;

			const BLOCK_ROOTS_HIT: org.bukkit.Sound;

			const BLOCK_ROOTS_PLACE: org.bukkit.Sound;

			const BLOCK_ROOTS_STEP: org.bukkit.Sound;

			const BLOCK_SAND_BREAK: org.bukkit.Sound;

			const BLOCK_SAND_FALL: org.bukkit.Sound;

			const BLOCK_SAND_HIT: org.bukkit.Sound;

			const BLOCK_SAND_PLACE: org.bukkit.Sound;

			const BLOCK_SAND_STEP: org.bukkit.Sound;

			const BLOCK_SCAFFOLDING_BREAK: org.bukkit.Sound;

			const BLOCK_SCAFFOLDING_FALL: org.bukkit.Sound;

			const BLOCK_SCAFFOLDING_HIT: org.bukkit.Sound;

			const BLOCK_SCAFFOLDING_PLACE: org.bukkit.Sound;

			const BLOCK_SCAFFOLDING_STEP: org.bukkit.Sound;

			const BLOCK_SCULK_BREAK: org.bukkit.Sound;

			const BLOCK_SCULK_CATALYST_BLOOM: org.bukkit.Sound;

			const BLOCK_SCULK_CATALYST_BREAK: org.bukkit.Sound;

			const BLOCK_SCULK_CATALYST_FALL: org.bukkit.Sound;

			const BLOCK_SCULK_CATALYST_HIT: org.bukkit.Sound;

			const BLOCK_SCULK_CATALYST_PLACE: org.bukkit.Sound;

			const BLOCK_SCULK_CATALYST_STEP: org.bukkit.Sound;

			const BLOCK_SCULK_CHARGE: org.bukkit.Sound;

			const BLOCK_SCULK_FALL: org.bukkit.Sound;

			const BLOCK_SCULK_HIT: org.bukkit.Sound;

			const BLOCK_SCULK_PLACE: org.bukkit.Sound;

			const BLOCK_SCULK_SENSOR_BREAK: org.bukkit.Sound;

			const BLOCK_SCULK_SENSOR_CLICKING: org.bukkit.Sound;

			const BLOCK_SCULK_SENSOR_CLICKING_STOP: org.bukkit.Sound;

			const BLOCK_SCULK_SENSOR_FALL: org.bukkit.Sound;

			const BLOCK_SCULK_SENSOR_HIT: org.bukkit.Sound;

			const BLOCK_SCULK_SENSOR_PLACE: org.bukkit.Sound;

			const BLOCK_SCULK_SENSOR_STEP: org.bukkit.Sound;

			const BLOCK_SCULK_SHRIEKER_BREAK: org.bukkit.Sound;

			const BLOCK_SCULK_SHRIEKER_FALL: org.bukkit.Sound;

			const BLOCK_SCULK_SHRIEKER_HIT: org.bukkit.Sound;

			const BLOCK_SCULK_SHRIEKER_PLACE: org.bukkit.Sound;

			const BLOCK_SCULK_SHRIEKER_SHRIEK: org.bukkit.Sound;

			const BLOCK_SCULK_SHRIEKER_STEP: org.bukkit.Sound;

			const BLOCK_SCULK_SPREAD: org.bukkit.Sound;

			const BLOCK_SCULK_STEP: org.bukkit.Sound;

			const BLOCK_SCULK_VEIN_BREAK: org.bukkit.Sound;

			const BLOCK_SCULK_VEIN_FALL: org.bukkit.Sound;

			const BLOCK_SCULK_VEIN_HIT: org.bukkit.Sound;

			const BLOCK_SCULK_VEIN_PLACE: org.bukkit.Sound;

			const BLOCK_SCULK_VEIN_STEP: org.bukkit.Sound;

			const BLOCK_SHROOMLIGHT_BREAK: org.bukkit.Sound;

			const BLOCK_SHROOMLIGHT_FALL: org.bukkit.Sound;

			const BLOCK_SHROOMLIGHT_HIT: org.bukkit.Sound;

			const BLOCK_SHROOMLIGHT_PLACE: org.bukkit.Sound;

			const BLOCK_SHROOMLIGHT_STEP: org.bukkit.Sound;

			const BLOCK_SHULKER_BOX_CLOSE: org.bukkit.Sound;

			const BLOCK_SHULKER_BOX_OPEN: org.bukkit.Sound;

			const BLOCK_SIGN_WAXED_INTERACT_FAIL: org.bukkit.Sound;

			const BLOCK_SLIME_BLOCK_BREAK: org.bukkit.Sound;

			const BLOCK_SLIME_BLOCK_FALL: org.bukkit.Sound;

			const BLOCK_SLIME_BLOCK_HIT: org.bukkit.Sound;

			const BLOCK_SLIME_BLOCK_PLACE: org.bukkit.Sound;

			const BLOCK_SLIME_BLOCK_STEP: org.bukkit.Sound;

			const BLOCK_SMALL_AMETHYST_BUD_BREAK: org.bukkit.Sound;

			const BLOCK_SMALL_AMETHYST_BUD_PLACE: org.bukkit.Sound;

			const BLOCK_SMALL_DRIPLEAF_BREAK: org.bukkit.Sound;

			const BLOCK_SMALL_DRIPLEAF_FALL: org.bukkit.Sound;

			const BLOCK_SMALL_DRIPLEAF_HIT: org.bukkit.Sound;

			const BLOCK_SMALL_DRIPLEAF_PLACE: org.bukkit.Sound;

			const BLOCK_SMALL_DRIPLEAF_STEP: org.bukkit.Sound;

			const BLOCK_SMITHING_TABLE_USE: org.bukkit.Sound;

			const BLOCK_SMOKER_SMOKE: org.bukkit.Sound;

			const BLOCK_SNIFFER_EGG_CRACK: org.bukkit.Sound;

			const BLOCK_SNIFFER_EGG_HATCH: org.bukkit.Sound;

			const BLOCK_SNIFFER_EGG_PLOP: org.bukkit.Sound;

			const BLOCK_SNOW_BREAK: org.bukkit.Sound;

			const BLOCK_SNOW_FALL: org.bukkit.Sound;

			const BLOCK_SNOW_HIT: org.bukkit.Sound;

			const BLOCK_SNOW_PLACE: org.bukkit.Sound;

			const BLOCK_SNOW_STEP: org.bukkit.Sound;

			const BLOCK_SOUL_SAND_BREAK: org.bukkit.Sound;

			const BLOCK_SOUL_SAND_FALL: org.bukkit.Sound;

			const BLOCK_SOUL_SAND_HIT: org.bukkit.Sound;

			const BLOCK_SOUL_SAND_PLACE: org.bukkit.Sound;

			const BLOCK_SOUL_SAND_STEP: org.bukkit.Sound;

			const BLOCK_SOUL_SOIL_BREAK: org.bukkit.Sound;

			const BLOCK_SOUL_SOIL_FALL: org.bukkit.Sound;

			const BLOCK_SOUL_SOIL_HIT: org.bukkit.Sound;

			const BLOCK_SOUL_SOIL_PLACE: org.bukkit.Sound;

			const BLOCK_SOUL_SOIL_STEP: org.bukkit.Sound;

			const BLOCK_SPONGE_ABSORB: org.bukkit.Sound;

			const BLOCK_SPONGE_BREAK: org.bukkit.Sound;

			const BLOCK_SPONGE_FALL: org.bukkit.Sound;

			const BLOCK_SPONGE_HIT: org.bukkit.Sound;

			const BLOCK_SPONGE_PLACE: org.bukkit.Sound;

			const BLOCK_SPONGE_STEP: org.bukkit.Sound;

			const BLOCK_SPORE_BLOSSOM_BREAK: org.bukkit.Sound;

			const BLOCK_SPORE_BLOSSOM_FALL: org.bukkit.Sound;

			const BLOCK_SPORE_BLOSSOM_HIT: org.bukkit.Sound;

			const BLOCK_SPORE_BLOSSOM_PLACE: org.bukkit.Sound;

			const BLOCK_SPORE_BLOSSOM_STEP: org.bukkit.Sound;

			const BLOCK_STEM_BREAK: org.bukkit.Sound;

			const BLOCK_STEM_FALL: org.bukkit.Sound;

			const BLOCK_STEM_HIT: org.bukkit.Sound;

			const BLOCK_STEM_PLACE: org.bukkit.Sound;

			const BLOCK_STEM_STEP: org.bukkit.Sound;

			const BLOCK_STONE_BREAK: org.bukkit.Sound;

			const BLOCK_STONE_BUTTON_CLICK_OFF: org.bukkit.Sound;

			const BLOCK_STONE_BUTTON_CLICK_ON: org.bukkit.Sound;

			const BLOCK_STONE_FALL: org.bukkit.Sound;

			const BLOCK_STONE_HIT: org.bukkit.Sound;

			const BLOCK_STONE_PLACE: org.bukkit.Sound;

			const BLOCK_STONE_PRESSURE_PLATE_CLICK_OFF: org.bukkit.Sound;

			const BLOCK_STONE_PRESSURE_PLATE_CLICK_ON: org.bukkit.Sound;

			const BLOCK_STONE_STEP: org.bukkit.Sound;

			const BLOCK_SUSPICIOUS_GRAVEL_BREAK: org.bukkit.Sound;

			const BLOCK_SUSPICIOUS_GRAVEL_FALL: org.bukkit.Sound;

			const BLOCK_SUSPICIOUS_GRAVEL_HIT: org.bukkit.Sound;

			const BLOCK_SUSPICIOUS_GRAVEL_PLACE: org.bukkit.Sound;

			const BLOCK_SUSPICIOUS_GRAVEL_STEP: org.bukkit.Sound;

			const BLOCK_SUSPICIOUS_SAND_BREAK: org.bukkit.Sound;

			const BLOCK_SUSPICIOUS_SAND_FALL: org.bukkit.Sound;

			const BLOCK_SUSPICIOUS_SAND_HIT: org.bukkit.Sound;

			const BLOCK_SUSPICIOUS_SAND_PLACE: org.bukkit.Sound;

			const BLOCK_SUSPICIOUS_SAND_STEP: org.bukkit.Sound;

			const BLOCK_SWEET_BERRY_BUSH_BREAK: org.bukkit.Sound;

			const BLOCK_SWEET_BERRY_BUSH_PICK_BERRIES: org.bukkit.Sound;

			const BLOCK_SWEET_BERRY_BUSH_PLACE: org.bukkit.Sound;

			const BLOCK_TRIAL_SPAWNER_ABOUT_TO_SPAWN_ITEM: org.bukkit.Sound;

			const BLOCK_TRIAL_SPAWNER_AMBIENT: org.bukkit.Sound;

			const BLOCK_TRIAL_SPAWNER_AMBIENT_OMINOUS: org.bukkit.Sound;

			const BLOCK_TRIAL_SPAWNER_BREAK: org.bukkit.Sound;

			const BLOCK_TRIAL_SPAWNER_CLOSE_SHUTTER: org.bukkit.Sound;

			const BLOCK_TRIAL_SPAWNER_DETECT_PLAYER: org.bukkit.Sound;

			const BLOCK_TRIAL_SPAWNER_EJECT_ITEM: org.bukkit.Sound;

			const BLOCK_TRIAL_SPAWNER_FALL: org.bukkit.Sound;

			const BLOCK_TRIAL_SPAWNER_HIT: org.bukkit.Sound;

			const BLOCK_TRIAL_SPAWNER_OMINOUS_ACTIVATE: org.bukkit.Sound;

			const BLOCK_TRIAL_SPAWNER_OPEN_SHUTTER: org.bukkit.Sound;

			const BLOCK_TRIAL_SPAWNER_PLACE: org.bukkit.Sound;

			const BLOCK_TRIAL_SPAWNER_SPAWN_ITEM: org.bukkit.Sound;

			const BLOCK_TRIAL_SPAWNER_SPAWN_ITEM_BEGIN: org.bukkit.Sound;

			const BLOCK_TRIAL_SPAWNER_SPAWN_MOB: org.bukkit.Sound;

			const BLOCK_TRIAL_SPAWNER_STEP: org.bukkit.Sound;

			const BLOCK_TRIPWIRE_ATTACH: org.bukkit.Sound;

			const BLOCK_TRIPWIRE_CLICK_OFF: org.bukkit.Sound;

			const BLOCK_TRIPWIRE_CLICK_ON: org.bukkit.Sound;

			const BLOCK_TRIPWIRE_DETACH: org.bukkit.Sound;

			const BLOCK_TUFF_BREAK: org.bukkit.Sound;

			const BLOCK_TUFF_BRICKS_BREAK: org.bukkit.Sound;

			const BLOCK_TUFF_BRICKS_FALL: org.bukkit.Sound;

			const BLOCK_TUFF_BRICKS_HIT: org.bukkit.Sound;

			const BLOCK_TUFF_BRICKS_PLACE: org.bukkit.Sound;

			const BLOCK_TUFF_BRICKS_STEP: org.bukkit.Sound;

			const BLOCK_TUFF_FALL: org.bukkit.Sound;

			const BLOCK_TUFF_HIT: org.bukkit.Sound;

			const BLOCK_TUFF_PLACE: org.bukkit.Sound;

			const BLOCK_TUFF_STEP: org.bukkit.Sound;

			const BLOCK_VAULT_ACTIVATE: org.bukkit.Sound;

			const BLOCK_VAULT_AMBIENT: org.bukkit.Sound;

			const BLOCK_VAULT_BREAK: org.bukkit.Sound;

			const BLOCK_VAULT_CLOSE_SHUTTER: org.bukkit.Sound;

			const BLOCK_VAULT_DEACTIVATE: org.bukkit.Sound;

			const BLOCK_VAULT_EJECT_ITEM: org.bukkit.Sound;

			const BLOCK_VAULT_FALL: org.bukkit.Sound;

			const BLOCK_VAULT_HIT: org.bukkit.Sound;

			const BLOCK_VAULT_INSERT_ITEM: org.bukkit.Sound;

			const BLOCK_VAULT_INSERT_ITEM_FAIL: org.bukkit.Sound;

			const BLOCK_VAULT_OPEN_SHUTTER: org.bukkit.Sound;

			const BLOCK_VAULT_PLACE: org.bukkit.Sound;

			const BLOCK_VAULT_REJECT_REWARDED_PLAYER: org.bukkit.Sound;

			const BLOCK_VAULT_STEP: org.bukkit.Sound;

			const BLOCK_VINE_BREAK: org.bukkit.Sound;

			const BLOCK_VINE_FALL: org.bukkit.Sound;

			const BLOCK_VINE_HIT: org.bukkit.Sound;

			const BLOCK_VINE_PLACE: org.bukkit.Sound;

			const BLOCK_VINE_STEP: org.bukkit.Sound;

			const BLOCK_WART_BLOCK_BREAK: org.bukkit.Sound;

			const BLOCK_WART_BLOCK_FALL: org.bukkit.Sound;

			const BLOCK_WART_BLOCK_HIT: org.bukkit.Sound;

			const BLOCK_WART_BLOCK_PLACE: org.bukkit.Sound;

			const BLOCK_WART_BLOCK_STEP: org.bukkit.Sound;

			const BLOCK_WATER_AMBIENT: org.bukkit.Sound;

			const BLOCK_WEEPING_VINES_BREAK: org.bukkit.Sound;

			const BLOCK_WEEPING_VINES_FALL: org.bukkit.Sound;

			const BLOCK_WEEPING_VINES_HIT: org.bukkit.Sound;

			const BLOCK_WEEPING_VINES_PLACE: org.bukkit.Sound;

			const BLOCK_WEEPING_VINES_STEP: org.bukkit.Sound;

			const BLOCK_WET_GRASS_BREAK: org.bukkit.Sound;

			const BLOCK_WET_GRASS_FALL: org.bukkit.Sound;

			const BLOCK_WET_GRASS_HIT: org.bukkit.Sound;

			const BLOCK_WET_GRASS_PLACE: org.bukkit.Sound;

			const BLOCK_WET_GRASS_STEP: org.bukkit.Sound;

			const BLOCK_WET_SPONGE_BREAK: org.bukkit.Sound;

			const BLOCK_WET_SPONGE_DRIES: org.bukkit.Sound;

			const BLOCK_WET_SPONGE_FALL: org.bukkit.Sound;

			const BLOCK_WET_SPONGE_HIT: org.bukkit.Sound;

			const BLOCK_WET_SPONGE_PLACE: org.bukkit.Sound;

			const BLOCK_WET_SPONGE_STEP: org.bukkit.Sound;

			const BLOCK_WOODEN_BUTTON_CLICK_OFF: org.bukkit.Sound;

			const BLOCK_WOODEN_BUTTON_CLICK_ON: org.bukkit.Sound;

			const BLOCK_WOODEN_DOOR_CLOSE: org.bukkit.Sound;

			const BLOCK_WOODEN_DOOR_OPEN: org.bukkit.Sound;

			const BLOCK_WOODEN_PRESSURE_PLATE_CLICK_OFF: org.bukkit.Sound;

			const BLOCK_WOODEN_PRESSURE_PLATE_CLICK_ON: org.bukkit.Sound;

			const BLOCK_WOODEN_TRAPDOOR_CLOSE: org.bukkit.Sound;

			const BLOCK_WOODEN_TRAPDOOR_OPEN: org.bukkit.Sound;

			const BLOCK_WOOD_BREAK: org.bukkit.Sound;

			const BLOCK_WOOD_FALL: org.bukkit.Sound;

			const BLOCK_WOOD_HIT: org.bukkit.Sound;

			const BLOCK_WOOD_PLACE: org.bukkit.Sound;

			const BLOCK_WOOD_STEP: org.bukkit.Sound;

			const BLOCK_WOOL_BREAK: org.bukkit.Sound;

			const BLOCK_WOOL_FALL: org.bukkit.Sound;

			const BLOCK_WOOL_HIT: org.bukkit.Sound;

			const BLOCK_WOOL_PLACE: org.bukkit.Sound;

			const BLOCK_WOOL_STEP: org.bukkit.Sound;

			const ENCHANT_THORNS_HIT: org.bukkit.Sound;

			const ENTITY_ALLAY_AMBIENT_WITHOUT_ITEM: org.bukkit.Sound;

			const ENTITY_ALLAY_AMBIENT_WITH_ITEM: org.bukkit.Sound;

			const ENTITY_ALLAY_DEATH: org.bukkit.Sound;

			const ENTITY_ALLAY_HURT: org.bukkit.Sound;

			const ENTITY_ALLAY_ITEM_GIVEN: org.bukkit.Sound;

			const ENTITY_ALLAY_ITEM_TAKEN: org.bukkit.Sound;

			const ENTITY_ALLAY_ITEM_THROWN: org.bukkit.Sound;

			const ENTITY_ARMADILLO_AMBIENT: org.bukkit.Sound;

			const ENTITY_ARMADILLO_BRUSH: org.bukkit.Sound;

			const ENTITY_ARMADILLO_DEATH: org.bukkit.Sound;

			const ENTITY_ARMADILLO_EAT: org.bukkit.Sound;

			const ENTITY_ARMADILLO_HURT: org.bukkit.Sound;

			const ENTITY_ARMADILLO_HURT_REDUCED: org.bukkit.Sound;

			const ENTITY_ARMADILLO_LAND: org.bukkit.Sound;

			const ENTITY_ARMADILLO_PEEK: org.bukkit.Sound;

			const ENTITY_ARMADILLO_ROLL: org.bukkit.Sound;

			const ENTITY_ARMADILLO_SCUTE_DROP: org.bukkit.Sound;

			const ENTITY_ARMADILLO_STEP: org.bukkit.Sound;

			const ENTITY_ARMADILLO_UNROLL_FINISH: org.bukkit.Sound;

			const ENTITY_ARMADILLO_UNROLL_START: org.bukkit.Sound;

			const ENTITY_ARMOR_STAND_BREAK: org.bukkit.Sound;

			const ENTITY_ARMOR_STAND_FALL: org.bukkit.Sound;

			const ENTITY_ARMOR_STAND_HIT: org.bukkit.Sound;

			const ENTITY_ARMOR_STAND_PLACE: org.bukkit.Sound;

			const ENTITY_ARROW_HIT: org.bukkit.Sound;

			const ENTITY_ARROW_HIT_PLAYER: org.bukkit.Sound;

			const ENTITY_ARROW_SHOOT: org.bukkit.Sound;

			const ENTITY_AXOLOTL_ATTACK: org.bukkit.Sound;

			const ENTITY_AXOLOTL_DEATH: org.bukkit.Sound;

			const ENTITY_AXOLOTL_HURT: org.bukkit.Sound;

			const ENTITY_AXOLOTL_IDLE_AIR: org.bukkit.Sound;

			const ENTITY_AXOLOTL_IDLE_WATER: org.bukkit.Sound;

			const ENTITY_AXOLOTL_SPLASH: org.bukkit.Sound;

			const ENTITY_AXOLOTL_SWIM: org.bukkit.Sound;

			const ENTITY_BAT_AMBIENT: org.bukkit.Sound;

			const ENTITY_BAT_DEATH: org.bukkit.Sound;

			const ENTITY_BAT_HURT: org.bukkit.Sound;

			const ENTITY_BAT_LOOP: org.bukkit.Sound;

			const ENTITY_BAT_TAKEOFF: org.bukkit.Sound;

			const ENTITY_BEE_DEATH: org.bukkit.Sound;

			const ENTITY_BEE_HURT: org.bukkit.Sound;

			const ENTITY_BEE_LOOP: org.bukkit.Sound;

			const ENTITY_BEE_LOOP_AGGRESSIVE: org.bukkit.Sound;

			const ENTITY_BEE_POLLINATE: org.bukkit.Sound;

			const ENTITY_BEE_STING: org.bukkit.Sound;

			const ENTITY_BLAZE_AMBIENT: org.bukkit.Sound;

			const ENTITY_BLAZE_BURN: org.bukkit.Sound;

			const ENTITY_BLAZE_DEATH: org.bukkit.Sound;

			const ENTITY_BLAZE_HURT: org.bukkit.Sound;

			const ENTITY_BLAZE_SHOOT: org.bukkit.Sound;

			const ENTITY_BOAT_PADDLE_LAND: org.bukkit.Sound;

			const ENTITY_BOAT_PADDLE_WATER: org.bukkit.Sound;

			const ENTITY_BOGGED_AMBIENT: org.bukkit.Sound;

			const ENTITY_BOGGED_DEATH: org.bukkit.Sound;

			const ENTITY_BOGGED_HURT: org.bukkit.Sound;

			const ENTITY_BOGGED_SHEAR: org.bukkit.Sound;

			const ENTITY_BOGGED_STEP: org.bukkit.Sound;

			const ENTITY_BREEZE_CHARGE: org.bukkit.Sound;

			const ENTITY_BREEZE_DEATH: org.bukkit.Sound;

			const ENTITY_BREEZE_DEFLECT: org.bukkit.Sound;

			const ENTITY_BREEZE_HURT: org.bukkit.Sound;

			const ENTITY_BREEZE_IDLE_AIR: org.bukkit.Sound;

			const ENTITY_BREEZE_IDLE_GROUND: org.bukkit.Sound;

			const ENTITY_BREEZE_INHALE: org.bukkit.Sound;

			const ENTITY_BREEZE_JUMP: org.bukkit.Sound;

			const ENTITY_BREEZE_LAND: org.bukkit.Sound;

			const ENTITY_BREEZE_SHOOT: org.bukkit.Sound;

			const ENTITY_BREEZE_SLIDE: org.bukkit.Sound;

			const ENTITY_BREEZE_WHIRL: org.bukkit.Sound;

			const ENTITY_BREEZE_WIND_BURST: org.bukkit.Sound;

			const ENTITY_CAMEL_AMBIENT: org.bukkit.Sound;

			const ENTITY_CAMEL_DASH: org.bukkit.Sound;

			const ENTITY_CAMEL_DASH_READY: org.bukkit.Sound;

			const ENTITY_CAMEL_DEATH: org.bukkit.Sound;

			const ENTITY_CAMEL_EAT: org.bukkit.Sound;

			const ENTITY_CAMEL_HURT: org.bukkit.Sound;

			const ENTITY_CAMEL_SADDLE: org.bukkit.Sound;

			const ENTITY_CAMEL_SIT: org.bukkit.Sound;

			const ENTITY_CAMEL_STAND: org.bukkit.Sound;

			const ENTITY_CAMEL_STEP: org.bukkit.Sound;

			const ENTITY_CAMEL_STEP_SAND: org.bukkit.Sound;

			const ENTITY_CAT_AMBIENT: org.bukkit.Sound;

			const ENTITY_CAT_BEG_FOR_FOOD: org.bukkit.Sound;

			const ENTITY_CAT_DEATH: org.bukkit.Sound;

			const ENTITY_CAT_EAT: org.bukkit.Sound;

			const ENTITY_CAT_HISS: org.bukkit.Sound;

			const ENTITY_CAT_HURT: org.bukkit.Sound;

			const ENTITY_CAT_PURR: org.bukkit.Sound;

			const ENTITY_CAT_PURREOW: org.bukkit.Sound;

			const ENTITY_CAT_STRAY_AMBIENT: org.bukkit.Sound;

			const ENTITY_CHICKEN_AMBIENT: org.bukkit.Sound;

			const ENTITY_CHICKEN_DEATH: org.bukkit.Sound;

			const ENTITY_CHICKEN_EGG: org.bukkit.Sound;

			const ENTITY_CHICKEN_HURT: org.bukkit.Sound;

			const ENTITY_CHICKEN_STEP: org.bukkit.Sound;

			const ENTITY_COD_AMBIENT: org.bukkit.Sound;

			const ENTITY_COD_DEATH: org.bukkit.Sound;

			const ENTITY_COD_FLOP: org.bukkit.Sound;

			const ENTITY_COD_HURT: org.bukkit.Sound;

			const ENTITY_COW_AMBIENT: org.bukkit.Sound;

			const ENTITY_COW_DEATH: org.bukkit.Sound;

			const ENTITY_COW_HURT: org.bukkit.Sound;

			const ENTITY_COW_MILK: org.bukkit.Sound;

			const ENTITY_COW_STEP: org.bukkit.Sound;

			const ENTITY_CREEPER_DEATH: org.bukkit.Sound;

			const ENTITY_CREEPER_HURT: org.bukkit.Sound;

			const ENTITY_CREEPER_PRIMED: org.bukkit.Sound;

			const ENTITY_DOLPHIN_AMBIENT: org.bukkit.Sound;

			const ENTITY_DOLPHIN_AMBIENT_WATER: org.bukkit.Sound;

			const ENTITY_DOLPHIN_ATTACK: org.bukkit.Sound;

			const ENTITY_DOLPHIN_DEATH: org.bukkit.Sound;

			const ENTITY_DOLPHIN_EAT: org.bukkit.Sound;

			const ENTITY_DOLPHIN_HURT: org.bukkit.Sound;

			const ENTITY_DOLPHIN_JUMP: org.bukkit.Sound;

			const ENTITY_DOLPHIN_PLAY: org.bukkit.Sound;

			const ENTITY_DOLPHIN_SPLASH: org.bukkit.Sound;

			const ENTITY_DOLPHIN_SWIM: org.bukkit.Sound;

			const ENTITY_DONKEY_AMBIENT: org.bukkit.Sound;

			const ENTITY_DONKEY_ANGRY: org.bukkit.Sound;

			const ENTITY_DONKEY_CHEST: org.bukkit.Sound;

			const ENTITY_DONKEY_DEATH: org.bukkit.Sound;

			const ENTITY_DONKEY_EAT: org.bukkit.Sound;

			const ENTITY_DONKEY_HURT: org.bukkit.Sound;

			const ENTITY_DONKEY_JUMP: org.bukkit.Sound;

			const ENTITY_DRAGON_FIREBALL_EXPLODE: org.bukkit.Sound;

			const ENTITY_DROWNED_AMBIENT: org.bukkit.Sound;

			const ENTITY_DROWNED_AMBIENT_WATER: org.bukkit.Sound;

			const ENTITY_DROWNED_DEATH: org.bukkit.Sound;

			const ENTITY_DROWNED_DEATH_WATER: org.bukkit.Sound;

			const ENTITY_DROWNED_HURT: org.bukkit.Sound;

			const ENTITY_DROWNED_HURT_WATER: org.bukkit.Sound;

			const ENTITY_DROWNED_SHOOT: org.bukkit.Sound;

			const ENTITY_DROWNED_STEP: org.bukkit.Sound;

			const ENTITY_DROWNED_SWIM: org.bukkit.Sound;

			const ENTITY_EGG_THROW: org.bukkit.Sound;

			const ENTITY_ELDER_GUARDIAN_AMBIENT: org.bukkit.Sound;

			const ENTITY_ELDER_GUARDIAN_AMBIENT_LAND: org.bukkit.Sound;

			const ENTITY_ELDER_GUARDIAN_CURSE: org.bukkit.Sound;

			const ENTITY_ELDER_GUARDIAN_DEATH: org.bukkit.Sound;

			const ENTITY_ELDER_GUARDIAN_DEATH_LAND: org.bukkit.Sound;

			const ENTITY_ELDER_GUARDIAN_FLOP: org.bukkit.Sound;

			const ENTITY_ELDER_GUARDIAN_HURT: org.bukkit.Sound;

			const ENTITY_ELDER_GUARDIAN_HURT_LAND: org.bukkit.Sound;

			const ENTITY_ENDERMAN_AMBIENT: org.bukkit.Sound;

			const ENTITY_ENDERMAN_DEATH: org.bukkit.Sound;

			const ENTITY_ENDERMAN_HURT: org.bukkit.Sound;

			const ENTITY_ENDERMAN_SCREAM: org.bukkit.Sound;

			const ENTITY_ENDERMAN_STARE: org.bukkit.Sound;

			const ENTITY_ENDERMAN_TELEPORT: org.bukkit.Sound;

			const ENTITY_ENDERMITE_AMBIENT: org.bukkit.Sound;

			const ENTITY_ENDERMITE_DEATH: org.bukkit.Sound;

			const ENTITY_ENDERMITE_HURT: org.bukkit.Sound;

			const ENTITY_ENDERMITE_STEP: org.bukkit.Sound;

			const ENTITY_ENDER_DRAGON_AMBIENT: org.bukkit.Sound;

			const ENTITY_ENDER_DRAGON_DEATH: org.bukkit.Sound;

			const ENTITY_ENDER_DRAGON_FLAP: org.bukkit.Sound;

			const ENTITY_ENDER_DRAGON_GROWL: org.bukkit.Sound;

			const ENTITY_ENDER_DRAGON_HURT: org.bukkit.Sound;

			const ENTITY_ENDER_DRAGON_SHOOT: org.bukkit.Sound;

			const ENTITY_ENDER_EYE_DEATH: org.bukkit.Sound;

			const ENTITY_ENDER_EYE_LAUNCH: org.bukkit.Sound;

			const ENTITY_ENDER_PEARL_THROW: org.bukkit.Sound;

			const ENTITY_EVOKER_AMBIENT: org.bukkit.Sound;

			const ENTITY_EVOKER_CAST_SPELL: org.bukkit.Sound;

			const ENTITY_EVOKER_CELEBRATE: org.bukkit.Sound;

			const ENTITY_EVOKER_DEATH: org.bukkit.Sound;

			const ENTITY_EVOKER_FANGS_ATTACK: org.bukkit.Sound;

			const ENTITY_EVOKER_HURT: org.bukkit.Sound;

			const ENTITY_EVOKER_PREPARE_ATTACK: org.bukkit.Sound;

			const ENTITY_EVOKER_PREPARE_SUMMON: org.bukkit.Sound;

			const ENTITY_EVOKER_PREPARE_WOLOLO: org.bukkit.Sound;

			const ENTITY_EXPERIENCE_BOTTLE_THROW: org.bukkit.Sound;

			const ENTITY_EXPERIENCE_ORB_PICKUP: org.bukkit.Sound;

			const ENTITY_FIREWORK_ROCKET_BLAST: org.bukkit.Sound;

			const ENTITY_FIREWORK_ROCKET_BLAST_FAR: org.bukkit.Sound;

			const ENTITY_FIREWORK_ROCKET_LARGE_BLAST: org.bukkit.Sound;

			const ENTITY_FIREWORK_ROCKET_LARGE_BLAST_FAR: org.bukkit.Sound;

			const ENTITY_FIREWORK_ROCKET_LAUNCH: org.bukkit.Sound;

			const ENTITY_FIREWORK_ROCKET_SHOOT: org.bukkit.Sound;

			const ENTITY_FIREWORK_ROCKET_TWINKLE: org.bukkit.Sound;

			const ENTITY_FIREWORK_ROCKET_TWINKLE_FAR: org.bukkit.Sound;

			const ENTITY_FISHING_BOBBER_RETRIEVE: org.bukkit.Sound;

			const ENTITY_FISHING_BOBBER_SPLASH: org.bukkit.Sound;

			const ENTITY_FISHING_BOBBER_THROW: org.bukkit.Sound;

			const ENTITY_FISH_SWIM: org.bukkit.Sound;

			const ENTITY_FOX_AGGRO: org.bukkit.Sound;

			const ENTITY_FOX_AMBIENT: org.bukkit.Sound;

			const ENTITY_FOX_BITE: org.bukkit.Sound;

			const ENTITY_FOX_DEATH: org.bukkit.Sound;

			const ENTITY_FOX_EAT: org.bukkit.Sound;

			const ENTITY_FOX_HURT: org.bukkit.Sound;

			const ENTITY_FOX_SCREECH: org.bukkit.Sound;

			const ENTITY_FOX_SLEEP: org.bukkit.Sound;

			const ENTITY_FOX_SNIFF: org.bukkit.Sound;

			const ENTITY_FOX_SPIT: org.bukkit.Sound;

			const ENTITY_FOX_TELEPORT: org.bukkit.Sound;

			const ENTITY_FROG_AMBIENT: org.bukkit.Sound;

			const ENTITY_FROG_DEATH: org.bukkit.Sound;

			const ENTITY_FROG_EAT: org.bukkit.Sound;

			const ENTITY_FROG_HURT: org.bukkit.Sound;

			const ENTITY_FROG_LAY_SPAWN: org.bukkit.Sound;

			const ENTITY_FROG_LONG_JUMP: org.bukkit.Sound;

			const ENTITY_FROG_STEP: org.bukkit.Sound;

			const ENTITY_FROG_TONGUE: org.bukkit.Sound;

			const ENTITY_GENERIC_BIG_FALL: org.bukkit.Sound;

			const ENTITY_GENERIC_BURN: org.bukkit.Sound;

			const ENTITY_GENERIC_DEATH: org.bukkit.Sound;

			const ENTITY_GENERIC_DRINK: org.bukkit.Sound;

			const ENTITY_GENERIC_EAT: org.bukkit.Sound;

			const ENTITY_GENERIC_EXPLODE: org.bukkit.Sound;

			const ENTITY_GENERIC_EXTINGUISH_FIRE: org.bukkit.Sound;

			const ENTITY_GENERIC_HURT: org.bukkit.Sound;

			const ENTITY_GENERIC_SMALL_FALL: org.bukkit.Sound;

			const ENTITY_GENERIC_SPLASH: org.bukkit.Sound;

			const ENTITY_GENERIC_SWIM: org.bukkit.Sound;

			const ENTITY_GHAST_AMBIENT: org.bukkit.Sound;

			const ENTITY_GHAST_DEATH: org.bukkit.Sound;

			const ENTITY_GHAST_HURT: org.bukkit.Sound;

			const ENTITY_GHAST_SCREAM: org.bukkit.Sound;

			const ENTITY_GHAST_SHOOT: org.bukkit.Sound;

			const ENTITY_GHAST_WARN: org.bukkit.Sound;

			const ENTITY_GLOW_ITEM_FRAME_ADD_ITEM: org.bukkit.Sound;

			const ENTITY_GLOW_ITEM_FRAME_BREAK: org.bukkit.Sound;

			const ENTITY_GLOW_ITEM_FRAME_PLACE: org.bukkit.Sound;

			const ENTITY_GLOW_ITEM_FRAME_REMOVE_ITEM: org.bukkit.Sound;

			const ENTITY_GLOW_ITEM_FRAME_ROTATE_ITEM: org.bukkit.Sound;

			const ENTITY_GLOW_SQUID_AMBIENT: org.bukkit.Sound;

			const ENTITY_GLOW_SQUID_DEATH: org.bukkit.Sound;

			const ENTITY_GLOW_SQUID_HURT: org.bukkit.Sound;

			const ENTITY_GLOW_SQUID_SQUIRT: org.bukkit.Sound;

			const ENTITY_GOAT_AMBIENT: org.bukkit.Sound;

			const ENTITY_GOAT_DEATH: org.bukkit.Sound;

			const ENTITY_GOAT_EAT: org.bukkit.Sound;

			const ENTITY_GOAT_HORN_BREAK: org.bukkit.Sound;

			const ENTITY_GOAT_HURT: org.bukkit.Sound;

			const ENTITY_GOAT_LONG_JUMP: org.bukkit.Sound;

			const ENTITY_GOAT_MILK: org.bukkit.Sound;

			const ENTITY_GOAT_PREPARE_RAM: org.bukkit.Sound;

			const ENTITY_GOAT_RAM_IMPACT: org.bukkit.Sound;

			const ENTITY_GOAT_SCREAMING_AMBIENT: org.bukkit.Sound;

			const ENTITY_GOAT_SCREAMING_DEATH: org.bukkit.Sound;

			const ENTITY_GOAT_SCREAMING_EAT: org.bukkit.Sound;

			const ENTITY_GOAT_SCREAMING_HORN_BREAK: org.bukkit.Sound;

			const ENTITY_GOAT_SCREAMING_HURT: org.bukkit.Sound;

			const ENTITY_GOAT_SCREAMING_LONG_JUMP: org.bukkit.Sound;

			const ENTITY_GOAT_SCREAMING_MILK: org.bukkit.Sound;

			const ENTITY_GOAT_SCREAMING_PREPARE_RAM: org.bukkit.Sound;

			const ENTITY_GOAT_SCREAMING_RAM_IMPACT: org.bukkit.Sound;

			const ENTITY_GOAT_STEP: org.bukkit.Sound;

			const ENTITY_GUARDIAN_AMBIENT: org.bukkit.Sound;

			const ENTITY_GUARDIAN_AMBIENT_LAND: org.bukkit.Sound;

			const ENTITY_GUARDIAN_ATTACK: org.bukkit.Sound;

			const ENTITY_GUARDIAN_DEATH: org.bukkit.Sound;

			const ENTITY_GUARDIAN_DEATH_LAND: org.bukkit.Sound;

			const ENTITY_GUARDIAN_FLOP: org.bukkit.Sound;

			const ENTITY_GUARDIAN_HURT: org.bukkit.Sound;

			const ENTITY_GUARDIAN_HURT_LAND: org.bukkit.Sound;

			const ENTITY_HOGLIN_AMBIENT: org.bukkit.Sound;

			const ENTITY_HOGLIN_ANGRY: org.bukkit.Sound;

			const ENTITY_HOGLIN_ATTACK: org.bukkit.Sound;

			const ENTITY_HOGLIN_CONVERTED_TO_ZOMBIFIED: org.bukkit.Sound;

			const ENTITY_HOGLIN_DEATH: org.bukkit.Sound;

			const ENTITY_HOGLIN_HURT: org.bukkit.Sound;

			const ENTITY_HOGLIN_RETREAT: org.bukkit.Sound;

			const ENTITY_HOGLIN_STEP: org.bukkit.Sound;

			const ENTITY_HORSE_AMBIENT: org.bukkit.Sound;

			const ENTITY_HORSE_ANGRY: org.bukkit.Sound;

			const ENTITY_HORSE_ARMOR: org.bukkit.Sound;

			const ENTITY_HORSE_BREATHE: org.bukkit.Sound;

			const ENTITY_HORSE_DEATH: org.bukkit.Sound;

			const ENTITY_HORSE_EAT: org.bukkit.Sound;

			const ENTITY_HORSE_GALLOP: org.bukkit.Sound;

			const ENTITY_HORSE_HURT: org.bukkit.Sound;

			const ENTITY_HORSE_JUMP: org.bukkit.Sound;

			const ENTITY_HORSE_LAND: org.bukkit.Sound;

			const ENTITY_HORSE_SADDLE: org.bukkit.Sound;

			const ENTITY_HORSE_STEP: org.bukkit.Sound;

			const ENTITY_HORSE_STEP_WOOD: org.bukkit.Sound;

			const ENTITY_HOSTILE_BIG_FALL: org.bukkit.Sound;

			const ENTITY_HOSTILE_DEATH: org.bukkit.Sound;

			const ENTITY_HOSTILE_HURT: org.bukkit.Sound;

			const ENTITY_HOSTILE_SMALL_FALL: org.bukkit.Sound;

			const ENTITY_HOSTILE_SPLASH: org.bukkit.Sound;

			const ENTITY_HOSTILE_SWIM: org.bukkit.Sound;

			const ENTITY_HUSK_AMBIENT: org.bukkit.Sound;

			const ENTITY_HUSK_CONVERTED_TO_ZOMBIE: org.bukkit.Sound;

			const ENTITY_HUSK_DEATH: org.bukkit.Sound;

			const ENTITY_HUSK_HURT: org.bukkit.Sound;

			const ENTITY_HUSK_STEP: org.bukkit.Sound;

			const ENTITY_ILLUSIONER_AMBIENT: org.bukkit.Sound;

			const ENTITY_ILLUSIONER_CAST_SPELL: org.bukkit.Sound;

			const ENTITY_ILLUSIONER_DEATH: org.bukkit.Sound;

			const ENTITY_ILLUSIONER_HURT: org.bukkit.Sound;

			const ENTITY_ILLUSIONER_MIRROR_MOVE: org.bukkit.Sound;

			const ENTITY_ILLUSIONER_PREPARE_BLINDNESS: org.bukkit.Sound;

			const ENTITY_ILLUSIONER_PREPARE_MIRROR: org.bukkit.Sound;

			const ENTITY_IRON_GOLEM_ATTACK: org.bukkit.Sound;

			const ENTITY_IRON_GOLEM_DAMAGE: org.bukkit.Sound;

			const ENTITY_IRON_GOLEM_DEATH: org.bukkit.Sound;

			const ENTITY_IRON_GOLEM_HURT: org.bukkit.Sound;

			const ENTITY_IRON_GOLEM_REPAIR: org.bukkit.Sound;

			const ENTITY_IRON_GOLEM_STEP: org.bukkit.Sound;

			const ENTITY_ITEM_BREAK: org.bukkit.Sound;

			const ENTITY_ITEM_FRAME_ADD_ITEM: org.bukkit.Sound;

			const ENTITY_ITEM_FRAME_BREAK: org.bukkit.Sound;

			const ENTITY_ITEM_FRAME_PLACE: org.bukkit.Sound;

			const ENTITY_ITEM_FRAME_REMOVE_ITEM: org.bukkit.Sound;

			const ENTITY_ITEM_FRAME_ROTATE_ITEM: org.bukkit.Sound;

			const ENTITY_ITEM_PICKUP: org.bukkit.Sound;

			const ENTITY_LEASH_KNOT_BREAK: org.bukkit.Sound;

			const ENTITY_LEASH_KNOT_PLACE: org.bukkit.Sound;

			const ENTITY_LIGHTNING_BOLT_IMPACT: org.bukkit.Sound;

			const ENTITY_LIGHTNING_BOLT_THUNDER: org.bukkit.Sound;

			const ENTITY_LINGERING_POTION_THROW: org.bukkit.Sound;

			const ENTITY_LLAMA_AMBIENT: org.bukkit.Sound;

			const ENTITY_LLAMA_ANGRY: org.bukkit.Sound;

			const ENTITY_LLAMA_CHEST: org.bukkit.Sound;

			const ENTITY_LLAMA_DEATH: org.bukkit.Sound;

			const ENTITY_LLAMA_EAT: org.bukkit.Sound;

			const ENTITY_LLAMA_HURT: org.bukkit.Sound;

			const ENTITY_LLAMA_SPIT: org.bukkit.Sound;

			const ENTITY_LLAMA_STEP: org.bukkit.Sound;

			const ENTITY_LLAMA_SWAG: org.bukkit.Sound;

			const ENTITY_MAGMA_CUBE_DEATH: org.bukkit.Sound;

			const ENTITY_MAGMA_CUBE_DEATH_SMALL: org.bukkit.Sound;

			const ENTITY_MAGMA_CUBE_HURT: org.bukkit.Sound;

			const ENTITY_MAGMA_CUBE_HURT_SMALL: org.bukkit.Sound;

			const ENTITY_MAGMA_CUBE_JUMP: org.bukkit.Sound;

			const ENTITY_MAGMA_CUBE_SQUISH: org.bukkit.Sound;

			const ENTITY_MAGMA_CUBE_SQUISH_SMALL: org.bukkit.Sound;

			const ENTITY_MINECART_INSIDE: org.bukkit.Sound;

			const ENTITY_MINECART_INSIDE_UNDERWATER: org.bukkit.Sound;

			const ENTITY_MINECART_RIDING: org.bukkit.Sound;

			const ENTITY_MOOSHROOM_CONVERT: org.bukkit.Sound;

			const ENTITY_MOOSHROOM_EAT: org.bukkit.Sound;

			const ENTITY_MOOSHROOM_MILK: org.bukkit.Sound;

			const ENTITY_MOOSHROOM_SHEAR: org.bukkit.Sound;

			const ENTITY_MOOSHROOM_SUSPICIOUS_MILK: org.bukkit.Sound;

			const ENTITY_MULE_AMBIENT: org.bukkit.Sound;

			const ENTITY_MULE_ANGRY: org.bukkit.Sound;

			const ENTITY_MULE_CHEST: org.bukkit.Sound;

			const ENTITY_MULE_DEATH: org.bukkit.Sound;

			const ENTITY_MULE_EAT: org.bukkit.Sound;

			const ENTITY_MULE_HURT: org.bukkit.Sound;

			const ENTITY_MULE_JUMP: org.bukkit.Sound;

			const ENTITY_OCELOT_AMBIENT: org.bukkit.Sound;

			const ENTITY_OCELOT_DEATH: org.bukkit.Sound;

			const ENTITY_OCELOT_HURT: org.bukkit.Sound;

			const ENTITY_PAINTING_BREAK: org.bukkit.Sound;

			const ENTITY_PAINTING_PLACE: org.bukkit.Sound;

			const ENTITY_PANDA_AGGRESSIVE_AMBIENT: org.bukkit.Sound;

			const ENTITY_PANDA_AMBIENT: org.bukkit.Sound;

			const ENTITY_PANDA_BITE: org.bukkit.Sound;

			const ENTITY_PANDA_CANT_BREED: org.bukkit.Sound;

			const ENTITY_PANDA_DEATH: org.bukkit.Sound;

			const ENTITY_PANDA_EAT: org.bukkit.Sound;

			const ENTITY_PANDA_HURT: org.bukkit.Sound;

			const ENTITY_PANDA_PRE_SNEEZE: org.bukkit.Sound;

			const ENTITY_PANDA_SNEEZE: org.bukkit.Sound;

			const ENTITY_PANDA_STEP: org.bukkit.Sound;

			const ENTITY_PANDA_WORRIED_AMBIENT: org.bukkit.Sound;

			const ENTITY_PARROT_AMBIENT: org.bukkit.Sound;

			const ENTITY_PARROT_DEATH: org.bukkit.Sound;

			const ENTITY_PARROT_EAT: org.bukkit.Sound;

			const ENTITY_PARROT_FLY: org.bukkit.Sound;

			const ENTITY_PARROT_HURT: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_BLAZE: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_BOGGED: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_BREEZE: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_CREEPER: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_DROWNED: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_ELDER_GUARDIAN: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_ENDERMITE: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_ENDER_DRAGON: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_EVOKER: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_GHAST: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_GUARDIAN: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_HOGLIN: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_HUSK: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_ILLUSIONER: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_MAGMA_CUBE: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_PHANTOM: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_PIGLIN: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_PIGLIN_BRUTE: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_PILLAGER: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_RAVAGER: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_SHULKER: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_SILVERFISH: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_SKELETON: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_SLIME: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_SPIDER: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_STRAY: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_VEX: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_VINDICATOR: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_WARDEN: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_WITCH: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_WITHER: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_WITHER_SKELETON: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_ZOGLIN: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_ZOMBIE: org.bukkit.Sound;

			const ENTITY_PARROT_IMITATE_ZOMBIE_VILLAGER: org.bukkit.Sound;

			const ENTITY_PARROT_STEP: org.bukkit.Sound;

			const ENTITY_PHANTOM_AMBIENT: org.bukkit.Sound;

			const ENTITY_PHANTOM_BITE: org.bukkit.Sound;

			const ENTITY_PHANTOM_DEATH: org.bukkit.Sound;

			const ENTITY_PHANTOM_FLAP: org.bukkit.Sound;

			const ENTITY_PHANTOM_HURT: org.bukkit.Sound;

			const ENTITY_PHANTOM_SWOOP: org.bukkit.Sound;

			const ENTITY_PIGLIN_ADMIRING_ITEM: org.bukkit.Sound;

			const ENTITY_PIGLIN_AMBIENT: org.bukkit.Sound;

			const ENTITY_PIGLIN_ANGRY: org.bukkit.Sound;

			const ENTITY_PIGLIN_BRUTE_AMBIENT: org.bukkit.Sound;

			const ENTITY_PIGLIN_BRUTE_ANGRY: org.bukkit.Sound;

			const ENTITY_PIGLIN_BRUTE_CONVERTED_TO_ZOMBIFIED: org.bukkit.Sound;

			const ENTITY_PIGLIN_BRUTE_DEATH: org.bukkit.Sound;

			const ENTITY_PIGLIN_BRUTE_HURT: org.bukkit.Sound;

			const ENTITY_PIGLIN_BRUTE_STEP: org.bukkit.Sound;

			const ENTITY_PIGLIN_CELEBRATE: org.bukkit.Sound;

			const ENTITY_PIGLIN_CONVERTED_TO_ZOMBIFIED: org.bukkit.Sound;

			const ENTITY_PIGLIN_DEATH: org.bukkit.Sound;

			const ENTITY_PIGLIN_HURT: org.bukkit.Sound;

			const ENTITY_PIGLIN_JEALOUS: org.bukkit.Sound;

			const ENTITY_PIGLIN_RETREAT: org.bukkit.Sound;

			const ENTITY_PIGLIN_STEP: org.bukkit.Sound;

			const ENTITY_PIG_AMBIENT: org.bukkit.Sound;

			const ENTITY_PIG_DEATH: org.bukkit.Sound;

			const ENTITY_PIG_HURT: org.bukkit.Sound;

			const ENTITY_PIG_SADDLE: org.bukkit.Sound;

			const ENTITY_PIG_STEP: org.bukkit.Sound;

			const ENTITY_PILLAGER_AMBIENT: org.bukkit.Sound;

			const ENTITY_PILLAGER_CELEBRATE: org.bukkit.Sound;

			const ENTITY_PILLAGER_DEATH: org.bukkit.Sound;

			const ENTITY_PILLAGER_HURT: org.bukkit.Sound;

			const ENTITY_PLAYER_ATTACK_CRIT: org.bukkit.Sound;

			const ENTITY_PLAYER_ATTACK_KNOCKBACK: org.bukkit.Sound;

			const ENTITY_PLAYER_ATTACK_NODAMAGE: org.bukkit.Sound;

			const ENTITY_PLAYER_ATTACK_STRONG: org.bukkit.Sound;

			const ENTITY_PLAYER_ATTACK_SWEEP: org.bukkit.Sound;

			const ENTITY_PLAYER_ATTACK_WEAK: org.bukkit.Sound;

			const ENTITY_PLAYER_BIG_FALL: org.bukkit.Sound;

			const ENTITY_PLAYER_BREATH: org.bukkit.Sound;

			const ENTITY_PLAYER_BURP: org.bukkit.Sound;

			const ENTITY_PLAYER_DEATH: org.bukkit.Sound;

			const ENTITY_PLAYER_HURT: org.bukkit.Sound;

			const ENTITY_PLAYER_HURT_DROWN: org.bukkit.Sound;

			const ENTITY_PLAYER_HURT_FREEZE: org.bukkit.Sound;

			const ENTITY_PLAYER_HURT_ON_FIRE: org.bukkit.Sound;

			const ENTITY_PLAYER_HURT_SWEET_BERRY_BUSH: org.bukkit.Sound;

			const ENTITY_PLAYER_LEVELUP: org.bukkit.Sound;

			const ENTITY_PLAYER_SMALL_FALL: org.bukkit.Sound;

			const ENTITY_PLAYER_SPLASH: org.bukkit.Sound;

			const ENTITY_PLAYER_SPLASH_HIGH_SPEED: org.bukkit.Sound;

			const ENTITY_PLAYER_SWIM: org.bukkit.Sound;

			const ENTITY_PLAYER_TELEPORT: org.bukkit.Sound;

			const ENTITY_POLAR_BEAR_AMBIENT: org.bukkit.Sound;

			const ENTITY_POLAR_BEAR_AMBIENT_BABY: org.bukkit.Sound;

			const ENTITY_POLAR_BEAR_DEATH: org.bukkit.Sound;

			const ENTITY_POLAR_BEAR_HURT: org.bukkit.Sound;

			const ENTITY_POLAR_BEAR_STEP: org.bukkit.Sound;

			const ENTITY_POLAR_BEAR_WARNING: org.bukkit.Sound;

			const ENTITY_PUFFER_FISH_AMBIENT: org.bukkit.Sound;

			const ENTITY_PUFFER_FISH_BLOW_OUT: org.bukkit.Sound;

			const ENTITY_PUFFER_FISH_BLOW_UP: org.bukkit.Sound;

			const ENTITY_PUFFER_FISH_DEATH: org.bukkit.Sound;

			const ENTITY_PUFFER_FISH_FLOP: org.bukkit.Sound;

			const ENTITY_PUFFER_FISH_HURT: org.bukkit.Sound;

			const ENTITY_PUFFER_FISH_STING: org.bukkit.Sound;

			const ENTITY_RABBIT_AMBIENT: org.bukkit.Sound;

			const ENTITY_RABBIT_ATTACK: org.bukkit.Sound;

			const ENTITY_RABBIT_DEATH: org.bukkit.Sound;

			const ENTITY_RABBIT_HURT: org.bukkit.Sound;

			const ENTITY_RABBIT_JUMP: org.bukkit.Sound;

			const ENTITY_RAVAGER_AMBIENT: org.bukkit.Sound;

			const ENTITY_RAVAGER_ATTACK: org.bukkit.Sound;

			const ENTITY_RAVAGER_CELEBRATE: org.bukkit.Sound;

			const ENTITY_RAVAGER_DEATH: org.bukkit.Sound;

			const ENTITY_RAVAGER_HURT: org.bukkit.Sound;

			const ENTITY_RAVAGER_ROAR: org.bukkit.Sound;

			const ENTITY_RAVAGER_STEP: org.bukkit.Sound;

			const ENTITY_RAVAGER_STUNNED: org.bukkit.Sound;

			const ENTITY_SALMON_AMBIENT: org.bukkit.Sound;

			const ENTITY_SALMON_DEATH: org.bukkit.Sound;

			const ENTITY_SALMON_FLOP: org.bukkit.Sound;

			const ENTITY_SALMON_HURT: org.bukkit.Sound;

			const ENTITY_SHEEP_AMBIENT: org.bukkit.Sound;

			const ENTITY_SHEEP_DEATH: org.bukkit.Sound;

			const ENTITY_SHEEP_HURT: org.bukkit.Sound;

			const ENTITY_SHEEP_SHEAR: org.bukkit.Sound;

			const ENTITY_SHEEP_STEP: org.bukkit.Sound;

			const ENTITY_SHULKER_AMBIENT: org.bukkit.Sound;

			const ENTITY_SHULKER_BULLET_HIT: org.bukkit.Sound;

			const ENTITY_SHULKER_BULLET_HURT: org.bukkit.Sound;

			const ENTITY_SHULKER_CLOSE: org.bukkit.Sound;

			const ENTITY_SHULKER_DEATH: org.bukkit.Sound;

			const ENTITY_SHULKER_HURT: org.bukkit.Sound;

			const ENTITY_SHULKER_HURT_CLOSED: org.bukkit.Sound;

			const ENTITY_SHULKER_OPEN: org.bukkit.Sound;

			const ENTITY_SHULKER_SHOOT: org.bukkit.Sound;

			const ENTITY_SHULKER_TELEPORT: org.bukkit.Sound;

			const ENTITY_SILVERFISH_AMBIENT: org.bukkit.Sound;

			const ENTITY_SILVERFISH_DEATH: org.bukkit.Sound;

			const ENTITY_SILVERFISH_HURT: org.bukkit.Sound;

			const ENTITY_SILVERFISH_STEP: org.bukkit.Sound;

			const ENTITY_SKELETON_AMBIENT: org.bukkit.Sound;

			const ENTITY_SKELETON_CONVERTED_TO_STRAY: org.bukkit.Sound;

			const ENTITY_SKELETON_DEATH: org.bukkit.Sound;

			const ENTITY_SKELETON_HORSE_AMBIENT: org.bukkit.Sound;

			const ENTITY_SKELETON_HORSE_AMBIENT_WATER: org.bukkit.Sound;

			const ENTITY_SKELETON_HORSE_DEATH: org.bukkit.Sound;

			const ENTITY_SKELETON_HORSE_GALLOP_WATER: org.bukkit.Sound;

			const ENTITY_SKELETON_HORSE_HURT: org.bukkit.Sound;

			const ENTITY_SKELETON_HORSE_JUMP_WATER: org.bukkit.Sound;

			const ENTITY_SKELETON_HORSE_STEP_WATER: org.bukkit.Sound;

			const ENTITY_SKELETON_HORSE_SWIM: org.bukkit.Sound;

			const ENTITY_SKELETON_HURT: org.bukkit.Sound;

			const ENTITY_SKELETON_SHOOT: org.bukkit.Sound;

			const ENTITY_SKELETON_STEP: org.bukkit.Sound;

			const ENTITY_SLIME_ATTACK: org.bukkit.Sound;

			const ENTITY_SLIME_DEATH: org.bukkit.Sound;

			const ENTITY_SLIME_DEATH_SMALL: org.bukkit.Sound;

			const ENTITY_SLIME_HURT: org.bukkit.Sound;

			const ENTITY_SLIME_HURT_SMALL: org.bukkit.Sound;

			const ENTITY_SLIME_JUMP: org.bukkit.Sound;

			const ENTITY_SLIME_JUMP_SMALL: org.bukkit.Sound;

			const ENTITY_SLIME_SQUISH: org.bukkit.Sound;

			const ENTITY_SLIME_SQUISH_SMALL: org.bukkit.Sound;

			const ENTITY_SNIFFER_DEATH: org.bukkit.Sound;

			const ENTITY_SNIFFER_DIGGING: org.bukkit.Sound;

			const ENTITY_SNIFFER_DIGGING_STOP: org.bukkit.Sound;

			const ENTITY_SNIFFER_DROP_SEED: org.bukkit.Sound;

			const ENTITY_SNIFFER_EAT: org.bukkit.Sound;

			const ENTITY_SNIFFER_HAPPY: org.bukkit.Sound;

			const ENTITY_SNIFFER_HURT: org.bukkit.Sound;

			const ENTITY_SNIFFER_IDLE: org.bukkit.Sound;

			const ENTITY_SNIFFER_SCENTING: org.bukkit.Sound;

			const ENTITY_SNIFFER_SEARCHING: org.bukkit.Sound;

			const ENTITY_SNIFFER_SNIFFING: org.bukkit.Sound;

			const ENTITY_SNIFFER_STEP: org.bukkit.Sound;

			const ENTITY_SNOWBALL_THROW: org.bukkit.Sound;

			const ENTITY_SNOW_GOLEM_AMBIENT: org.bukkit.Sound;

			const ENTITY_SNOW_GOLEM_DEATH: org.bukkit.Sound;

			const ENTITY_SNOW_GOLEM_HURT: org.bukkit.Sound;

			const ENTITY_SNOW_GOLEM_SHEAR: org.bukkit.Sound;

			const ENTITY_SNOW_GOLEM_SHOOT: org.bukkit.Sound;

			const ENTITY_SPIDER_AMBIENT: org.bukkit.Sound;

			const ENTITY_SPIDER_DEATH: org.bukkit.Sound;

			const ENTITY_SPIDER_HURT: org.bukkit.Sound;

			const ENTITY_SPIDER_STEP: org.bukkit.Sound;

			const ENTITY_SPLASH_POTION_BREAK: org.bukkit.Sound;

			const ENTITY_SPLASH_POTION_THROW: org.bukkit.Sound;

			const ENTITY_SQUID_AMBIENT: org.bukkit.Sound;

			const ENTITY_SQUID_DEATH: org.bukkit.Sound;

			const ENTITY_SQUID_HURT: org.bukkit.Sound;

			const ENTITY_SQUID_SQUIRT: org.bukkit.Sound;

			const ENTITY_STRAY_AMBIENT: org.bukkit.Sound;

			const ENTITY_STRAY_DEATH: org.bukkit.Sound;

			const ENTITY_STRAY_HURT: org.bukkit.Sound;

			const ENTITY_STRAY_STEP: org.bukkit.Sound;

			const ENTITY_STRIDER_AMBIENT: org.bukkit.Sound;

			const ENTITY_STRIDER_DEATH: org.bukkit.Sound;

			const ENTITY_STRIDER_EAT: org.bukkit.Sound;

			const ENTITY_STRIDER_HAPPY: org.bukkit.Sound;

			const ENTITY_STRIDER_HURT: org.bukkit.Sound;

			const ENTITY_STRIDER_RETREAT: org.bukkit.Sound;

			const ENTITY_STRIDER_SADDLE: org.bukkit.Sound;

			const ENTITY_STRIDER_STEP: org.bukkit.Sound;

			const ENTITY_STRIDER_STEP_LAVA: org.bukkit.Sound;

			const ENTITY_TADPOLE_DEATH: org.bukkit.Sound;

			const ENTITY_TADPOLE_FLOP: org.bukkit.Sound;

			const ENTITY_TADPOLE_GROW_UP: org.bukkit.Sound;

			const ENTITY_TADPOLE_HURT: org.bukkit.Sound;

			const ENTITY_TNT_PRIMED: org.bukkit.Sound;

			const ENTITY_TROPICAL_FISH_AMBIENT: org.bukkit.Sound;

			const ENTITY_TROPICAL_FISH_DEATH: org.bukkit.Sound;

			const ENTITY_TROPICAL_FISH_FLOP: org.bukkit.Sound;

			const ENTITY_TROPICAL_FISH_HURT: org.bukkit.Sound;

			const ENTITY_TURTLE_AMBIENT_LAND: org.bukkit.Sound;

			const ENTITY_TURTLE_DEATH: org.bukkit.Sound;

			const ENTITY_TURTLE_DEATH_BABY: org.bukkit.Sound;

			const ENTITY_TURTLE_EGG_BREAK: org.bukkit.Sound;

			const ENTITY_TURTLE_EGG_CRACK: org.bukkit.Sound;

			const ENTITY_TURTLE_EGG_HATCH: org.bukkit.Sound;

			const ENTITY_TURTLE_HURT: org.bukkit.Sound;

			const ENTITY_TURTLE_HURT_BABY: org.bukkit.Sound;

			const ENTITY_TURTLE_LAY_EGG: org.bukkit.Sound;

			const ENTITY_TURTLE_SHAMBLE: org.bukkit.Sound;

			const ENTITY_TURTLE_SHAMBLE_BABY: org.bukkit.Sound;

			const ENTITY_TURTLE_SWIM: org.bukkit.Sound;

			const ENTITY_VEX_AMBIENT: org.bukkit.Sound;

			const ENTITY_VEX_CHARGE: org.bukkit.Sound;

			const ENTITY_VEX_DEATH: org.bukkit.Sound;

			const ENTITY_VEX_HURT: org.bukkit.Sound;

			const ENTITY_VILLAGER_AMBIENT: org.bukkit.Sound;

			const ENTITY_VILLAGER_CELEBRATE: org.bukkit.Sound;

			const ENTITY_VILLAGER_DEATH: org.bukkit.Sound;

			const ENTITY_VILLAGER_HURT: org.bukkit.Sound;

			const ENTITY_VILLAGER_NO: org.bukkit.Sound;

			const ENTITY_VILLAGER_TRADE: org.bukkit.Sound;

			const ENTITY_VILLAGER_WORK_ARMORER: org.bukkit.Sound;

			const ENTITY_VILLAGER_WORK_BUTCHER: org.bukkit.Sound;

			const ENTITY_VILLAGER_WORK_CARTOGRAPHER: org.bukkit.Sound;

			const ENTITY_VILLAGER_WORK_CLERIC: org.bukkit.Sound;

			const ENTITY_VILLAGER_WORK_FARMER: org.bukkit.Sound;

			const ENTITY_VILLAGER_WORK_FISHERMAN: org.bukkit.Sound;

			const ENTITY_VILLAGER_WORK_FLETCHER: org.bukkit.Sound;

			const ENTITY_VILLAGER_WORK_LEATHERWORKER: org.bukkit.Sound;

			const ENTITY_VILLAGER_WORK_LIBRARIAN: org.bukkit.Sound;

			const ENTITY_VILLAGER_WORK_MASON: org.bukkit.Sound;

			const ENTITY_VILLAGER_WORK_SHEPHERD: org.bukkit.Sound;

			const ENTITY_VILLAGER_WORK_TOOLSMITH: org.bukkit.Sound;

			const ENTITY_VILLAGER_WORK_WEAPONSMITH: org.bukkit.Sound;

			const ENTITY_VILLAGER_YES: org.bukkit.Sound;

			const ENTITY_VINDICATOR_AMBIENT: org.bukkit.Sound;

			const ENTITY_VINDICATOR_CELEBRATE: org.bukkit.Sound;

			const ENTITY_VINDICATOR_DEATH: org.bukkit.Sound;

			const ENTITY_VINDICATOR_HURT: org.bukkit.Sound;

			const ENTITY_WANDERING_TRADER_AMBIENT: org.bukkit.Sound;

			const ENTITY_WANDERING_TRADER_DEATH: org.bukkit.Sound;

			const ENTITY_WANDERING_TRADER_DISAPPEARED: org.bukkit.Sound;

			const ENTITY_WANDERING_TRADER_DRINK_MILK: org.bukkit.Sound;

			const ENTITY_WANDERING_TRADER_DRINK_POTION: org.bukkit.Sound;

			const ENTITY_WANDERING_TRADER_HURT: org.bukkit.Sound;

			const ENTITY_WANDERING_TRADER_NO: org.bukkit.Sound;

			const ENTITY_WANDERING_TRADER_REAPPEARED: org.bukkit.Sound;

			const ENTITY_WANDERING_TRADER_TRADE: org.bukkit.Sound;

			const ENTITY_WANDERING_TRADER_YES: org.bukkit.Sound;

			const ENTITY_WARDEN_AGITATED: org.bukkit.Sound;

			const ENTITY_WARDEN_AMBIENT: org.bukkit.Sound;

			const ENTITY_WARDEN_ANGRY: org.bukkit.Sound;

			const ENTITY_WARDEN_ATTACK_IMPACT: org.bukkit.Sound;

			const ENTITY_WARDEN_DEATH: org.bukkit.Sound;

			const ENTITY_WARDEN_DIG: org.bukkit.Sound;

			const ENTITY_WARDEN_EMERGE: org.bukkit.Sound;

			const ENTITY_WARDEN_HEARTBEAT: org.bukkit.Sound;

			const ENTITY_WARDEN_HURT: org.bukkit.Sound;

			const ENTITY_WARDEN_LISTENING: org.bukkit.Sound;

			const ENTITY_WARDEN_LISTENING_ANGRY: org.bukkit.Sound;

			const ENTITY_WARDEN_NEARBY_CLOSE: org.bukkit.Sound;

			const ENTITY_WARDEN_NEARBY_CLOSER: org.bukkit.Sound;

			const ENTITY_WARDEN_NEARBY_CLOSEST: org.bukkit.Sound;

			const ENTITY_WARDEN_ROAR: org.bukkit.Sound;

			const ENTITY_WARDEN_SNIFF: org.bukkit.Sound;

			const ENTITY_WARDEN_SONIC_BOOM: org.bukkit.Sound;

			const ENTITY_WARDEN_SONIC_CHARGE: org.bukkit.Sound;

			const ENTITY_WARDEN_STEP: org.bukkit.Sound;

			const ENTITY_WARDEN_TENDRIL_CLICKS: org.bukkit.Sound;

			const ENTITY_WIND_CHARGE_THROW: org.bukkit.Sound;

			const ENTITY_WIND_CHARGE_WIND_BURST: org.bukkit.Sound;

			const ENTITY_WITCH_AMBIENT: org.bukkit.Sound;

			const ENTITY_WITCH_CELEBRATE: org.bukkit.Sound;

			const ENTITY_WITCH_DEATH: org.bukkit.Sound;

			const ENTITY_WITCH_DRINK: org.bukkit.Sound;

			const ENTITY_WITCH_HURT: org.bukkit.Sound;

			const ENTITY_WITCH_THROW: org.bukkit.Sound;

			const ENTITY_WITHER_AMBIENT: org.bukkit.Sound;

			const ENTITY_WITHER_BREAK_BLOCK: org.bukkit.Sound;

			const ENTITY_WITHER_DEATH: org.bukkit.Sound;

			const ENTITY_WITHER_HURT: org.bukkit.Sound;

			const ENTITY_WITHER_SHOOT: org.bukkit.Sound;

			const ENTITY_WITHER_SKELETON_AMBIENT: org.bukkit.Sound;

			const ENTITY_WITHER_SKELETON_DEATH: org.bukkit.Sound;

			const ENTITY_WITHER_SKELETON_HURT: org.bukkit.Sound;

			const ENTITY_WITHER_SKELETON_STEP: org.bukkit.Sound;

			const ENTITY_WITHER_SPAWN: org.bukkit.Sound;

			const ENTITY_WOLF_AMBIENT: org.bukkit.Sound;

			const ENTITY_WOLF_DEATH: org.bukkit.Sound;

			const ENTITY_WOLF_GROWL: org.bukkit.Sound;

			const ENTITY_WOLF_HOWL: org.bukkit.Sound;

			const ENTITY_WOLF_HURT: org.bukkit.Sound;

			const ENTITY_WOLF_PANT: org.bukkit.Sound;

			const ENTITY_WOLF_SHAKE: org.bukkit.Sound;

			const ENTITY_WOLF_STEP: org.bukkit.Sound;

			const ENTITY_WOLF_WHINE: org.bukkit.Sound;

			const ENTITY_ZOGLIN_AMBIENT: org.bukkit.Sound;

			const ENTITY_ZOGLIN_ANGRY: org.bukkit.Sound;

			const ENTITY_ZOGLIN_ATTACK: org.bukkit.Sound;

			const ENTITY_ZOGLIN_DEATH: org.bukkit.Sound;

			const ENTITY_ZOGLIN_HURT: org.bukkit.Sound;

			const ENTITY_ZOGLIN_STEP: org.bukkit.Sound;

			const ENTITY_ZOMBIE_AMBIENT: org.bukkit.Sound;

			const ENTITY_ZOMBIE_ATTACK_IRON_DOOR: org.bukkit.Sound;

			const ENTITY_ZOMBIE_ATTACK_WOODEN_DOOR: org.bukkit.Sound;

			const ENTITY_ZOMBIE_BREAK_WOODEN_DOOR: org.bukkit.Sound;

			const ENTITY_ZOMBIE_CONVERTED_TO_DROWNED: org.bukkit.Sound;

			const ENTITY_ZOMBIE_DEATH: org.bukkit.Sound;

			const ENTITY_ZOMBIE_DESTROY_EGG: org.bukkit.Sound;

			const ENTITY_ZOMBIE_HORSE_AMBIENT: org.bukkit.Sound;

			const ENTITY_ZOMBIE_HORSE_DEATH: org.bukkit.Sound;

			const ENTITY_ZOMBIE_HORSE_HURT: org.bukkit.Sound;

			const ENTITY_ZOMBIE_HURT: org.bukkit.Sound;

			const ENTITY_ZOMBIE_INFECT: org.bukkit.Sound;

			const ENTITY_ZOMBIE_STEP: org.bukkit.Sound;

			const ENTITY_ZOMBIE_VILLAGER_AMBIENT: org.bukkit.Sound;

			const ENTITY_ZOMBIE_VILLAGER_CONVERTED: org.bukkit.Sound;

			const ENTITY_ZOMBIE_VILLAGER_CURE: org.bukkit.Sound;

			const ENTITY_ZOMBIE_VILLAGER_DEATH: org.bukkit.Sound;

			const ENTITY_ZOMBIE_VILLAGER_HURT: org.bukkit.Sound;

			const ENTITY_ZOMBIE_VILLAGER_STEP: org.bukkit.Sound;

			const ENTITY_ZOMBIFIED_PIGLIN_AMBIENT: org.bukkit.Sound;

			const ENTITY_ZOMBIFIED_PIGLIN_ANGRY: org.bukkit.Sound;

			const ENTITY_ZOMBIFIED_PIGLIN_DEATH: org.bukkit.Sound;

			const ENTITY_ZOMBIFIED_PIGLIN_HURT: org.bukkit.Sound;

			const EVENT_MOB_EFFECT_BAD_OMEN: org.bukkit.Sound;

			const EVENT_MOB_EFFECT_RAID_OMEN: org.bukkit.Sound;

			const EVENT_MOB_EFFECT_TRIAL_OMEN: org.bukkit.Sound;

			const EVENT_RAID_HORN: org.bukkit.Sound;

			const INTENTIONALLY_EMPTY: org.bukkit.Sound;

			const ITEM_ARMOR_EQUIP_CHAIN: org.bukkit.Sound;

			const ITEM_ARMOR_EQUIP_DIAMOND: org.bukkit.Sound;

			const ITEM_ARMOR_EQUIP_ELYTRA: org.bukkit.Sound;

			const ITEM_ARMOR_EQUIP_GENERIC: org.bukkit.Sound;

			const ITEM_ARMOR_EQUIP_GOLD: org.bukkit.Sound;

			const ITEM_ARMOR_EQUIP_IRON: org.bukkit.Sound;

			const ITEM_ARMOR_EQUIP_LEATHER: org.bukkit.Sound;

			const ITEM_ARMOR_EQUIP_NETHERITE: org.bukkit.Sound;

			const ITEM_ARMOR_EQUIP_TURTLE: org.bukkit.Sound;

			const ITEM_ARMOR_EQUIP_WOLF: org.bukkit.Sound;

			const ITEM_ARMOR_UNEQUIP_WOLF: org.bukkit.Sound;

			const ITEM_AXE_SCRAPE: org.bukkit.Sound;

			const ITEM_AXE_STRIP: org.bukkit.Sound;

			const ITEM_AXE_WAX_OFF: org.bukkit.Sound;

			const ITEM_BONE_MEAL_USE: org.bukkit.Sound;

			const ITEM_BOOK_PAGE_TURN: org.bukkit.Sound;

			const ITEM_BOOK_PUT: org.bukkit.Sound;

			const ITEM_BOTTLE_EMPTY: org.bukkit.Sound;

			const ITEM_BOTTLE_FILL: org.bukkit.Sound;

			const ITEM_BOTTLE_FILL_DRAGONBREATH: org.bukkit.Sound;

			const ITEM_BRUSH_BRUSHING_GENERIC: org.bukkit.Sound;

			const ITEM_BRUSH_BRUSHING_GRAVEL: org.bukkit.Sound;

			const ITEM_BRUSH_BRUSHING_GRAVEL_COMPLETE: org.bukkit.Sound;

			const ITEM_BRUSH_BRUSHING_SAND: org.bukkit.Sound;

			const ITEM_BRUSH_BRUSHING_SAND_COMPLETE: org.bukkit.Sound;

			const ITEM_BUCKET_EMPTY: org.bukkit.Sound;

			const ITEM_BUCKET_EMPTY_AXOLOTL: org.bukkit.Sound;

			const ITEM_BUCKET_EMPTY_FISH: org.bukkit.Sound;

			const ITEM_BUCKET_EMPTY_LAVA: org.bukkit.Sound;

			const ITEM_BUCKET_EMPTY_POWDER_SNOW: org.bukkit.Sound;

			const ITEM_BUCKET_EMPTY_TADPOLE: org.bukkit.Sound;

			const ITEM_BUCKET_FILL: org.bukkit.Sound;

			const ITEM_BUCKET_FILL_AXOLOTL: org.bukkit.Sound;

			const ITEM_BUCKET_FILL_FISH: org.bukkit.Sound;

			const ITEM_BUCKET_FILL_LAVA: org.bukkit.Sound;

			const ITEM_BUCKET_FILL_POWDER_SNOW: org.bukkit.Sound;

			const ITEM_BUCKET_FILL_TADPOLE: org.bukkit.Sound;

			const ITEM_BUNDLE_DROP_CONTENTS: org.bukkit.Sound;

			const ITEM_BUNDLE_INSERT: org.bukkit.Sound;

			const ITEM_BUNDLE_REMOVE_ONE: org.bukkit.Sound;

			const ITEM_CHORUS_FRUIT_TELEPORT: org.bukkit.Sound;

			const ITEM_CROP_PLANT: org.bukkit.Sound;

			const ITEM_CROSSBOW_HIT: org.bukkit.Sound;

			const ITEM_CROSSBOW_LOADING_END: org.bukkit.Sound;

			const ITEM_CROSSBOW_LOADING_MIDDLE: org.bukkit.Sound;

			const ITEM_CROSSBOW_LOADING_START: org.bukkit.Sound;

			const ITEM_CROSSBOW_QUICK_CHARGE_1: org.bukkit.Sound;

			const ITEM_CROSSBOW_QUICK_CHARGE_2: org.bukkit.Sound;

			const ITEM_CROSSBOW_QUICK_CHARGE_3: org.bukkit.Sound;

			const ITEM_CROSSBOW_SHOOT: org.bukkit.Sound;

			const ITEM_DYE_USE: org.bukkit.Sound;

			const ITEM_ELYTRA_FLYING: org.bukkit.Sound;

			const ITEM_FIRECHARGE_USE: org.bukkit.Sound;

			const ITEM_FLINTANDSTEEL_USE: org.bukkit.Sound;

			const ITEM_GLOW_INK_SAC_USE: org.bukkit.Sound;

			const ITEM_GOAT_HORN_PLAY: org.bukkit.Sound;

			const ITEM_GOAT_HORN_SOUND_0: org.bukkit.Sound;

			const ITEM_GOAT_HORN_SOUND_1: org.bukkit.Sound;

			const ITEM_GOAT_HORN_SOUND_2: org.bukkit.Sound;

			const ITEM_GOAT_HORN_SOUND_3: org.bukkit.Sound;

			const ITEM_GOAT_HORN_SOUND_4: org.bukkit.Sound;

			const ITEM_GOAT_HORN_SOUND_5: org.bukkit.Sound;

			const ITEM_GOAT_HORN_SOUND_6: org.bukkit.Sound;

			const ITEM_GOAT_HORN_SOUND_7: org.bukkit.Sound;

			const ITEM_HOE_TILL: org.bukkit.Sound;

			const ITEM_HONEYCOMB_WAX_ON: org.bukkit.Sound;

			const ITEM_HONEY_BOTTLE_DRINK: org.bukkit.Sound;

			const ITEM_INK_SAC_USE: org.bukkit.Sound;

			const ITEM_LODESTONE_COMPASS_LOCK: org.bukkit.Sound;

			const ITEM_MACE_SMASH_AIR: org.bukkit.Sound;

			const ITEM_MACE_SMASH_GROUND: org.bukkit.Sound;

			const ITEM_MACE_SMASH_GROUND_HEAVY: org.bukkit.Sound;

			const ITEM_NETHER_WART_PLANT: org.bukkit.Sound;

			const ITEM_OMINOUS_BOTTLE_DISPOSE: org.bukkit.Sound;

			const ITEM_SHIELD_BLOCK: org.bukkit.Sound;

			const ITEM_SHIELD_BREAK: org.bukkit.Sound;

			const ITEM_SHOVEL_FLATTEN: org.bukkit.Sound;

			const ITEM_SPYGLASS_STOP_USING: org.bukkit.Sound;

			const ITEM_SPYGLASS_USE: org.bukkit.Sound;

			const ITEM_TOTEM_USE: org.bukkit.Sound;

			const ITEM_TRIDENT_HIT: org.bukkit.Sound;

			const ITEM_TRIDENT_HIT_GROUND: org.bukkit.Sound;

			const ITEM_TRIDENT_RETURN: org.bukkit.Sound;

			const ITEM_TRIDENT_RIPTIDE_1: org.bukkit.Sound;

			const ITEM_TRIDENT_RIPTIDE_2: org.bukkit.Sound;

			const ITEM_TRIDENT_RIPTIDE_3: org.bukkit.Sound;

			const ITEM_TRIDENT_THROW: org.bukkit.Sound;

			const ITEM_TRIDENT_THUNDER: org.bukkit.Sound;

			const ITEM_WOLF_ARMOR_BREAK: org.bukkit.Sound;

			const ITEM_WOLF_ARMOR_CRACK: org.bukkit.Sound;

			const ITEM_WOLF_ARMOR_DAMAGE: org.bukkit.Sound;

			const ITEM_WOLF_ARMOR_REPAIR: org.bukkit.Sound;

			const MUSIC_CREATIVE: org.bukkit.Sound;

			const MUSIC_CREDITS: org.bukkit.Sound;

			const MUSIC_DISC_11: org.bukkit.Sound;

			const MUSIC_DISC_13: org.bukkit.Sound;

			const MUSIC_DISC_5: org.bukkit.Sound;

			const MUSIC_DISC_BLOCKS: org.bukkit.Sound;

			const MUSIC_DISC_CAT: org.bukkit.Sound;

			const MUSIC_DISC_CHIRP: org.bukkit.Sound;

			const MUSIC_DISC_CREATOR: org.bukkit.Sound;

			const MUSIC_DISC_CREATOR_MUSIC_BOX: org.bukkit.Sound;

			const MUSIC_DISC_FAR: org.bukkit.Sound;

			const MUSIC_DISC_MALL: org.bukkit.Sound;

			const MUSIC_DISC_MELLOHI: org.bukkit.Sound;

			const MUSIC_DISC_OTHERSIDE: org.bukkit.Sound;

			const MUSIC_DISC_PIGSTEP: org.bukkit.Sound;

			const MUSIC_DISC_PRECIPICE: org.bukkit.Sound;

			const MUSIC_DISC_RELIC: org.bukkit.Sound;

			const MUSIC_DISC_STAL: org.bukkit.Sound;

			const MUSIC_DISC_STRAD: org.bukkit.Sound;

			const MUSIC_DISC_WAIT: org.bukkit.Sound;

			const MUSIC_DISC_WARD: org.bukkit.Sound;

			const MUSIC_DRAGON: org.bukkit.Sound;

			const MUSIC_END: org.bukkit.Sound;

			const MUSIC_GAME: org.bukkit.Sound;

			const MUSIC_MENU: org.bukkit.Sound;

			const MUSIC_NETHER_BASALT_DELTAS: org.bukkit.Sound;

			const MUSIC_NETHER_CRIMSON_FOREST: org.bukkit.Sound;

			const MUSIC_NETHER_NETHER_WASTES: org.bukkit.Sound;

			const MUSIC_NETHER_SOUL_SAND_VALLEY: org.bukkit.Sound;

			const MUSIC_NETHER_WARPED_FOREST: org.bukkit.Sound;

			const MUSIC_OVERWORLD_BADLANDS: org.bukkit.Sound;

			const MUSIC_OVERWORLD_BAMBOO_JUNGLE: org.bukkit.Sound;

			const MUSIC_OVERWORLD_CHERRY_GROVE: org.bukkit.Sound;

			const MUSIC_OVERWORLD_DEEP_DARK: org.bukkit.Sound;

			const MUSIC_OVERWORLD_DESERT: org.bukkit.Sound;

			const MUSIC_OVERWORLD_DRIPSTONE_CAVES: org.bukkit.Sound;

			const MUSIC_OVERWORLD_FLOWER_FOREST: org.bukkit.Sound;

			const MUSIC_OVERWORLD_FOREST: org.bukkit.Sound;

			const MUSIC_OVERWORLD_FROZEN_PEAKS: org.bukkit.Sound;

			const MUSIC_OVERWORLD_GROVE: org.bukkit.Sound;

			const MUSIC_OVERWORLD_JAGGED_PEAKS: org.bukkit.Sound;

			const MUSIC_OVERWORLD_JUNGLE: org.bukkit.Sound;

			const MUSIC_OVERWORLD_LUSH_CAVES: org.bukkit.Sound;

			const MUSIC_OVERWORLD_MEADOW: org.bukkit.Sound;

			const MUSIC_OVERWORLD_OLD_GROWTH_TAIGA: org.bukkit.Sound;

			const MUSIC_OVERWORLD_SNOWY_SLOPES: org.bukkit.Sound;

			const MUSIC_OVERWORLD_SPARSE_JUNGLE: org.bukkit.Sound;

			const MUSIC_OVERWORLD_STONY_PEAKS: org.bukkit.Sound;

			const MUSIC_OVERWORLD_SWAMP: org.bukkit.Sound;

			const MUSIC_UNDER_WATER: org.bukkit.Sound;

			const PARTICLE_SOUL_ESCAPE: org.bukkit.Sound;

			const UI_BUTTON_CLICK: org.bukkit.Sound;

			const UI_CARTOGRAPHY_TABLE_TAKE_RESULT: org.bukkit.Sound;

			const UI_LOOM_SELECT_PATTERN: org.bukkit.Sound;

			const UI_LOOM_TAKE_RESULT: org.bukkit.Sound;

			const UI_STONECUTTER_SELECT_RECIPE: org.bukkit.Sound;

			const UI_STONECUTTER_TAKE_RESULT: org.bukkit.Sound;

			const UI_TOAST_CHALLENGE_COMPLETE: org.bukkit.Sound;

			const UI_TOAST_IN: org.bukkit.Sound;

			const UI_TOAST_OUT: org.bukkit.Sound;

			const WEATHER_RAIN: org.bukkit.Sound;

			const WEATHER_RAIN_ABOVE: org.bukkit.Sound;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.Sound;

		}
		interface SoundCategory {}
		namespace SoundCategory {
			const MASTER: org.bukkit.SoundCategory;

			const MUSIC: org.bukkit.SoundCategory;

			const RECORDS: org.bukkit.SoundCategory;

			const WEATHER: org.bukkit.SoundCategory;

			const BLOCKS: org.bukkit.SoundCategory;

			const HOSTILE: org.bukkit.SoundCategory;

			const NEUTRAL: org.bukkit.SoundCategory;

			const PLAYERS: org.bukkit.SoundCategory;

			const AMBIENT: org.bukkit.SoundCategory;

			const VOICE: org.bukkit.SoundCategory;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.SoundCategory;

		}
		interface SoundGroup {
			/**
			 * Get the volume these sounds are played at.
			 * Note that this volume does not always represent the actual volume
			 * received by the client.
			 */
			getVolume(): number;

			/**
			 * Gets the pitch these sounds are played at.
			 * Note that this pitch does not always represent the actual pitch received
			 * by the client.
			 */
			getPitch(): number;

			/**
			 * Gets the corresponding breaking sound for this group.
			 */
			getBreakSound(): org.bukkit.Sound;

			/**
			 * Gets the corresponding step sound for this group.
			 */
			getStepSound(): org.bukkit.Sound;

			/**
			 * Gets the corresponding place sound for this group.
			 */
			getPlaceSound(): org.bukkit.Sound;

			/**
			 * Gets the corresponding hit sound for this group.
			 */
			getHitSound(): org.bukkit.Sound;

			/**
			 * Gets the corresponding fall sound for this group.
			 */
			getFallSound(): org.bukkit.Sound;

		}
		interface Statistic {
			/**
			 * Gets the type of this statistic.
			 */
			getType(): org.bukkit.Statistic.Type;

			/**
			 * Checks if this is a substatistic.
			 * 
			 * A substatistic exists en masse for each block, item, or entitytype, depending on
			 * getType().
			 * 
			 * This is a redundant method and equivalent to checking
			 * getType() != Type.UNTYPED
			 */
			isSubstatistic(): boolean;

			/**
			 * Checks if this is a substatistic dealing with blocks.
			 * 
			 * This is a redundant method and equivalent to checking
			 * getType() == Type.BLOCK
			 */
			isBlock(): boolean;

			/**
			 * Description copied from interface:Â Keyed
			 */
			getKey(): org.bukkit.NamespacedKey;

		}
		namespace Statistic {
			const DAMAGE_DEALT: org.bukkit.Statistic;

			const DAMAGE_TAKEN: org.bukkit.Statistic;

			const DEATHS: org.bukkit.Statistic;

			const MOB_KILLS: org.bukkit.Statistic;

			const PLAYER_KILLS: org.bukkit.Statistic;

			const FISH_CAUGHT: org.bukkit.Statistic;

			const ANIMALS_BRED: org.bukkit.Statistic;

			const LEAVE_GAME: org.bukkit.Statistic;

			const JUMP: org.bukkit.Statistic;

			const DROP_COUNT: org.bukkit.Statistic;

			const DROP: org.bukkit.Statistic;

			const PICKUP: org.bukkit.Statistic;

			/**
			 * Name is misleading, actually records ticks played.
			 */
			const PLAY_ONE_MINUTE: org.bukkit.Statistic;

			const TOTAL_WORLD_TIME: org.bukkit.Statistic;

			const WALK_ONE_CM: org.bukkit.Statistic;

			const WALK_ON_WATER_ONE_CM: org.bukkit.Statistic;

			const FALL_ONE_CM: org.bukkit.Statistic;

			const SNEAK_TIME: org.bukkit.Statistic;

			const CLIMB_ONE_CM: org.bukkit.Statistic;

			const FLY_ONE_CM: org.bukkit.Statistic;

			const WALK_UNDER_WATER_ONE_CM: org.bukkit.Statistic;

			const MINECART_ONE_CM: org.bukkit.Statistic;

			const BOAT_ONE_CM: org.bukkit.Statistic;

			const PIG_ONE_CM: org.bukkit.Statistic;

			const HORSE_ONE_CM: org.bukkit.Statistic;

			const SPRINT_ONE_CM: org.bukkit.Statistic;

			const CROUCH_ONE_CM: org.bukkit.Statistic;

			const AVIATE_ONE_CM: org.bukkit.Statistic;

			const MINE_BLOCK: org.bukkit.Statistic;

			const USE_ITEM: org.bukkit.Statistic;

			const BREAK_ITEM: org.bukkit.Statistic;

			const CRAFT_ITEM: org.bukkit.Statistic;

			const KILL_ENTITY: org.bukkit.Statistic;

			const ENTITY_KILLED_BY: org.bukkit.Statistic;

			const TIME_SINCE_DEATH: org.bukkit.Statistic;

			const TALKED_TO_VILLAGER: org.bukkit.Statistic;

			const TRADED_WITH_VILLAGER: org.bukkit.Statistic;

			const CAKE_SLICES_EATEN: org.bukkit.Statistic;

			const CAULDRON_FILLED: org.bukkit.Statistic;

			const CAULDRON_USED: org.bukkit.Statistic;

			const ARMOR_CLEANED: org.bukkit.Statistic;

			const BANNER_CLEANED: org.bukkit.Statistic;

			const BREWINGSTAND_INTERACTION: org.bukkit.Statistic;

			const BEACON_INTERACTION: org.bukkit.Statistic;

			const DROPPER_INSPECTED: org.bukkit.Statistic;

			const HOPPER_INSPECTED: org.bukkit.Statistic;

			const DISPENSER_INSPECTED: org.bukkit.Statistic;

			const NOTEBLOCK_PLAYED: org.bukkit.Statistic;

			const NOTEBLOCK_TUNED: org.bukkit.Statistic;

			const FLOWER_POTTED: org.bukkit.Statistic;

			const TRAPPED_CHEST_TRIGGERED: org.bukkit.Statistic;

			const ENDERCHEST_OPENED: org.bukkit.Statistic;

			const ITEM_ENCHANTED: org.bukkit.Statistic;

			const RECORD_PLAYED: org.bukkit.Statistic;

			const FURNACE_INTERACTION: org.bukkit.Statistic;

			const CRAFTING_TABLE_INTERACTION: org.bukkit.Statistic;

			const CHEST_OPENED: org.bukkit.Statistic;

			const SLEEP_IN_BED: org.bukkit.Statistic;

			const SHULKER_BOX_OPENED: org.bukkit.Statistic;

			const TIME_SINCE_REST: org.bukkit.Statistic;

			const SWIM_ONE_CM: org.bukkit.Statistic;

			const DAMAGE_DEALT_ABSORBED: org.bukkit.Statistic;

			const DAMAGE_DEALT_RESISTED: org.bukkit.Statistic;

			const DAMAGE_BLOCKED_BY_SHIELD: org.bukkit.Statistic;

			const DAMAGE_ABSORBED: org.bukkit.Statistic;

			const DAMAGE_RESISTED: org.bukkit.Statistic;

			const CLEAN_SHULKER_BOX: org.bukkit.Statistic;

			const OPEN_BARREL: org.bukkit.Statistic;

			const INTERACT_WITH_BLAST_FURNACE: org.bukkit.Statistic;

			const INTERACT_WITH_SMOKER: org.bukkit.Statistic;

			const INTERACT_WITH_LECTERN: org.bukkit.Statistic;

			const INTERACT_WITH_CAMPFIRE: org.bukkit.Statistic;

			const INTERACT_WITH_CARTOGRAPHY_TABLE: org.bukkit.Statistic;

			const INTERACT_WITH_LOOM: org.bukkit.Statistic;

			const INTERACT_WITH_STONECUTTER: org.bukkit.Statistic;

			const BELL_RING: org.bukkit.Statistic;

			const RAID_TRIGGER: org.bukkit.Statistic;

			const RAID_WIN: org.bukkit.Statistic;

			const INTERACT_WITH_ANVIL: org.bukkit.Statistic;

			const INTERACT_WITH_GRINDSTONE: org.bukkit.Statistic;

			const TARGET_HIT: org.bukkit.Statistic;

			const INTERACT_WITH_SMITHING_TABLE: org.bukkit.Statistic;

			const STRIDER_ONE_CM: org.bukkit.Statistic;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.Statistic;

		}
		namespace Statistic {
			interface Type {}
			namespace Type {
				/**
				 * Statistics of this type do not require a qualifier.
				 */
				const UNTYPED: org.bukkit.Statistic.Type;

				/**
				 * Statistics of this type require an Item Material qualifier.
				 */
				const ITEM: org.bukkit.Statistic.Type;

				/**
				 * Statistics of this type require a Block Material qualifier.
				 */
				const BLOCK: org.bukkit.Statistic.Type;

				/**
				 * Statistics of this type require an EntityType qualifier.
				 */
				const ENTITY: org.bukkit.Statistic.Type;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.Statistic.Type;

			}
		}
		interface StructureType {
			/**
			 * Get the name of this structure. This is case-sensitive when used in
			 * commands.
			 */
			getName(): string;

			/**
			 * Get the MapCursor.Type that this structure can use on maps. If
			 * this is null, this structure will not appear on explorer maps.
			 */
			getMapIcon(): (org.bukkit.map.MapCursor.Type | null);

			equals(other: any): boolean;

			hashCode(): number;

			toString(): string;

			/**
			 * Description copied from interface:Â Keyed
			 */
			getKey(): org.bukkit.NamespacedKey;

		}
		namespace StructureType {
			/**
			 * Mineshafts are underground structures which consist of branching mining
			 * tunnels with wooden supports and broken rails.
			 * 
			 * They are the only place where cave spider spawners and minecarts with
			 * chests can be found naturally.
			 */
			const MINESHAFT: org.bukkit.StructureType;

			/**
			 * Villages are naturally generating structures that form above ground.
			 * 
			 * They are usually generated in desert, plains, taiga, and savanna biomes
			 * and are a site for villager spawns, with whom the player can trade.
			 */
			const VILLAGE: org.bukkit.StructureType;

			/**
			 * Nether fortresses are very large complexes that mainly consist of
			 * netherbricks.
			 * 
			 * They contain blaze spawners, nether wart farms, and loot chests. They are
			 * only generated in the nether dimension.
			 */
			const NETHER_FORTRESS: org.bukkit.StructureType;

			/**
			 * Strongholds are underground structures that consist of many rooms,
			 * libraries, and an end portal room.
			 * 
			 * They can be found using an Material.ENDER_EYE.
			 */
			const STRONGHOLD: org.bukkit.StructureType;

			/**
			 * Jungle pyramids (also known as jungle temples) are found in jungles.
			 * 
			 * They are usually composed of cobblestone and mossy cobblestone. They
			 * consist of three floors, with the bottom floor containing treasure
			 * chests.
			 */
			const JUNGLE_PYRAMID: org.bukkit.StructureType;

			/**
			 * Ocean ruins are clusters of many different blocks that generate
			 * underwater in ocean biomes (as well as on the surface of beaches).
			 * 
			 * They come in my different variations. The cold variants consist primarily
			 * of stone brick, and the warm variants consist of sandstone.
			 */
			const OCEAN_RUIN: org.bukkit.StructureType;

			/**
			 * Desert pyramids (also known as desert temples) are found in deserts.
			 * 
			 * They are usually composed of sandstone and stained terracotta.
			 */
			const DESERT_PYRAMID: org.bukkit.StructureType;

			/**
			 * Igloos are structures that generate in snowy biomes.
			 * 
			 * They consist of the house, as well as a basement.
			 */
			const IGLOO: org.bukkit.StructureType;

			/**
			 * Swamp huts (also known as witch huts) generate in swamp biomes and have
			 * the ability to spawn witches.
			 */
			const SWAMP_HUT: org.bukkit.StructureType;

			/**
			 * Ocean monuments are underwater structures.
			 * 
			 * They are usually composed on all three different prismarine types and sea
			 * lanterns. They are the only place guardians and elder guardians spawn
			 * naturally.
			 */
			const OCEAN_MONUMENT: org.bukkit.StructureType;

			/**
			 * End Cities are tall castle-like structures that generate in the outer
			 * island of the End dimension.
			 * 
			 * They consist primarily of end stone bricks, purpur blocks, and end rods.
			 * They are the only place where shulkers can be found.
			 */
			const END_CITY: org.bukkit.StructureType;

			/**
			 * Mansions (also known as woodland mansions) are massive house structures
			 * that generate in dark forests, containing a wide variety of rooms.
			 * 
			 * They are the only place where evokers, vindicators, and vexes spawn
			 * naturally (but only once)
			 */
			const WOODLAND_MANSION: org.bukkit.StructureType;

			/**
			 * Buried treasure consists of a single chest buried in the beach sand or
			 * gravel, with random loot in it.
			 */
			const BURIED_TREASURE: org.bukkit.StructureType;

			/**
			 * Shipwrecks are structures that generate on the floor of oceans or
			 * beaches.
			 * 
			 * They are made up of wood materials, and contain 1-3 loot chests. They can
			 * generate sideways, upside-down, or upright.
			 */
			const SHIPWRECK: org.bukkit.StructureType;

			/**
			 * Pillager outposts may contain crossbows.
			 */
			const PILLAGER_OUTPOST: org.bukkit.StructureType;

			/**
			 * Nether fossils.
			 */
			const NETHER_FOSSIL: org.bukkit.StructureType;

			/**
			 * Ruined portal.
			 */
			const RUINED_PORTAL: org.bukkit.StructureType;

			/**
			 * Bastion remnant.
			 */
			const BASTION_REMNANT: org.bukkit.StructureType;

			/**
			 * Get all registered StructureTypes.
			 */
			function getStructureTypes(): globalThis.java.util.Map<string, org.bukkit.StructureType>;

		}
		interface Tag<T = any> extends Modify<org.bukkit.Keyed, {
			/**
			 * Returns whether or not this tag has an entry for the specified item.
			 */
			isTagged(item: T): boolean;

			/**
			 * Gets an immutable set of all tagged items.
			 */
			getValues(): globalThis.java.util.Set<T>;

		}> {}
		namespace Tag {
			/**
			 * Key for the built in block registry.
			 */
			const REGISTRY_BLOCKS: string;

			/**
			 * Vanilla block tag representing all colors of wool.
			 */
			const WOOL: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all plank variants.
			 */
			const PLANKS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all regular/mossy/cracked/chiseled stone
			 * bricks.
			 */
			const STONE_BRICKS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all wooden buttons.
			 */
			const WOODEN_BUTTONS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all stone buttons.
			 */
			const STONE_BUTTONS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all buttons (inherits from
			 * WOODEN_BUTTONS.
			 */
			const BUTTONS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all colors of carpet.
			 */
			const WOOL_CARPETS: org.bukkit.Tag<org.bukkit.Material>;

			const CARPETS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all wooden doors.
			 */
			const WOODEN_DOORS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all doors which can be opened by mobs.
			 */
			const MOB_INTERACTABLE_DOORS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all wooden stairs.
			 */
			const WOODEN_STAIRS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all wooden slabs.
			 */
			const WOODEN_SLABS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all wooden fences.
			 */
			const WOODEN_FENCES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all pressure plates.
			 */
			const PRESSURE_PLATES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all wooden pressure plates.
			 */
			const WOODEN_PRESSURE_PLATES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all stone pressure plates.
			 */
			const STONE_PRESSURE_PLATES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all wooden trapdoors.
			 */
			const WOODEN_TRAPDOORS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all doors (inherits from
			 * WOODEN_DOORS.
			 */
			const DOORS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all sapling variants.
			 */
			const SAPLINGS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all log and bark variants that burn.
			 */
			const LOGS_THAT_BURN: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all log and bark variants.
			 */
			const LOGS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all dark oak log and bark variants.
			 */
			const DARK_OAK_LOGS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all oak log and bark variants.
			 */
			const OAK_LOGS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all birch log and bark variants.
			 */
			const BIRCH_LOGS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all acacia log and bark variants.
			 */
			const ACACIA_LOGS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all cherry log and bark variants.
			 */
			const CHERRY_LOGS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all jungle log and bark variants.
			 */
			const JUNGLE_LOGS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all spruce log and bark variants.
			 */
			const SPRUCE_LOGS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all mangrove log and bark variants.
			 */
			const MANGROVE_LOGS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all crimson stems.
			 */
			const CRIMSON_STEMS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all warped stems.
			 */
			const WARPED_STEMS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all bamboo blocks.
			 */
			const BAMBOO_BLOCKS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all banner blocks.
			 */
			const BANNERS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all sand blocks.
			 */
			const SAND: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which smelt to glass in a furnace.
			 */
			const SMELTS_TO_GLASS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all stairs.
			 */
			const STAIRS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all slabs.
			 */
			const SLABS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all walls.
			 */
			const WALLS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all damaged and undamaged anvils.
			 */
			const ANVIL: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all Minecart rails.
			 */
			const RAILS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all leaves fans.
			 */
			const LEAVES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all trapdoors (inherits from
			 * WOODEN_TRAPDOORS.
			 */
			const TRAPDOORS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all empty and filled flower pots.
			 */
			const FLOWER_POTS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all small flowers.
			 */
			const SMALL_FLOWERS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all beds.
			 */
			const BEDS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all fences.
			 */
			const FENCES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all tall flowers.
			 */
			const TALL_FLOWERS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all flowers.
			 */
			const FLOWERS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all piglin repellents.
			 */
			const PIGLIN_REPELLENTS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all gold ores.
			 */
			const GOLD_ORES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all iron ores.
			 */
			const IRON_ORES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all diamond ores.
			 */
			const DIAMOND_ORES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all redstone ores.
			 */
			const REDSTONE_ORES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all lapis ores.
			 */
			const LAPIS_ORES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all coal ores.
			 */
			const COAL_ORES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all emerald ores.
			 */
			const EMERALD_ORES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all copper ores.
			 */
			const COPPER_ORES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all candles.
			 */
			const CANDLES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all dirt.
			 */
			const DIRT: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all terracotta.
			 */
			const TERRACOTTA: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all badlands terracotta.
			 */
			const BADLANDS_TERRACOTTA: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all concrete powder.
			 */
			const CONCRETE_POWDER: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which complete the find tree
			 * tutorial.
			 */
			const COMPLETES_FIND_TREE_TUTORIAL: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag denoting blocks that enderman may pick up and hold.
			 */
			const ENDERMAN_HOLDABLE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag denoting ice blocks.
			 */
			const ICE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag denoting all valid mob spawn positions.
			 */
			const VALID_SPAWN: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag denoting impermeable blocks which do not drip fluids.
			 */
			const IMPERMEABLE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag denoting all underwater blocks which may be bonemealed.
			 */
			const UNDERWATER_BONEMEALS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all coral blocks.
			 */
			const CORAL_BLOCKS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all wall corals.
			 */
			const WALL_CORALS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all coral plants.
			 */
			const CORAL_PLANTS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all coral.
			 */
			const CORALS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag denoting all blocks bamboo may be planted on.
			 */
			const BAMBOO_PLANTABLE_ON: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all standing signs.
			 */
			const STANDING_SIGNS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all wall signs.
			 */
			const WALL_SIGNS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all regular signs.
			 */
			const SIGNS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all ceiling signs.
			 */
			const CEILING_HANGING_SIGNS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all wall hanging signs.
			 */
			const WALL_HANGING_SIGNS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all hanging signs.
			 */
			const ALL_HANGING_SIGNS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all signs, regardless of type.
			 */
			const ALL_SIGNS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks immune to dragons.
			 */
			const DRAGON_IMMUNE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks transparent to the ender
			 * dragon.
			 */
			const DRAGON_TRANSPARENT: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks immune to withers.
			 */
			const WITHER_IMMUNE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all base blocks used for wither summoning.
			 */
			const WITHER_SUMMON_BASE_BLOCKS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all beehives.
			 */
			const BEEHIVES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all crops.
			 */
			const CROPS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all bee growables.
			 */
			const BEE_GROWABLES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all portals.
			 */
			const PORTALS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all fire blocks.
			 */
			const FIRE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all nylium blocks.
			 */
			const NYLIUM: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all wart blocks.
			 */
			const WART_BLOCKS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all beacon base blocks.
			 */
			const BEACON_BASE_BLOCKS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks affected by the soul speed
			 * enchantment.
			 */
			const SOUL_SPEED_BLOCKS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all wall post overrides.
			 */
			const WALL_POST_OVERRIDE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all climbable blocks.
			 */
			const CLIMBABLE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which reset fall damage.
			 */
			const FALL_DAMAGE_RESETTING: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all shulker boxes.
			 */
			const SHULKER_BOXES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all hoglin repellents.
			 */
			const HOGLIN_REPELLENTS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all soul fire base blocks.
			 */
			const SOUL_FIRE_BASE_BLOCKS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all warm strider blocks.
			 */
			const STRIDER_WARM_BLOCKS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all campfires.
			 */
			const CAMPFIRES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks guarded by piglins.
			 */
			const GUARDED_BY_PIGLINS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks that prevent inside mob
			 * spawning.
			 */
			const PREVENT_MOB_SPAWNING_INSIDE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all fence gates.
			 */
			const FENCE_GATES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all unstable bottom center blocks.
			 */
			const UNSTABLE_BOTTOM_CENTER: org.bukkit.Tag<org.bukkit.Material>;

			const MUSHROOM_GROW_BLOCK: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks that burn forever in the
			 * overworld.
			 */
			const INFINIBURN_OVERWORLD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks that burn forever in the
			 * nether.
			 */
			const INFINIBURN_NETHER: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks that burn forever in the end.
			 */
			const INFINIBURN_END: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing the overworld base material.
			 */
			const BASE_STONE_OVERWORLD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks that may be replaced by ores.
			 */
			const STONE_ORE_REPLACEABLES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks that may be replaced by
			 * deepslate ores.
			 */
			const DEEPSLATE_ORE_REPLACEABLES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing the nether base material.
			 */
			const BASE_STONE_NETHER: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks replaceable by the overworld
			 * carver.
			 */
			const OVERWORLD_CARVER_REPLACEABLES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks replaceable by the nether
			 * carver.
			 */
			const NETHER_CARVER_REPLACEABLES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all candle cakes.
			 */
			const CANDLE_CAKES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all cauldrons.
			 */
			const CAULDRONS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks that make crystal sounds.
			 */
			const CRYSTAL_SOUND_BLOCKS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks that play muffled step sounds.
			 */
			const INSIDE_STEP_SOUND_BLOCKS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks that play combination step sounds.
			 */
			const COMBINATION_STEP_SOUND_BLOCKS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks that play step sounds with camels on sand.
			 */
			const CAMEL_SAND_STEP_SOUND_BLOCKS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks that block vibration signals.
			 */
			const OCCLUDES_VIBRATION_SIGNALS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks that dampen the propagation of
			 * vibration signals.
			 */
			const DAMPENS_VIBRATIONS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks that are replaceable by
			 * dripstone.
			 */
			const DRIPSTONE_REPLACEABLE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all cave vines.
			 */
			const CAVE_VINES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks replaceable by moss.
			 */
			const MOSS_REPLACEABLE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks replaceable by lush ground.
			 */
			const LUSH_GROUND_REPLACEABLE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks replaceable by azalea root.
			 */
			const AZALEA_ROOT_REPLACEABLE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which small dripleaf can be
			 * placed on.
			 */
			const SMALL_DRIPLEAF_PLACEABLE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which big dripleaf can be
			 * placed on.
			 */
			const BIG_DRIPLEAF_PLACEABLE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all snow blocks.
			 */
			const SNOW: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks mineable with an axe.
			 */
			const MINEABLE_AXE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks mineable with a hoe.
			 */
			const MINEABLE_HOE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks mineable with a pickaxe.
			 */
			const MINEABLE_PICKAXE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks mineable with a shovel.
			 */
			const MINEABLE_SHOVEL: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks that can be efficiently mined with a sword.
			 */
			const SWORD_EFFICIENT: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which require a diamond tool.
			 */
			const NEEDS_DIAMOND_TOOL: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which require an iron tool.
			 */
			const NEEDS_IRON_TOOL: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which require a stone tool.
			 */
			const NEEDS_STONE_TOOL: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which will not drop items with a netherite tool.
			 */
			const INCORRECT_FOR_NETHERITE_TOOL: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which will not drop items with a diamond tool.
			 */
			const INCORRECT_FOR_DIAMOND_TOOL: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which will not drop items with a iron tool.
			 */
			const INCORRECT_FOR_IRON_TOOL: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which will not drop items with a stone tool.
			 */
			const INCORRECT_FOR_STONE_TOOL: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which will not drop items with a gold tool.
			 */
			const INCORRECT_FOR_GOLD_TOOL: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which will not drop items with a wooden tool.
			 */
			const INCORRECT_FOR_WOODEN_TOOL: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which will not be replaced by
			 * world generation features.
			 */
			const FEATURES_CANNOT_REPLACE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which lava pools will not
			 * replace.
			 */
			const LAVA_POOL_STONE_CANNOT_REPLACE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which geodes will not spawn in.
			 */
			const GEODE_INVALID_BLOCKS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which frogs prefer to jump to.
			 */
			const FROG_PREFER_JUMP_TO: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which can be replaced by skulk.
			 */
			const SCULK_REPLACEABLE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which can be replaced by skulk
			 * during world generation.
			 */
			const SCULK_REPLACEABLE_WORLD_GEN: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which can be replaced by
			 * ancient cities.
			 */
			const ANCIENT_CITY_REPLACEABLE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which resonate vibrations.
			 */
			const VIBRATION_RESONATORS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which animals will spawn on.
			 */
			const ANIMALS_SPAWNABLE_ON: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which armadillos will spawn on.
			 */
			const ARMADILLO_SPAWNABLE_ON: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which axolotls will spawn on.
			 */
			const AXOLOTLS_SPAWNABLE_ON: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which goats will spawn on.
			 */
			const GOATS_SPAWNABLE_ON: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which mooshrooms will spawn on.
			 */
			const MOOSHROOMS_SPAWNABLE_ON: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which parrots will spawn on.
			 */
			const PARROTS_SPAWNABLE_ON: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which polar bears will spawn
			 * on.
			 */
			const POLAR_BEARS_SPAWNABLE_ON_ALTERNATE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which rabbits will spawn on.
			 */
			const RABBITS_SPAWNABLE_ON: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which foxes will spawn on.
			 */
			const FOXES_SPAWNABLE_ON: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which wolves will spawn on.
			 */
			const WOLVES_SPAWNABLE_ON: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which frogs will spawn on.
			 */
			const FROGS_SPAWNABLE_ON: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which azaleas will grow on.
			 */
			const AZALEA_GROWS_ON: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which may be converted to mud.
			 */
			const CONVERTABLE_TO_MUD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which mangrove logs can grow
			 * through.
			 */
			const MANGROVE_LOGS_CAN_GROW_THROUGH: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which mangrove roots can grow
			 * through.
			 */
			const MANGROVE_ROOTS_CAN_GROW_THROUGH: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which dead bushes may be placed
			 * on.
			 */
			const DEAD_BUSH_MAY_PLACE_ON: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which snap dropped goat horns.
			 */
			const SNAPS_GOAT_HORN: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks replaceable by growing trees.
			 */
			const REPLACEABLE_BY_TREES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing blocks which snow cannot survive on.
			 */
			const SNOW_LAYER_CANNOT_SURVIVE_ON: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing blocks which snow can survive on.
			 */
			const SNOW_LAYER_CAN_SURVIVE_ON: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing blocks which cannot be dismounted into.
			 */
			const INVALID_SPAWN_INSIDE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing blocks which can be dug by sniffers.
			 */
			const SNIFFER_DIGGABLE_BLOCK: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which booster sniffer egg hatching.
			 */
			const SNIFFER_EGG_HATCH_BOOST: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which can be replaced by trail ruins.
			 */
			const TRAIL_RUINS_REPLACEABLE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which are replaceable.
			 */
			const REPLACEABLE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which provide enchantment power.
			 */
			const ENCHANTMENT_POWER_PROVIDER: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which transmit enchantment power.
			 */
			const ENCHANTMENT_POWER_TRANSMITTER: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which do not destroy farmland when placed.
			 */
			const MAINTAINS_FARMLAND: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks which block wind charge explosions.
			 */
			const BLOCKS_WIND_CHARGE_EXPLOSIONS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing solid blocks which do not block hopper operation.
			 */
			const DOES_NOT_BLOCK_HOPPERS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla block tag representing all blocks that resemble air.
			 */
			const AIR: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Key for the built in item registry.
			 */
			const REGISTRY_ITEMS: string;

			/**
			 * Vanilla item tag representing all items loved by piglins.
			 */
			const ITEMS_PIGLIN_LOVED: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all items ignored by piglin babies.
			 */
			const IGNORED_BY_PIGLIN_BABIES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all meat.
			 */
			const ITEMS_MEAT: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all sniffer food.
			 */
			const ITEMS_SNIFFER_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all piglin food.
			 */
			const ITEMS_PIGLIN_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all piglin food.
			 */
			const PIGLIN_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all fox food.
			 */
			const ITEMS_FOX_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all fox food.
			 */
			const FOX_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all cow food.
			 */
			const ITEMS_COW_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all goat food.
			 */
			const ITEMS_GOAT_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all sheep food.
			 */
			const ITEMS_SHEEP_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all wolf food.
			 */
			const ITEMS_WOLF_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all cat food.
			 */
			const ITEMS_CAT_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all horse food.
			 */
			const ITEMS_HORSE_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all horse tempt items.
			 */
			const ITEMS_HORSE_TEMPT_ITEMS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all camel food.
			 */
			const ITEMS_CAMEL_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all armadillo food.
			 */
			const ITEMS_ARMADILLO_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all bee food.
			 */
			const ITEMS_BEE_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all chicken food.
			 */
			const ITEMS_CHICKEN_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all frog food.
			 */
			const ITEMS_FROG_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all hoglin food.
			 */
			const ITEMS_HOGLIN_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all llama food.
			 */
			const ITEMS_LLAMA_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all llama tempt items.
			 */
			const ITEMS_LLAMA_TEMPT_ITEMS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all ocelot food.
			 */
			const ITEMS_OCELOT_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all panda food.
			 */
			const ITEMS_PANDA_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all pig food.
			 */
			const ITEMS_PIG_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all rabbit food.
			 */
			const ITEMS_RABBIT_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all strider food.
			 */
			const ITEMS_STRIDER_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all strider tempt items.
			 */
			const ITEMS_STRIDER_TEMPT_ITEMS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all turtle food.
			 */
			const ITEMS_TURTLE_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all parrot food.
			 */
			const ITEMS_PARROT_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all parrot poisonous food.
			 */
			const ITEMS_PARROT_POISONOUS_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all axolotl food.
			 */
			const ITEMS_AXOLOTL_FOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all banner items.
			 */
			const ITEMS_BANNERS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all non flammable wood items.
			 */
			const ITEMS_NON_FLAMMABLE_WOOD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all boat items.
			 */
			const ITEMS_BOATS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all chest boat items.
			 */
			const ITEMS_CHEST_BOATS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all fish items.
			 */
			const ITEMS_FISHES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all music disc items dropped by creepers.
			 */
			const ITEMS_CREEPER_DROP_MUSIC_DISCS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all coal items.
			 */
			const ITEMS_COALS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all arrow items.
			 */
			const ITEMS_ARROWS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all books that may be placed on lecterns.
			 */
			const ITEMS_LECTERN_BOOKS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all books that may be placed on bookshelves.
			 */
			const ITEMS_BOOKSHELF_BOOKS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all items that may be placed in beacons.
			 */
			const ITEMS_BEACON_PAYMENT_ITEMS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all stone tool materials.
			 */
			const ITEMS_STONE_TOOL_MATERIALS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all furnace materials.
			 */
			const ITEMS_FURNACE_MATERIALS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all compasses.
			 */
			const ITEMS_COMPASSES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all hanging signs.
			 */
			const ITEMS_HANGING_SIGNS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all items which will ignite creepers when
			 * interacted with.
			 */
			const ITEMS_CREEPER_IGNITERS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all items which modify note block sounds when placed on top.
			 */
			const ITEMS_NOTE_BLOCK_TOP_INSTRUMENTS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all foot armor.
			 */
			const ITEMS_FOOT_ARMOR: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all leg armor.
			 */
			const ITEMS_LEG_ARMOR: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all chest armor.
			 */
			const ITEMS_CHEST_ARMOR: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all head armor.
			 */
			const ITEMS_HEAD_ARMOR: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all skulls.
			 */
			const ITEMS_SKULLS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all trimmable armor items.
			 */
			const ITEMS_TRIMMABLE_ARMOR: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all materials which can be used for trimming armor.
			 */
			const ITEMS_TRIM_MATERIALS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all trimming templates.
			 */
			const ITEMS_TRIM_TEMPLATES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all decorated pot sherds.
			 */
			const ITEMS_DECORATED_POT_SHERDS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all decorated pot ingredients.
			 */
			const ITEMS_DECORATED_POT_INGREDIENTS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all swords.
			 */
			const ITEMS_SWORDS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all axes.
			 */
			const ITEMS_AXES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all hoes.
			 */
			const ITEMS_HOES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all pickaxes.
			 */
			const ITEMS_PICKAXES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all shovels.
			 */
			const ITEMS_SHOVELS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all items which break decorated pots.
			 */
			const ITEMS_BREAKS_DECORATED_POTS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all tools.
			 */
			const ITEMS_TOOLS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all seeds planteable by villagers.
			 */
			const ITEMS_VILLAGER_PLANTABLE_SEEDS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all dyeable items.
			 */
			const ITEMS_DYEABLE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all enchantable foot armor.
			 */
			const ITEMS_ENCHANTABLE_FOOT_ARMOR: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all enchantable leg armor.
			 */
			const ITEMS_ENCHANTABLE_LEG_ARMOR: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all enchantable chest armor.
			 */
			const ITEMS_ENCHANTABLE_CHEST_ARMOR: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all enchantable head armor.
			 */
			const ITEMS_ENCHANTABLE_HEAD_ARMOR: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all enchantable armor.
			 */
			const ITEMS_ENCHANTABLE_ARMOR: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all enchantable swords.
			 */
			const ITEMS_ENCHANTABLE_SWORD: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all items enchantable with the fire aspect enchantment.
			 */
			const ITEMS_ENCHANTABLE_FIRE_ASPECT: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all items enchantable with the sharpness enchantment.
			 */
			const ITEMS_ENCHANTABLE_SHARP_WEAPON: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all enchantable weapons.
			 */
			const ITEMS_ENCHANTABLE_WEAPON: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all enchantable mining tools.
			 */
			const ITEMS_ENCHANTABLE_MINING: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all items enchantable with the mining_loot enchantment.
			 */
			const ITEMS_ENCHANTABLE_MINING_LOOT: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all items enchantable with fishing enchantments.
			 */
			const ITEMS_ENCHANTABLE_FISHING: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all items enchantable with trident enchantments.
			 */
			const ITEMS_ENCHANTABLE_TRIDENT: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all items enchantable with durability enchantments.
			 */
			const ITEMS_ENCHANTABLE_DURABILITY: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all items enchantable with bow enchantments.
			 */
			const ITEMS_ENCHANTABLE_BOW: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all items enchantable with the binding enchantment.
			 */
			const ITEMS_ENCHANTABLE_EQUIPPABLE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all items enchantable with crossbow enchantments.
			 */
			const ITEMS_ENCHANTABLE_CROSSBOW: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all items enchantable with the vanishing enchantment.
			 */
			const ITEMS_ENCHANTABLE_VANISHING: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all items enchantable with mace enchantments.
			 */
			const ITEMS_ENCHANTABLE_MACE: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all items that confer freeze immunity on
			 * the wearer.
			 */
			const FREEZE_IMMUNE_WEARABLES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all items which tempt axolotls.
			 */
			const AXOLOTL_TEMPT_ITEMS: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Vanilla item tag representing all items which are preferred for
			 * harvesting clusters (unused).
			 */
			const CLUSTER_MAX_HARVESTABLES: org.bukkit.Tag<org.bukkit.Material>;

			/**
			 * Key for the built in fluid registry.
			 */
			const REGISTRY_FLUIDS: string;

			/**
			 * Vanilla fluid tag representing lava and flowing lava.
			 */
			const FLUIDS_LAVA: org.bukkit.Tag<org.bukkit.Fluid>;

			/**
			 * Vanilla fluid tag representing water and flowing water.
			 */
			const FLUIDS_WATER: org.bukkit.Tag<org.bukkit.Fluid>;

			/**
			 * Key for the built in entity registry.
			 */
			const REGISTRY_ENTITY_TYPES: string;

			/**
			 * Vanilla tag representing skeletons.
			 */
			const ENTITY_TYPES_SKELETONS: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing raiders.
			 */
			const ENTITY_TYPES_RAIDERS: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing entities which can live in beehives.
			 */
			const ENTITY_TYPES_BEEHIVE_INHABITORS: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing arrows.
			 */
			const ENTITY_TYPES_ARROWS: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing projectiles.
			 */
			const ENTITY_TYPES_IMPACT_PROJECTILES: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing mobs which can walk on powder snow.
			 */
			const ENTITY_TYPES_POWDER_SNOW_WALKABLE_MOBS: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing which entities axolotls are always hostile to.
			 */
			const ENTITY_TYPES_AXOLOTL_ALWAYS_HOSTILES: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing axolotl targets.
			 */
			const ENTITY_TYPES_AXOLOTL_HUNT_TARGETS: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing entities immune from freezing.
			 */
			const ENTITY_TYPES_FREEZE_IMMUNE_ENTITY_TYPES: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing entities extra susceptible to freezing.
			 */
			const ENTITY_TYPES_FREEZE_HURTS_EXTRA_TYPES: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing entities which can be eaten by frogs.
			 */
			const ENTITY_TYPES_FROG_FOOD: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing entities which are immune from fall damage.
			 */
			const ENTITY_TYPES_FALL_DAMAGE_IMMUNE: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing entities which are dismounted when underwater.
			 */
			const ENTITY_TYPES_DISMOUNTS_UNDERWATER: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing entities which are not controlled by their mount.
			 */
			const ENTITY_TYPES_NON_CONTROLLING_RIDER: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing entities which deflect projectiles.
			 */
			const ENTITY_TYPES_DEFLECTS_PROJECTILES: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing entities which deflect arrows.
			 */
			const ENTITY_TYPES_DEFLECTS_ARROWS: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing entities which can turn in boats.
			 */
			const ENTITY_TYPES_CAN_TURN_IN_BOATS: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing all entities sensitive to illager enchantments.
			 */
			const ENTITY_TYPES_ILLAGER: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing all entities sensitive to aquatic enchantments..
			 */
			const ENTITY_TYPES_AQUATIC: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing all entities sensitive to arthropod enchantments..
			 */
			const ENTITY_TYPES_ARTHROPOD: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing all entities which ignores poison and regeneration effects.
			 */
			const ENTITY_TYPES_IGNORES_POISON_AND_REGEN: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing all entities which are sensitive to inverted healing and harm potion effects.
			 */
			const ENTITY_TYPES_INVERTED_HEALING_AND_HARM: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing all entities which are friendly with withers.
			 */
			const ENTITY_TYPES_WITHER_FRIENDS: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing all entities which are friendly with illagers.
			 */
			const ENTITY_TYPES_ILLAGER_FRIENDS: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing all entities which are not scary for pufferfish.
			 */
			const ENTITY_TYPES_NOT_SCARY_FOR_PUFFERFISH: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing all entities which are sensitive to impaling.
			 */
			const ENTITY_TYPES_SENSITIVE_TO_IMPALING: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing all entities which are sensitive to the bane_of_arthropods enchantment.
			 */
			const ENTITY_TYPES_SENSITIVE_TO_BANE_OF_ARTHROPODS: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing all entities which are sensitive to the smite enchantment.
			 */
			const ENTITY_TYPES_SENSITIVE_TO_SMITE: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing all entities which do not receive anger from wind charges.
			 */
			const ENTITY_TYPES_NO_ANGER_FROM_WIND_CHARGE: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing all entities which are immune from the oozing effect.
			 */
			const ENTITY_TYPES_IMMUNE_TO_OOZING: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing all entities which are immune from the infested effect.
			 */
			const ENTITY_TYPES_IMMUNE_TO_INFESTED: org.bukkit.Tag<org.bukkit.entity.EntityType>;

			/**
			 * Vanilla tag representing all projectiles which can be punched back.
			 */
			const ENTITY_TYPES_REDIRECTABLE_PROJECTILE: org.bukkit.Tag<org.bukkit.entity.EntityType>;

		}
		interface Translatable {
			/**
			 * Get the translation key, suitable for use in a translation component.
			 */
			getTranslationKey(): string;

		}
		interface TreeSpecies {
			/**
			 * Gets the associated data value representing this species
			 */
			getData(): any /* byte */;

		}
		namespace TreeSpecies {
			/**
			 * Represents the common tree species.
			 */
			const GENERIC: org.bukkit.TreeSpecies;

			/**
			 * Represents the darker barked/leaved tree species.
			 */
			const REDWOOD: org.bukkit.TreeSpecies;

			/**
			 * Represents birches.
			 */
			const BIRCH: org.bukkit.TreeSpecies;

			/**
			 * Represents jungle trees.
			 */
			const JUNGLE: org.bukkit.TreeSpecies;

			/**
			 * Represents acacia trees.
			 */
			const ACACIA: org.bukkit.TreeSpecies;

			/**
			 * Represents dark oak trees.
			 */
			const DARK_OAK: org.bukkit.TreeSpecies;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.TreeSpecies;

			/**
			 * Gets the TreeSpecies with the given data value
			 */
			function getByData(data: any /* byte */): (org.bukkit.TreeSpecies | null);

		}
		interface TreeType {}
		namespace TreeType {
			/**
			 * Regular tree, no branches
			 */
			const TREE: org.bukkit.TreeType;

			/**
			 * Regular tree, extra tall with branches
			 */
			const BIG_TREE: org.bukkit.TreeType;

			/**
			 * Redwood tree, shaped like a pine tree
			 */
			const REDWOOD: org.bukkit.TreeType;

			/**
			 * Tall redwood tree with just a few leaves at the top
			 */
			const TALL_REDWOOD: org.bukkit.TreeType;

			/**
			 * Birch tree
			 */
			const BIRCH: org.bukkit.TreeType;

			/**
			 * Standard jungle tree; 4 blocks wide and tall
			 */
			const JUNGLE: org.bukkit.TreeType;

			/**
			 * Smaller jungle tree; 1 block wide
			 */
			const SMALL_JUNGLE: org.bukkit.TreeType;

			/**
			 * Jungle tree with cocoa plants; 1 block wide
			 */
			const COCOA_TREE: org.bukkit.TreeType;

			/**
			 * Small bush that grows in the jungle
			 */
			const JUNGLE_BUSH: org.bukkit.TreeType;

			/**
			 * Big red mushroom; short and fat
			 */
			const RED_MUSHROOM: org.bukkit.TreeType;

			/**
			 * Big brown mushroom; tall and umbrella-like
			 */
			const BROWN_MUSHROOM: org.bukkit.TreeType;

			/**
			 * Swamp tree (regular with vines on the side)
			 */
			const SWAMP: org.bukkit.TreeType;

			/**
			 * Acacia tree.
			 */
			const ACACIA: org.bukkit.TreeType;

			/**
			 * Dark Oak tree.
			 */
			const DARK_OAK: org.bukkit.TreeType;

			/**
			 * Mega redwood tree; 4 blocks wide and tall
			 */
			const MEGA_REDWOOD: org.bukkit.TreeType;

			/**
			 * Mega pine tree
			 */
			const MEGA_PINE: org.bukkit.TreeType;

			/**
			 * Tall birch tree
			 */
			const TALL_BIRCH: org.bukkit.TreeType;

			/**
			 * Large plant native to The End
			 */
			const CHORUS_PLANT: org.bukkit.TreeType;

			/**
			 * Large crimson fungus native to the nether
			 */
			const CRIMSON_FUNGUS: org.bukkit.TreeType;

			/**
			 * Large warped fungus native to the nether
			 */
			const WARPED_FUNGUS: org.bukkit.TreeType;

			/**
			 * Tree with large roots which grows above lush caves
			 */
			const AZALEA: org.bukkit.TreeType;

			/**
			 * Mangrove tree
			 */
			const MANGROVE: org.bukkit.TreeType;

			/**
			 * Tall mangrove tree
			 */
			const TALL_MANGROVE: org.bukkit.TreeType;

			/**
			 * Cherry tree
			 */
			const CHERRY: org.bukkit.TreeType;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.TreeType;

		}
		interface UndefinedNullability {}
		interface UnsafeValues {
			toLegacy(material: org.bukkit.Material): org.bukkit.Material;

			fromLegacy(material: org.bukkit.Material): org.bukkit.Material;

			fromLegacy(material: org.bukkit.material.MaterialData): org.bukkit.Material;

			fromLegacy(material: org.bukkit.material.MaterialData, itemPriority: boolean): org.bukkit.Material;

			fromLegacy(material: org.bukkit.Material, data: any /* byte */): org.bukkit.block.data.BlockData;

			getMaterial(material: string, version: number): org.bukkit.Material;

			getDataVersion(): number;

			modifyItemStack(stack: org.bukkit.inventory.ItemStack, arguments: string): org.bukkit.inventory.ItemStack;

			checkSupported(pdf: org.bukkit.plugin.PluginDescriptionFile): void;

			/**
			 * Load an advancement represented by the specified string into the server.
			 * The advancement format is governed by Minecraft and has no specified
			 * layout.
			 * 
			 * It is currently a JSON object, as described by the Minecraft wiki.
			 * 
			 * Loaded advancements will be stored and persisted across server restarts
			 * and reloads.
			 * 
			 * Callers should be prepared for Exception to be thrown.
			 */
			loadAdvancement(key: org.bukkit.NamespacedKey, advancement: string): org.bukkit.advancement.Advancement;

			/**
			 * Delete an advancement which was loaded and saved by
			 * loadAdvancement(org.bukkit.NamespacedKey, java.lang.String).
			 * 
			 * This method will only remove advancement from persistent storage. It
			 * should be accompanied by a call to Server.reloadData() in order
			 * to fully remove it from the running instance.
			 */
			removeAdvancement(key: org.bukkit.NamespacedKey): boolean;

			getDefaultAttributeModifiers(material: org.bukkit.Material, slot: org.bukkit.inventory.EquipmentSlot): any /* com.google.common.collect.Multimap */;

			getCreativeCategory(material: org.bukkit.Material): org.bukkit.inventory.CreativeCategory;

			getBlockTranslationKey(material: org.bukkit.Material): string;

			getItemTranslationKey(material: org.bukkit.Material): string;

			getTranslationKey(entityType: org.bukkit.entity.EntityType): string;

			getTranslationKey(itemStack: org.bukkit.inventory.ItemStack): string;

			getTranslationKey(attribute: org.bukkit.attribute.Attribute): string;

			getFeatureFlag(key: org.bukkit.NamespacedKey): (org.bukkit.FeatureFlag | null);

			/**
			 * Do not use, method will get removed, and the plugin won't run
			 */
			getInternalPotionData(key: org.bukkit.NamespacedKey): org.bukkit.potion.PotionType.InternalPotionData;

			getDamageEffect(key: string): (org.bukkit.damage.DamageEffect | null);

			/**
			 * Create a new DamageSource.Builder.
			 */
			createDamageSourceBuilder(damageType: org.bukkit.damage.DamageType): org.bukkit.damage.DamageSource.Builder;

			get(aClass: globalThis.java.lang.Class, value: string): string;

			get<B = any>(registry: org.bukkit.Registry<B>, key: org.bukkit.NamespacedKey): B;

		}
		interface Utility {}
		interface Vibration {
			/**
			 * Get the origin of the vibration.
			 */
			getOrigin(): org.bukkit.Location;

			/**
			 * Get the vibration destination.
			 */
			getDestination(): org.bukkit.Vibration.Destination;

			/**
			 * Get the vibration arrival time in ticks.
			 */
			getArrivalTime(): number;

		}
		class Vibration {
			constructor(origin: org.bukkit.Location, destination: org.bukkit.Vibration.Destination, arrivalTime: number);

		}
		namespace Vibration {
			interface Destination {}
		}
		namespace Vibration.Destination {
			interface BlockDestination {
				getLocation(): org.bukkit.Location;

				getBlock(): org.bukkit.block.Block;

			}
			class BlockDestination {
				constructor(block: org.bukkit.Location);

				constructor(block: org.bukkit.block.Block);

			}
		}
		namespace Vibration.Destination {
			interface EntityDestination {
				getEntity(): org.bukkit.entity.Entity;

			}
			class EntityDestination {
				constructor(entity: org.bukkit.entity.Entity);

			}
		}
		interface Warning {}
		namespace Warning {
			interface WarningState {
				/**
				 * This method checks the provided warning should be printed for this
				 * state
				 */
				printFor(warning: (org.bukkit.Warning | null)): boolean;

			}
			namespace WarningState {
				/**
				 * Indicates all warnings should be printed for deprecated items.
				 */
				const ON: org.bukkit.Warning.WarningState;

				/**
				 * Indicates no warnings should be printed for deprecated items.
				 */
				const OFF: org.bukkit.Warning.WarningState;

				/**
				 * Indicates each warning would default to the configured Warning annotation, or always if annotation not found.
				 */
				const DEFAULT: org.bukkit.Warning.WarningState;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.Warning.WarningState;

				/**
				 * This method returns the corresponding warning state for the given
				 * string value.
				 */
				function value(value: (string | null)): org.bukkit.Warning.WarningState;

			}
		}
		interface WeatherType {}
		namespace WeatherType {
			/**
			 * Raining or snowing depending on biome.
			 */
			const DOWNFALL: org.bukkit.WeatherType;

			/**
			 * Clear weather, clouds but no rain.
			 */
			const CLEAR: org.bukkit.WeatherType;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.WeatherType;

		}
		interface World extends Modify<org.bukkit.RegionAccessor & org.bukkit.generator.WorldInfo & org.bukkit.plugin.messaging.PluginMessageRecipient & org.bukkit.metadata.Metadatable & org.bukkit.persistence.PersistentDataHolder & org.bukkit.Keyed, {
			/**
			 * Gets the Block at the given coordinates
			 */
			getBlockAt(x: number, y: number, z: number): org.bukkit.block.Block;

			/**
			 * Gets the Block at the given Location
			 */
			getBlockAt(location: org.bukkit.Location): org.bukkit.block.Block;

			/**
			 * Gets the highest non-empty (impassable) block at the given coordinates.
			 */
			getHighestBlockAt(x: number, z: number): org.bukkit.block.Block;

			/**
			 * Gets the highest non-empty (impassable) block at the given coordinates.
			 */
			getHighestBlockAt(location: org.bukkit.Location): org.bukkit.block.Block;

			/**
			 * Gets the highest block corresponding to the HeightMap at the
			 * given coordinates.
			 */
			getHighestBlockAt(x: number, z: number, heightMap: org.bukkit.HeightMap): org.bukkit.block.Block;

			/**
			 * Gets the highest block corresponding to the HeightMap at the
			 * given coordinates.
			 */
			getHighestBlockAt(location: org.bukkit.Location, heightMap: org.bukkit.HeightMap): org.bukkit.block.Block;

			/**
			 * Gets the Chunk at the given coordinates
			 */
			getChunkAt(x: number, z: number): org.bukkit.Chunk;

			/**
			 * Gets the Chunk at the given coordinates
			 */
			getChunkAt(x: number, z: number, generate: boolean): org.bukkit.Chunk;

			/**
			 * Gets the Chunk at the given Location
			 */
			getChunkAt(location: org.bukkit.Location): org.bukkit.Chunk;

			/**
			 * Gets the Chunk that contains the given Block
			 */
			getChunkAt(block: org.bukkit.block.Block): org.bukkit.Chunk;

			/**
			 * Checks if the specified Chunk is loaded
			 */
			isChunkLoaded(chunk: org.bukkit.Chunk): boolean;

			/**
			 * Loads the specified Chunk.
			 * 
			 * This method will keep the specified chunk loaded until one of the
			 * unload methods is manually called. Callers are advised to instead use
			 * getChunkAt which will only temporarily load the requested chunk.
			 */
			loadChunk(chunk: org.bukkit.Chunk): void;

			/**
			 * Checks if the Chunk at the specified coordinates is loaded
			 */
			isChunkLoaded(x: number, z: number): boolean;

			/**
			 * Checks if the Chunk at the specified coordinates is generated
			 */
			isChunkGenerated(x: number, z: number): boolean;

			/**
			 * Checks if the Chunk at the specified coordinates is loaded and
			 * in use by one or more players
			 */
			isChunkInUse(x: number, z: number): boolean;

			/**
			 * Loads the Chunk at the specified coordinates.
			 * 
			 * This method will keep the specified chunk loaded until one of the
			 * unload methods is manually called. Callers are advised to instead use
			 * getChunkAt which will only temporarily load the requested chunk.
			 * 
			 * If the chunk does not exist, it will be generated.
			 * 
			 * This method is analogous to loadChunk(int, int, boolean) where
			 * generate is true.
			 */
			loadChunk(x: number, z: number): void;

			/**
			 * Loads the Chunk at the specified coordinates.
			 * 
			 * This method will keep the specified chunk loaded until one of the
			 * unload methods is manually called. Callers are advised to instead use
			 * getChunkAt which will only temporarily load the requested chunk.
			 */
			loadChunk(x: number, z: number, generate: boolean): boolean;

			/**
			 * Safely unloads and saves the Chunk at the specified coordinates
			 * 
			 * This method is analogous to unloadChunk(int, int, boolean)
			 * where save is true.
			 */
			unloadChunk(chunk: org.bukkit.Chunk): boolean;

			/**
			 * Safely unloads and saves the Chunk at the specified coordinates
			 * 
			 * This method is analogous to unloadChunk(int, int, boolean)
			 * where save is true.
			 */
			unloadChunk(x: number, z: number): boolean;

			/**
			 * Safely unloads and optionally saves the Chunk at the specified
			 * coordinates.
			 */
			unloadChunk(x: number, z: number, save: boolean): boolean;

			/**
			 * Safely queues the Chunk at the specified coordinates for
			 * unloading.
			 */
			unloadChunkRequest(x: number, z: number): boolean;

			/**
			 * Regenerates the Chunk at the specified coordinates
			 */
			regenerateChunk(x: number, z: number): boolean;

			/**
			 * Resends the Chunk to all clients
			 */
			refreshChunk(x: number, z: number): boolean;

			/**
			 * Get a list of all players who are can view the specified chunk from their
			 * client
			 * 
			 * This list will be empty if no players are viewing the chunk, or the chunk
			 * is unloaded.
			 */
			getPlayersSeeingChunk(chunk: org.bukkit.Chunk): globalThis.java.util.Collection<org.bukkit.entity.Player>;

			/**
			 * Get a list of all players who are can view the specified chunk from their
			 * client
			 * 
			 * This list will be empty if no players are viewing the chunk, or the chunk
			 * is unloaded.
			 */
			getPlayersSeeingChunk(x: number, z: number): globalThis.java.util.Collection<org.bukkit.entity.Player>;

			/**
			 * Gets whether the chunk at the specified chunk coordinates is force
			 * loaded.
			 * 
			 * A force loaded chunk will not be unloaded due to lack of player activity.
			 */
			isChunkForceLoaded(x: number, z: number): boolean;

			/**
			 * Sets whether the chunk at the specified chunk coordinates is force
			 * loaded.
			 * 
			 * A force loaded chunk will not be unloaded due to lack of player activity.
			 */
			setChunkForceLoaded(x: number, z: number, forced: boolean): void;

			/**
			 * Returns all force loaded chunks in this world.
			 * 
			 * A force loaded chunk will not be unloaded due to lack of player activity.
			 */
			getForceLoadedChunks(): globalThis.java.util.Collection<org.bukkit.Chunk>;

			/**
			 * Adds a plugin ticket for the specified chunk, loading the chunk if it is
			 * not already loaded.
			 * 
			 * A plugin ticket will prevent a chunk from unloading until it is
			 * explicitly removed. A plugin instance may only have one ticket per chunk,
			 * but each chunk can have multiple plugin tickets.
			 * 
			 */
			addPluginChunkTicket(x: number, z: number, plugin: org.bukkit.plugin.Plugin): boolean;

			/**
			 * Removes the specified plugin's ticket for the specified chunk
			 * 
			 * A plugin ticket will prevent a chunk from unloading until it is
			 * explicitly removed. A plugin instance may only have one ticket per chunk,
			 * but each chunk can have multiple plugin tickets.
			 * 
			 */
			removePluginChunkTicket(x: number, z: number, plugin: org.bukkit.plugin.Plugin): boolean;

			/**
			 * Removes all plugin tickets for the specified plugin
			 * 
			 * A plugin ticket will prevent a chunk from unloading until it is
			 * explicitly removed. A plugin instance may only have one ticket per chunk,
			 * but each chunk can have multiple plugin tickets.
			 * 
			 */
			removePluginChunkTickets(plugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Retrieves a collection specifying which plugins have tickets for the
			 * specified chunk. This collection is not updated when plugin tickets are
			 * added or removed to the chunk.
			 * 
			 * A plugin ticket will prevent a chunk from unloading until it is
			 * explicitly removed. A plugin instance may only have one ticket per chunk,
			 * but each chunk can have multiple plugin tickets.
			 * 
			 */
			getPluginChunkTickets(x: number, z: number): globalThis.java.util.Collection<org.bukkit.plugin.Plugin>;

			/**
			 * Returns a map of which plugins have tickets for what chunks. The returned
			 * map is not updated when plugin tickets are added or removed to chunks. If
			 * a plugin has no tickets, it will be absent from the map.
			 * 
			 * A plugin ticket will prevent a chunk from unloading until it is
			 * explicitly removed. A plugin instance may only have one ticket per chunk,
			 * but each chunk can have multiple plugin tickets.
			 * 
			 */
			getPluginChunkTickets(): globalThis.java.util.Map<org.bukkit.plugin.Plugin, globalThis.java.util.Collection<org.bukkit.Chunk>>;

			/**
			 * Gets all Chunks intersecting the given BoundingBox.
			 */
			getIntersectingChunks(box: org.bukkit.util.BoundingBox): globalThis.java.util.Collection<org.bukkit.Chunk>;

			/**
			 * Drops an item at the specified Location
			 */
			dropItem(location: org.bukkit.Location, item: org.bukkit.inventory.ItemStack): org.bukkit.entity.Item;

			/**
			 * Drops an item at the specified Location
			 * Note that functions will run before the entity is spawned
			 */
			dropItem(location: org.bukkit.Location, item: org.bukkit.inventory.ItemStack, func: ((value: org.bukkit.entity.Item) => void | null)): org.bukkit.entity.Item;

			/**
			 * Drops an item at the specified Location with a random offset
			 */
			dropItemNaturally(location: org.bukkit.Location, item: org.bukkit.inventory.ItemStack): org.bukkit.entity.Item;

			/**
			 * Drops an item at the specified Location with a random offset
			 * Note that functions will run before the entity is spawned
			 */
			dropItemNaturally(location: org.bukkit.Location, item: org.bukkit.inventory.ItemStack, func: ((value: org.bukkit.entity.Item) => void | null)): org.bukkit.entity.Item;

			/**
			 * Creates an Arrow entity at the given Location
			 */
			spawnArrow(location: org.bukkit.Location, direction: org.bukkit.util.Vector, speed: number, spread: number): org.bukkit.entity.Arrow;

			/**
			 * Creates an arrow entity of the given class at the given Location
			 */
			spawnArrow<T = any>(location: org.bukkit.Location, direction: org.bukkit.util.Vector, speed: number, spread: number, clazz: globalThis.java.lang.Class<T>): T;

			/**
			 * Creates a tree at the given Location
			 */
			generateTree(location: org.bukkit.Location, type: org.bukkit.TreeType): boolean;

			/**
			 * Creates a tree at the given Location
			 */
			generateTree(loc: org.bukkit.Location, type: org.bukkit.TreeType, delegate: org.bukkit.BlockChangeDelegate): boolean;

			/**
			 * Strikes lightning at the given Location
			 */
			strikeLightning(loc: org.bukkit.Location): org.bukkit.entity.LightningStrike;

			/**
			 * Strikes lightning at the given Location without doing damage
			 */
			strikeLightningEffect(loc: org.bukkit.Location): org.bukkit.entity.LightningStrike;

			/**
			 * Get a list of all entities in this World
			 */
			getEntities(): globalThis.java.util.List<org.bukkit.entity.Entity>;

			/**
			 * Get a list of all living entities in this World
			 */
			getLivingEntities(): globalThis.java.util.List<org.bukkit.entity.LivingEntity>;

			/**
			 * Get a collection of all entities in this World matching the given
			 * class/interface
			 */
			getEntitiesByClass<T = any>(...classes: globalThis.java.lang.Class<T>[]): globalThis.java.util.Collection<T>;

			/**
			 * Get a collection of all entities in this World matching the given
			 * class/interface
			 */
			getEntitiesByClass<T = any>(cls: globalThis.java.lang.Class<T>): globalThis.java.util.Collection<T>;

			/**
			 * Get a collection of all entities in this World matching any of the
			 * given classes/interfaces
			 */
			getEntitiesByClasses(...classes: globalThis.java.lang.Class[]): globalThis.java.util.Collection<org.bukkit.entity.Entity>;

			/**
			 * Get a list of all players in this World
			 */
			getPlayers(): globalThis.java.util.List<org.bukkit.entity.Player>;

			/**
			 * Returns a list of entities within a bounding box centered around a
			 * Location.
			 * 
			 * This may not consider entities in currently unloaded chunks. Some
			 * implementations may impose artificial restrictions on the size of the
			 * search bounding box.
			 */
			getNearbyEntities(location: org.bukkit.Location, x: number, y: number, z: number): globalThis.java.util.Collection<org.bukkit.entity.Entity>;

			/**
			 * Returns a list of entities within a bounding box centered around a
			 * Location.
			 * 
			 * This may not consider entities in currently unloaded chunks. Some
			 * implementations may impose artificial restrictions on the size of the
			 * search bounding box.
			 */
			getNearbyEntities(location: org.bukkit.Location, x: number, y: number, z: number, filter: ((value: org.bukkit.entity.Entity) => boolean | null)): globalThis.java.util.Collection<org.bukkit.entity.Entity>;

			/**
			 * Returns a list of entities within the given bounding box.
			 * 
			 * This may not consider entities in currently unloaded chunks. Some
			 * implementations may impose artificial restrictions on the size of the
			 * search bounding box.
			 */
			getNearbyEntities(boundingBox: org.bukkit.util.BoundingBox): globalThis.java.util.Collection<org.bukkit.entity.Entity>;

			/**
			 * Returns a list of entities within the given bounding box.
			 * 
			 * This may not consider entities in currently unloaded chunks. Some
			 * implementations may impose artificial restrictions on the size of the
			 * search bounding box.
			 */
			getNearbyEntities(boundingBox: org.bukkit.util.BoundingBox, filter: ((value: org.bukkit.entity.Entity) => boolean | null)): globalThis.java.util.Collection<org.bukkit.entity.Entity>;

			/**
			 * Performs a ray trace that checks for entity collisions.
			 * 
			 * This may not consider entities in currently unloaded chunks. Some
			 * implementations may impose artificial restrictions on the maximum
			 * distance.
			 * 
			 * Note: Due to display entities having a zero size hitbox, this method will not detect them.
			 * To detect display entities use rayTraceEntities(Location, Vector, double, double) with a positive raySize
			 */
			rayTraceEntities(start: org.bukkit.Location, direction: org.bukkit.util.Vector, maxDistance: number): (org.bukkit.util.RayTraceResult | null);

			/**
			 * Performs a ray trace that checks for entity collisions.
			 * 
			 * This may not consider entities in currently unloaded chunks. Some
			 * implementations may impose artificial restrictions on the maximum
			 * distance.
			 */
			rayTraceEntities(start: org.bukkit.Location, direction: org.bukkit.util.Vector, maxDistance: number, raySize: number): (org.bukkit.util.RayTraceResult | null);

			/**
			 * Performs a ray trace that checks for entity collisions.
			 * 
			 * This may not consider entities in currently unloaded chunks. Some
			 * implementations may impose artificial restrictions on the maximum
			 * distance.
			 * 
			 * Note: Due to display entities having a zero size hitbox, this method will not detect them.
			 * To detect display entities use rayTraceEntities(Location, Vector, double, double, Predicate) with a positive raySize
			 */
			rayTraceEntities(start: org.bukkit.Location, direction: org.bukkit.util.Vector, maxDistance: number, filter: ((value: org.bukkit.entity.Entity) => boolean | null)): (org.bukkit.util.RayTraceResult | null);

			/**
			 * Performs a ray trace that checks for entity collisions.
			 * 
			 * This may not consider entities in currently unloaded chunks. Some
			 * implementations may impose artificial restrictions on the maximum
			 * distance.
			 */
			rayTraceEntities(start: org.bukkit.Location, direction: org.bukkit.util.Vector, maxDistance: number, raySize: number, filter: ((value: org.bukkit.entity.Entity) => boolean | null)): (org.bukkit.util.RayTraceResult | null);

			/**
			 * Performs a ray trace that checks for block collisions using the blocks'
			 * precise collision shapes.
			 * 
			 * This takes collisions with passable blocks into account, but ignores
			 * fluids.
			 * 
			 * This may cause loading of chunks! Some implementations may impose
			 * artificial restrictions on the maximum distance.
			 */
			rayTraceBlocks(start: org.bukkit.Location, direction: org.bukkit.util.Vector, maxDistance: number): (org.bukkit.util.RayTraceResult | null);

			/**
			 * Performs a ray trace that checks for block collisions using the blocks'
			 * precise collision shapes.
			 * 
			 * This takes collisions with passable blocks into account.
			 * 
			 * This may cause loading of chunks! Some implementations may impose
			 * artificial restrictions on the maximum distance.
			 */
			rayTraceBlocks(start: org.bukkit.Location, direction: org.bukkit.util.Vector, maxDistance: number, fluidCollisionMode: org.bukkit.FluidCollisionMode): (org.bukkit.util.RayTraceResult | null);

			/**
			 * Performs a ray trace that checks for block collisions using the blocks'
			 * precise collision shapes.
			 * 
			 * If collisions with passable blocks are ignored, fluid collisions are
			 * ignored as well regardless of the fluid collision mode.
			 * 
			 * Portal blocks are only considered passable if the ray starts within
			 * them. Apart from that collisions with portal blocks will be considered
			 * even if collisions with passable blocks are otherwise ignored.
			 * 
			 * This may cause loading of chunks! Some implementations may impose
			 * artificial restrictions on the maximum distance.
			 */
			rayTraceBlocks(start: org.bukkit.Location, direction: org.bukkit.util.Vector, maxDistance: number, fluidCollisionMode: org.bukkit.FluidCollisionMode, ignorePassableBlocks: boolean): (org.bukkit.util.RayTraceResult | null);

			/**
			 * Performs a ray trace that checks for both block and entity collisions.
			 * 
			 * Block collisions use the blocks' precise collision shapes. The
			 * raySize parameter is only taken into account for entity
			 * collision checks.
			 * 
			 * If collisions with passable blocks are ignored, fluid collisions are
			 * ignored as well regardless of the fluid collision mode.
			 * 
			 * Portal blocks are only considered passable if the ray starts within them.
			 * Apart from that collisions with portal blocks will be considered even if
			 * collisions with passable blocks are otherwise ignored.
			 * 
			 * This may cause loading of chunks! Some implementations may impose
			 * artificial restrictions on the maximum distance.
			 */
			rayTrace(start: org.bukkit.Location, direction: org.bukkit.util.Vector, maxDistance: number, fluidCollisionMode: org.bukkit.FluidCollisionMode, ignorePassableBlocks: boolean, raySize: number, filter: ((value: org.bukkit.entity.Entity) => boolean | null)): (org.bukkit.util.RayTraceResult | null);

			/**
			 * Gets the default spawn Location of this world
			 */
			getSpawnLocation(): org.bukkit.Location;

			/**
			 * Sets the spawn location of the world.
			 * 
			 * The location provided must be equal to this world.
			 */
			setSpawnLocation(location: org.bukkit.Location): boolean;

			/**
			 * Sets the spawn location of the world
			 */
			setSpawnLocation(x: number, y: number, z: number, angle: number): boolean;

			/**
			 * Sets the spawn location of the world
			 */
			setSpawnLocation(x: number, y: number, z: number): boolean;

			/**
			 * Gets the relative in-game time of this world.
			 * 
			 * The relative time is analogous to hours * 1000
			 */
			getTime(): number;

			/**
			 * Sets the relative in-game time on the server.
			 * 
			 * The relative time is analogous to hours * 1000
			 * 
			 * Note that setting the relative time below the current relative time
			 * will actually move the clock forward a day. If you require to rewind
			 * time, please see setFullTime(long)
			 */
			setTime(time: number): void;

			/**
			 * Gets the full in-game time on this world
			 */
			getFullTime(): number;

			/**
			 * Sets the in-game time on the server
			 * 
			 * Note that this sets the full time of the world, which may cause adverse
			 * effects such as breaking redstone clocks and any scheduled events
			 */
			setFullTime(time: number): void;

			/**
			 * Gets the full in-game time on this world since the world generation
			 */
			getGameTime(): number;

			/**
			 * Returns whether the world has an ongoing storm.
			 */
			hasStorm(): boolean;

			/**
			 * Set whether there is a storm. A duration will be set for the new
			 * current conditions.
			 * This will implicitly call setClearWeatherDuration(int) with 0
			 * ticks to reset the world's clear weather.
			 */
			setStorm(hasStorm: boolean): void;

			/**
			 * Get the remaining time in ticks of the current conditions.
			 */
			getWeatherDuration(): number;

			/**
			 * Set the remaining time in ticks of the current conditions.
			 */
			setWeatherDuration(duration: number): void;

			/**
			 * Returns whether there is thunder.
			 */
			isThundering(): boolean;

			/**
			 * Set whether it is thundering.
			 * This will implicitly call setClearWeatherDuration(int) with 0
			 * ticks to reset the world's clear weather.
			 */
			setThundering(thundering: boolean): void;

			/**
			 * Get the thundering duration.
			 */
			getThunderDuration(): number;

			/**
			 * Set the thundering duration.
			 */
			setThunderDuration(duration: number): void;

			/**
			 * Returns whether the world has clear weather.
			 * This will be true such that isThundering() and
			 * hasStorm() are both false.
			 */
			isClearWeather(): boolean;

			/**
			 * Set the clear weather duration.
			 * The clear weather ticks determine whether or not the world will be
			 * allowed to rain or storm. If clear weather ticks are > 0, the world will
			 * not naturally do either until the duration has elapsed.
			 * This method is equivalent to calling /weather clear with a set
			 * amount of ticks.
			 */
			setClearWeatherDuration(duration: number): void;

			/**
			 * Get the clear weather duration.
			 */
			getClearWeatherDuration(): number;

			/**
			 * Creates explosion at given coordinates with given power
			 */
			createExplosion(x: number, y: number, z: number, power: number): boolean;

			/**
			 * Creates explosion at given coordinates with given power and optionally
			 * setting blocks on fire.
			 */
			createExplosion(x: number, y: number, z: number, power: number, setFire: boolean): boolean;

			/**
			 * Creates explosion at given coordinates with given power and optionally
			 * setting blocks on fire or breaking blocks.
			 */
			createExplosion(x: number, y: number, z: number, power: number, setFire: boolean, breakBlocks: boolean): boolean;

			/**
			 * Creates explosion at given coordinates with given power and optionally
			 * setting blocks on fire or breaking blocks.
			 * 
			 * Note that if a non-null source Entity is provided and
			 * breakBlocks is true, the value of breakBlocks will be
			 * ignored if GameRule.MOB_GRIEFING is false in the world
			 * in which the explosion occurs. In other words, the mob griefing gamerule
			 * will take priority over breakBlocks if explosions are not allowed.
			 */
			createExplosion(x: number, y: number, z: number, power: number, setFire: boolean, breakBlocks: boolean, source: (org.bukkit.entity.Entity | null)): boolean;

			/**
			 * Creates explosion at given coordinates with given power
			 */
			createExplosion(loc: org.bukkit.Location, power: number): boolean;

			/**
			 * Creates explosion at given coordinates with given power and optionally
			 * setting blocks on fire.
			 */
			createExplosion(loc: org.bukkit.Location, power: number, setFire: boolean): boolean;

			/**
			 * Creates explosion at given coordinates with given power and optionally
			 * setting blocks on fire or breaking blocks.
			 */
			createExplosion(loc: org.bukkit.Location, power: number, setFire: boolean, breakBlocks: boolean): boolean;

			/**
			 * Creates explosion at given coordinates with given power and optionally
			 * setting blocks on fire or breaking blocks.
			 * 
			 * Note that if a non-null source Entity is provided and
			 * breakBlocks is true, the value of breakBlocks will be
			 * ignored if GameRule.MOB_GRIEFING is false in the world
			 * in which the explosion occurs. In other words, the mob griefing gamerule
			 * will take priority over breakBlocks if explosions are not allowed.
			 */
			createExplosion(loc: org.bukkit.Location, power: number, setFire: boolean, breakBlocks: boolean, source: (org.bukkit.entity.Entity | null)): boolean;

			/**
			 * Gets the current PVP setting for this world.
			 */
			getPVP(): boolean;

			/**
			 * Sets the PVP setting for this world.
			 */
			setPVP(pvp: boolean): void;

			/**
			 * Gets the chunk generator for this world
			 */
			getGenerator(): (org.bukkit.generator.ChunkGenerator | null);

			/**
			 * Gets the biome provider for this world
			 */
			getBiomeProvider(): (org.bukkit.generator.BiomeProvider | null);

			/**
			 * Saves world to disk
			 */
			save(): void;

			/**
			 * Gets a list of all applied BlockPopulators for this World
			 */
			getPopulators(): globalThis.java.util.List<org.bukkit.generator.BlockPopulator>;

			/**
			 * Creates a new entity at the given Location with the supplied
			 * function run before the entity is added to the world.
			 * 
			 * Note that when the function is run, the entity will not be actually in
			 * the world. Any operation involving such as teleporting the entity is undefined
			 * until after this function returns.
			 * The passed function however is run after the potential entity's spawn
			 * randomization and hence already allows access to the values of the mob,
			 * whether or not those were randomized, such as attributes or the entity
			 * equipment.
			 */
			spawn<T = any>(location: org.bukkit.Location, clazz: globalThis.java.lang.Class<T>, spawnReason: org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason, randomizeData: boolean, func: ((value: T) => void | null)): T;

			/**
			 * Spawn a FallingBlock entity at the given Location of
			 * the specified MaterialData. The MaterialData dictates what is falling.
			 * When the FallingBlock hits the ground, it will place that block.
			 * 
			 * The Material must be a block type, check with data.getItemType().isBlock(). The Material may not be air.
			 */
			spawnFallingBlock(location: org.bukkit.Location, data: org.bukkit.material.MaterialData): org.bukkit.entity.FallingBlock;

			/**
			 * Spawn a FallingBlock entity at the given Location of
			 * the specified BlockData. The BlockData dictates what is falling.
			 * When the FallingBlock hits the ground, it will place that block.
			 */
			spawnFallingBlock(location: org.bukkit.Location, data: org.bukkit.block.data.BlockData): org.bukkit.entity.FallingBlock;

			/**
			 * Spawn a FallingBlock entity at the given Location of the
			 * specified Material. The material dictates what is falling.
			 * When the FallingBlock hits the ground, it will place that block.
			 * 
			 * The Material must be a block type, check with material.isBlock(). The Material may not be air.
			 */
			spawnFallingBlock(location: org.bukkit.Location, material: org.bukkit.Material, data: any /* byte */): org.bukkit.entity.FallingBlock;

			/**
			 * Plays an effect to all players within a default radius around a given
			 * location.
			 */
			playEffect(location: org.bukkit.Location, effect: org.bukkit.Effect, data: number): void;

			/**
			 * Plays an effect to all players within a given radius around a location.
			 */
			playEffect(location: org.bukkit.Location, effect: org.bukkit.Effect, data: number, radius: number): void;

			/**
			 * Plays an effect to all players within a default radius around a given
			 * location.
			 */
			playEffect<T = any>(location: org.bukkit.Location, effect: org.bukkit.Effect, data: (T | null)): void;

			/**
			 * Plays an effect to all players within a given radius around a location.
			 */
			playEffect<T = any>(location: org.bukkit.Location, effect: org.bukkit.Effect, data: (T | null), radius: number): void;

			/**
			 * Get empty chunk snapshot (equivalent to all air blocks), optionally
			 * including valid biome data. Used for representing an ungenerated chunk,
			 * or for fetching only biome data without loading a chunk.
			 */
			getEmptyChunkSnapshot(x: number, z: number, includeBiome: boolean, includeBiomeTemp: boolean): org.bukkit.ChunkSnapshot;

			/**
			 * Sets the spawn flags for this.
			 */
			setSpawnFlags(allowMonsters: boolean, allowAnimals: boolean): void;

			/**
			 * Gets whether animals can spawn in this world.
			 */
			getAllowAnimals(): boolean;

			/**
			 * Gets whether monsters can spawn in this world.
			 */
			getAllowMonsters(): boolean;

			/**
			 * Gets the biome for the given block coordinates.
			 */
			getBiome(x: number, z: number): org.bukkit.block.Biome;

			/**
			 * Sets the biome for the given block coordinates
			 */
			setBiome(x: number, z: number, bio: org.bukkit.block.Biome): void;

			/**
			 * Gets the temperature for the given block coordinates.
			 * 
			 * It is safe to run this method when the block does not exist, it will
			 * not create the block.
			 * 
			 * This method will return the raw temperature without adjusting for block
			 * height effects.
			 */
			getTemperature(x: number, z: number): number;

			/**
			 * Gets the temperature for the given block coordinates.
			 * 
			 * It is safe to run this method when the block does not exist, it will
			 * not create the block.
			 * 
			 * This method will return the raw temperature without adjusting for block
			 * height effects.
			 */
			getTemperature(x: number, y: number, z: number): number;

			/**
			 * Gets the humidity for the given block coordinates.
			 * 
			 * It is safe to run this method when the block does not exist, it will
			 * not create the block.
			 */
			getHumidity(x: number, z: number): number;

			/**
			 * Gets the humidity for the given block coordinates.
			 * 
			 * It is safe to run this method when the block does not exist, it will
			 * not create the block.
			 */
			getHumidity(x: number, y: number, z: number): number;

			/**
			 * Gets the maximum height to which chorus fruits and nether portals can
			 * bring players within this dimension.
			 * This excludes portals that were already built above the limit as they
			 * still connect normally. May not be greater than WorldInfo.getMaxHeight().
			 */
			getLogicalHeight(): number;

			/**
			 * Gets if this world is natural.
			 * When false, compasses spin randomly, and using a bed to set the respawn
			 * point or sleep, is disabled. When true, nether portals can spawn
			 * zombified piglins.
			 */
			isNatural(): boolean;

			/**
			 * Gets if beds work in this world.
			 * A non-working bed will blow up when trying to sleep. isNatural()
			 * defines if a bed can be used to set spawn point.
			 */
			isBedWorks(): boolean;

			/**
			 * Gets if this world has skylight access.
			 */
			hasSkyLight(): boolean;

			/**
			 * Gets if this world has a ceiling.
			 */
			hasCeiling(): boolean;

			/**
			 * Gets if this world allow to piglins to survive without shaking and
			 * transforming to zombified piglins.
			 */
			isPiglinSafe(): boolean;

			/**
			 * Gets if this world allows players to charge and use respawn anchors.
			 */
			isRespawnAnchorWorks(): boolean;

			/**
			 * Gets if players with the bad omen effect in this world will trigger a
			 * raid.
			 */
			hasRaids(): boolean;

			/**
			 * Gets if various water/lava mechanics will be triggered in this world, eg:
			 * 
			 * 
			 * Water is evaporated
			 * Sponges dry
			 * Lava spreads faster and further
			 * 
			 */
			isUltraWarm(): boolean;

			/**
			 * Gets the sea level for this world.
			 * 
			 * This is often half of WorldInfo.getMaxHeight()
			 */
			getSeaLevel(): number;

			/**
			 * Gets whether the world's spawn area should be kept loaded into memory
			 * or not.
			 */
			getKeepSpawnInMemory(): boolean;

			/**
			 * Sets whether the world's spawn area should be kept loaded into memory
			 * or not.
			 */
			setKeepSpawnInMemory(keepLoaded: boolean): void;

			/**
			 * Gets whether or not the world will automatically save
			 */
			isAutoSave(): boolean;

			/**
			 * Sets whether or not the world will automatically save
			 */
			setAutoSave(value: boolean): void;

			/**
			 * Sets the Difficulty of the world.
			 */
			setDifficulty(difficulty: org.bukkit.Difficulty): void;

			/**
			 * Gets the Difficulty of the world.
			 */
			getDifficulty(): org.bukkit.Difficulty;

			/**
			 * Returns the view distance used for this world.
			 */
			getViewDistance(): number;

			/**
			 * Returns the simulation distance used for this world.
			 */
			getSimulationDistance(): number;

			/**
			 * Gets the folder of this world on disk.
			 */
			getWorldFolder(): any /* java.io.File */;

			/**
			 * Gets the type of this world.
			 */
			getWorldType(): (org.bukkit.WorldType | null);

			/**
			 * Gets whether or not structures are being generated.
			 */
			canGenerateStructures(): boolean;

			/**
			 * Gets whether the world is hardcore or not.
			 * In a hardcore world the difficulty is locked to hard.
			 */
			isHardcore(): boolean;

			/**
			 * Sets whether the world is hardcore or not.
			 * In a hardcore world the difficulty is locked to hard.
			 */
			setHardcore(hardcore: boolean): void;

			/**
			 * Gets the world's ticks per animal spawns value
			 * 
			 * This value determines how many ticks there are between attempts to
			 * spawn animals.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn animals in
			 * this world every tick.
			 * A value of 400 will mean the server will attempt to spawn animals
			 * in this world every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note:
			 * If set to 0, animal spawning will be disabled for this world. We
			 * recommend using setSpawnFlags(boolean, boolean) to control
			 * this instead.
			 * 
			 * Minecraft default: 400.
			 */
			getTicksPerAnimalSpawns(): number;

			/**
			 * Sets the world's ticks per animal spawns value
			 * 
			 * This value determines how many ticks there are between attempts to
			 * spawn animals.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn animals in
			 * this world every tick.
			 * A value of 400 will mean the server will attempt to spawn animals
			 * in this world every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note:
			 * If set to 0, animal spawning will be disabled for this world. We
			 * recommend using setSpawnFlags(boolean, boolean) to control
			 * this instead.
			 * 
			 * Minecraft default: 400.
			 */
			setTicksPerAnimalSpawns(ticksPerAnimalSpawns: number): void;

			/**
			 * Gets the world's ticks per monster spawns value
			 * 
			 * This value determines how many ticks there are between attempts to
			 * spawn monsters.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn monsters in
			 * this world every tick.
			 * A value of 400 will mean the server will attempt to spawn monsters
			 * in this world every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note:
			 * If set to 0, monsters spawning will be disabled for this world. We
			 * recommend using setSpawnFlags(boolean, boolean) to control
			 * this instead.
			 * 
			 * Minecraft default: 1.
			 */
			getTicksPerMonsterSpawns(): number;

			/**
			 * Sets the world's ticks per monster spawns value
			 * 
			 * This value determines how many ticks there are between attempts to
			 * spawn monsters.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn monsters in
			 * this world on every tick.
			 * A value of 400 will mean the server will attempt to spawn monsters
			 * in this world every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note:
			 * If set to 0, monsters spawning will be disabled for this world. We
			 * recommend using setSpawnFlags(boolean, boolean) to control
			 * this instead.
			 * 
			 * Minecraft default: 1.
			 */
			setTicksPerMonsterSpawns(ticksPerMonsterSpawns: number): void;

			/**
			 * Gets the world's ticks per water mob spawns value
			 * 
			 * This value determines how many ticks there are between attempts to
			 * spawn water mobs.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn water mobs in
			 * this world every tick.
			 * A value of 400 will mean the server will attempt to spawn water mobs
			 * in this world every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note:
			 * If set to 0, water mobs spawning will be disabled for this world.
			 * 
			 * Minecraft default: 1.
			 */
			getTicksPerWaterSpawns(): number;

			/**
			 * Sets the world's ticks per water mob spawns value
			 * 
			 * This value determines how many ticks there are between attempts to
			 * spawn water mobs.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn water mobs in
			 * this world on every tick.
			 * A value of 400 will mean the server will attempt to spawn water mobs
			 * in this world every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note:
			 * If set to 0, water mobs spawning will be disabled for this world.
			 * 
			 * Minecraft default: 1.
			 */
			setTicksPerWaterSpawns(ticksPerWaterSpawns: number): void;

			/**
			 * Gets the default ticks per water ambient mob spawns value.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn water ambient mobs
			 * every tick.
			 * A value of 400 will mean the server will attempt to spawn water ambient mobs
			 * every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note: If set to 0, ambient mobs spawning will be disabled.
			 * 
			 * Minecraft default: 1.
			 */
			getTicksPerWaterAmbientSpawns(): number;

			/**
			 * Sets the world's ticks per water ambient mob spawns value
			 * 
			 * This value determines how many ticks there are between attempts to
			 * spawn water ambient mobs.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn water ambient mobs in
			 * this world on every tick.
			 * A value of 400 will mean the server will attempt to spawn water ambient mobs
			 * in this world every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note:
			 * If set to 0, water ambient mobs spawning will be disabled for this world.
			 * 
			 * Minecraft default: 1.
			 */
			setTicksPerWaterAmbientSpawns(ticksPerAmbientSpawns: number): void;

			/**
			 * Gets the default ticks per water underground creature spawns value.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn water underground creature
			 * every tick.
			 * A value of 400 will mean the server will attempt to spawn water underground creature
			 * every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note: If set to 0, water underground creature spawning will be disabled.
			 * 
			 * Minecraft default: 1.
			 */
			getTicksPerWaterUndergroundCreatureSpawns(): number;

			/**
			 * Sets the world's ticks per water underground creature spawns value
			 * 
			 * This value determines how many ticks there are between attempts to
			 * spawn water underground creature.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn water underground creature in
			 * this world on every tick.
			 * A value of 400 will mean the server will attempt to spawn water underground creature
			 * in this world every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note:
			 * If set to 0, water underground creature spawning will be disabled for this world.
			 * 
			 * Minecraft default: 1.
			 */
			setTicksPerWaterUndergroundCreatureSpawns(ticksPerWaterUndergroundCreatureSpawns: number): void;

			/**
			 * Gets the world's ticks per ambient mob spawns value
			 * 
			 * This value determines how many ticks there are between attempts to
			 * spawn ambient mobs.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn ambient mobs in
			 * this world every tick.
			 * A value of 400 will mean the server will attempt to spawn ambient mobs
			 * in this world every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note:
			 * If set to 0, ambient mobs spawning will be disabled for this world.
			 * 
			 * Minecraft default: 1.
			 */
			getTicksPerAmbientSpawns(): number;

			/**
			 * Sets the world's ticks per ambient mob spawns value
			 * 
			 * This value determines how many ticks there are between attempts to
			 * spawn ambient mobs.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn ambient mobs in
			 * this world on every tick.
			 * A value of 400 will mean the server will attempt to spawn ambient mobs
			 * in this world every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note:
			 * If set to 0, ambient mobs spawning will be disabled for this world.
			 * 
			 * Minecraft default: 1.
			 */
			setTicksPerAmbientSpawns(ticksPerAmbientSpawns: number): void;

			/**
			 * Gets the world's ticks per SpawnCategory mob spawns value
			 * 
			 * This value determines how many ticks there are between attempts to
			 * spawn SpawnCategory mobs.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn SpawnCategory mobs in
			 * this world every tick.
			 * A value of 400 will mean the server will attempt to spawn SpawnCategory mobs
			 * in this world every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note:
			 * If set to 0, SpawnCategory mobs spawning will be disabled for this world.
			 * 
			 * Minecraft default: 1.
			 */
			getTicksPerSpawns(spawnCategory: org.bukkit.entity.SpawnCategory): number;

			/**
			 * Sets the world's ticks per SpawnCategory mob spawns value
			 * 
			 * This value determines how many ticks there are between attempts to
			 * spawn SpawnCategory mobs.
			 * 
			 * Example Usage:
			 * 
			 * A value of 1 will mean the server will attempt to spawn SpawnCategory mobs in
			 * this world on every tick.
			 * A value of 400 will mean the server will attempt to spawn SpawnCategory mobs
			 * in this world every 400th tick.
			 * A value below 0 will be reset back to Minecraft's default.
			 * 
			 * 
			 * Note:
			 * If set to 0, SpawnCategory mobs spawning will be disabled for this world.
			 * 
			 * Minecraft default: 1.
			 */
			setTicksPerSpawns(spawnCategory: org.bukkit.entity.SpawnCategory, ticksPerCategorySpawn: number): void;

			/**
			 * Gets limit for number of monsters that can spawn in a chunk in this
			 * world
			 */
			getMonsterSpawnLimit(): number;

			/**
			 * Sets the limit for number of monsters that can spawn in a chunk in this
			 * world
			 * 
			 * Note: If set to a negative number the world will use the
			 * server-wide spawn limit instead.
			 */
			setMonsterSpawnLimit(limit: number): void;

			/**
			 * Gets the limit for number of animals that can spawn in a chunk in this
			 * world
			 */
			getAnimalSpawnLimit(): number;

			/**
			 * Sets the limit for number of animals that can spawn in a chunk in this
			 * world
			 * 
			 * Note: If set to a negative number the world will use the
			 * server-wide spawn limit instead.
			 */
			setAnimalSpawnLimit(limit: number): void;

			/**
			 * Gets the limit for number of water animals that can spawn in a chunk in
			 * this world
			 */
			getWaterAnimalSpawnLimit(): number;

			/**
			 * Sets the limit for number of water animals that can spawn in a chunk in
			 * this world
			 * 
			 * Note: If set to a negative number the world will use the
			 * server-wide spawn limit instead.
			 */
			setWaterAnimalSpawnLimit(limit: number): void;

			/**
			 * Gets the limit for number of water underground creature that can spawn in a chunk in
			 * this world
			 */
			getWaterUndergroundCreatureSpawnLimit(): number;

			/**
			 * Sets the limit for number of water underground creature that can spawn in a chunk in
			 * this world
			 * 
			 * Note: If set to a negative number the world will use the
			 * server-wide spawn limit instead.
			 */
			setWaterUndergroundCreatureSpawnLimit(limit: number): void;

			/**
			 * Gets user-specified limit for number of water ambient mobs that can spawn
			 * in a chunk.
			 */
			getWaterAmbientSpawnLimit(): number;

			/**
			 * Sets the limit for number of water ambient mobs that can spawn in a chunk
			 * in this world
			 * 
			 * Note: If set to a negative number the world will use the
			 * server-wide spawn limit instead.
			 */
			setWaterAmbientSpawnLimit(limit: number): void;

			/**
			 * Gets the limit for number of ambient mobs that can spawn in a chunk in
			 * this world
			 */
			getAmbientSpawnLimit(): number;

			/**
			 * Sets the limit for number of ambient mobs that can spawn in a chunk in
			 * this world
			 * 
			 * Note: If set to a negative number the world will use the
			 * server-wide spawn limit instead.
			 */
			setAmbientSpawnLimit(limit: number): void;

			/**
			 * Gets the limit for number of SpawnCategory entities that can spawn in a chunk in
			 * this world
			 */
			getSpawnLimit(spawnCategory: org.bukkit.entity.SpawnCategory): number;

			/**
			 * Sets the limit for number of SpawnCategory entities that can spawn in a chunk in
			 * this world
			 * 
			 * Note: If set to a negative number the world will use the
			 * server-wide spawn limit instead.
			 */
			setSpawnLimit(spawnCategory: org.bukkit.entity.SpawnCategory, limit: number): void;

			/**
			 * Play a note at the provided Location in the World.
			 * This will work with cake.
			 * 
			 * This method will fail silently when called with Instrument.CUSTOM_HEAD.
			 */
			playNote(loc: org.bukkit.Location, instrument: org.bukkit.Instrument, note: org.bukkit.Note): void;

			/**
			 * Play a Sound at the provided Location in the World.
			 * 
			 * This function will fail silently if Location or Sound are null.
			 */
			playSound(location: org.bukkit.Location, sound: org.bukkit.Sound, volume: number, pitch: number): void;

			/**
			 * Play a Sound at the provided Location in the World.
			 * 
			 * This function will fail silently if Location or Sound are null. No
			 * sound will be heard by the players if their clients do not have the
			 * respective sound for the value passed.
			 */
			playSound(location: org.bukkit.Location, sound: string, volume: number, pitch: number): void;

			/**
			 * Play a Sound at the provided Location in the World.
			 * 
			 * This function will fail silently if Location or Sound are null.
			 */
			playSound(location: org.bukkit.Location, sound: org.bukkit.Sound, category: org.bukkit.SoundCategory, volume: number, pitch: number): void;

			/**
			 * Play a Sound at the provided Location in the World.
			 * 
			 * This function will fail silently if Location or Sound are null. No sound
			 * will be heard by the players if their clients do not have the respective
			 * sound for the value passed.
			 */
			playSound(location: org.bukkit.Location, sound: string, category: org.bukkit.SoundCategory, volume: number, pitch: number): void;

			/**
			 * Play a Sound at the provided Location in the World. For sounds with multiple
			 * variations passing the same seed will always play the same variation.
			 * 
			 * This function will fail silently if Location or Sound are null.
			 */
			playSound(location: org.bukkit.Location, sound: org.bukkit.Sound, category: org.bukkit.SoundCategory, volume: number, pitch: number, seed: number): void;

			/**
			 * Play a Sound at the provided Location in the World. For sounds with multiple
			 * variations passing the same seed will always play the same variation.
			 * 
			 * This function will fail silently if Location or Sound are null. No sound will
			 * be heard by the players if their clients do not have the respective sound for
			 * the value passed.
			 */
			playSound(location: org.bukkit.Location, sound: string, category: org.bukkit.SoundCategory, volume: number, pitch: number, seed: number): void;

			/**
			 * Play a Sound at the location of the provided entity in the World.
			 * 
			 * This function will fail silently if Entity or Sound are null.
			 */
			playSound(entity: org.bukkit.entity.Entity, sound: org.bukkit.Sound, volume: number, pitch: number): void;

			/**
			 * Play a Sound at the location of the provided entity in the World.
			 * 
			 * This function will fail silently if Entity or Sound are null.
			 */
			playSound(entity: org.bukkit.entity.Entity, sound: string, volume: number, pitch: number): void;

			/**
			 * Play a Sound at the location of the provided entity in the World.
			 * 
			 * This function will fail silently if Entity or Sound are null.
			 */
			playSound(entity: org.bukkit.entity.Entity, sound: org.bukkit.Sound, category: org.bukkit.SoundCategory, volume: number, pitch: number): void;

			/**
			 * Play a Sound at the location of the provided entity in the World.
			 * 
			 * This function will fail silently if Entity or Sound are null.
			 */
			playSound(entity: org.bukkit.entity.Entity, sound: string, category: org.bukkit.SoundCategory, volume: number, pitch: number): void;

			/**
			 * Play a Sound at the location of the provided entity in the World. For sounds
			 * with multiple variations passing the same seed will always play the same
			 * variation.
			 * 
			 * This function will fail silently if Entity or Sound are null.
			 */
			playSound(entity: org.bukkit.entity.Entity, sound: org.bukkit.Sound, category: org.bukkit.SoundCategory, volume: number, pitch: number, seed: number): void;

			/**
			 * Play a Sound at the location of the provided entity in the World. For sounds
			 * with multiple variations passing the same seed will always play the same
			 * variation.
			 * 
			 * This function will fail silently if Entity or Sound are null.
			 */
			playSound(entity: org.bukkit.entity.Entity, sound: string, category: org.bukkit.SoundCategory, volume: number, pitch: number, seed: number): void;

			/**
			 * Gets the current state of the specified rule
			 * 
			 * Will return null if rule passed is null
			 */
			getGameRuleValue(rule: (string | null)): (string | null);

			/**
			 * Set the specified gamerule to specified value.
			 * 
			 * The rule may attempt to validate the value passed, will return true if
			 * value was set.
			 * 
			 * If rule is null, the function will return false.
			 */
			setGameRuleValue(rule: string, value: string): boolean;

			/**
			 * Checks if string is a valid game rule
			 */
			isGameRule(rule: string): boolean;

			/**
			 * Get the current value for a given GameRule.
			 */
			getGameRuleValue<T = any>(rule: org.bukkit.GameRule<T>): (T | null);

			/**
			 * Get the default value for a given GameRule. This value is not
			 * guaranteed to match the current value.
			 */
			getGameRuleDefault<T = any>(rule: org.bukkit.GameRule<T>): (T | null);

			/**
			 * Set the given GameRule's new value.
			 */
			setGameRule<T = any>(rule: org.bukkit.GameRule<T>, newValue: T): boolean;

			/**
			 * Gets the world border for this world.
			 */
			getWorldBorder(): org.bukkit.WorldBorder;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location.
			 */
			spawnParticle(particle: org.bukkit.Particle, location: org.bukkit.Location, count: number): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location.
			 */
			spawnParticle(particle: org.bukkit.Particle, x: number, y: number, z: number, count: number): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location.
			 */
			spawnParticle<T = any>(particle: org.bukkit.Particle, location: org.bukkit.Location, count: number, data: (T | null)): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location.
			 */
			spawnParticle<T = any>(particle: org.bukkit.Particle, x: number, y: number, z: number, count: number, data: (T | null)): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location. The position of each particle will be
			 * randomized positively and negatively by the offset parameters
			 * on each axis.
			 */
			spawnParticle(particle: org.bukkit.Particle, location: org.bukkit.Location, count: number, offsetX: number, offsetY: number, offsetZ: number): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location. The position of each particle will be
			 * randomized positively and negatively by the offset parameters
			 * on each axis.
			 */
			spawnParticle(particle: org.bukkit.Particle, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location. The position of each particle will be
			 * randomized positively and negatively by the offset parameters
			 * on each axis.
			 */
			spawnParticle<T = any>(particle: org.bukkit.Particle, location: org.bukkit.Location, count: number, offsetX: number, offsetY: number, offsetZ: number, data: (T | null)): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location. The position of each particle will be
			 * randomized positively and negatively by the offset parameters
			 * on each axis.
			 */
			spawnParticle<T = any>(particle: org.bukkit.Particle, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number, data: (T | null)): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location. The position of each particle will be
			 * randomized positively and negatively by the offset parameters
			 * on each axis.
			 */
			spawnParticle(particle: org.bukkit.Particle, location: org.bukkit.Location, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location. The position of each particle will be
			 * randomized positively and negatively by the offset parameters
			 * on each axis.
			 */
			spawnParticle(particle: org.bukkit.Particle, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location. The position of each particle will be
			 * randomized positively and negatively by the offset parameters
			 * on each axis.
			 */
			spawnParticle<T = any>(particle: org.bukkit.Particle, location: org.bukkit.Location, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number, data: (T | null)): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location. The position of each particle will be
			 * randomized positively and negatively by the offset parameters
			 * on each axis.
			 */
			spawnParticle<T = any>(particle: org.bukkit.Particle, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number, data: (T | null)): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location. The position of each particle will be
			 * randomized positively and negatively by the offset parameters
			 * on each axis.
			 */
			spawnParticle<T = any>(particle: org.bukkit.Particle, location: org.bukkit.Location, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number, data: (T | null), force: boolean): void;

			/**
			 * Spawns the particle (the number of times specified by count)
			 * at the target location. The position of each particle will be
			 * randomized positively and negatively by the offset parameters
			 * on each axis.
			 */
			spawnParticle<T = any>(particle: org.bukkit.Particle, x: number, y: number, z: number, count: number, offsetX: number, offsetY: number, offsetZ: number, extra: number, data: (T | null), force: boolean): void;

			/**
			 * Find the closest nearby structure of a given StructureType.
			 * Finding unexplored structures can, and will, block if the world is
			 * looking in chunks that gave not generated yet. This can lead to the world
			 * temporarily freezing while locating an unexplored structure.
			 * 
			 * The radius is not a rigid square radius. Each structure may alter
			 * how many chunks to check for each iteration. Do not assume that only a
			 * radius x radius chunk area will be checked. For example,
			 * StructureType.WOODLAND_MANSION can potentially check up to 20,000
			 * blocks away (or more) regardless of the radius used.
			 * 
			 * This will not load or generate chunks. This can also lead to
			 * instances where the server can hang if you are only looking for
			 * unexplored structures. This is because it will keep looking further and
			 * further out in order to find the structure.
			 */
			locateNearestStructure(origin: org.bukkit.Location, structureType: org.bukkit.StructureType, radius: number, findUnexplored: boolean): (org.bukkit.Location | null);

			/**
			 * Find the closest nearby structure of a given StructureType.
			 * Finding unexplored structures can, and will, block if the world is
			 * looking in chunks that gave not generated yet. This can lead to the world
			 * temporarily freezing while locating an unexplored structure.
			 * 
			 * The radius is not a rigid square radius. Each structure may alter
			 * how many chunks to check for each iteration. Do not assume that only a
			 * radius x radius chunk area will be checked. For example,
			 * StructureType.WOODLAND_MANSION can potentially check up to 20,000
			 * blocks away (or more) regardless of the radius used.
			 * 
			 * This will not load or generate chunks. This can also lead to
			 * instances where the server can hang if you are only looking for
			 * unexplored structures. This is because it will keep looking further and
			 * further out in order to find the structure.
			 * 
			 * The difference between searching for a StructureType and a
			 * Structure is, that a StructureType can refer to multiple
			 * Structures while searching for a Structure
			 * while only search for the given Structure.
			 */
			locateNearestStructure(origin: org.bukkit.Location, structureType: org.bukkit.generator.structure.StructureType, radius: number, findUnexplored: boolean): (org.bukkit.util.StructureSearchResult | null);

			/**
			 * Find the closest nearby structure of a given Structure. Finding
			 * unexplored structures can, and will, block if the world is looking in
			 * chunks that gave not generated yet. This can lead to the world
			 * temporarily freezing while locating an unexplored structure.
			 * 
			 * The radius is not a rigid square radius. Each structure may alter
			 * how many chunks to check for each iteration. Do not assume that only a
			 * radius x radius chunk area will be checked. For example,
			 * Structure.MANSION can potentially check up to 20,000 blocks away
			 * (or more) regardless of the radius used.
			 * 
			 * This will not load or generate chunks. This can also lead to
			 * instances where the server can hang if you are only looking for
			 * unexplored structures. This is because it will keep looking further and
			 * further out in order to find the structure.
			 * 
			 * The difference between searching for a StructureType and a
			 * Structure is, that a StructureType can refer to multiple
			 * Structures while searching for a Structure
			 * while only search for the given Structure.
			 */
			locateNearestStructure(origin: org.bukkit.Location, structure: org.bukkit.generator.structure.Structure, radius: number, findUnexplored: boolean): (org.bukkit.util.StructureSearchResult | null);

			/**
			 * Find the closest nearby location with a biome matching the provided
			 * Biome(s). Finding biomes can, and will, block if the world is looking
			 * in chunks that have not generated yet. This can lead to the world temporarily
			 * freezing while locating a biome.
			 * 
			 * Note: This will not reflect changes made to the world after
			 * generation, this method only sees the biome at the time of world generation.
			 * This will not load or generate chunks.
			 * 
			 * If multiple biomes are provided BiomeSearchResult.getBiome() will
			 * indicate which one was located.
			 * 
			 * This method will use a horizontal interval of 32 and a vertical interval of
			 * 64, equal to the /locate command.
			 */
			locateNearestBiome(origin: org.bukkit.Location, radius: number, ...biomes: org.bukkit.block.Biome[]): (org.bukkit.util.BiomeSearchResult | null);

			/**
			 * Find the closest nearby location with a biome matching the provided
			 * Biome(s). Finding biomes can, and will, block if the world is looking
			 * in chunks that have not generated yet. This can lead to the world temporarily
			 * freezing while locating a biome.
			 * 
			 * Note: This will not reflect changes made to the world after
			 * generation, this method only sees the biome at the time of world generation.
			 * This will not load or generate chunks.
			 * 
			 * If multiple biomes are provided BiomeSearchResult.getBiome() will
			 * indicate which one was located. Higher values for horizontalInterval
			 * and verticalInterval will result in faster searches, but may lead to
			 * small biomes being missed.
			 */
			locateNearestBiome(origin: org.bukkit.Location, radius: number, horizontalInterval: number, verticalInterval: number, ...biomes: org.bukkit.block.Biome[]): (org.bukkit.util.BiomeSearchResult | null);

			/**
			 * Finds the nearest raid close to the given location.
			 */
			locateNearestRaid(location: org.bukkit.Location, radius: number): (org.bukkit.Raid | null);

			/**
			 * Gets all raids that are going on over this world.
			 */
			getRaids(): globalThis.java.util.List<org.bukkit.Raid>;

			/**
			 * Get the DragonBattle associated with this world.
			 * If this world's environment is not World.Environment.THE_END, null will
			 * be returned.
			 * 
			 * If an end world, a dragon battle instance will be returned regardless of
			 * whether or not a dragon is present in the world or a fight sequence has
			 * been activated. The dragon battle instance acts as a state holder.
			 */
			getEnderDragonBattle(): (org.bukkit.boss.DragonBattle | null);

			/**
			 * Get all FeatureFlag enabled in this world.
			 */
			getFeatureFlags(): globalThis.java.util.Set<org.bukkit.FeatureFlag>;

			/**
			 * Gets all generated structures that intersect the chunk at the given
			 * coordinates.
			 * If no structures are present an empty collection will be returned.
			 */
			getStructures(x: number, z: number): globalThis.java.util.Collection<org.bukkit.generator.structure.GeneratedStructure>;

			/**
			 * Gets all generated structures of a given Structure that intersect
			 * the chunk at the given coordinates.
			 * If no structures are present an empty collection will be returned.
			 */
			getStructures(x: number, z: number, structure: org.bukkit.generator.structure.Structure): globalThis.java.util.Collection<org.bukkit.generator.structure.GeneratedStructure>;

		}> {}
		namespace World {
			interface Environment {
				/**
				 * Gets the dimension ID of this environment
				 */
				getId(): number;

			}
			namespace Environment {
				/**
				 * Represents the "normal"/"surface world" map
				 */
				const NORMAL: org.bukkit.World.Environment;

				/**
				 * Represents a nether based map ("hell")
				 */
				const NETHER: org.bukkit.World.Environment;

				/**
				 * Represents the "end" map
				 */
				const THE_END: org.bukkit.World.Environment;

				/**
				 * Represents a custom dimension
				 */
				const CUSTOM: org.bukkit.World.Environment;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.World.Environment;

				/**
				 * Get an environment by ID
				 */
				function getEnvironment(id: number): (org.bukkit.World.Environment | null);

			}
		}
		interface WorldBorder {
			/**
			 * Get the World in which the border resides.
			 */
			getWorld(): (org.bukkit.World | null);

			/**
			 * Resets the border to default values.
			 */
			reset(): void;

			/**
			 * Gets the current side length of the border.
			 */
			getSize(): number;

			/**
			 * Sets the border to a square region with the specified side length in blocks.
			 */
			setSize(newSize: number): void;

			/**
			 * Sets the border to a square region with the specified side length in blocks.
			 */
			setSize(newSize: number, seconds: number): void;

			/**
			 * Sets the border to a square region with the specified side length in blocks.
			 */
			setSize(newSize: number, unit: globalThis.java.util.concurrent.TimeUnit, time: number): void;

			/**
			 * Gets the current border center.
			 */
			getCenter(): org.bukkit.Location;

			/**
			 * Sets the new border center.
			 */
			setCenter(x: number, z: number): void;

			/**
			 * Sets the new border center.
			 */
			setCenter(location: org.bukkit.Location): void;

			/**
			 * Gets the current border damage buffer.
			 */
			getDamageBuffer(): number;

			/**
			 * Sets the amount of blocks a player may safely be outside the border before taking damage.
			 */
			setDamageBuffer(blocks: number): void;

			/**
			 * Gets the current border damage amount.
			 */
			getDamageAmount(): number;

			/**
			 * Sets the amount of damage a player takes when outside the border plus the border buffer.
			 */
			setDamageAmount(damage: number): void;

			/**
			 * Gets the current border warning time in seconds.
			 */
			getWarningTime(): number;

			/**
			 * Sets the warning time that causes the screen to be tinted red when a contracting border will reach the player within the specified time.
			 */
			setWarningTime(seconds: number): void;

			/**
			 * Gets the current border warning distance.
			 */
			getWarningDistance(): number;

			/**
			 * Sets the warning distance that causes the screen to be tinted red when the player is within the specified number of blocks from the border.
			 */
			setWarningDistance(distance: number): void;

			/**
			 * Check if the specified location is inside this border.
			 */
			isInside(location: org.bukkit.Location): boolean;

			/**
			 * Gets the maximum possible size of a WorldBorder.
			 */
			getMaxSize(): number;

			/**
			 * Gets the absolute value of the maximum x/z center coordinate of a
			 * WorldBorder.
			 */
			getMaxCenterCoordinate(): number;

		}
		interface WorldCreator {
			/**
			 * Copies the options from the specified world
			 */
			copy(world: org.bukkit.World): org.bukkit.WorldCreator;

			/**
			 * Copies the options from the specified WorldCreator
			 */
			copy(creator: org.bukkit.WorldCreator): org.bukkit.WorldCreator;

			/**
			 * Gets the name of the world that is to be loaded or created.
			 */
			name(): string;

			/**
			 * Gets the seed that will be used to create this world
			 */
			seed(): number;

			/**
			 * Sets the seed that will be used to create this world
			 */
			seed(seed: number): org.bukkit.WorldCreator;

			/**
			 * Gets the environment that will be used to create or load the world
			 */
			environment(): org.bukkit.World.Environment;

			/**
			 * Sets the environment that will be used to create or load the world
			 */
			environment(env: org.bukkit.World.Environment): org.bukkit.WorldCreator;

			/**
			 * Gets the type of the world that will be created or loaded
			 */
			type(): org.bukkit.WorldType;

			/**
			 * Sets the type of the world that will be created or loaded
			 */
			type(type: org.bukkit.WorldType): org.bukkit.WorldCreator;

			/**
			 * Gets the generator that will be used to create or load the world.
			 * 
			 * This may be null, in which case the "natural" generator for this
			 * environment will be used.
			 */
			generator(): (org.bukkit.generator.ChunkGenerator | null);

			/**
			 * Sets the generator that will be used to create or load the world.
			 * 
			 * This may be null, in which case the "natural" generator for this
			 * environment will be used.
			 */
			generator(generator: (org.bukkit.generator.ChunkGenerator | null)): org.bukkit.WorldCreator;

			/**
			 * Sets the generator that will be used to create or load the world.
			 * 
			 * This may be null, in which case the "natural" generator for this
			 * environment will be used.
			 * 
			 * If the generator cannot be found for the given name, the natural
			 * environment generator will be used instead and a warning will be
			 * printed to the console.
			 */
			generator(generator: (string | null)): org.bukkit.WorldCreator;

			/**
			 * Sets the generator that will be used to create or load the world.
			 * 
			 * This may be null, in which case the "natural" generator for this
			 * environment will be used.
			 * 
			 * If the generator cannot be found for the given name, the natural
			 * environment generator will be used instead and a warning will be
			 * printed to the specified output
			 */
			generator(generator: (string | null), output: (org.bukkit.command.CommandSender | null)): org.bukkit.WorldCreator;

			/**
			 * Gets the biome provider that will be used to create or load the world.
			 * 
			 * This may be null, in which case the biome provider from the ChunkGenerator
			 * will be used. If no ChunkGenerator is specific the "natural" biome provider
			 * for this environment will be used.
			 */
			biomeProvider(): (org.bukkit.generator.BiomeProvider | null);

			/**
			 * Sets the biome provider that will be used to create or load the world.
			 * 
			 * This may be null, in which case the biome provider from the
			 * ChunkGenerator will be used. If no ChunkGenerator is
			 * specific the "natural" biome provider for this environment will be used.
			 */
			biomeProvider(biomeProvider: (org.bukkit.generator.BiomeProvider | null)): org.bukkit.WorldCreator;

			/**
			 * Sets the biome provider that will be used to create or load the world.
			 * 
			 * This may be null, in which case the biome provider from the
			 * ChunkGenerator will be used. If no ChunkGenerator is
			 * specific the "natural" biome provider for this environment will be used.
			 * 
			 * If the biome provider cannot be found for the given name and no
			 * ChunkGenerator is specific, the natural environment biome
			 * provider will be used instead and a warning will be printed to the
			 * specified output
			 */
			biomeProvider(biomeProvider: (string | null)): org.bukkit.WorldCreator;

			/**
			 * Sets the biome provider that will be used to create or load the world.
			 * 
			 * This may be null, in which case the biome provider from the
			 * ChunkGenerator will be used. If no ChunkGenerator is
			 * specific the "natural" biome provider for this environment will be used.
			 * 
			 * If the biome provider cannot be found for the given name and no
			 * ChunkGenerator is specific, the natural environment biome
			 * provider will be used instead and a warning will be printed to the
			 * specified output
			 */
			biomeProvider(biomeProvider: (string | null), output: (org.bukkit.command.CommandSender | null)): org.bukkit.WorldCreator;

			/**
			 * Sets the generator settings of the world that will be created or loaded.
			 * 
			 * Currently only WorldType.FLAT uses these settings, and expects
			 * them to be in JSON format with a valid biome (1.18.2 and
			 * above) defined. An example valid configuration is as follows:
			 * {"layers": [{"block": "stone", "height": 1}, {"block": "grass_block", "height": 1}], "biome":"plains"}
			 */
			generatorSettings(generatorSettings: string): org.bukkit.WorldCreator;

			/**
			 * Gets the generator settings of the world that will be created or loaded.
			 */
			generatorSettings(): string;

			/**
			 * Sets whether or not worlds created or loaded with this creator will
			 * have structures.
			 */
			generateStructures(generate: boolean): org.bukkit.WorldCreator;

			/**
			 * Gets whether or not structures will be generated in the world.
			 */
			generateStructures(): boolean;

			/**
			 * Sets whether the world will be hardcore or not.
			 * In a hardcore world the difficulty will be locked to hard.
			 */
			hardcore(hardcore: boolean): org.bukkit.WorldCreator;

			/**
			 * Gets whether the world will be hardcore or not.
			 * In a hardcore world the difficulty will be locked to hard.
			 */
			hardcore(): boolean;

			/**
			 * Sets whether the spawn chunks will be kept loaded.
			 * Setting this to false will also stop the spawn chunks from being generated
			 * when creating a new world.
			 * 
			 * Has little performance benefit unless paired with a ChunkGenerator
			 * that overrides ChunkGenerator.getFixedSpawnLocation(World, Random).
			 */
			keepSpawnInMemory(keepSpawnInMemory: boolean): org.bukkit.WorldCreator;

			/**
			 * Gets whether or not the spawn chunks will be kept loaded.
			 */
			keepSpawnInMemory(): boolean;

			/**
			 * Creates a world with the specified options.
			 * 
			 * If the world already exists, it will be loaded from disk and some
			 * options may be ignored.
			 */
			createWorld(): (org.bukkit.World | null);

		}
		class WorldCreator {
			/**
			 * Creates an empty WorldCreationOptions for the given world name
			 */
			constructor(name: string);

		}
		namespace WorldCreator {
			/**
			 * Creates a new WorldCreator for the given world name
			 */
			function name(name: string): org.bukkit.WorldCreator;

			/**
			 * Attempts to get the ChunkGenerator with the given name.
			 * 
			 * If the generator is not found, null will be returned and a message will
			 * be printed to the specified CommandSender explaining why.
			 * 
			 * The name must be in the "plugin:id" notation, or optionally just
			 * "plugin", where "plugin" is the safe-name of a plugin and "id" is an
			 * optional unique identifier for the generator you wish to request from
			 * the plugin.
			 */
			function getGeneratorForName(world: string, name: (string | null), output: (org.bukkit.command.CommandSender | null)): (org.bukkit.generator.ChunkGenerator | null);

			/**
			 * Attempts to get the BiomeProvider with the given name.
			 * 
			 * If the biome provider is not found, null will be returned and a message
			 * will be printed to the specified CommandSender explaining why.
			 * 
			 * The name must be in the "plugin:id" notation, or optionally just
			 * "plugin", where "plugin" is the safe-name of a plugin and "id" is an
			 * optional unique identifier for the biome provider you wish to request
			 * from the plugin.
			 */
			function getBiomeProviderForName(world: string, name: (string | null), output: (org.bukkit.command.CommandSender | null)): (org.bukkit.generator.BiomeProvider | null);

		}
		interface WorldType {
			/**
			 * Gets the name of this WorldType
			 */
			getName(): string;

		}
		namespace WorldType {
			const NORMAL: org.bukkit.WorldType;

			const FLAT: org.bukkit.WorldType;

			const LARGE_BIOMES: org.bukkit.WorldType;

			const AMPLIFIED: org.bukkit.WorldType;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.WorldType;

			/**
			 * Gets a WorldType by its name
			 */
			function getByName(name: string): (org.bukkit.WorldType | null);

		}
	}
	namespace org.bukkit.event.player {
		interface AsyncPlayerChatEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the message that the player is attempting to send. This message
			 * will be used with getFormat().
			 */
			getMessage(): string;

			/**
			 * Sets the message that the player will send. This message will be used
			 * with getFormat().
			 */
			setMessage(message: string): void;

			/**
			 * Gets the format to use to display this chat message.
			 * 
			 * When this event finishes execution, the first format parameter is the
			 * Player.getDisplayName() and the second parameter is getMessage()
			 */
			getFormat(): string;

			/**
			 * Sets the format to use to display this chat message.
			 * 
			 * When this event finishes execution, the first format parameter is the
			 * Player.getDisplayName() and the second parameter is getMessage()
			 */
			setFormat(format: string): void;

			/**
			 * Gets a set of recipients that this chat message will be displayed to.
			 * 
			 * The set returned is not guaranteed to be mutable and may auto-populate
			 * on access. Any listener accessing the returned set should be aware that
			 * it may reduce performance for a lazy set implementation.
			 * 
			 * Listeners should be aware that modifying the list may throw UnsupportedOperationException if the event caller provides an
			 * unmodifiable set.
			 */
			getRecipients(): globalThis.java.util.Set<org.bukkit.entity.Player>;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class AsyncPlayerChatEvent {
			constructor(async: boolean, who: org.bukkit.entity.Player, message: string, players: globalThis.java.util.Set<org.bukkit.entity.Player>);

		}
		namespace AsyncPlayerChatEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface AsyncPlayerChatPreviewEvent extends Modify<org.bukkit.event.player.AsyncPlayerChatEvent, {
			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class AsyncPlayerChatPreviewEvent {
			constructor(async: boolean, who: org.bukkit.entity.Player, message: string, players: globalThis.java.util.Set<org.bukkit.entity.Player>);

		}
		namespace AsyncPlayerChatPreviewEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface AsyncPlayerPreLoginEvent extends Modify<org.bukkit.event.Event, {
			/**
			 * Gets the current result of the login, as an enum
			 */
			getLoginResult(): org.bukkit.event.player.AsyncPlayerPreLoginEvent.Result;

			/**
			 * Gets the current result of the login, as an enum
			 */
			getResult(): org.bukkit.event.player.PlayerPreLoginEvent.Result;

			/**
			 * Sets the new result of the login, as an enum
			 */
			setLoginResult(result: org.bukkit.event.player.AsyncPlayerPreLoginEvent.Result): void;

			/**
			 * Sets the new result of the login, as an enum
			 */
			setResult(result: org.bukkit.event.player.PlayerPreLoginEvent.Result): void;

			/**
			 * Gets the current kick message that will be used if getResult() !=
			 * Result.ALLOWED
			 */
			getKickMessage(): string;

			/**
			 * Sets the kick message to display if getResult() != Result.ALLOWED
			 */
			setKickMessage(message: string): void;

			/**
			 * Allows the player to log in
			 */
			allow(): void;

			/**
			 * Disallows the player from logging in, with the given reason
			 */
			disallow(result: org.bukkit.event.player.AsyncPlayerPreLoginEvent.Result, message: string): void;

			/**
			 * Disallows the player from logging in, with the given reason
			 */
			disallow(result: org.bukkit.event.player.PlayerPreLoginEvent.Result, message: string): void;

			/**
			 * Gets the player's name.
			 */
			getName(): string;

			/**
			 * Gets the player IP address.
			 */
			getAddress(): any /* java.net.InetAddress */;

			/**
			 * Gets the player's unique ID.
			 */
			getUniqueId(): globalThis.java.util.UUID;

			/**
			 * Gets if this connection has been transferred from another server.
			 */
			isTransferred(): boolean;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class AsyncPlayerPreLoginEvent {
			constructor(name: string, ipAddress: any /* java.net.InetAddress */);

			constructor(name: string, ipAddress: any /* java.net.InetAddress */, uniqueId: globalThis.java.util.UUID);

			constructor(name: string, ipAddress: any /* java.net.InetAddress */, uniqueId: globalThis.java.util.UUID, transferred: boolean);

		}
		namespace AsyncPlayerPreLoginEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace AsyncPlayerPreLoginEvent {
			interface Result {}
			namespace Result {
				/**
				 * The player is allowed to log in
				 */
				const ALLOWED: org.bukkit.event.player.AsyncPlayerPreLoginEvent.Result;

				/**
				 * The player is not allowed to log in, due to the server being full
				 */
				const KICK_FULL: org.bukkit.event.player.AsyncPlayerPreLoginEvent.Result;

				/**
				 * The player is not allowed to log in, due to them being banned
				 */
				const KICK_BANNED: org.bukkit.event.player.AsyncPlayerPreLoginEvent.Result;

				/**
				 * The player is not allowed to log in, due to them not being on the
				 * white list
				 */
				const KICK_WHITELIST: org.bukkit.event.player.AsyncPlayerPreLoginEvent.Result;

				/**
				 * The player is not allowed to log in, for reasons undefined
				 */
				const KICK_OTHER: org.bukkit.event.player.AsyncPlayerPreLoginEvent.Result;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.player.AsyncPlayerPreLoginEvent.Result;

			}
		}
		interface PlayerAdvancementDoneEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Get the advancement which has been completed.
			 */
			getAdvancement(): org.bukkit.advancement.Advancement;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerAdvancementDoneEvent {
			constructor(who: org.bukkit.entity.Player, advancement: org.bukkit.advancement.Advancement);

		}
		namespace PlayerAdvancementDoneEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerAnimationEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Get the type of this animation event
			 */
			getAnimationType(): org.bukkit.event.player.PlayerAnimationType;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerAnimationEvent {
			constructor(player: org.bukkit.entity.Player);

			/**
			 * Construct a new PlayerAnimation event
			 */
			constructor(player: org.bukkit.entity.Player, playerAnimationType: org.bukkit.event.player.PlayerAnimationType);

		}
		namespace PlayerAnimationEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerAnimationType {}
		namespace PlayerAnimationType {
			const ARM_SWING: org.bukkit.event.player.PlayerAnimationType;

			const OFF_ARM_SWING: org.bukkit.event.player.PlayerAnimationType;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.event.player.PlayerAnimationType;

		}
		interface PlayerArmorStandManipulateEvent extends Modify<org.bukkit.event.player.PlayerInteractEntityEvent, {
			/**
			 * Returns the item held by the player.
			 * 
			 * If this item is empty and the armor stand item is also empty, there will be no
			 * transaction between the player and the armor stand. If the player's item is empty
			 * but the armor stand item is not, the player's item will be placed on the armor
			 * stand. If both items are not empty, the items will be swapped.
			 * 
			 * In the case that this event is cancelled, the original items will remain the same.
			 */
			getPlayerItem(): org.bukkit.inventory.ItemStack;

			/**
			 * Returns the item held by the armor stand.
			 * 
			 * If this item is empty and the player's item is also empty, there will be no
			 * transaction between the player and the armor stand. If the player's item is empty
			 * but the armor stand item is not, then the player will obtain the armor stand item.
			 * In the case that the player's item is not empty but the armor stand item is empty,
			 * the player's item will be placed on the armor stand. If both items are not empty,
			 * the items will be swapped.
			 * 
			 * In the case that the event is cancelled the original items will remain the same.
			 */
			getArmorStandItem(): org.bukkit.inventory.ItemStack;

			/**
			 * Returns the raw item slot of the armor stand in this event.
			 */
			getSlot(): org.bukkit.inventory.EquipmentSlot;

			/**
			 * The hand used to perform this interaction.
			 * 
			 * Note that this is not the hand of the armor stand that was changed, but rather
			 * the hand used by the player to swap items with the armor stand.
			 */
			getHand(): org.bukkit.inventory.EquipmentSlot;

			/**
			 * Description copied from class:Â PlayerInteractEntityEvent
			 */
			getRightClicked(): org.bukkit.entity.ArmorStand;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerArmorStandManipulateEvent {
			constructor(who: org.bukkit.entity.Player, clickedEntity: org.bukkit.entity.ArmorStand, playerItem: org.bukkit.inventory.ItemStack, armorStandItem: org.bukkit.inventory.ItemStack, slot: org.bukkit.inventory.EquipmentSlot, hand: org.bukkit.inventory.EquipmentSlot);

			constructor(who: org.bukkit.entity.Player, clickedEntity: org.bukkit.entity.ArmorStand, playerItem: org.bukkit.inventory.ItemStack, armorStandItem: org.bukkit.inventory.ItemStack, slot: org.bukkit.inventory.EquipmentSlot);

		}
		namespace PlayerArmorStandManipulateEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerBedEnterEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * This describes the default outcome of this event.
			 */
			getBedEnterResult(): org.bukkit.event.player.PlayerBedEnterEvent.BedEnterResult;

			/**
			 * This controls the action to take with the bed that was clicked on.
			 * 
			 * In case of Event.Result.DEFAULT, the default outcome is described by
			 * getBedEnterResult().
			 */
			useBed(): org.bukkit.event.Event.Result;

			/**
			 * Sets the action to take with the interacted bed.
			 * 
			 * Event.Result.ALLOW will result in the player sleeping, regardless of
			 * the default outcome described by getBedEnterResult().
			 * 
			 * Event.Result.DENY will prevent the player from sleeping. This has the
			 * same effect as canceling the event via setCancelled(boolean).
			 * 
			 * Event.Result.DEFAULT will result in the outcome described by
			 * getBedEnterResult().
			 */
			setUseBed(useBed: org.bukkit.event.Event.Result): void;

			/**
			 * Gets the cancellation state of this event. Set to true if you want to
			 * prevent the player from sleeping.
			 * 
			 * Canceling the event has the same effect as setting useBed() to
			 * Event.Result.DENY.
			 * 
			 * For backwards compatibility reasons this also returns true if
			 * useBed() is Event.Result.DEFAULT and the
			 * default action is to prevent bed entering.
			 */
			isCancelled(): boolean;

			/**
			 * Sets the cancellation state of this event. A canceled event will not be
			 * executed in the server, but will still pass to other plugins.
			 * 
			 * Canceling this event will prevent use of the bed.
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Returns the bed block involved in this event.
			 */
			getBed(): org.bukkit.block.Block;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerBedEnterEvent {
			constructor(who: org.bukkit.entity.Player, bed: org.bukkit.block.Block, bedEnterResult: org.bukkit.event.player.PlayerBedEnterEvent.BedEnterResult);

			constructor(who: org.bukkit.entity.Player, bed: org.bukkit.block.Block);

		}
		namespace PlayerBedEnterEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace PlayerBedEnterEvent {
			interface BedEnterResult {}
			namespace BedEnterResult {
				/**
				 * The player will enter the bed.
				 */
				const OK: org.bukkit.event.player.PlayerBedEnterEvent.BedEnterResult;

				/**
				 * The world doesn't allow sleeping or saving the spawn point (eg,
				 * Nether, The End or Custom Worlds). This is based on
				 * World.isBedWorks() and World.isNatural().
				 * Entering the bed is prevented and if World.isBedWorks() is
				 * false then the bed explodes.
				 */
				const NOT_POSSIBLE_HERE: org.bukkit.event.player.PlayerBedEnterEvent.BedEnterResult;

				/**
				 * Entering the bed is prevented due to it not being night nor
				 * thundering currently.
				 * 
				 * If the event is forcefully allowed during daytime, the player will
				 * enter the bed (and set its bed location), but might get immediately
				 * thrown out again.
				 */
				const NOT_POSSIBLE_NOW: org.bukkit.event.player.PlayerBedEnterEvent.BedEnterResult;

				/**
				 * Entering the bed is prevented due to the player being too far away.
				 */
				const TOO_FAR_AWAY: org.bukkit.event.player.PlayerBedEnterEvent.BedEnterResult;

				/**
				 * Entering the bed is prevented due to there being monsters nearby.
				 */
				const NOT_SAFE: org.bukkit.event.player.PlayerBedEnterEvent.BedEnterResult;

				/**
				 * Entering the bed is prevented due to there being some other problem.
				 */
				const OTHER_PROBLEM: org.bukkit.event.player.PlayerBedEnterEvent.BedEnterResult;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.player.PlayerBedEnterEvent.BedEnterResult;

			}
		}
		interface PlayerBedLeaveEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Returns the bed block involved in this event.
			 */
			getBed(): org.bukkit.block.Block;

			/**
			 * Get if this event should set the new spawn location for the
			 * Player.
			 * 
			 * This does not remove any existing spawn location, only prevent it from
			 * being changed (if true).
			 * 
			 * To change a Player's spawn location, use
			 * Player.setBedSpawnLocation(Location).
			 */
			shouldSetSpawnLocation(): boolean;

			/**
			 * Set if this event should set the new spawn location for the
			 * Player.
			 * 
			 * This will not remove any existing spawn location, only prevent it from
			 * being changed (if true).
			 * 
			 * To change a Player's spawn location, use
			 * Player.setBedSpawnLocation(Location).
			 */
			setSpawnLocation(setBedSpawn: boolean): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancelled: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerBedLeaveEvent {
			constructor(who: org.bukkit.entity.Player, bed: org.bukkit.block.Block, setBedSpawn: boolean);

		}
		namespace PlayerBedLeaveEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerBucketEmptyEvent extends Modify<org.bukkit.event.player.PlayerBucketEvent, {
			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerBucketEmptyEvent {
			constructor(who: org.bukkit.entity.Player, blockClicked: org.bukkit.block.Block, blockFace: org.bukkit.block.BlockFace, bucket: org.bukkit.Material, itemInHand: org.bukkit.inventory.ItemStack);

			constructor(who: org.bukkit.entity.Player, block: org.bukkit.block.Block, blockClicked: org.bukkit.block.Block, blockFace: org.bukkit.block.BlockFace, bucket: org.bukkit.Material, itemInHand: org.bukkit.inventory.ItemStack);

			constructor(who: org.bukkit.entity.Player, block: org.bukkit.block.Block, blockClicked: org.bukkit.block.Block, blockFace: org.bukkit.block.BlockFace, bucket: org.bukkit.Material, itemInHand: org.bukkit.inventory.ItemStack, hand: org.bukkit.inventory.EquipmentSlot);

		}
		namespace PlayerBucketEmptyEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerBucketEntityEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the Entity being put into the bucket.
			 */
			getEntity(): org.bukkit.entity.Entity;

			/**
			 * Gets the bucket used to capture the Entity.
			 * This refers to the bucket clicked with, eg Material.WATER_BUCKET.
			 */
			getOriginalBucket(): org.bukkit.inventory.ItemStack;

			/**
			 * Gets the bucket that the Entity will be put into.
			 * This refers to the bucket with the entity, eg
			 * Material.PUFFERFISH_BUCKET.
			 */
			getEntityBucket(): org.bukkit.inventory.ItemStack;

			/**
			 * Get the hand that was used to bucket the entity.
			 */
			getHand(): org.bukkit.inventory.EquipmentSlot;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerBucketEntityEvent {
			constructor(player: org.bukkit.entity.Player, entity: org.bukkit.entity.Entity, originalBucket: org.bukkit.inventory.ItemStack, entityBucket: org.bukkit.inventory.ItemStack, hand: org.bukkit.inventory.EquipmentSlot);

		}
		namespace PlayerBucketEntityEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerBucketEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Returns the bucket used in this event
			 */
			getBucket(): org.bukkit.Material;

			/**
			 * Get the resulting item in hand after the bucket event
			 */
			getItemStack(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Set the item in hand after the event
			 */
			setItemStack(itemStack: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Gets the block involved in this event.
			 */
			getBlock(): org.bukkit.block.Block;

			/**
			 * Return the block clicked
			 */
			getBlockClicked(): org.bukkit.block.Block;

			/**
			 * Get the face on the clicked block
			 */
			getBlockFace(): org.bukkit.block.BlockFace;

			/**
			 * Get the hand that was used in this event.
			 */
			getHand(): org.bukkit.inventory.EquipmentSlot;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

		}> {}
		class PlayerBucketEvent {
			constructor(who: org.bukkit.entity.Player, blockClicked: org.bukkit.block.Block, blockFace: org.bukkit.block.BlockFace, bucket: org.bukkit.Material, itemInHand: org.bukkit.inventory.ItemStack);

			constructor(who: org.bukkit.entity.Player, block: org.bukkit.block.Block, blockClicked: org.bukkit.block.Block, blockFace: org.bukkit.block.BlockFace, bucket: org.bukkit.Material, itemInHand: org.bukkit.inventory.ItemStack);

			constructor(who: org.bukkit.entity.Player, block: org.bukkit.block.Block, blockClicked: org.bukkit.block.Block, blockFace: org.bukkit.block.BlockFace, bucket: org.bukkit.Material, itemInHand: org.bukkit.inventory.ItemStack, hand: org.bukkit.inventory.EquipmentSlot);

		}
		interface PlayerBucketFillEvent extends Modify<org.bukkit.event.player.PlayerBucketEvent, {
			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerBucketFillEvent {
			constructor(who: org.bukkit.entity.Player, blockClicked: org.bukkit.block.Block, blockFace: org.bukkit.block.BlockFace, bucket: org.bukkit.Material, itemInHand: org.bukkit.inventory.ItemStack);

			constructor(who: org.bukkit.entity.Player, block: org.bukkit.block.Block, blockClicked: org.bukkit.block.Block, blockFace: org.bukkit.block.BlockFace, bucket: org.bukkit.Material, itemInHand: org.bukkit.inventory.ItemStack);

			constructor(who: org.bukkit.entity.Player, block: org.bukkit.block.Block, blockClicked: org.bukkit.block.Block, blockFace: org.bukkit.block.BlockFace, bucket: org.bukkit.Material, itemInHand: org.bukkit.inventory.ItemStack, hand: org.bukkit.inventory.EquipmentSlot);

		}
		namespace PlayerBucketFillEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerBucketFishEvent extends Modify<org.bukkit.event.player.PlayerBucketEntityEvent, {
			/**
			 * Gets the fish involved with this event.
			 */
			getEntity(): org.bukkit.entity.Fish;

			/**
			 * Gets the bucket used.
			 * This refers to the bucket clicked with, ie Material.WATER_BUCKET.
			 */
			getWaterBucket(): org.bukkit.inventory.ItemStack;

			/**
			 * Gets the bucket that the fish will be put into.
			 * This refers to the bucket with the fish, ie
			 * Material.PUFFERFISH_BUCKET.
			 */
			getFishBucket(): org.bukkit.inventory.ItemStack;

		}> {}
		class PlayerBucketFishEvent {
			constructor(player: org.bukkit.entity.Player, fish: org.bukkit.entity.Fish, waterBucket: org.bukkit.inventory.ItemStack, fishBucket: org.bukkit.inventory.ItemStack, hand: org.bukkit.inventory.EquipmentSlot);

		}
		interface PlayerChangedMainHandEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the new main hand of the player. The old hand is still momentarily
			 * available via HumanEntity.getMainHand().
			 */
			getMainHand(): org.bukkit.inventory.MainHand;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerChangedMainHandEvent {
			constructor(who: org.bukkit.entity.Player, mainHand: org.bukkit.inventory.MainHand);

		}
		namespace PlayerChangedMainHandEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerChangedWorldEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the world the player is switching from.
			 */
			getFrom(): org.bukkit.World;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerChangedWorldEvent {
			constructor(player: org.bukkit.entity.Player, from: org.bukkit.World);

		}
		namespace PlayerChangedWorldEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerChannelEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			getChannel(): string;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerChannelEvent {
			constructor(player: org.bukkit.entity.Player, channel: string);

		}
		namespace PlayerChannelEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerChatEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the message that the player is attempting to send
			 */
			getMessage(): string;

			/**
			 * Sets the message that the player will send
			 */
			setMessage(message: string): void;

			/**
			 * Sets the player that this message will display as, or command will be
			 * executed as
			 */
			setPlayer(player: org.bukkit.entity.Player): void;

			/**
			 * Gets the format to use to display this chat message
			 */
			getFormat(): string;

			/**
			 * Sets the format to use to display this chat message
			 */
			setFormat(format: string): void;

			/**
			 * Gets a set of recipients that this chat message will be displayed to
			 */
			getRecipients(): globalThis.java.util.Set<org.bukkit.entity.Player>;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerChatEvent {
			constructor(player: org.bukkit.entity.Player, message: string);

			constructor(player: org.bukkit.entity.Player, message: string, format: string, recipients: globalThis.java.util.Set<org.bukkit.entity.Player>);

		}
		namespace PlayerChatEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerChatTabCompleteEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the chat message being tab-completed.
			 */
			getChatMessage(): string;

			/**
			 * Gets the last 'token' of the message being tab-completed.
			 * 
			 * The token is the substring starting with the character after the last
			 * space in the message.
			 */
			getLastToken(): string;

			/**
			 * This is the collection of completions for this event.
			 */
			getTabCompletions(): globalThis.java.util.Collection<string>;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerChatTabCompleteEvent {
			constructor(who: org.bukkit.entity.Player, message: string, completions: globalThis.java.util.Collection<string>);

		}
		namespace PlayerChatTabCompleteEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerCommandPreprocessEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the command that the player is attempting to send.
			 * 
			 * All commands begin with a special character; implementations do not
			 * consider the first character when executing the content.
			 */
			getMessage(): string;

			/**
			 * Sets the command that the player will send.
			 * 
			 * All commands begin with a special character; implementations do not
			 * consider the first character when executing the content.
			 */
			setMessage(command: string): void;

			/**
			 * Sets the player that this command will be executed as.
			 */
			setPlayer(player: org.bukkit.entity.Player): void;

			/**
			 * Gets a set of recipients that this chat message will be displayed to.
			 * 
			 * The set returned is not guaranteed to be mutable and may auto-populate
			 * on access. Any listener accessing the returned set should be aware that
			 * it may reduce performance for a lazy set implementation. Listeners
			 * should be aware that modifying the list may throw UnsupportedOperationException if the event caller provides an
			 * unmodifiable set.
			 */
			getRecipients(): globalThis.java.util.Set<org.bukkit.entity.Player>;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerCommandPreprocessEvent {
			constructor(player: org.bukkit.entity.Player, message: string);

			constructor(player: org.bukkit.entity.Player, message: string, recipients: globalThis.java.util.Set<org.bukkit.entity.Player>);

		}
		namespace PlayerCommandPreprocessEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerCommandSendEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Returns a mutable collection of all top level commands to be sent.
			 * 
			 * It is not legal to add entries to this collection, only remove them.
			 * Behaviour of adding entries is undefined.
			 */
			getCommands(): globalThis.java.util.Collection<string>;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerCommandSendEvent {
			constructor(player: org.bukkit.entity.Player, commands: globalThis.java.util.Collection<string>);

		}
		namespace PlayerCommandSendEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerDropItemEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the ItemDrop created by the player
			 */
			getItemDrop(): org.bukkit.entity.Item;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerDropItemEvent {
			constructor(player: org.bukkit.entity.Player, drop: org.bukkit.entity.Item);

		}
		namespace PlayerDropItemEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerEditBookEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the book meta currently on the book.
			 * 
			 * Note: this is a copy of the book meta. You cannot use this object to
			 * change the existing book meta.
			 */
			getPreviousBookMeta(): org.bukkit.inventory.meta.BookMeta;

			/**
			 * Gets the book meta that the player is attempting to add to the book.
			 * 
			 * Note: this is a copy of the proposed new book meta. Use setNewBookMeta(BookMeta) to change what will actually be added to the
			 * book.
			 */
			getNewBookMeta(): org.bukkit.inventory.meta.BookMeta;

			/**
			 * Gets the inventory slot number for the book item that triggered this
			 * event.
			 * 
			 * This is a slot number on the player's hotbar in the range 0-8, or -1 for
			 * off hand.
			 */
			getSlot(): number;

			/**
			 * Sets the book meta that will actually be added to the book.
			 */
			setNewBookMeta(newBookMeta: org.bukkit.inventory.meta.BookMeta): void;

			/**
			 * Gets whether or not the book is being signed. If a book is signed the
			 * Material changes from BOOK_AND_QUILL to WRITTEN_BOOK.
			 */
			isSigning(): boolean;

			/**
			 * Sets whether or not the book is being signed. If a book is signed the
			 * Material changes from BOOK_AND_QUILL to WRITTEN_BOOK.
			 */
			setSigning(signing: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

		}> {}
		class PlayerEditBookEvent {
			constructor(who: org.bukkit.entity.Player, slot: number, previousBookMeta: org.bukkit.inventory.meta.BookMeta, newBookMeta: org.bukkit.inventory.meta.BookMeta, isSigning: boolean);

		}
		namespace PlayerEditBookEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerEggThrowEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the egg involved in this event.
			 */
			getEgg(): org.bukkit.entity.Egg;

			/**
			 * Gets whether the egg is hatching or not. Will be what the server
			 * would've done without interaction.
			 */
			isHatching(): boolean;

			/**
			 * Sets whether the egg will hatch or not.
			 */
			setHatching(hatching: boolean): void;

			/**
			 * Get the type of the mob being hatched (EntityType.CHICKEN by default)
			 */
			getHatchingType(): org.bukkit.entity.EntityType;

			/**
			 * Change the type of mob being hatched by the egg
			 */
			setHatchingType(hatchType: org.bukkit.entity.EntityType): void;

			/**
			 * Get the number of mob hatches from the egg. By default the number will
			 * be the number the server would've done
			 * 
			 * 7/8 chance of being 0
			 * 31/256 ~= 1/8 chance to be 1
			 * 1/256 chance to be 4
			 * 
			 */
			getNumHatches(): any /* byte */;

			/**
			 * Change the number of mobs coming out of the hatched egg
			 * 
			 * The boolean hatching will override this number. Ie. If hatching =
			 * false, this number will not matter
			 */
			setNumHatches(numHatches: any /* byte */): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerEggThrowEvent {
			constructor(player: org.bukkit.entity.Player, egg: org.bukkit.entity.Egg, hatching: boolean, numHatches: any /* byte */, hatchingType: org.bukkit.entity.EntityType);

		}
		namespace PlayerEggThrowEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerEvent extends Modify<org.bukkit.event.Event, {
			/**
			 * Returns the player involved in this event
			 */
			getPlayer(): org.bukkit.entity.Player;

		}> {}
		class PlayerEvent {
			constructor(who: org.bukkit.entity.Player);

		}
		interface PlayerExpChangeEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Get the amount of experience the player will receive
			 */
			getAmount(): number;

			/**
			 * Set the amount of experience the player will receive
			 */
			setAmount(amount: number): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerExpChangeEvent {
			constructor(player: org.bukkit.entity.Player, expAmount: number);

		}
		namespace PlayerExpChangeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerExpCooldownChangeEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the reason for the change.
			 */
			getReason(): org.bukkit.event.player.PlayerExpCooldownChangeEvent.ChangeReason;

			/**
			 * Gets the new cooldown for the player.
			 */
			getNewCooldown(): number;

			/**
			 * Sets the new cooldown for the player.
			 */
			setNewCooldown(newCooldown: number): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerExpCooldownChangeEvent {
			constructor(player: org.bukkit.entity.Player, newcooldown: number, reason: org.bukkit.event.player.PlayerExpCooldownChangeEvent.ChangeReason);

		}
		namespace PlayerExpCooldownChangeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace PlayerExpCooldownChangeEvent {
			interface ChangeReason {}
			namespace ChangeReason {
				/**
				 * The cooldown was set by picking up an experience orb.
				 */
				const PICKUP_ORB: org.bukkit.event.player.PlayerExpCooldownChangeEvent.ChangeReason;

				/**
				 * The cooldown was set by a plugin.
				 */
				const PLUGIN: org.bukkit.event.player.PlayerExpCooldownChangeEvent.ChangeReason;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.player.PlayerExpCooldownChangeEvent.ChangeReason;

			}
		}
		interface PlayerFishEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the entity caught by the player.
			 * 
			 * If player has fished successfully, the result may be cast to Item.
			 */
			getCaught(): (org.bukkit.entity.Entity | null);

			/**
			 * Gets the fishing hook.
			 */
			getHook(): org.bukkit.entity.FishHook;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the amount of experience received when fishing.
			 * 
			 * Note: This value has no default effect unless the event state is PlayerFishEvent.State.CAUGHT_FISH.
			 */
			getExpToDrop(): number;

			/**
			 * Sets the amount of experience received when fishing.
			 * 
			 * Note: This value has no default effect unless the event state is PlayerFishEvent.State.CAUGHT_FISH.
			 */
			setExpToDrop(amount: number): void;

			/**
			 * Get the hand that was used in this event.
			 * 
			 * The hand used is only present when the event state is PlayerFishEvent.State.FISHING.
			 * In all other states, the hand is null.
			 */
			getHand(): (org.bukkit.inventory.EquipmentSlot | null);

			/**
			 * Gets the state of the fishing
			 */
			getState(): org.bukkit.event.player.PlayerFishEvent.State;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerFishEvent {
			constructor(player: org.bukkit.entity.Player, entity: (org.bukkit.entity.Entity | null), hookEntity: org.bukkit.entity.FishHook, hand: (org.bukkit.inventory.EquipmentSlot | null), state: org.bukkit.event.player.PlayerFishEvent.State);

			constructor(player: org.bukkit.entity.Player, entity: (org.bukkit.entity.Entity | null), hookEntity: org.bukkit.entity.FishHook, state: org.bukkit.event.player.PlayerFishEvent.State);

		}
		namespace PlayerFishEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace PlayerFishEvent {
			interface State {}
			namespace State {
				/**
				 * When a player is fishing, ie casting the line out.
				 */
				const FISHING: org.bukkit.event.player.PlayerFishEvent.State;

				/**
				 * When a player has successfully caught a fish and is reeling it in. In
				 * this instance, a "fish" is any item retrieved from water as a result
				 * of fishing, ie an item, but not necessarily a fish.
				 */
				const CAUGHT_FISH: org.bukkit.event.player.PlayerFishEvent.State;

				/**
				 * When a player has successfully caught an entity. This refers to any
				 * already spawned entity in the world that has been hooked directly by
				 * the rod.
				 */
				const CAUGHT_ENTITY: org.bukkit.event.player.PlayerFishEvent.State;

				/**
				 * When a bobber is stuck in the ground.
				 */
				const IN_GROUND: org.bukkit.event.player.PlayerFishEvent.State;

				/**
				 * When a player fails to catch a bite while fishing usually due to
				 * poor timing.
				 */
				const FAILED_ATTEMPT: org.bukkit.event.player.PlayerFishEvent.State;

				/**
				 * When a player reels in their hook without receiving any bites.
				 */
				const REEL_IN: org.bukkit.event.player.PlayerFishEvent.State;

				/**
				 * Called when there is a bite on the hook and it is ready to be reeled
				 * in.
				 */
				const BITE: org.bukkit.event.player.PlayerFishEvent.State;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.player.PlayerFishEvent.State;

			}
		}
		interface PlayerGameModeChangeEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the GameMode the player is switched to.
			 */
			getNewGameMode(): org.bukkit.GameMode;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerGameModeChangeEvent {
			constructor(player: org.bukkit.entity.Player, newGameMode: org.bukkit.GameMode);

		}
		namespace PlayerGameModeChangeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerHarvestBlockEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the block that is being harvested.
			 */
			getHarvestedBlock(): org.bukkit.block.Block;

			/**
			 * Get the hand used to harvest the block.
			 */
			getHand(): org.bukkit.inventory.EquipmentSlot;

			/**
			 * Gets a list of items that are being harvested from this block.
			 */
			getItemsHarvested(): globalThis.java.util.List<org.bukkit.inventory.ItemStack>;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerHarvestBlockEvent {
			constructor(player: org.bukkit.entity.Player, harvestedBlock: org.bukkit.block.Block, hand: org.bukkit.inventory.EquipmentSlot, itemsHarvested: globalThis.java.util.List<org.bukkit.inventory.ItemStack>);

			constructor(player: org.bukkit.entity.Player, harvestedBlock: org.bukkit.block.Block, itemsHarvested: globalThis.java.util.List<org.bukkit.inventory.ItemStack>);

		}
		namespace PlayerHarvestBlockEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerHideEntityEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the entity which has been hidden from the player.
			 */
			getEntity(): org.bukkit.entity.Entity;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerHideEntityEvent {
			constructor(who: org.bukkit.entity.Player, entity: org.bukkit.entity.Entity);

		}
		namespace PlayerHideEntityEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerInteractAtEntityEvent extends Modify<org.bukkit.event.player.PlayerInteractEntityEvent, {
			getClickedPosition(): org.bukkit.util.Vector;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerInteractAtEntityEvent {
			constructor(who: org.bukkit.entity.Player, clickedEntity: org.bukkit.entity.Entity, position: org.bukkit.util.Vector);

			constructor(who: org.bukkit.entity.Player, clickedEntity: org.bukkit.entity.Entity, position: org.bukkit.util.Vector, hand: org.bukkit.inventory.EquipmentSlot);

		}
		namespace PlayerInteractAtEntityEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerInteractEntityEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the entity that was right-clicked by the player.
			 */
			getRightClicked(): org.bukkit.entity.Entity;

			/**
			 * The hand used to perform this interaction.
			 */
			getHand(): org.bukkit.inventory.EquipmentSlot;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerInteractEntityEvent {
			constructor(who: org.bukkit.entity.Player, clickedEntity: org.bukkit.entity.Entity);

			constructor(who: org.bukkit.entity.Player, clickedEntity: org.bukkit.entity.Entity, hand: org.bukkit.inventory.EquipmentSlot);

		}
		namespace PlayerInteractEntityEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerInteractEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Returns the action type
			 */
			getAction(): org.bukkit.event.block.Action;

			/**
			 * Gets the cancellation state of this event. Set to true if you want to
			 * prevent buckets from placing water and so forth
			 */
			isCancelled(): boolean;

			/**
			 * Sets the cancellation state of this event. A canceled event will not be
			 * executed in the server, but will still pass to other plugins
			 * 
			 * Canceling this event will prevent use of food (player won't lose the
			 * food item), prevent bows/snowballs/eggs from firing, etc. (player won't
			 * lose the ammo)
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Returns the item in hand represented by this event
			 */
			getItem(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Convenience method. Returns the material of the item represented by
			 * this event
			 */
			getMaterial(): org.bukkit.Material;

			/**
			 * Check if this event involved a block
			 */
			hasBlock(): boolean;

			/**
			 * Check if this event involved an item
			 */
			hasItem(): boolean;

			/**
			 * Convenience method to inform the user whether this was a block
			 * placement event.
			 */
			isBlockInHand(): boolean;

			/**
			 * Returns the clicked block
			 */
			getClickedBlock(): (org.bukkit.block.Block | null);

			/**
			 * Returns the face of the block that was clicked
			 */
			getBlockFace(): org.bukkit.block.BlockFace;

			/**
			 * This controls the action to take with the block (if any) that was
			 * clicked on. This event gets processed for all blocks, but most don't
			 * have a default action
			 */
			useInteractedBlock(): org.bukkit.event.Event.Result;

			setUseInteractedBlock(useInteractedBlock: org.bukkit.event.Event.Result): void;

			/**
			 * This controls the action to take with the item the player is holding.
			 * This includes both blocks and items (such as flint and steel or
			 * records). When this is set to default, it will be allowed if no action
			 * is taken on the interacted block.
			 */
			useItemInHand(): org.bukkit.event.Event.Result;

			setUseItemInHand(useItemInHand: org.bukkit.event.Event.Result): void;

			/**
			 * The hand used to perform this interaction. May be null in the case of
			 * Action.PHYSICAL.
			 */
			getHand(): (org.bukkit.inventory.EquipmentSlot | null);

			/**
			 * Gets the exact position on the block the player interacted with, this will
			 * be null outside of Action.RIGHT_CLICK_BLOCK.
			 * 
			 * All vector components are between 0.0 and 1.0 inclusive.
			 */
			getClickedPosition(): (org.bukkit.util.Vector | null);

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerInteractEvent {
			constructor(who: org.bukkit.entity.Player, action: org.bukkit.event.block.Action, item: (org.bukkit.inventory.ItemStack | null), clickedBlock: (org.bukkit.block.Block | null), clickedFace: org.bukkit.block.BlockFace);

			constructor(who: org.bukkit.entity.Player, action: org.bukkit.event.block.Action, item: (org.bukkit.inventory.ItemStack | null), clickedBlock: (org.bukkit.block.Block | null), clickedFace: org.bukkit.block.BlockFace, hand: (org.bukkit.inventory.EquipmentSlot | null));

			constructor(who: org.bukkit.entity.Player, action: org.bukkit.event.block.Action, item: (org.bukkit.inventory.ItemStack | null), clickedBlock: (org.bukkit.block.Block | null), clickedFace: org.bukkit.block.BlockFace, hand: (org.bukkit.inventory.EquipmentSlot | null), clickedPosition: (org.bukkit.util.Vector | null));

		}
		namespace PlayerInteractEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerItemBreakEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the item that broke
			 */
			getBrokenItem(): org.bukkit.inventory.ItemStack;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerItemBreakEvent {
			constructor(player: org.bukkit.entity.Player, brokenItem: org.bukkit.inventory.ItemStack);

		}
		namespace PlayerItemBreakEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerItemConsumeEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the item that is being consumed. Modifying the returned item will
			 * have no effect, you must use setItem(org.bukkit.inventory.ItemStack) instead.
			 */
			getItem(): org.bukkit.inventory.ItemStack;

			/**
			 * Set the item being consumed
			 */
			setItem(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Get the hand used to consume the item.
			 */
			getHand(): org.bukkit.inventory.EquipmentSlot;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerItemConsumeEvent {
			constructor(player: org.bukkit.entity.Player, item: org.bukkit.inventory.ItemStack, hand: org.bukkit.inventory.EquipmentSlot);

			constructor(player: org.bukkit.entity.Player, item: org.bukkit.inventory.ItemStack);

		}
		namespace PlayerItemConsumeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerItemDamageEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the item being damaged.
			 */
			getItem(): org.bukkit.inventory.ItemStack;

			/**
			 * Gets the amount of durability damage this item will be taking.
			 */
			getDamage(): number;

			setDamage(damage: number): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerItemDamageEvent {
			constructor(player: org.bukkit.entity.Player, what: org.bukkit.inventory.ItemStack, damage: number);

		}
		namespace PlayerItemDamageEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerItemHeldEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the previous held slot index
			 */
			getPreviousSlot(): number;

			/**
			 * Gets the new held slot index
			 */
			getNewSlot(): number;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerItemHeldEvent {
			constructor(player: org.bukkit.entity.Player, previous: number, current: number);

		}
		namespace PlayerItemHeldEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerItemMendEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Get the ItemStack to be repaired.
			 * This is not necessarily the item the player is holding.
			 */
			getItem(): org.bukkit.inventory.ItemStack;

			/**
			 * Get the EquipmentSlot in which the repaired ItemStack
			 * may be found.
			 */
			getSlot(): org.bukkit.inventory.EquipmentSlot;

			/**
			 * Get the experience orb triggering the event.
			 */
			getExperienceOrb(): org.bukkit.entity.ExperienceOrb;

			/**
			 * Get the amount the item is to be repaired.
			 * The default value is twice the value of the consumed experience orb
			 * or the remaining damage left on the item, whichever is smaller.
			 */
			getRepairAmount(): number;

			/**
			 * Set the amount the item will be repaired.
			 * Half of this value will be subtracted from the experience orb which initiated this event.
			 */
			setRepairAmount(amount: number): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancelled: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerItemMendEvent {
			constructor(who: org.bukkit.entity.Player, item: org.bukkit.inventory.ItemStack, slot: org.bukkit.inventory.EquipmentSlot, experienceOrb: org.bukkit.entity.ExperienceOrb, repairAmount: number);

			constructor(who: org.bukkit.entity.Player, item: org.bukkit.inventory.ItemStack, experienceOrb: org.bukkit.entity.ExperienceOrb, repairAmount: number);

		}
		namespace PlayerItemMendEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerJoinEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the join message to send to all online players
			 */
			getJoinMessage(): (string | null);

			/**
			 * Sets the join message to send to all online players
			 */
			setJoinMessage(joinMessage: (string | null)): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerJoinEvent {
			constructor(playerJoined: org.bukkit.entity.Player, joinMessage: (string | null));

		}
		namespace PlayerJoinEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerKickEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the reason why the player is getting kicked
			 */
			getReason(): string;

			/**
			 * Gets the leave message send to all online players
			 */
			getLeaveMessage(): string;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Sets the reason why the player is getting kicked
			 */
			setReason(kickReason: string): void;

			/**
			 * Sets the leave message send to all online players
			 */
			setLeaveMessage(leaveMessage: string): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerKickEvent {
			constructor(playerKicked: org.bukkit.entity.Player, kickReason: string, leaveMessage: string);

		}
		namespace PlayerKickEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerLevelChangeEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the old level of the player
			 */
			getOldLevel(): number;

			/**
			 * Gets the new level of the player
			 */
			getNewLevel(): number;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerLevelChangeEvent {
			constructor(player: org.bukkit.entity.Player, oldLevel: number, newLevel: number);

		}
		namespace PlayerLevelChangeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerLinksSendEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the links to be sent, for modification.
			 */
			getLinks(): org.bukkit.ServerLinks;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerLinksSendEvent {
			constructor(player: org.bukkit.entity.Player, links: org.bukkit.ServerLinks);

		}
		namespace PlayerLinksSendEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerLocaleChangeEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			getLocale(): string;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerLocaleChangeEvent {
			constructor(who: org.bukkit.entity.Player, locale: string);

		}
		namespace PlayerLocaleChangeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerLoginEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the current result of the login, as an enum
			 */
			getResult(): org.bukkit.event.player.PlayerLoginEvent.Result;

			/**
			 * Sets the new result of the login, as an enum
			 */
			setResult(result: org.bukkit.event.player.PlayerLoginEvent.Result): void;

			/**
			 * Gets the current kick message that will be used if getResult() !=
			 * Result.ALLOWED
			 */
			getKickMessage(): string;

			/**
			 * Sets the kick message to display if getResult() != Result.ALLOWED
			 */
			setKickMessage(message: string): void;

			/**
			 * Gets the hostname that the player used to connect to the server, or
			 * blank if unknown
			 */
			getHostname(): string;

			/**
			 * Allows the player to log in
			 */
			allow(): void;

			/**
			 * Disallows the player from logging in, with the given reason
			 */
			disallow(result: org.bukkit.event.player.PlayerLoginEvent.Result, message: string): void;

			/**
			 * Gets the InetAddress for the Player associated with this event.
			 * This method is provided as a workaround for player.getAddress()
			 * returning null during PlayerLoginEvent.
			 */
			getAddress(): any /* java.net.InetAddress */;

			/**
			 * Gets the connection address of this player, regardless of whether it has
			 * been spoofed or not.
			 */
			getRealAddress(): any /* java.net.InetAddress */;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerLoginEvent {
			/**
			 * This constructor defaults message to an empty string, and result to
			 * ALLOWED
			 */
			constructor(player: org.bukkit.entity.Player, hostname: string, address: any /* java.net.InetAddress */, realAddress: any /* java.net.InetAddress */);

			/**
			 * This constructor defaults message to an empty string, and result to
			 * ALLOWED
			 */
			constructor(player: org.bukkit.entity.Player, hostname: string, address: any /* java.net.InetAddress */);

			/**
			 * This constructor pre-configures the event with a result and message
			 */
			constructor(player: org.bukkit.entity.Player, hostname: string, address: any /* java.net.InetAddress */, result: org.bukkit.event.player.PlayerLoginEvent.Result, message: string, realAddress: any /* java.net.InetAddress */);

		}
		namespace PlayerLoginEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace PlayerLoginEvent {
			interface Result {}
			namespace Result {
				/**
				 * The player is allowed to log in
				 */
				const ALLOWED: org.bukkit.event.player.PlayerLoginEvent.Result;

				/**
				 * The player is not allowed to log in, due to the server being full
				 */
				const KICK_FULL: org.bukkit.event.player.PlayerLoginEvent.Result;

				/**
				 * The player is not allowed to log in, due to them being banned
				 */
				const KICK_BANNED: org.bukkit.event.player.PlayerLoginEvent.Result;

				/**
				 * The player is not allowed to log in, due to them not being on the
				 * white list
				 */
				const KICK_WHITELIST: org.bukkit.event.player.PlayerLoginEvent.Result;

				/**
				 * The player is not allowed to log in, for reasons undefined
				 */
				const KICK_OTHER: org.bukkit.event.player.PlayerLoginEvent.Result;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.player.PlayerLoginEvent.Result;

			}
		}
		interface PlayerMoveEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the cancellation state of this event. A cancelled event will not
			 * be executed in the server, but will still pass to other plugins
			 * 
			 * If a move or teleport event is cancelled, the player will be moved or
			 * teleported back to the Location as defined by getFrom(). This will not
			 * fire an event
			 */
			isCancelled(): boolean;

			/**
			 * Sets the cancellation state of this event. A cancelled event will not
			 * be executed in the server, but will still pass to other plugins
			 * 
			 * If a move or teleport event is cancelled, the player will be moved or
			 * teleported back to the Location as defined by getFrom(). This will not
			 * fire an event
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the location this player moved from
			 */
			getFrom(): org.bukkit.Location;

			/**
			 * Sets the location to mark as where the player moved from
			 */
			setFrom(from: org.bukkit.Location): void;

			/**
			 * Gets the location this player moved to
			 */
			getTo(): (org.bukkit.Location | null);

			/**
			 * Sets the location that this player will move to
			 */
			setTo(to: org.bukkit.Location): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerMoveEvent {
			constructor(player: org.bukkit.entity.Player, from: org.bukkit.Location, to: (org.bukkit.Location | null));

		}
		namespace PlayerMoveEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerPickupArrowEvent extends Modify<org.bukkit.event.player.PlayerPickupItemEvent, {
			/**
			 * Get the arrow being picked up by the player
			 */
			getArrow(): org.bukkit.entity.AbstractArrow;

		}> {}
		class PlayerPickupArrowEvent {
			constructor(player: org.bukkit.entity.Player, item: org.bukkit.entity.Item, arrow: org.bukkit.entity.AbstractArrow);

		}
		interface PlayerPickupItemEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the Item picked up by the player.
			 */
			getItem(): org.bukkit.entity.Item;

			/**
			 * Gets the amount remaining on the ground, if any
			 */
			getRemaining(): number;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerPickupItemEvent {
			constructor(player: org.bukkit.entity.Player, item: org.bukkit.entity.Item, remaining: number);

		}
		namespace PlayerPickupItemEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerPortalEvent extends Modify<org.bukkit.event.player.PlayerTeleportEvent, {
			/**
			 * Set the Block radius to search in for available portals.
			 */
			setSearchRadius(searchRadius: number): void;

			/**
			 * Gets the search radius value for finding an available portal.
			 */
			getSearchRadius(): number;

			/**
			 * Returns whether the server will attempt to create a destination portal or
			 * not.
			 */
			getCanCreatePortal(): boolean;

			/**
			 * Sets whether the server should attempt to create a destination portal or
			 * not.
			 */
			setCanCreatePortal(canCreatePortal: boolean): void;

			/**
			 * Sets the maximum radius the world is searched for a free space from the
			 * given location.
			 * If enough free space is found then the portal will be created there, if
			 * not it will force create with air-space at the target location.
			 * Does not apply to end portal target platforms which will always appear at
			 * the target location.
			 */
			setCreationRadius(creationRadius: number): void;

			/**
			 * Gets the maximum radius the world is searched for a free space from the
			 * given location.
			 * If enough free space is found then the portal will be created there, if
			 * not it will force create with air-space at the target location.
			 * Does not apply to end portal target platforms which will always appear at
			 * the target location.
			 */
			getCreationRadius(): number;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerPortalEvent {
			constructor(player: org.bukkit.entity.Player, from: org.bukkit.Location, to: (org.bukkit.Location | null));

			constructor(player: org.bukkit.entity.Player, from: org.bukkit.Location, to: (org.bukkit.Location | null), cause: org.bukkit.event.player.PlayerTeleportEvent.TeleportCause);

			constructor(player: org.bukkit.entity.Player, from: org.bukkit.Location, to: (org.bukkit.Location | null), cause: org.bukkit.event.player.PlayerTeleportEvent.TeleportCause, getSearchRadius: number, canCreatePortal: boolean, creationRadius: number);

		}
		namespace PlayerPortalEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerPreLoginEvent extends Modify<org.bukkit.event.Event, {
			/**
			 * Gets the current result of the login, as an enum
			 */
			getResult(): org.bukkit.event.player.PlayerPreLoginEvent.Result;

			/**
			 * Sets the new result of the login, as an enum
			 */
			setResult(result: org.bukkit.event.player.PlayerPreLoginEvent.Result): void;

			/**
			 * Gets the current kick message that will be used if getResult() !=
			 * Result.ALLOWED
			 */
			getKickMessage(): string;

			/**
			 * Sets the kick message to display if getResult() != Result.ALLOWED
			 */
			setKickMessage(message: string): void;

			/**
			 * Allows the player to log in
			 */
			allow(): void;

			/**
			 * Disallows the player from logging in, with the given reason
			 */
			disallow(result: org.bukkit.event.player.PlayerPreLoginEvent.Result, message: string): void;

			/**
			 * Gets the player's name.
			 */
			getName(): string;

			/**
			 * Gets the player IP address.
			 */
			getAddress(): any /* java.net.InetAddress */;

			getHandlers(): org.bukkit.event.HandlerList;

			/**
			 * Gets the player's unique ID.
			 */
			getUniqueId(): globalThis.java.util.UUID;

		}> {}
		class PlayerPreLoginEvent {
			constructor(name: string, ipAddress: any /* java.net.InetAddress */);

			constructor(name: string, ipAddress: any /* java.net.InetAddress */, uniqueId: globalThis.java.util.UUID);

		}
		namespace PlayerPreLoginEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace PlayerPreLoginEvent {
			interface Result {}
			namespace Result {
				/**
				 * The player is allowed to log in
				 */
				const ALLOWED: org.bukkit.event.player.PlayerPreLoginEvent.Result;

				/**
				 * The player is not allowed to log in, due to the server being full
				 */
				const KICK_FULL: org.bukkit.event.player.PlayerPreLoginEvent.Result;

				/**
				 * The player is not allowed to log in, due to them being banned
				 */
				const KICK_BANNED: org.bukkit.event.player.PlayerPreLoginEvent.Result;

				/**
				 * The player is not allowed to log in, due to them not being on the
				 * white list
				 */
				const KICK_WHITELIST: org.bukkit.event.player.PlayerPreLoginEvent.Result;

				/**
				 * The player is not allowed to log in, for reasons undefined
				 */
				const KICK_OTHER: org.bukkit.event.player.PlayerPreLoginEvent.Result;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.player.PlayerPreLoginEvent.Result;

			}
		}
		interface PlayerQuitEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the quit message to send to all online players
			 */
			getQuitMessage(): (string | null);

			/**
			 * Sets the quit message to send to all online players
			 */
			setQuitMessage(quitMessage: (string | null)): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerQuitEvent {
			constructor(who: org.bukkit.entity.Player, quitMessage: (string | null));

		}
		namespace PlayerQuitEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerRecipeBookClickEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the original recipe the player was trying to craft.
			 * This will not reflect any changes made with setRecipe(org.bukkit.inventory.Recipe).
			 */
			getOriginalRecipe(): org.bukkit.inventory.Recipe;

			/**
			 * Gets the recipe the player is trying to craft.
			 * This will reflect changes made with setRecipe(org.bukkit.inventory.Recipe).
			 */
			getRecipe(): org.bukkit.inventory.Recipe;

			/**
			 * Set the recipe that will be used.
			 * The game will attempt to move the ingredients for this recipe into the
			 * appropriate slots.
			 * 
			 * If the original recipe is a CraftingRecipe the provided recipe
			 * must also be a CraftingRecipe, otherwise the provided recipe must
			 * be of the same type as the original recipe.
			 */
			setRecipe(recipe: org.bukkit.inventory.Recipe): void;

			/**
			 * If true the game will attempt to move the ingredients for as many copies
			 * of this recipe as possible into the appropriate slots, otherwise only 1
			 * copy will be moved.
			 */
			isShiftClick(): boolean;

			/**
			 * Sets if the game will attempt to move the ingredients for as many copies
			 * of this recipe as possible into the appropriate slots.
			 */
			setShiftClick(shiftClick: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerRecipeBookClickEvent {
			constructor(player: org.bukkit.entity.Player, recipe: org.bukkit.inventory.Recipe, shiftClick: boolean);

		}
		namespace PlayerRecipeBookClickEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerRecipeBookSettingsChangeEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the type of recipe book the player is changing the settings for.
			 */
			getRecipeBookType(): org.bukkit.event.player.PlayerRecipeBookSettingsChangeEvent.RecipeBookType;

			/**
			 * Checks if the recipe book is being opened or closed.
			 */
			isOpen(): boolean;

			/**
			 * Checks if the recipe book filter is being enabled or disabled.
			 */
			isFiltering(): boolean;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerRecipeBookSettingsChangeEvent {
			constructor(player: org.bukkit.entity.Player, recipeBookType: org.bukkit.event.player.PlayerRecipeBookSettingsChangeEvent.RecipeBookType, open: boolean, filtering: boolean);

		}
		namespace PlayerRecipeBookSettingsChangeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace PlayerRecipeBookSettingsChangeEvent {
			interface RecipeBookType {}
			namespace RecipeBookType {
				/**
				 * Recipe book seen in crafting table and player inventory.
				 */
				const CRAFTING: org.bukkit.event.player.PlayerRecipeBookSettingsChangeEvent.RecipeBookType;

				/**
				 * Recipe book seen in furnace.
				 */
				const FURNACE: org.bukkit.event.player.PlayerRecipeBookSettingsChangeEvent.RecipeBookType;

				/**
				 * Recipe book seen in blast furnace.
				 */
				const BLAST_FURNACE: org.bukkit.event.player.PlayerRecipeBookSettingsChangeEvent.RecipeBookType;

				/**
				 * Recipe book seen in smoker.
				 */
				const SMOKER: org.bukkit.event.player.PlayerRecipeBookSettingsChangeEvent.RecipeBookType;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.player.PlayerRecipeBookSettingsChangeEvent.RecipeBookType;

			}
		}
		interface PlayerRecipeDiscoverEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Get the namespaced key of the discovered recipe.
			 */
			getRecipe(): org.bukkit.NamespacedKey;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerRecipeDiscoverEvent {
			constructor(who: org.bukkit.entity.Player, recipe: org.bukkit.NamespacedKey);

		}
		namespace PlayerRecipeDiscoverEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerRegisterChannelEvent extends Modify<org.bukkit.event.player.PlayerChannelEvent, {
		}> {}
		class PlayerRegisterChannelEvent {
			constructor(player: org.bukkit.entity.Player, channel: string);

		}
		interface PlayerResourcePackStatusEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the unique ID of this pack.
			 */
			getID(): globalThis.java.util.UUID;

			/**
			 * Gets the status of this pack.
			 */
			getStatus(): org.bukkit.event.player.PlayerResourcePackStatusEvent.Status;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerResourcePackStatusEvent {
			constructor(who: org.bukkit.entity.Player, id: globalThis.java.util.UUID, resourcePackStatus: org.bukkit.event.player.PlayerResourcePackStatusEvent.Status);

		}
		namespace PlayerResourcePackStatusEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace PlayerResourcePackStatusEvent {
			interface Status {}
			namespace Status {
				/**
				 * The resource pack has been successfully downloaded and applied to the
				 * client.
				 */
				const SUCCESSFULLY_LOADED: org.bukkit.event.player.PlayerResourcePackStatusEvent.Status;

				/**
				 * The client refused to accept the resource pack.
				 */
				const DECLINED: org.bukkit.event.player.PlayerResourcePackStatusEvent.Status;

				/**
				 * The client accepted the pack, but download failed.
				 */
				const FAILED_DOWNLOAD: org.bukkit.event.player.PlayerResourcePackStatusEvent.Status;

				/**
				 * The client accepted the pack and is beginning a download of it.
				 */
				const ACCEPTED: org.bukkit.event.player.PlayerResourcePackStatusEvent.Status;

				/**
				 * The client successfully downloaded the pack.
				 */
				const DOWNLOADED: org.bukkit.event.player.PlayerResourcePackStatusEvent.Status;

				/**
				 * The pack URL was invalid.
				 */
				const INVALID_URL: org.bukkit.event.player.PlayerResourcePackStatusEvent.Status;

				/**
				 * The client was unable to reload the pack.
				 */
				const FAILED_RELOAD: org.bukkit.event.player.PlayerResourcePackStatusEvent.Status;

				/**
				 * The pack was discarded by the client.
				 */
				const DISCARDED: org.bukkit.event.player.PlayerResourcePackStatusEvent.Status;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.player.PlayerResourcePackStatusEvent.Status;

			}
		}
		interface PlayerRespawnEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the current respawn location
			 */
			getRespawnLocation(): org.bukkit.Location;

			/**
			 * Sets the new respawn location
			 */
			setRespawnLocation(respawnLocation: org.bukkit.Location): void;

			/**
			 * Gets whether the respawn location is the player's bed.
			 */
			isBedSpawn(): boolean;

			/**
			 * Gets whether the respawn location is the player's respawn anchor.
			 */
			isAnchorSpawn(): boolean;

			/**
			 * Gets the reason this respawn event was called.
			 */
			getRespawnReason(): org.bukkit.event.player.PlayerRespawnEvent.RespawnReason;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerRespawnEvent {
			constructor(respawnPlayer: org.bukkit.entity.Player, respawnLocation: org.bukkit.Location, isBedSpawn: boolean);

			constructor(respawnPlayer: org.bukkit.entity.Player, respawnLocation: org.bukkit.Location, isBedSpawn: boolean, isAnchorSpawn: boolean);

			constructor(respawnPlayer: org.bukkit.entity.Player, respawnLocation: org.bukkit.Location, isBedSpawn: boolean, isAnchorSpawn: boolean, respawnReason: org.bukkit.event.player.PlayerRespawnEvent.RespawnReason);

		}
		namespace PlayerRespawnEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace PlayerRespawnEvent {
			interface RespawnReason {}
			namespace RespawnReason {
				/**
				 * When the player dies and presses the respawn button.
				 */
				const DEATH: org.bukkit.event.player.PlayerRespawnEvent.RespawnReason;

				/**
				 * When the player exits the end through the end portal.
				 */
				const END_PORTAL: org.bukkit.event.player.PlayerRespawnEvent.RespawnReason;

				/**
				 * When a plugin respawns the player.
				 */
				const PLUGIN: org.bukkit.event.player.PlayerRespawnEvent.RespawnReason;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.player.PlayerRespawnEvent.RespawnReason;

			}
		}
		interface PlayerRiptideEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the item containing the used enchantment.
			 */
			getItem(): org.bukkit.inventory.ItemStack;

			/**
			 * Get the velocity applied to the player as a result of this riptide.
			 */
			getVelocity(): org.bukkit.util.Vector;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerRiptideEvent {
			constructor(who: org.bukkit.entity.Player, item: org.bukkit.inventory.ItemStack, velocity: org.bukkit.util.Vector);

			constructor(who: org.bukkit.entity.Player, item: org.bukkit.inventory.ItemStack);

		}
		namespace PlayerRiptideEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerShearEntityEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the entity the player is shearing
			 */
			getEntity(): org.bukkit.entity.Entity;

			/**
			 * Gets the item used to shear the entity.
			 */
			getItem(): org.bukkit.inventory.ItemStack;

			/**
			 * Gets the hand used to shear the entity.
			 */
			getHand(): org.bukkit.inventory.EquipmentSlot;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerShearEntityEvent {
			constructor(who: org.bukkit.entity.Player, what: org.bukkit.entity.Entity, item: org.bukkit.inventory.ItemStack, hand: org.bukkit.inventory.EquipmentSlot);

			constructor(who: org.bukkit.entity.Player, what: org.bukkit.entity.Entity);

		}
		namespace PlayerShearEntityEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerShowEntityEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the entity which has been shown to the player.
			 */
			getEntity(): org.bukkit.entity.Entity;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerShowEntityEvent {
			constructor(who: org.bukkit.entity.Player, entity: org.bukkit.entity.Entity);

		}
		namespace PlayerShowEntityEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerSignOpenEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the sign that was opened.
			 */
			getSign(): org.bukkit.block.Sign;

			/**
			 * Gets side of the sign opened.
			 */
			getSide(): org.bukkit.block.sign.Side;

			/**
			 * Gets the cause of the sign open.
			 */
			getCause(): org.bukkit.event.player.PlayerSignOpenEvent.Cause;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerSignOpenEvent {
			constructor(player: org.bukkit.entity.Player, sign: org.bukkit.block.Sign, side: org.bukkit.block.sign.Side, cause: org.bukkit.event.player.PlayerSignOpenEvent.Cause);

		}
		namespace PlayerSignOpenEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace PlayerSignOpenEvent {
			interface Cause {}
			namespace Cause {
				/**
				 * Indicate the sign was opened because of an interaction.
				 */
				const INTERACT: org.bukkit.event.player.PlayerSignOpenEvent.Cause;

				/**
				 * Indicate the sign was opened because the sign was placed.
				 */
				const PLACE: org.bukkit.event.player.PlayerSignOpenEvent.Cause;

				/**
				 * Indicate the sign was opened because of a plugin.
				 */
				const PLUGIN: org.bukkit.event.player.PlayerSignOpenEvent.Cause;

				/**
				 * Indicate the sign was opened for an unknown reason.
				 */
				const UNKNOWN: org.bukkit.event.player.PlayerSignOpenEvent.Cause;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.player.PlayerSignOpenEvent.Cause;

			}
		}
		interface PlayerSpawnChangeEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the cause of spawn change.
			 */
			getCause(): org.bukkit.event.player.PlayerSpawnChangeEvent.Cause;

			/**
			 * Gets if the spawn position will be used regardless of bed obstruction
			 * rules.
			 */
			isForced(): boolean;

			/**
			 * Sets if the spawn position will be used regardless of bed obstruction
			 * rules.
			 */
			setForced(forced: boolean): void;

			/**
			 * Gets the new spawn to be set.
			 */
			getNewSpawn(): (org.bukkit.Location | null);

			/**
			 * Sets the new spawn location.
			 */
			setNewSpawn(newSpawn: (org.bukkit.Location | null)): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerSpawnChangeEvent {
			constructor(player: org.bukkit.entity.Player, newSpawn: (org.bukkit.Location | null), forced: boolean, cause: org.bukkit.event.player.PlayerSpawnChangeEvent.Cause);

		}
		namespace PlayerSpawnChangeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace PlayerSpawnChangeEvent {
			interface Cause {}
			namespace Cause {
				/**
				 * Indicate the spawn was set by a command.
				 */
				const COMMAND: org.bukkit.event.player.PlayerSpawnChangeEvent.Cause;

				/**
				 * Indicate the spawn was set by the player interacting with a bed.
				 */
				const BED: org.bukkit.event.player.PlayerSpawnChangeEvent.Cause;

				/**
				 * Indicate the spawn was set by the player interacting with a respawn
				 * anchor.
				 */
				const RESPAWN_ANCHOR: org.bukkit.event.player.PlayerSpawnChangeEvent.Cause;

				/**
				 * Indicate the spawn was set by the use of plugins.
				 */
				const PLUGIN: org.bukkit.event.player.PlayerSpawnChangeEvent.Cause;

				/**
				 * Indicate the spawn was reset by an invalid bed position or empty
				 * respawn anchor.
				 */
				const RESET: org.bukkit.event.player.PlayerSpawnChangeEvent.Cause;

				/**
				 * Indicate the spawn was caused by an unknown reason.
				 */
				const UNKNOWN: org.bukkit.event.player.PlayerSpawnChangeEvent.Cause;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.player.PlayerSpawnChangeEvent.Cause;

			}
		}
		interface PlayerStatisticIncrementEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the statistic that is being incremented.
			 */
			getStatistic(): org.bukkit.Statistic;

			/**
			 * Gets the previous value of the statistic.
			 */
			getPreviousValue(): number;

			/**
			 * Gets the new value of the statistic.
			 */
			getNewValue(): number;

			/**
			 * Gets the EntityType if getStatistic() is an
			 * entity statistic otherwise returns null.
			 */
			getEntityType(): (org.bukkit.entity.EntityType | null);

			/**
			 * Gets the Material if getStatistic() is a block
			 * or item statistic otherwise returns null.
			 */
			getMaterial(): (org.bukkit.Material | null);

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerStatisticIncrementEvent {
			constructor(player: org.bukkit.entity.Player, statistic: org.bukkit.Statistic, initialValue: number, newValue: number);

			constructor(player: org.bukkit.entity.Player, statistic: org.bukkit.Statistic, initialValue: number, newValue: number, entityType: org.bukkit.entity.EntityType);

			constructor(player: org.bukkit.entity.Player, statistic: org.bukkit.Statistic, initialValue: number, newValue: number, material: org.bukkit.Material);

		}
		namespace PlayerStatisticIncrementEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerSwapHandItemsEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the item switched to the main hand.
			 */
			getMainHandItem(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Sets the item in the main hand.
			 */
			setMainHandItem(mainHandItem: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Gets the item switched to the off hand.
			 */
			getOffHandItem(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Sets the item in the off hand.
			 */
			setOffHandItem(offHandItem: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerSwapHandItemsEvent {
			constructor(player: org.bukkit.entity.Player, mainHandItem: org.bukkit.inventory.ItemStack, offHandItem: org.bukkit.inventory.ItemStack);

		}
		namespace PlayerSwapHandItemsEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerTakeLecternBookEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets the lectern involved.
			 */
			getLectern(): org.bukkit.block.Lectern;

			/**
			 * Gets the current ItemStack on the lectern.
			 */
			getBook(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerTakeLecternBookEvent {
			constructor(who: org.bukkit.entity.Player, lectern: org.bukkit.block.Lectern);

		}
		namespace PlayerTakeLecternBookEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerTeleportEvent extends Modify<org.bukkit.event.player.PlayerMoveEvent, {
			/**
			 * Gets the cause of this teleportation event
			 */
			getCause(): org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerTeleportEvent {
			constructor(player: org.bukkit.entity.Player, from: org.bukkit.Location, to: (org.bukkit.Location | null));

			constructor(player: org.bukkit.entity.Player, from: org.bukkit.Location, to: (org.bukkit.Location | null), cause: org.bukkit.event.player.PlayerTeleportEvent.TeleportCause);

		}
		namespace PlayerTeleportEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace PlayerTeleportEvent {
			interface TeleportCause {}
			namespace TeleportCause {
				/**
				 * Indicates the teleporation was caused by a player throwing an Ender
				 * Pearl
				 */
				const ENDER_PEARL: org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;

				/**
				 * Indicates the teleportation was caused by a player executing a
				 * command
				 */
				const COMMAND: org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;

				/**
				 * Indicates the teleportation was caused by a plugin
				 */
				const PLUGIN: org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;

				/**
				 * Indicates the teleportation was caused by a player entering a
				 * Nether portal
				 */
				const NETHER_PORTAL: org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;

				/**
				 * Indicates the teleportation was caused by a player entering an End
				 * portal
				 */
				const END_PORTAL: org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;

				/**
				 * Indicates the teleportation was caused by a player teleporting to a
				 * Entity/Player via the spectator menu
				 */
				const SPECTATE: org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;

				/**
				 * Indicates the teleportation was caused by a player entering an End
				 * gateway
				 */
				const END_GATEWAY: org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;

				/**
				 * Indicates the teleportation was caused by a player consuming chorus
				 * fruit
				 */
				const CHORUS_FRUIT: org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;

				/**
				 * Indicates the teleportation was caused by a player exiting a vehicle
				 */
				const DISMOUNT: org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;

				/**
				 * Indicates the teleportation was caused by a player exiting a bed
				 */
				const EXIT_BED: org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;

				/**
				 * Indicates the teleportation was caused by an event not covered by
				 * this enum
				 */
				const UNKNOWN: org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;

			}
		}
		interface PlayerToggleFlightEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Returns whether the player is trying to start or stop flying.
			 */
			isFlying(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerToggleFlightEvent {
			constructor(player: org.bukkit.entity.Player, isFlying: boolean);

		}
		namespace PlayerToggleFlightEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerToggleSneakEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Returns whether the player is now sneaking or not.
			 */
			isSneaking(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerToggleSneakEvent {
			constructor(player: org.bukkit.entity.Player, isSneaking: boolean);

		}
		namespace PlayerToggleSneakEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerToggleSprintEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Gets whether the player is now sprinting or not.
			 */
			isSprinting(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerToggleSprintEvent {
			constructor(player: org.bukkit.entity.Player, isSprinting: boolean);

		}
		namespace PlayerToggleSprintEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PlayerUnleashEntityEvent extends Modify<org.bukkit.event.entity.EntityUnleashEvent, {
			/**
			 * Returns the player who is unleashing the entity.
			 */
			getPlayer(): org.bukkit.entity.Player;

			/**
			 * Get the hand used by the player to unleash the entity.
			 */
			getHand(): org.bukkit.inventory.EquipmentSlot;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

		}> {}
		class PlayerUnleashEntityEvent {
			constructor(entity: org.bukkit.entity.Entity, player: org.bukkit.entity.Player, hand: org.bukkit.inventory.EquipmentSlot);

			constructor(entity: org.bukkit.entity.Entity, player: org.bukkit.entity.Player);

		}
		interface PlayerUnregisterChannelEvent extends Modify<org.bukkit.event.player.PlayerChannelEvent, {
		}> {}
		class PlayerUnregisterChannelEvent {
			constructor(player: org.bukkit.entity.Player, channel: string);

		}
		interface PlayerVelocityEvent extends Modify<org.bukkit.event.player.PlayerEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the velocity vector that will be sent to the player
			 */
			getVelocity(): org.bukkit.util.Vector;

			/**
			 * Sets the velocity vector in meters per tick that will be sent to the player
			 */
			setVelocity(velocity: org.bukkit.util.Vector): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PlayerVelocityEvent {
			constructor(player: org.bukkit.entity.Player, velocity: org.bukkit.util.Vector);

		}
		namespace PlayerVelocityEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
	}
	namespace org.bukkit.event.world {
		interface AsyncStructureGenerateEvent extends Modify<org.bukkit.event.world.WorldEvent, {
			/**
			 * Gets the event cause.
			 */
			getCause(): org.bukkit.event.world.AsyncStructureGenerateEvent.Cause;

			/**
			 * Gets a block transformer by key.
			 */
			getBlockTransformer(key: org.bukkit.NamespacedKey): (org.bukkit.util.BlockTransformer | null);

			/**
			 * Sets a block transformer to a key.
			 */
			setBlockTransformer(key: org.bukkit.NamespacedKey, transformer: org.bukkit.util.BlockTransformer): void;

			/**
			 * Removes a block transformer.
			 */
			removeBlockTransformer(key: org.bukkit.NamespacedKey): void;

			/**
			 * Removes all block transformers.
			 */
			clearBlockTransformers(): void;

			/**
			 * Gets all block transformers in a unmodifiable map.
			 */
			getBlockTransformers(): globalThis.java.util.Map<org.bukkit.NamespacedKey, org.bukkit.util.BlockTransformer>;

			/**
			 * Gets a entity transformer by key.
			 */
			getEntityTransformer(key: org.bukkit.NamespacedKey): (org.bukkit.util.EntityTransformer | null);

			/**
			 * Sets a entity transformer to a key.
			 */
			setEntityTransformer(key: org.bukkit.NamespacedKey, transformer: org.bukkit.util.EntityTransformer): void;

			/**
			 * Removes a entity transformer.
			 */
			removeEntityTransformer(key: org.bukkit.NamespacedKey): void;

			/**
			 * Removes all entity transformers.
			 */
			clearEntityTransformers(): void;

			/**
			 * Gets all entity transformers in a unmodifiable map.
			 */
			getEntityTransformers(): globalThis.java.util.Map<org.bukkit.NamespacedKey, org.bukkit.util.EntityTransformer>;

			/**
			 * Get the structure reference that is generated.
			 */
			getStructure(): org.bukkit.generator.structure.Structure;

			/**
			 * Get the bounding box of the structure.
			 */
			getBoundingBox(): org.bukkit.util.BoundingBox;

			/**
			 * Get the x coordinate of the origin chunk of the structure.
			 */
			getChunkX(): number;

			/**
			 * Get the z coordinate of the origin chunk of the structure.
			 */
			getChunkZ(): number;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class AsyncStructureGenerateEvent {
			constructor(world: org.bukkit.World, async: boolean, cause: org.bukkit.event.world.AsyncStructureGenerateEvent.Cause, structure: org.bukkit.generator.structure.Structure, boundingBox: org.bukkit.util.BoundingBox, chunkX: number, chunkZ: number);

		}
		namespace AsyncStructureGenerateEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace AsyncStructureGenerateEvent {
			interface Cause {}
			namespace Cause {
				const COMMAND: org.bukkit.event.world.AsyncStructureGenerateEvent.Cause;

				const WORLD_GENERATION: org.bukkit.event.world.AsyncStructureGenerateEvent.Cause;

				const CUSTOM: org.bukkit.event.world.AsyncStructureGenerateEvent.Cause;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.world.AsyncStructureGenerateEvent.Cause;

			}
		}
		interface AsyncStructureSpawnEvent extends Modify<org.bukkit.event.world.WorldEvent, {
			/**
			 * Get the structure reference that is generated.
			 */
			getStructure(): org.bukkit.generator.structure.Structure;

			/**
			 * Get the bounding box of the structure.
			 */
			getBoundingBox(): org.bukkit.util.BoundingBox;

			/**
			 * Get the x coordinate of the origin chunk of the structure.
			 * Note, it is not safe to attempt to retrieve or interact with this
			 * chunk. This event is informative only!
			 */
			getChunkX(): number;

			/**
			 * Get the z coordinate of the origin chunk of the structure.
			 * Note, it is not safe to attempt to retrieve or interact with this
			 * chunk. This event is informative only!
			 */
			getChunkZ(): number;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class AsyncStructureSpawnEvent {
			constructor(world: org.bukkit.World, structure: org.bukkit.generator.structure.Structure, boundingBox: org.bukkit.util.BoundingBox, chunkX: number, chunkZ: number);

		}
		namespace AsyncStructureSpawnEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface ChunkEvent extends Modify<org.bukkit.event.world.WorldEvent, {
			/**
			 * Gets the chunk being loaded/unloaded
			 */
			getChunk(): org.bukkit.Chunk;

		}> {}
		interface ChunkLoadEvent extends Modify<org.bukkit.event.world.ChunkEvent, {
			/**
			 * Gets if this chunk was newly created or not.
			 * 
			 * Note: Do not use this to generated blocks in a newly generated chunk.
			 * Use a BlockPopulator instead.
			 */
			isNewChunk(): boolean;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class ChunkLoadEvent {
			constructor(chunk: org.bukkit.Chunk, newChunk: boolean);

		}
		namespace ChunkLoadEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface ChunkPopulateEvent extends Modify<org.bukkit.event.world.ChunkEvent, {
			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class ChunkPopulateEvent {
			constructor(chunk: org.bukkit.Chunk);

		}
		namespace ChunkPopulateEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface ChunkUnloadEvent extends Modify<org.bukkit.event.world.ChunkEvent, {
			/**
			 * Return whether this chunk will be saved to disk.
			 */
			isSaveChunk(): boolean;

			/**
			 * Set whether this chunk will be saved to disk.
			 */
			setSaveChunk(saveChunk: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class ChunkUnloadEvent {
			constructor(chunk: org.bukkit.Chunk);

			constructor(chunk: org.bukkit.Chunk, save: boolean);

		}
		namespace ChunkUnloadEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntitiesLoadEvent extends Modify<org.bukkit.event.world.ChunkEvent, {
			/**
			 * Get the entities which are being loaded.
			 */
			getEntities(): globalThis.java.util.List<org.bukkit.entity.Entity>;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntitiesLoadEvent {
			constructor(chunk: org.bukkit.Chunk, entities: globalThis.java.util.List<org.bukkit.entity.Entity>);

		}
		namespace EntitiesLoadEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface EntitiesUnloadEvent extends Modify<org.bukkit.event.world.ChunkEvent, {
			/**
			 * Get the entities which are being unloaded.
			 */
			getEntities(): globalThis.java.util.List<org.bukkit.entity.Entity>;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EntitiesUnloadEvent {
			constructor(chunk: org.bukkit.Chunk, entities: globalThis.java.util.List<org.bukkit.entity.Entity>);

		}
		namespace EntitiesUnloadEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface GenericGameEvent extends Modify<org.bukkit.event.world.WorldEvent, {
			/**
			 * Get the underlying event.
			 */
			getEvent(): org.bukkit.GameEvent;

			/**
			 * Get the location where the event occurred.
			 */
			getLocation(): org.bukkit.Location;

			/**
			 * Get the entity which triggered this event, if present.
			 */
			getEntity(): (org.bukkit.entity.Entity | null);

			/**
			 * Get the block radius to which this event will be broadcast.
			 */
			getRadius(): number;

			/**
			 * Set the radius to which the event should be broadcast.
			 */
			setRadius(radius: number): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class GenericGameEvent {
			constructor(event: org.bukkit.GameEvent, location: org.bukkit.Location, entity: (org.bukkit.entity.Entity | null), radius: number, isAsync: boolean);

		}
		namespace GenericGameEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface LootGenerateEvent extends Modify<org.bukkit.event.world.WorldEvent, {
			/**
			 * Get the entity used as context for loot generation (if applicable).
			 * For inventories where entities are not required to generate loot, such as
			 * hoppers, null will be returned.
			 * This is a convenience method for
			 * getLootContext().getLootedEntity().
			 */
			getEntity(): (org.bukkit.entity.Entity | null);

			/**
			 * Get the inventory holder in which the loot was generated.
			 * If the loot was generated as a result of the block being broken, the
			 * inventory holder will be null as this event is called post block break.
			 */
			getInventoryHolder(): (org.bukkit.inventory.InventoryHolder | null);

			/**
			 * Get the loot table used to generate loot.
			 */
			getLootTable(): org.bukkit.loot.LootTable;

			/**
			 * Get the loot context used to provide context to the loot table's loot
			 * generation.
			 */
			getLootContext(): org.bukkit.loot.LootContext;

			/**
			 * Set the loot to be generated. Null items will be treated as air.
			 * Note: the set collection is not the one which will be returned by
			 * getLoot().
			 */
			setLoot(loot: (globalThis.java.util.Collection<org.bukkit.inventory.ItemStack> | null)): void;

			/**
			 * Get a mutable list of all loot to be generated.
			 * Any items added or removed from the returned list will be reflected in
			 * the loot generation. Null items will be treated as air.
			 */
			getLoot(): globalThis.java.util.List<org.bukkit.inventory.ItemStack>;

			/**
			 * Check whether or not this event was called as a result of a plugin
			 * invoking
			 * LootTable.fillInventory(org.bukkit.inventory.Inventory, java.util.Random, LootContext).
			 */
			isPlugin(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class LootGenerateEvent {
			constructor(world: org.bukkit.World, entity: (org.bukkit.entity.Entity | null), inventoryHolder: (org.bukkit.inventory.InventoryHolder | null), lootTable: org.bukkit.loot.LootTable, lootContext: org.bukkit.loot.LootContext, items: globalThis.java.util.List<org.bukkit.inventory.ItemStack>, plugin: boolean);

		}
		namespace LootGenerateEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PortalCreateEvent extends Modify<org.bukkit.event.world.WorldEvent, {
			/**
			 * Gets an array list of all the blocks associated with the created portal
			 */
			getBlocks(): globalThis.java.util.List<org.bukkit.block.BlockState>;

			/**
			 * Returns the Entity that triggered this portal creation (if available)
			 */
			getEntity(): (org.bukkit.entity.Entity | null);

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the reason for the portal's creation
			 */
			getReason(): org.bukkit.event.world.PortalCreateEvent.CreateReason;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PortalCreateEvent {
			constructor(blocks: globalThis.java.util.List<org.bukkit.block.BlockState>, world: org.bukkit.World, reason: org.bukkit.event.world.PortalCreateEvent.CreateReason);

			constructor(blocks: globalThis.java.util.List<org.bukkit.block.BlockState>, world: org.bukkit.World, entity: (org.bukkit.entity.Entity | null), reason: org.bukkit.event.world.PortalCreateEvent.CreateReason);

		}
		namespace PortalCreateEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace PortalCreateEvent {
			interface CreateReason {}
			namespace CreateReason {
				/**
				 * When the blocks inside a portal are created due to a portal frame
				 * being set on fire.
				 */
				const FIRE: org.bukkit.event.world.PortalCreateEvent.CreateReason;

				/**
				 * When a nether portal frame and portal is created at the exit of an
				 * entered nether portal.
				 */
				const NETHER_PAIR: org.bukkit.event.world.PortalCreateEvent.CreateReason;

				/**
				 * When the target end platform is created as a result of a player
				 * entering an end portal.
				 */
				const END_PLATFORM: org.bukkit.event.world.PortalCreateEvent.CreateReason;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.world.PortalCreateEvent.CreateReason;

			}
		}
		interface SpawnChangeEvent extends Modify<org.bukkit.event.world.WorldEvent, {
			/**
			 * Gets the previous spawn location
			 */
			getPreviousLocation(): org.bukkit.Location;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class SpawnChangeEvent {
			constructor(world: org.bukkit.World, previousLocation: org.bukkit.Location);

		}
		namespace SpawnChangeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface StructureGrowEvent extends Modify<org.bukkit.event.world.WorldEvent, {
			/**
			 * Gets the location of the structure.
			 */
			getLocation(): org.bukkit.Location;

			/**
			 * Gets the species type (birch, normal, pine, red mushroom, brown
			 * mushroom)
			 */
			getSpecies(): org.bukkit.TreeType;

			/**
			 * Checks if structure was grown using bonemeal.
			 */
			isFromBonemeal(): boolean;

			/**
			 * Gets the player that created the structure.
			 */
			getPlayer(): (org.bukkit.entity.Player | null);

			/**
			 * Gets a list of all blocks associated with the structure.
			 */
			getBlocks(): globalThis.java.util.List<org.bukkit.block.BlockState>;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class StructureGrowEvent {
			constructor(location: org.bukkit.Location, species: org.bukkit.TreeType, bonemeal: boolean, player: (org.bukkit.entity.Player | null), blocks: globalThis.java.util.List<org.bukkit.block.BlockState>);

		}
		namespace StructureGrowEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface TimeSkipEvent extends Modify<org.bukkit.event.world.WorldEvent, {
			/**
			 * Gets the reason why the time has skipped.
			 */
			getSkipReason(): org.bukkit.event.world.TimeSkipEvent.SkipReason;

			/**
			 * Gets the amount of time that was skipped.
			 */
			getSkipAmount(): number;

			/**
			 * Sets the amount of time to skip.
			 */
			setSkipAmount(skipAmount: number): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class TimeSkipEvent {
			constructor(world: org.bukkit.World, skipReason: org.bukkit.event.world.TimeSkipEvent.SkipReason, skipAmount: number);

		}
		namespace TimeSkipEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace TimeSkipEvent {
			interface SkipReason {}
			namespace SkipReason {
				/**
				 * When time is changed using the vanilla /time command.
				 */
				const COMMAND: org.bukkit.event.world.TimeSkipEvent.SkipReason;

				/**
				 * When time is changed by a plugin.
				 */
				const CUSTOM: org.bukkit.event.world.TimeSkipEvent.SkipReason;

				/**
				 * When time is changed by all players sleeping in their beds and the
				 * night skips.
				 */
				const NIGHT_SKIP: org.bukkit.event.world.TimeSkipEvent.SkipReason;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.world.TimeSkipEvent.SkipReason;

			}
		}
		interface WorldEvent extends Modify<org.bukkit.event.Event, {
			/**
			 * Gets the world primarily involved with this event
			 */
			getWorld(): org.bukkit.World;

		}> {}
		class WorldEvent {
			constructor(world: org.bukkit.World);

			constructor(world: org.bukkit.World, isAsync: boolean);

		}
		interface WorldInitEvent extends Modify<org.bukkit.event.world.WorldEvent, {
			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class WorldInitEvent {
			constructor(world: org.bukkit.World);

		}
		namespace WorldInitEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface WorldLoadEvent extends Modify<org.bukkit.event.world.WorldEvent, {
			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class WorldLoadEvent {
			constructor(world: org.bukkit.World);

		}
		namespace WorldLoadEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface WorldSaveEvent extends Modify<org.bukkit.event.world.WorldEvent, {
			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class WorldSaveEvent {
			constructor(world: org.bukkit.World);

		}
		namespace WorldSaveEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface WorldUnloadEvent extends Modify<org.bukkit.event.world.WorldEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class WorldUnloadEvent {
			constructor(world: org.bukkit.World);

		}
		namespace WorldUnloadEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
	}
	namespace org.bukkit.material {
		interface Attachable extends Modify<org.bukkit.material.Directional, {
			/**
			 * Gets the face that this block is attached on
			 */
			getAttachedFace(): org.bukkit.block.BlockFace;

		}> {}
		interface Banner extends Modify<org.bukkit.material.MaterialData, {
			isWallBanner(): boolean;

			/**
			 * Description copied from interface:Â Attachable
			 */
			getAttachedFace(): org.bukkit.block.BlockFace;

			/**
			 * Description copied from interface:Â Directional
			 */
			getFacing(): org.bukkit.block.BlockFace;

			/**
			 * Description copied from interface:Â Directional
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			toString(): string;

			clone(): org.bukkit.material.Banner;

		}> {}
		class Banner {
			constructor();

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Bed extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Determine if this block represents the head of the bed
			 */
			isHeadOfBed(): boolean;

			/**
			 * Configure this to be either the head or the foot of the bed
			 */
			setHeadOfBed(isHeadOfBed: boolean): void;

			/**
			 * Set which direction the head of the bed is facing. Note that this will
			 * only affect one of the two blocks the bed is made of.
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			/**
			 * Get the direction that this bed's head is facing toward
			 */
			getFacing(): org.bukkit.block.BlockFace;

			toString(): string;

			clone(): org.bukkit.material.Bed;

		}> {}
		class Bed {
			/**
			 * Default constructor for a bed.
			 */
			constructor();

			/**
			 * Instantiate a bed facing in a particular direction.
			 */
			constructor(direction: org.bukkit.block.BlockFace);

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Button extends Modify<org.bukkit.material.SimpleAttachableMaterialData, {
			/**
			 * Gets the current state of this Material, indicating if it's powered or
			 * unpowered
			 */
			isPowered(): boolean;

			/**
			 * Sets the current state of this button
			 */
			setPowered(bool: boolean): void;

			/**
			 * Gets the face that this block is attached on
			 */
			getAttachedFace(): org.bukkit.block.BlockFace;

			/**
			 * Sets the direction this button is pointing toward
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			toString(): string;

			clone(): org.bukkit.material.Button;

		}> {}
		class Button {
			constructor();

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Cake extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Gets the number of slices eaten from this cake
			 */
			getSlicesEaten(): number;

			/**
			 * Gets the number of slices remaining on this cake
			 */
			getSlicesRemaining(): number;

			/**
			 * Sets the number of slices eaten from this cake
			 */
			setSlicesEaten(n: number): void;

			/**
			 * Sets the number of slices remaining on this cake
			 */
			setSlicesRemaining(n: number): void;

			toString(): string;

			clone(): org.bukkit.material.Cake;

		}> {}
		class Cake {
			constructor();

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Cauldron extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Check if the cauldron is full.
			 */
			isFull(): boolean;

			/**
			 * Check if the cauldron is empty.
			 */
			isEmpty(): boolean;

			toString(): string;

			clone(): org.bukkit.material.Cauldron;

		}> {}
		class Cauldron {
			constructor();

			constructor(type: org.bukkit.Material, data: any /* byte */);

			constructor(data: any /* byte */);

		}
		interface Chest extends Modify<org.bukkit.material.DirectionalContainer, {
			clone(): org.bukkit.material.Chest;

		}> {}
		class Chest {
			constructor();

			/**
			 * Instantiate a chest facing in a particular direction.
			 */
			constructor(direction: org.bukkit.block.BlockFace);

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Coal extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Gets the current type of this coal
			 */
			getType(): org.bukkit.CoalType;

			/**
			 * Sets the type of this coal
			 */
			setType(type: org.bukkit.CoalType): void;

			toString(): string;

			clone(): org.bukkit.material.Coal;

		}> {}
		class Coal {
			constructor();

			constructor(type: org.bukkit.CoalType);

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface CocoaPlant extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Get size of plant
			 */
			getSize(): org.bukkit.material.CocoaPlant.CocoaPlantSize;

			/**
			 * Set size of plant
			 */
			setSize(sz: org.bukkit.material.CocoaPlant.CocoaPlantSize): void;

			/**
			 * Description copied from interface:Â Attachable
			 */
			getAttachedFace(): org.bukkit.block.BlockFace;

			/**
			 * Description copied from interface:Â Directional
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			/**
			 * Description copied from interface:Â Directional
			 */
			getFacing(): org.bukkit.block.BlockFace;

			clone(): org.bukkit.material.CocoaPlant;

			toString(): string;

		}> {}
		class CocoaPlant {
			constructor();

			constructor(type: org.bukkit.Material, data: any /* byte */);

			constructor(sz: org.bukkit.material.CocoaPlant.CocoaPlantSize);

			constructor(sz: org.bukkit.material.CocoaPlant.CocoaPlantSize, dir: org.bukkit.block.BlockFace);

		}
		namespace CocoaPlant {
			interface CocoaPlantSize {}
			namespace CocoaPlantSize {
				const SMALL: org.bukkit.material.CocoaPlant.CocoaPlantSize;

				const MEDIUM: org.bukkit.material.CocoaPlant.CocoaPlantSize;

				const LARGE: org.bukkit.material.CocoaPlant.CocoaPlantSize;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.material.CocoaPlant.CocoaPlantSize;

			}
		}
		interface Colorable {
			/**
			 * Gets the color of this object.
			 * 
			 * This may be null to represent the default color of an object, if the
			 * object has a special default color (e.g Shulkers).
			 */
			getColor(): (org.bukkit.DyeColor | null);

			/**
			 * Sets the color of this object to the specified DyeColor.
			 * 
			 * This may be null to represent the default color of an object, if the
			 * object has a special default color (e.g Shulkers).
			 */
			setColor(color: org.bukkit.DyeColor): void;

		}
		interface Command extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Gets the current state of this Material, indicating if it's powered or
			 * unpowered
			 */
			isPowered(): boolean;

			/**
			 * Sets the current state of this Material
			 */
			setPowered(bool: boolean): void;

			toString(): string;

			clone(): org.bukkit.material.Command;

		}> {}
		class Command {
			constructor();

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Comparator extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Sets whether the comparator is in subtraction mode.
			 */
			setSubtractionMode(isSubtraction: boolean): void;

			/**
			 * Checks whether the comparator is in subtraction mode
			 */
			isSubtractionMode(): boolean;

			/**
			 * Sets the direction this comparator is facing
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			/**
			 * Gets the direction this comparator is facing
			 */
			getFacing(): org.bukkit.block.BlockFace;

			toString(): string;

			clone(): org.bukkit.material.Comparator;

			/**
			 * Checks if the comparator is powered
			 */
			isPowered(): boolean;

			/**
			 * Checks if the comparator is being powered
			 */
			isBeingPowered(): boolean;

		}> {}
		class Comparator {
			/**
			 * Constructs a comparator switched off, with the default mode (normal) and facing the default direction (north).
			 */
			constructor();

			/**
			 * Constructs a comparator switched off, with the default mode (normal) and facing the specified direction.
			 */
			constructor(facingDirection: org.bukkit.block.BlockFace);

			/**
			 * Constructs a comparator switched off, with the specified mode and facing the specified direction.
			 */
			constructor(facingDirection: org.bukkit.block.BlockFace, isSubtraction: boolean);

			/**
			 * Constructs a comparator switched on or off, with the specified mode and facing the specified direction.
			 */
			constructor(facingDirection: org.bukkit.block.BlockFace, isSubtraction: boolean, state: boolean);

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Crops extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Gets the current growth state of this crop
			 * For crops with only four growth states such as beetroot, only the values SEEDED, SMALL, TALL and RIPE will be
			 * returned.
			 */
			getState(): org.bukkit.CropState;

			/**
			 * Sets the growth state of this crop
			 * For crops with only four growth states such as beetroot, the 8 CropStates are mapped into four states:
			 * SEEDED, SMALL, TALL and RIPE
			 * GERMINATED will change to SEEDED
			 * VERY_SMALL will change to SMALL
			 * MEDIUM will change to TALL
			 * VERY_TALL will change to RIPE
			 */
			setState(state: org.bukkit.CropState): void;

			toString(): string;

			clone(): org.bukkit.material.Crops;

		}> {}
		class Crops {
			/**
			 * Constructs a wheat crop block in the seeded state.
			 */
			constructor();

			/**
			 * Constructs a wheat crop block in the given growth state
			 */
			constructor(state: org.bukkit.CropState);

			/**
			 * Constructs a crop block of the given type and in the given growth state
			 */
			constructor(type: org.bukkit.Material, state: org.bukkit.CropState);

			/**
			 * Constructs a crop block of the given type and in the seeded state
			 */
			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface DetectorRail extends Modify<org.bukkit.material.ExtendedRails, {
			isPressed(): boolean;

			setPressed(isPressed: boolean): void;

			clone(): org.bukkit.material.DetectorRail;

		}> {}
		class DetectorRail {
			constructor();

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Diode extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Sets the delay of the repeater.
			 */
			setDelay(delay: number): void;

			/**
			 * Gets the delay of the repeater in ticks.
			 */
			getDelay(): number;

			/**
			 * Sets the direction this diode is facing.
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			/**
			 * Gets the direction this diode is facing
			 */
			getFacing(): org.bukkit.block.BlockFace;

			toString(): string;

			clone(): org.bukkit.material.Diode;

			/**
			 * Checks if the diode is powered.
			 */
			isPowered(): boolean;

		}> {}
		class Diode {
			/**
			 * Constructs a diode switched on, with a delay of 1 and facing the default
			 * direction (north).
			 * By default this constructor creates a diode that is switched on for
			 * backwards compatibility with past implementations.
			 */
			constructor();

			/**
			 * Constructs a diode switched off, with a delay of 1 and facing the
			 * specified direction.
			 */
			constructor(facingDirection: org.bukkit.block.BlockFace);

			/**
			 * Constructs a diode switched off, with the specified delay and facing the
			 * specified direction.
			 */
			constructor(facingDirection: org.bukkit.block.BlockFace, delay: number);

			/**
			 * Constructs a diode switched on or off, with the specified delay and
			 * facing the specified direction.
			 */
			constructor(facingDirection: org.bukkit.block.BlockFace, delay: number, state: boolean);

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Directional {
			/**
			 * Sets the direction that this block is facing in
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			/**
			 * Gets the direction this block is facing
			 */
			getFacing(): org.bukkit.block.BlockFace;

		}
		interface DirectionalContainer extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Description copied from interface:Â Directional
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			/**
			 * Description copied from interface:Â Directional
			 */
			getFacing(): org.bukkit.block.BlockFace;

			toString(): string;

			clone(): org.bukkit.material.DirectionalContainer;

		}> {}
		class DirectionalContainer {
			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Dispenser extends Modify<org.bukkit.material.FurnaceAndDispenser, {
			/**
			 * Description copied from interface:Â Directional
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			/**
			 * Description copied from interface:Â Directional
			 */
			getFacing(): org.bukkit.block.BlockFace;

			clone(): org.bukkit.material.Dispenser;

		}> {}
		class Dispenser {
			constructor();

			constructor(direction: org.bukkit.block.BlockFace);

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Door extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Result is undefined if isTopHalf() is true.
			 */
			isOpen(): boolean;

			/**
			 * Set whether the door is open. Undefined if isTopHalf() is true.
			 */
			setOpen(isOpen: boolean): void;

			isTopHalf(): boolean;

			/**
			 * Configure this part of the door to be either the top or the bottom half
			 */
			setTopHalf(isTopHalf: boolean): void;

			getHingeCorner(): org.bukkit.block.BlockFace;

			toString(): string;

			/**
			 * Set the direction that this door should is facing.
			 * Undefined if isTopHalf() is true.
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			/**
			 * Get the direction that this door is facing.
			 * Undefined if isTopHalf() is true.
			 */
			getFacing(): org.bukkit.block.BlockFace;

			/**
			 * Returns the side of the door the hinge is on.
			 * Undefined if isTopHalf() is false.
			 */
			getHinge(): boolean;

			/**
			 * Set whether the hinge is on the left or right side. Left is false, right is true.
			 * Undefined if isTopHalf() is false.
			 */
			setHinge(isHingeRight: boolean): void;

			clone(): org.bukkit.material.Door;

		}> {}
		class Door {
			constructor();

			constructor(type: org.bukkit.Material);

			/**
			 * Constructs the bottom half of a door of the given material type, facing the specified direction and set to closed
			 */
			constructor(type: org.bukkit.Material, face: org.bukkit.block.BlockFace);

			/**
			 * Constructs the bottom half of a door of the given material type, facing the specified direction and set to open
			 * or closed
			 */
			constructor(type: org.bukkit.Material, face: org.bukkit.block.BlockFace, isOpen: boolean);

			/**
			 * Constructs the top half of door of the given material type and with the hinge on the left or right
			 */
			constructor(type: org.bukkit.Material, isHingeRight: boolean);

			/**
			 * Constructs the bottom half of a wooden door of the given species, facing the specified direction and set to
			 * closed
			 */
			constructor(species: org.bukkit.TreeSpecies, face: org.bukkit.block.BlockFace);

			/**
			 * Constructs the bottom half of a wooden door of the given species, facing the specified direction and set to open
			 * or closed
			 */
			constructor(species: org.bukkit.TreeSpecies, face: org.bukkit.block.BlockFace, isOpen: boolean);

			/**
			 * Constructs the top half of a wooden door of the given species and with the hinge on the left or right
			 */
			constructor(species: org.bukkit.TreeSpecies, isHingeRight: boolean);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		namespace Door {
			/**
			 * Returns the item type of a wooden door for the given tree species.
			 */
			function getWoodDoorOfSpecies(species: org.bukkit.TreeSpecies): org.bukkit.Material;

		}
		interface Dye extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Gets the current color of this dye
			 */
			getColor(): org.bukkit.DyeColor;

			/**
			 * Sets the color of this dye
			 */
			setColor(color: org.bukkit.DyeColor): void;

			toString(): string;

			clone(): org.bukkit.material.Dye;

		}> {}
		class Dye {
			constructor();

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

			constructor(color: org.bukkit.DyeColor);

		}
		interface EnderChest extends Modify<org.bukkit.material.DirectionalContainer, {
			clone(): org.bukkit.material.EnderChest;

		}> {}
		class EnderChest {
			constructor();

			/**
			 * Instantiate an ender chest facing in a particular direction.
			 */
			constructor(direction: org.bukkit.block.BlockFace);

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface ExtendedRails extends Modify<org.bukkit.material.Rails, {
			isCurve(): boolean;

			/**
			 * Description copied from class:Â Rails
			 */
			setDirection(face: org.bukkit.block.BlockFace, isOnSlope: boolean): void;

			clone(): org.bukkit.material.ExtendedRails;

		}> {}
		class ExtendedRails {
			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface FlowerPot extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Get the material in the flower pot
			 */
			getContents(): org.bukkit.material.MaterialData;

			/**
			 * Set the contents of the flower pot
			 */
			setContents(materialData: org.bukkit.material.MaterialData): void;

			toString(): string;

			clone(): org.bukkit.material.FlowerPot;

		}> {}
		class FlowerPot {
			/**
			 * Default constructor for a flower pot.
			 */
			constructor();

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Furnace extends Modify<org.bukkit.material.FurnaceAndDispenser, {
			clone(): org.bukkit.material.Furnace;

		}> {}
		class Furnace {
			constructor();

			/**
			 * Instantiate a furnace facing in a particular direction.
			 */
			constructor(direction: org.bukkit.block.BlockFace);

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface FurnaceAndDispenser extends Modify<org.bukkit.material.DirectionalContainer, {
			clone(): org.bukkit.material.FurnaceAndDispenser;

		}> {}
		class FurnaceAndDispenser {
			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Gate extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Description copied from interface:Â Directional
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			/**
			 * Description copied from interface:Â Directional
			 */
			getFacing(): org.bukkit.block.BlockFace;

			/**
			 * Description copied from interface:Â Openable
			 */
			isOpen(): boolean;

			/**
			 * Description copied from interface:Â Openable
			 */
			setOpen(isOpen: boolean): void;

			toString(): string;

			clone(): org.bukkit.material.Gate;

		}> {}
		class Gate {
			constructor();

			constructor(type: org.bukkit.Material, data: any /* byte */);

			constructor(data: any /* byte */);

		}
		interface Hopper extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Sets whether the hopper is active or not.
			 */
			setActive(isActive: boolean): void;

			/**
			 * Checks whether the hopper is active or not.
			 */
			isActive(): boolean;

			/**
			 * Sets the direction this hopper is facing
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			/**
			 * Gets the direction this hopper is facing
			 */
			getFacing(): org.bukkit.block.BlockFace;

			toString(): string;

			clone(): org.bukkit.material.Hopper;

			/**
			 * Checks if the hopper is powered.
			 */
			isPowered(): boolean;

		}> {}
		class Hopper {
			/**
			 * Constructs a hopper facing the default direction (down) and initially
			 * active.
			 */
			constructor();

			/**
			 * Constructs a hopper facing the specified direction and initially active.
			 */
			constructor(facingDirection: org.bukkit.block.BlockFace);

			/**
			 * Constructs a hopper facing the specified direction and either active or
			 * not.
			 */
			constructor(facingDirection: org.bukkit.block.BlockFace, isActive: boolean);

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Ladder extends Modify<org.bukkit.material.SimpleAttachableMaterialData, {
			/**
			 * Gets the face that this block is attached on
			 */
			getAttachedFace(): org.bukkit.block.BlockFace;

			/**
			 * Sets the direction this ladder is facing
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			clone(): org.bukkit.material.Ladder;

		}> {}
		class Ladder {
			constructor();

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Leaves extends Modify<org.bukkit.material.Wood, {
			/**
			 * Checks if this leaf block is in the process of decaying
			 */
			isDecaying(): boolean;

			/**
			 * Set whether this leaf block is in the process of decaying
			 */
			setDecaying(isDecaying: boolean): void;

			/**
			 * Checks if this leaf block is permanent or can decay when too far from a
			 * log
			 */
			isDecayable(): boolean;

			/**
			 * Set whether this leaf block will disappear when too far from a log
			 */
			setDecayable(isDecayable: boolean): void;

			toString(): string;

			clone(): org.bukkit.material.Leaves;

		}> {}
		class Leaves {
			/**
			 * Constructs a leaf block.
			 */
			constructor();

			/**
			 * Constructs a leaf block of the given tree species.
			 */
			constructor(species: org.bukkit.TreeSpecies);

			/**
			 * Constructs a leaf block of the given tree species and flag for whether
			 * this leaf block will disappear when too far from a log.
			 */
			constructor(species: org.bukkit.TreeSpecies, isDecayable: boolean);

			/**
			 * Constructs a leaf block of the given type.
			 */
			constructor(type: org.bukkit.Material);

			/**
			 * Constructs a leaf block of the given type and tree species.
			 */
			constructor(type: org.bukkit.Material, species: org.bukkit.TreeSpecies);

			/**
			 * Constructs a leaf block of the given type and tree species and flag for
			 * whether this leaf block will disappear when too far from a log.
			 */
			constructor(type: org.bukkit.Material, species: org.bukkit.TreeSpecies, isDecayable: boolean);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Lever extends Modify<org.bukkit.material.SimpleAttachableMaterialData, {
			/**
			 * Gets the current state of this Material, indicating if it's powered or
			 * unpowered
			 */
			isPowered(): boolean;

			/**
			 * Set this lever to be powered or not.
			 */
			setPowered(isPowered: boolean): void;

			/**
			 * Gets the face that this block is attached on
			 */
			getAttachedFace(): org.bukkit.block.BlockFace;

			/**
			 * Sets the direction this lever is pointing in
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			toString(): string;

			clone(): org.bukkit.material.Lever;

		}> {}
		class Lever {
			constructor();

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface LongGrass extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Gets the current species of this grass
			 */
			getSpecies(): org.bukkit.GrassSpecies;

			/**
			 * Sets the species of this grass
			 */
			setSpecies(species: org.bukkit.GrassSpecies): void;

			toString(): string;

			clone(): org.bukkit.material.LongGrass;

		}> {}
		class LongGrass {
			constructor();

			constructor(species: org.bukkit.GrassSpecies);

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface MaterialData {
			/**
			 * Gets the raw data in this material
			 */
			getData(): any /* byte */;

			/**
			 * Sets the raw data of this material
			 */
			setData(data: any /* byte */): void;

			/**
			 * Gets the Material that this MaterialData represents
			 */
			getItemType(): org.bukkit.Material;

			/**
			 * Creates a new ItemStack based on this MaterialData
			 */
			toItemStack(): org.bukkit.inventory.ItemStack;

			/**
			 * Creates a new ItemStack based on this MaterialData
			 */
			toItemStack(amount: number): org.bukkit.inventory.ItemStack;

			toString(): string;

			hashCode(): number;

			equals(obj: any): boolean;

			clone(): org.bukkit.material.MaterialData;

		}
		class MaterialData {
			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface MonsterEggs extends Modify<org.bukkit.material.TexturedMaterial, {
			/**
			 * Description copied from class:Â TexturedMaterial
			 */
			getTextures(): globalThis.java.util.List<org.bukkit.Material>;

			clone(): org.bukkit.material.MonsterEggs;

		}> {}
		class MonsterEggs {
			constructor();

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Mushroom extends Modify<org.bukkit.material.MaterialData, {
			isStem(): boolean;

			/**
			 * Sets this to be a mushroom stem.
			 */
			setStem(): void;

			/**
			 * Gets the mushroom texture of this block.
			 */
			getBlockTexture(): org.bukkit.material.types.MushroomBlockTexture;

			/**
			 * Sets the mushroom texture of this block.
			 */
			setBlockTexture(texture: org.bukkit.material.types.MushroomBlockTexture): void;

			/**
			 * Checks whether a face of the block is painted with cap texture.
			 */
			isFacePainted(face: org.bukkit.block.BlockFace): boolean;

			/**
			 * Set a face of the block to be painted or not. Note that due to the
			 * nature of how the data is stored, setting a face painted or not is not
			 * guaranteed to leave the other faces unchanged.
			 */
			setFacePainted(face: org.bukkit.block.BlockFace, painted: boolean): void;

			getPaintedFaces(): globalThis.java.util.Set<org.bukkit.block.BlockFace>;

			toString(): string;

			clone(): org.bukkit.material.Mushroom;

		}> {}
		class Mushroom {
			/**
			 * Constructs a brown/red mushroom block with all sides set to pores.
			 */
			constructor(shroom: org.bukkit.Material);

			/**
			 * Constructs a brown/red mushroom cap block with the specified face or
			 * faces set to cap texture.
			 * Setting any of the four sides will also set the top to cap.
			 * To set two side faces at once use e.g. north-west.
			 * Specify self to set all six faces at once.
			 */
			constructor(shroom: org.bukkit.Material, capFace: org.bukkit.block.BlockFace);

			/**
			 * Constructs a brown/red mushroom block with the specified textures.
			 */
			constructor(shroom: org.bukkit.Material, texture: org.bukkit.material.types.MushroomBlockTexture);

			constructor(shroom: org.bukkit.Material, data: any /* byte */);

		}
		interface NetherWarts extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Gets the current growth state of this nether wart
			 */
			getState(): org.bukkit.NetherWartsState;

			/**
			 * Sets the growth state of this nether wart
			 */
			setState(state: org.bukkit.NetherWartsState): void;

			toString(): string;

			clone(): org.bukkit.material.NetherWarts;

		}> {}
		class NetherWarts {
			constructor();

			constructor(state: org.bukkit.NetherWartsState);

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Observer extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Description copied from interface:Â Redstone
			 */
			isPowered(): boolean;

			/**
			 * Description copied from interface:Â Directional
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			/**
			 * Description copied from interface:Â Directional
			 */
			getFacing(): org.bukkit.block.BlockFace;

			toString(): string;

			clone(): org.bukkit.material.Observer;

		}> {}
		class Observer {
			constructor();

			constructor(direction: org.bukkit.block.BlockFace);

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Openable {
			/**
			 * Check to see if the door is open.
			 */
			isOpen(): boolean;

			/**
			 * Configure this door to be either open or closed;
			 */
			setOpen(isOpen: boolean): void;

		}
		interface PistonBaseMaterial extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Description copied from interface:Â Directional
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			/**
			 * Description copied from interface:Â Directional
			 */
			getFacing(): org.bukkit.block.BlockFace;

			/**
			 * Description copied from interface:Â Redstone
			 */
			isPowered(): boolean;

			/**
			 * Sets the current state of this piston
			 */
			setPowered(powered: boolean): void;

			/**
			 * Checks if this piston base is sticky, and returns true if so
			 */
			isSticky(): boolean;

			clone(): org.bukkit.material.PistonBaseMaterial;

		}> {}
		class PistonBaseMaterial {
			constructor(type: org.bukkit.Material);

			/**
			 * Constructs a PistonBaseMaterial.
			 */
			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface PistonExtensionMaterial extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Description copied from interface:Â Directional
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			/**
			 * Description copied from interface:Â Directional
			 */
			getFacing(): org.bukkit.block.BlockFace;

			/**
			 * Checks if this piston extension is sticky, and returns true if so
			 */
			isSticky(): boolean;

			/**
			 * Sets whether or not this extension is sticky
			 */
			setSticky(sticky: boolean): void;

			/**
			 * Description copied from interface:Â Attachable
			 */
			getAttachedFace(): org.bukkit.block.BlockFace;

			clone(): org.bukkit.material.PistonExtensionMaterial;

		}> {}
		class PistonExtensionMaterial {
			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface PoweredRail extends Modify<org.bukkit.material.ExtendedRails, {
			/**
			 * Description copied from interface:Â Redstone
			 */
			isPowered(): boolean;

			/**
			 * Set whether this PoweredRail should be powered or not.
			 */
			setPowered(isPowered: boolean): void;

			clone(): org.bukkit.material.PoweredRail;

		}> {}
		class PoweredRail {
			constructor();

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface PressurePlate extends Modify<org.bukkit.material.MaterialData, {
			isPressed(): boolean;

			toString(): string;

			clone(): org.bukkit.material.PressurePlate;

		}> {}
		class PressurePlate {
			constructor();

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface PressureSensor {
			isPressed(): boolean;

		}
		interface Pumpkin extends Modify<org.bukkit.material.MaterialData, {
			isLit(): boolean;

			/**
			 * Description copied from interface:Â Directional
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			/**
			 * Description copied from interface:Â Directional
			 */
			getFacing(): org.bukkit.block.BlockFace;

			toString(): string;

			clone(): org.bukkit.material.Pumpkin;

		}> {}
		class Pumpkin {
			constructor();

			/**
			 * Instantiate a pumpkin facing in a particular direction.
			 */
			constructor(direction: org.bukkit.block.BlockFace);

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Rails extends Modify<org.bukkit.material.MaterialData, {
			isOnSlope(): boolean;

			isCurve(): boolean;

			getDirection(): org.bukkit.block.BlockFace;

			toString(): string;

			/**
			 * Set the direction of these tracks
			 * 
			 * Note that tracks are bidirectional and that the direction returned is
			 * the ascending direction if the track is set on a slope. If it is set as
			 * a curve, the corner of the track should be supplied.
			 */
			setDirection(face: org.bukkit.block.BlockFace, isOnSlope: boolean): void;

			clone(): org.bukkit.material.Rails;

		}> {}
		class Rails {
			constructor();

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Redstone {
			/**
			 * Gets the current state of this Material, indicating if it's powered or
			 * unpowered
			 */
			isPowered(): boolean;

		}
		interface RedstoneTorch extends Modify<org.bukkit.material.Torch, {
			/**
			 * Gets the current state of this Material, indicating if it's powered or
			 * unpowered
			 */
			isPowered(): boolean;

			toString(): string;

			clone(): org.bukkit.material.RedstoneTorch;

		}> {}
		class RedstoneTorch {
			constructor();

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface RedstoneWire extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Gets the current state of this Material, indicating if it's powered or
			 * unpowered
			 */
			isPowered(): boolean;

			toString(): string;

			clone(): org.bukkit.material.RedstoneWire;

		}> {}
		class RedstoneWire {
			constructor();

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Sandstone extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Gets the current type of this sandstone
			 */
			getType(): org.bukkit.SandstoneType;

			/**
			 * Sets the type of this sandstone
			 */
			setType(type: org.bukkit.SandstoneType): void;

			toString(): string;

			clone(): org.bukkit.material.Sandstone;

		}> {}
		class Sandstone {
			constructor();

			constructor(type: org.bukkit.SandstoneType);

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Sapling extends Modify<org.bukkit.material.Wood, {
			/**
			 * Checks if the Sapling would grow when next ticked with bonemeal
			 */
			isInstantGrowable(): boolean;

			/**
			 * Set whether this sapling will grow when next ticked with bonemeal
			 */
			setIsInstantGrowable(isInstantGrowable: boolean): void;

			toString(): string;

			clone(): org.bukkit.material.Sapling;

		}> {}
		class Sapling {
			/**
			 * Constructs a sapling.
			 */
			constructor();

			/**
			 * Constructs a sapling of the given tree species.
			 */
			constructor(species: org.bukkit.TreeSpecies);

			/**
			 * Constructs a sapling of the given tree species and if is it instant
			 * growable
			 */
			constructor(species: org.bukkit.TreeSpecies, isInstantGrowable: boolean);

			/**
			 * Constructs a sapling of the given type.
			 */
			constructor(type: org.bukkit.Material);

			/**
			 * Constructs a sapling of the given type and tree species.
			 */
			constructor(type: org.bukkit.Material, species: org.bukkit.TreeSpecies);

			/**
			 * Constructs a sapling of the given type and tree species and if is it
			 * instant growable
			 */
			constructor(type: org.bukkit.Material, species: org.bukkit.TreeSpecies, isInstantGrowable: boolean);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Sign extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Check if this sign is attached to a wall
			 */
			isWallSign(): boolean;

			/**
			 * Gets the face that this block is attached on
			 */
			getAttachedFace(): org.bukkit.block.BlockFace;

			/**
			 * Gets the direction that this sign is currently facing
			 */
			getFacing(): org.bukkit.block.BlockFace;

			/**
			 * Description copied from interface:Â Directional
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			toString(): string;

			clone(): org.bukkit.material.Sign;

		}> {}
		class Sign {
			constructor();

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface SimpleAttachableMaterialData extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Description copied from interface:Â Directional
			 */
			getFacing(): org.bukkit.block.BlockFace;

			toString(): string;

			clone(): org.bukkit.material.SimpleAttachableMaterialData;

		}> {}
		class SimpleAttachableMaterialData {
			constructor(type: org.bukkit.Material, direction: org.bukkit.block.BlockFace);

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Skull extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Description copied from interface:Â Directional
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			/**
			 * Description copied from interface:Â Directional
			 */
			getFacing(): org.bukkit.block.BlockFace;

			toString(): string;

			clone(): org.bukkit.material.Skull;

		}> {}
		class Skull {
			constructor();

			/**
			 * Instantiate a skull facing in a particular direction.
			 */
			constructor(direction: org.bukkit.block.BlockFace);

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface SmoothBrick extends Modify<org.bukkit.material.TexturedMaterial, {
			/**
			 * Description copied from class:Â TexturedMaterial
			 */
			getTextures(): globalThis.java.util.List<org.bukkit.Material>;

			clone(): org.bukkit.material.SmoothBrick;

		}> {}
		class SmoothBrick {
			constructor();

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface SpawnEgg extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Get the type of entity this egg will spawn.
			 */
			getSpawnedType(): org.bukkit.entity.EntityType;

			/**
			 * Set the type of entity this egg will spawn.
			 */
			setSpawnedType(type: org.bukkit.entity.EntityType): void;

			toString(): string;

			clone(): org.bukkit.material.SpawnEgg;

		}> {}
		class SpawnEgg {
			constructor();

			constructor(type: org.bukkit.Material, data: any /* byte */);

			constructor(data: any /* byte */);

			constructor(type: org.bukkit.entity.EntityType);

		}
		interface Stairs extends Modify<org.bukkit.material.MaterialData, {
			getAscendingDirection(): org.bukkit.block.BlockFace;

			getDescendingDirection(): org.bukkit.block.BlockFace;

			/**
			 * Set the direction the stair part of the block is facing
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			/**
			 * Description copied from interface:Â Directional
			 */
			getFacing(): org.bukkit.block.BlockFace;

			/**
			 * Test if step is inverted
			 */
			isInverted(): boolean;

			/**
			 * Set step inverted state
			 */
			setInverted(inv: boolean): void;

			toString(): string;

			clone(): org.bukkit.material.Stairs;

		}> {}
		class Stairs {
			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Step extends Modify<org.bukkit.material.TexturedMaterial, {
			/**
			 * Description copied from class:Â TexturedMaterial
			 */
			getTextures(): globalThis.java.util.List<org.bukkit.Material>;

			/**
			 * Test if step is inverted
			 */
			isInverted(): boolean;

			/**
			 * Set step inverted state
			 */
			setInverted(inv: boolean): void;

			clone(): org.bukkit.material.Step;

			toString(): string;

		}> {}
		class Step {
			constructor();

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface TexturedMaterial extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Retrieve a list of possible textures. The first element of the list
			 * will be used as a default.
			 */
			getTextures(): globalThis.java.util.List<org.bukkit.Material>;

			/**
			 * Gets the current Material this block is made of
			 */
			getMaterial(): org.bukkit.Material;

			/**
			 * Sets the material this block is made of
			 */
			setMaterial(material: org.bukkit.Material): void;

			toString(): string;

			clone(): org.bukkit.material.TexturedMaterial;

		}> {}
		class TexturedMaterial {
			constructor(m: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Torch extends Modify<org.bukkit.material.SimpleAttachableMaterialData, {
			/**
			 * Gets the face that this block is attached on
			 */
			getAttachedFace(): org.bukkit.block.BlockFace;

			/**
			 * Description copied from interface:Â Directional
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			clone(): org.bukkit.material.Torch;

		}> {}
		class Torch {
			constructor();

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface TrapDoor extends Modify<org.bukkit.material.SimpleAttachableMaterialData, {
			/**
			 * Description copied from interface:Â Openable
			 */
			isOpen(): boolean;

			/**
			 * Description copied from interface:Â Openable
			 */
			setOpen(isOpen: boolean): void;

			/**
			 * Test if trapdoor is inverted
			 */
			isInverted(): boolean;

			/**
			 * Set trapdoor inverted state
			 */
			setInverted(inv: boolean): void;

			/**
			 * Description copied from interface:Â Attachable
			 */
			getAttachedFace(): org.bukkit.block.BlockFace;

			/**
			 * Description copied from interface:Â Directional
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			toString(): string;

			clone(): org.bukkit.material.TrapDoor;

		}> {}
		class TrapDoor {
			constructor();

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Tree extends Modify<org.bukkit.material.Wood, {
			/**
			 * Get direction of the log
			 */
			getDirection(): org.bukkit.block.BlockFace;

			/**
			 * Set direction of the log
			 */
			setDirection(dir: org.bukkit.block.BlockFace): void;

			toString(): string;

			clone(): org.bukkit.material.Tree;

		}> {}
		class Tree {
			/**
			 * Constructs a tree block.
			 */
			constructor();

			/**
			 * Constructs a tree block of the given tree species.
			 */
			constructor(species: org.bukkit.TreeSpecies);

			/**
			 * Constructs a tree block of the given tree species, and facing the given
			 * direction.
			 */
			constructor(species: org.bukkit.TreeSpecies, dir: org.bukkit.block.BlockFace);

			/**
			 * Constructs a tree block of the given type.
			 */
			constructor(type: org.bukkit.Material);

			/**
			 * Constructs a tree block of the given type and tree species.
			 */
			constructor(type: org.bukkit.Material, species: org.bukkit.TreeSpecies);

			/**
			 * Constructs a tree block of the given type and tree species, and facing
			 * the given direction.
			 */
			constructor(type: org.bukkit.Material, species: org.bukkit.TreeSpecies, dir: org.bukkit.block.BlockFace);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Tripwire extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Test if tripwire is currently activated
			 */
			isActivated(): boolean;

			/**
			 * Set tripwire activated state
			 */
			setActivated(act: boolean): void;

			/**
			 * Test if object triggering this tripwire directly
			 */
			isObjectTriggering(): boolean;

			/**
			 * Set object triggering state for this tripwire
			 */
			setObjectTriggering(trig: boolean): void;

			clone(): org.bukkit.material.Tripwire;

			toString(): string;

		}> {}
		class Tripwire {
			constructor();

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface TripwireHook extends Modify<org.bukkit.material.SimpleAttachableMaterialData, {
			/**
			 * Test if tripwire is connected
			 */
			isConnected(): boolean;

			/**
			 * Set tripwire connection state
			 */
			setConnected(connected: boolean): void;

			/**
			 * Test if hook is currently activated
			 */
			isActivated(): boolean;

			/**
			 * Set hook activated state
			 */
			setActivated(act: boolean): void;

			/**
			 * Description copied from interface:Â Directional
			 */
			setFacingDirection(face: org.bukkit.block.BlockFace): void;

			/**
			 * Description copied from interface:Â Attachable
			 */
			getAttachedFace(): org.bukkit.block.BlockFace;

			/**
			 * Description copied from interface:Â Redstone
			 */
			isPowered(): boolean;

			clone(): org.bukkit.material.TripwireHook;

			toString(): string;

		}> {}
		class TripwireHook {
			constructor();

			constructor(type: org.bukkit.Material, data: any /* byte */);

			constructor(dir: org.bukkit.block.BlockFace);

		}
		interface Vine extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Check if the vine is attached to the specified face of an adjacent
			 * block. You can check two faces at once by passing e.g. BlockFace.NORTH_EAST.
			 */
			isOnFace(face: org.bukkit.block.BlockFace): boolean;

			/**
			 * Attach the vine to the specified face of an adjacent block.
			 */
			putOnFace(face: org.bukkit.block.BlockFace): void;

			/**
			 * Detach the vine from the specified face of an adjacent block.
			 */
			removeFromFace(face: org.bukkit.block.BlockFace): void;

			toString(): string;

			clone(): org.bukkit.material.Vine;

		}> {}
		class Vine {
			constructor();

			constructor(type: org.bukkit.Material, data: any /* byte */);

			constructor(data: any /* byte */);

			constructor(...faces: org.bukkit.block.BlockFace[]);

			constructor(faces: globalThis.java.util.EnumSet<org.bukkit.block.BlockFace>);

		}
		interface Wood extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Gets the current species of this wood block
			 */
			getSpecies(): org.bukkit.TreeSpecies;

			/**
			 * Sets the species of this wood block
			 */
			setSpecies(species: org.bukkit.TreeSpecies): void;

			toString(): string;

			clone(): org.bukkit.material.Wood;

		}> {}
		class Wood {
			/**
			 * Constructs a wood block.
			 */
			constructor();

			/**
			 * Constructs a wood block of the given tree species.
			 */
			constructor(species: org.bukkit.TreeSpecies);

			/**
			 * Constructs a wood block of the given type.
			 */
			constructor(type: org.bukkit.Material);

			/**
			 * Constructs a wood block of the given type and tree species.
			 */
			constructor(type: org.bukkit.Material, species: org.bukkit.TreeSpecies);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface WoodenStep extends Modify<org.bukkit.material.Wood, {
			/**
			 * Test if step is inverted
			 */
			isInverted(): boolean;

			/**
			 * Set step inverted state
			 */
			setInverted(inv: boolean): void;

			clone(): org.bukkit.material.WoodenStep;

			toString(): string;

		}> {}
		class WoodenStep {
			/**
			 * Constructs a wooden step.
			 */
			constructor();

			/**
			 * Constructs a wooden step of the given tree species.
			 */
			constructor(species: org.bukkit.TreeSpecies);

			/**
			 * Constructs a wooden step of the given type and tree species, either
			 * inverted or not.
			 */
			constructor(species: org.bukkit.TreeSpecies, inv: boolean);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
		interface Wool extends Modify<org.bukkit.material.MaterialData, {
			/**
			 * Gets the current color of this dye
			 */
			getColor(): org.bukkit.DyeColor;

			/**
			 * Sets the color of this dye
			 */
			setColor(color: org.bukkit.DyeColor): void;

			toString(): string;

			clone(): org.bukkit.material.Wool;

		}> {}
		class Wool {
			constructor();

			constructor(color: org.bukkit.DyeColor);

			constructor(type: org.bukkit.Material);

			constructor(type: org.bukkit.Material, data: any /* byte */);

		}
	}
	namespace org.bukkit.attribute {
		interface Attributable {
			/**
			 * Gets the specified attribute instance from the object. This instance will
			 * be backed directly to the object and any changes will be visible at once.
			 */
			getAttribute(attribute: org.bukkit.attribute.Attribute): (org.bukkit.attribute.AttributeInstance | null);

		}
		interface Attribute {
			/**
			 * Description copied from interface:Â Keyed
			 */
			getKey(): org.bukkit.NamespacedKey;

			/**
			 * Description copied from interface:Â Translatable
			 */
			getTranslationKey(): string;

		}
		namespace Attribute {
			/**
			 * Maximum health of an Entity.
			 */
			const GENERIC_MAX_HEALTH: org.bukkit.attribute.Attribute;

			/**
			 * Range at which an Entity will follow others.
			 */
			const GENERIC_FOLLOW_RANGE: org.bukkit.attribute.Attribute;

			/**
			 * Resistance of an Entity to knockback.
			 */
			const GENERIC_KNOCKBACK_RESISTANCE: org.bukkit.attribute.Attribute;

			/**
			 * Movement speed of an Entity.
			 */
			const GENERIC_MOVEMENT_SPEED: org.bukkit.attribute.Attribute;

			/**
			 * Flying speed of an Entity.
			 */
			const GENERIC_FLYING_SPEED: org.bukkit.attribute.Attribute;

			/**
			 * Attack damage of an Entity.
			 */
			const GENERIC_ATTACK_DAMAGE: org.bukkit.attribute.Attribute;

			/**
			 * Attack knockback of an Entity.
			 */
			const GENERIC_ATTACK_KNOCKBACK: org.bukkit.attribute.Attribute;

			/**
			 * Attack speed of an Entity.
			 */
			const GENERIC_ATTACK_SPEED: org.bukkit.attribute.Attribute;

			/**
			 * Armor bonus of an Entity.
			 */
			const GENERIC_ARMOR: org.bukkit.attribute.Attribute;

			/**
			 * Armor durability bonus of an Entity.
			 */
			const GENERIC_ARMOR_TOUGHNESS: org.bukkit.attribute.Attribute;

			/**
			 * The fall damage multiplier of an Entity.
			 */
			const GENERIC_FALL_DAMAGE_MULTIPLIER: org.bukkit.attribute.Attribute;

			/**
			 * Luck bonus of an Entity.
			 */
			const GENERIC_LUCK: org.bukkit.attribute.Attribute;

			/**
			 * Maximum absorption of an Entity.
			 */
			const GENERIC_MAX_ABSORPTION: org.bukkit.attribute.Attribute;

			/**
			 * The distance which an Entity can fall without damage.
			 */
			const GENERIC_SAFE_FALL_DISTANCE: org.bukkit.attribute.Attribute;

			/**
			 * The relative scale of an Entity.
			 */
			const GENERIC_SCALE: org.bukkit.attribute.Attribute;

			/**
			 * The height which an Entity can walk over.
			 */
			const GENERIC_STEP_HEIGHT: org.bukkit.attribute.Attribute;

			/**
			 * The gravity applied to an Entity.
			 */
			const GENERIC_GRAVITY: org.bukkit.attribute.Attribute;

			/**
			 * Strength with which an Entity will jump.
			 */
			const GENERIC_JUMP_STRENGTH: org.bukkit.attribute.Attribute;

			/**
			 * How long an entity remains burning after ingition.
			 */
			const GENERIC_BURNING_TIME: org.bukkit.attribute.Attribute;

			/**
			 * Resistance to knockback from explosions.
			 */
			const GENERIC_EXPLOSION_KNOCKBACK_RESISTANCE: org.bukkit.attribute.Attribute;

			/**
			 * Movement speed through difficult terrain.
			 */
			const GENERIC_MOVEMENT_EFFICIENCY: org.bukkit.attribute.Attribute;

			/**
			 * Oxygen use underwater.
			 */
			const GENERIC_OXYGEN_BONUS: org.bukkit.attribute.Attribute;

			/**
			 * Movement speed through water.
			 */
			const GENERIC_WATER_MOVEMENT_EFFICIENCY: org.bukkit.attribute.Attribute;

			/**
			 * The block reach distance of a Player.
			 */
			const PLAYER_BLOCK_INTERACTION_RANGE: org.bukkit.attribute.Attribute;

			/**
			 * The entity reach distance of a Player.
			 */
			const PLAYER_ENTITY_INTERACTION_RANGE: org.bukkit.attribute.Attribute;

			/**
			 * Block break speed of a Player.
			 */
			const PLAYER_BLOCK_BREAK_SPEED: org.bukkit.attribute.Attribute;

			/**
			 * Mining speed for correct tools.
			 */
			const PLAYER_MINING_EFFICIENCY: org.bukkit.attribute.Attribute;

			/**
			 * Sneaking speed.
			 */
			const PLAYER_SNEAKING_SPEED: org.bukkit.attribute.Attribute;

			/**
			 * Underwater mining speed.
			 */
			const PLAYER_SUBMERGED_MINING_SPEED: org.bukkit.attribute.Attribute;

			/**
			 * Sweeping damage.
			 */
			const PLAYER_SWEEPING_DAMAGE_RATIO: org.bukkit.attribute.Attribute;

			/**
			 * Chance of a zombie to spawn reinforcements.
			 */
			const ZOMBIE_SPAWN_REINFORCEMENTS: org.bukkit.attribute.Attribute;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.attribute.Attribute;

		}
		interface AttributeInstance {
			/**
			 * The attribute pertaining to this instance.
			 */
			getAttribute(): org.bukkit.attribute.Attribute;

			/**
			 * Base value of this instance before modifiers are applied.
			 */
			getBaseValue(): number;

			/**
			 * Set the base value of this instance.
			 */
			setBaseValue(value: number): void;

			/**
			 * Get all modifiers present on this instance.
			 */
			getModifiers(): globalThis.java.util.Collection<org.bukkit.attribute.AttributeModifier>;

			/**
			 * Add a modifier to this instance.
			 */
			addModifier(modifier: org.bukkit.attribute.AttributeModifier): void;

			/**
			 * Remove a modifier from this instance.
			 */
			removeModifier(modifier: org.bukkit.attribute.AttributeModifier): void;

			/**
			 * Get the value of this instance after all associated modifiers have been
			 * applied.
			 */
			getValue(): number;

			/**
			 * Gets the default value of the Attribute attached to this instance.
			 */
			getDefaultValue(): number;

		}
		interface AttributeModifier {
			/**
			 * Get the unique ID for this modifier.
			 */
			getUniqueId(): globalThis.java.util.UUID;

			/**
			 * Description copied from interface:Â Keyed
			 */
			getKey(): org.bukkit.NamespacedKey;

			/**
			 * Get the name of this modifier.
			 */
			getName(): string;

			/**
			 * Get the amount by which this modifier will apply its AttributeModifier.Operation.
			 */
			getAmount(): number;

			/**
			 * Get the operation this modifier will apply.
			 */
			getOperation(): org.bukkit.attribute.AttributeModifier.Operation;

			/**
			 * Get the EquipmentSlot this AttributeModifier is active on,
			 * or null if this modifier is applicable for any slot.
			 */
			getSlot(): (org.bukkit.inventory.EquipmentSlot | null);

			/**
			 * Get the EquipmentSlot this AttributeModifier is active on,
			 * or null if this modifier is applicable for any slot.
			 */
			getSlotGroup(): org.bukkit.inventory.EquipmentSlotGroup;

			/**
			 * Description copied from interface:Â ConfigurationSerializable
			 */
			serialize(): globalThis.java.util.Map<string, any>;

			equals(other: any): boolean;

			hashCode(): number;

			toString(): string;

		}
		class AttributeModifier {
			constructor(name: string, amount: number, operation: org.bukkit.attribute.AttributeModifier.Operation);

			constructor(uuid: globalThis.java.util.UUID, name: string, amount: number, operation: org.bukkit.attribute.AttributeModifier.Operation);

			constructor(uuid: globalThis.java.util.UUID, name: string, amount: number, operation: org.bukkit.attribute.AttributeModifier.Operation, slot: (org.bukkit.inventory.EquipmentSlot | null));

			constructor(uuid: globalThis.java.util.UUID, name: string, amount: number, operation: org.bukkit.attribute.AttributeModifier.Operation, slot: org.bukkit.inventory.EquipmentSlotGroup);

			constructor(key: org.bukkit.NamespacedKey, amount: number, operation: org.bukkit.attribute.AttributeModifier.Operation, slot: org.bukkit.inventory.EquipmentSlotGroup);

		}
		namespace AttributeModifier {
			function deserialize(args: globalThis.java.util.Map<string, any>): org.bukkit.attribute.AttributeModifier;

		}
		namespace AttributeModifier {
			interface Operation {}
			namespace Operation {
				/**
				 * Adds (or subtracts) the specified amount to the base value.
				 */
				const ADD_NUMBER: org.bukkit.attribute.AttributeModifier.Operation;

				/**
				 * Adds this scalar of amount to the base value.
				 */
				const ADD_SCALAR: org.bukkit.attribute.AttributeModifier.Operation;

				/**
				 * Multiply amount by this value, after adding 1 to it.
				 */
				const MULTIPLY_SCALAR_1: org.bukkit.attribute.AttributeModifier.Operation;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.attribute.AttributeModifier.Operation;

			}
		}
	}
	namespace org.bukkit.plugin {
		interface AuthorNagException {
			getMessage(): string;

		}
		class AuthorNagException {
			/**
			 * Constructs a new AuthorNagException based on the given Exception
			 */
			constructor(message: string);

		}
		interface EventExecutor {
			execute(listener: org.bukkit.event.Listener, event: org.bukkit.event.Event): void;

		}
		interface IllegalPluginAccessException {
		}
		class IllegalPluginAccessException {
			/**
			 * Creates a new instance of IllegalPluginAccessException
			 * without detail message.
			 */
			constructor();

			/**
			 * Constructs an instance of IllegalPluginAccessException
			 * with the specified detail message.
			 */
			constructor(msg: string);

		}
		interface InvalidDescriptionException {
		}
		class InvalidDescriptionException {
			/**
			 * Constructs a new InvalidDescriptionException based on the given
			 * Exception
			 */
			constructor(cause: globalThis.java.lang.Throwable, message: string);

			/**
			 * Constructs a new InvalidDescriptionException based on the given
			 * Exception
			 */
			constructor(cause: globalThis.java.lang.Throwable);

			/**
			 * Constructs a new InvalidDescriptionException with the given message
			 */
			constructor(message: string);

			/**
			 * Constructs a new InvalidDescriptionException
			 */
			constructor();

		}
		interface InvalidPluginException {
		}
		class InvalidPluginException {
			/**
			 * Constructs a new InvalidPluginException based on the given Exception
			 */
			constructor(cause: globalThis.java.lang.Throwable);

			/**
			 * Constructs a new InvalidPluginException
			 */
			constructor();

			/**
			 * Constructs a new InvalidPluginException with the specified detail
			 * message and cause.
			 */
			constructor(message: string, cause: globalThis.java.lang.Throwable);

			/**
			 * Constructs a new InvalidPluginException with the specified detail
			 * message
			 */
			constructor(message: string);

		}
		interface Plugin extends Modify<org.bukkit.command.TabExecutor, {
			/**
			 * Returns the folder that the plugin data's files are located in. The
			 * folder may not yet exist.
			 */
			getDataFolder(): any /* java.io.File */;

			/**
			 * Returns the plugin.yaml file containing the details for this plugin
			 */
			getDescription(): org.bukkit.plugin.PluginDescriptionFile;

			/**
			 * Gets a FileConfiguration for this plugin, read through
			 * "config.yml"
			 * 
			 * If there is a default config.yml embedded in this plugin, it will be
			 * provided as a default for this Configuration.
			 */
			getConfig(): org.bukkit.configuration.file.FileConfiguration;

			/**
			 * Gets an embedded resource in this plugin
			 */
			getResource(filename: string): (any /* java.io.InputStream */ | null);

			/**
			 * Saves the FileConfiguration retrievable by getConfig().
			 */
			saveConfig(): void;

			/**
			 * Saves the raw contents of the default config.yml file to the location
			 * retrievable by getConfig().
			 * 
			 * This should fail silently if the config.yml already exists.
			 */
			saveDefaultConfig(): void;

			/**
			 * Saves the raw contents of any resource embedded with a plugin's .jar
			 * file assuming it can be found using getResource(String).
			 * 
			 * The resource is saved into the plugin's data folder using the same
			 * hierarchy as the .jar file (subdirectories are preserved).
			 */
			saveResource(resourcePath: string, replace: boolean): void;

			/**
			 * Discards any data in getConfig() and reloads from disk.
			 */
			reloadConfig(): void;

			/**
			 * Gets the associated PluginLoader responsible for this plugin
			 */
			getPluginLoader(): org.bukkit.plugin.PluginLoader;

			/**
			 * Returns the Server instance currently running this plugin
			 */
			getServer(): org.bukkit.Server;

			/**
			 * Returns a value indicating whether or not this plugin is currently
			 * enabled
			 */
			isEnabled(): boolean;

			/**
			 * Called when this plugin is disabled
			 */
			onDisable(): void;

			/**
			 * Called after a plugin is loaded but before it has been enabled.
			 * 
			 * When multiple plugins are loaded, the onLoad() for all plugins is
			 * called before any onEnable() is called.
			 */
			onLoad(): void;

			/**
			 * Called when this plugin is enabled
			 */
			onEnable(): void;

			/**
			 * Simple boolean if we can still nag to the logs about things
			 */
			isNaggable(): boolean;

			/**
			 * Set naggable state
			 */
			setNaggable(canNag: boolean): void;

			/**
			 * Gets a ChunkGenerator for use in a default world, as specified
			 * in the server configuration
			 */
			getDefaultWorldGenerator(worldName: string, id: (string | null)): (org.bukkit.generator.ChunkGenerator | null);

			/**
			 * Gets a BiomeProvider for use in a default world, as specified
			 * in the server configuration
			 */
			getDefaultBiomeProvider(worldName: string, id: (string | null)): (org.bukkit.generator.BiomeProvider | null);

			/**
			 * Returns the plugin logger associated with this server's logger. The
			 * returned logger automatically tags all log messages with the plugin's
			 * name.
			 */
			getLogger(): globalThis.java.util.logging.Logger;

			/**
			 * Returns the name of the plugin.
			 * 
			 * This should return the bare name of the plugin and should be used for
			 * comparison.
			 */
			getName(): string;

		}> {}
		interface PluginAwareness {}
		namespace PluginAwareness {
			interface Flags {}
			namespace Flags {
				/**
				 * This specifies that all (text) resources stored in a plugin's jar
				 * use UTF-8 encoding.
				 */
				const UTF8: org.bukkit.plugin.PluginAwareness.Flags;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.plugin.PluginAwareness.Flags;

			}
		}
		interface PluginBase {
			hashCode(): number;

			equals(obj: any): boolean;

			/**
			 * Description copied from interface:Â Plugin
			 */
			getName(): string;

		}
		class PluginBase {
			constructor();

		}
		interface PluginDescriptionFile {
			/**
			 * Gives the name of the plugin. This name is a unique identifier for
			 * plugins.
			 * 
			 * Must consist of all alphanumeric characters, underscores, hyphon,
			 * and period (a-z,A-Z,0-9, _.-). Any other character will cause the
			 * plugin.yml to fail loading.
			 * Used to determine the name of the plugin's data folder. Data
			 * folders are placed in the ./plugins/ directory by default, but this
			 * behavior should not be relied on. Plugin.getDataFolder()
			 * should be used to reference the data folder.
			 * It is good practice to name your jar the same as this, for example
			 * 'MyPlugin.jar'.
			 * Case sensitive.
			 * The is the token referenced in getDepend(), getSoftDepend(), and getLoadBefore().
			 * Using spaces in the plugin's name is deprecated.
			 * 
			 * 
			 * In the plugin.yml, this entry is named name.
			 * 
			 * Example:name: MyPlugin
			 */
			getName(): string;

			/**
			 * Gives the list of other plugin APIs which this plugin provides.
			 * These are usable for other plugins to depend on.
			 * 
			 * Must consist of all alphanumeric characters, underscores, hyphon,
			 * and period (a-z,A-Z,0-9, _.-). Any other character will cause the
			 * plugin.yml to fail loading.
			 * A different plugin providing the same one or using it as their name
			 * will not result in the plugin to fail loading.
			 * Case sensitive.
			 * An entry of this list can be referenced in getDepend(),
			 * getSoftDepend(), and getLoadBefore().
			 * provides must be in YAML list
			 * format.
			 * 
			 * 
			 * In the plugin.yml, this entry is named provides.
			 * 
			 * Example:
			 * provides:
			 * - OtherPluginName
			 * - OldPluginName
			 */
			getProvides(): globalThis.java.util.List<string>;

			/**
			 * Gives the version of the plugin.
			 * 
			 * Version is an arbitrary string, however the most common format is
			 * MajorRelease.MinorRelease.Build (eg: 1.4.1).
			 * Typically you will increment this every time you release a new
			 * feature or bug fix.
			 * Displayed when a user types /version PluginName
			 * 
			 * 
			 * In the plugin.yml, this entry is named version.
			 * 
			 * Example:version: 1.4.1
			 */
			getVersion(): string;

			/**
			 * Gives the fully qualified name of the main class for a plugin. The
			 * format should follow the ClassLoader.loadClass(String) syntax
			 * to successfully be resolved at runtime. For most plugins, this is the
			 * class that extends JavaPlugin.
			 * 
			 * This must contain the full namespace including the class file
			 * itself.
			 * If your namespace is org.bukkit.plugin, and your class
			 * file is called MyPlugin then this must be
			 * org.bukkit.plugin.MyPlugin
			 * No plugin can use org.bukkit. as a base package for
			 * any class, including the main class.
			 * 
			 * 
			 * In the plugin.yml, this entry is named main.
			 * 
			 * Example:
			 * main: org.bukkit.plugin.MyPlugin
			 */
			getMain(): string;

			/**
			 * Gives a human-friendly description of the functionality the plugin
			 * provides.
			 * 
			 * The description can have multiple lines.
			 * Displayed when a user types /version PluginName
			 * 
			 * 
			 * In the plugin.yml, this entry is named description.
			 * 
			 * Example:
			 * description: This plugin is so 31337. You can set yourself on fire.
			 */
			getDescription(): (string | null);

			/**
			 * Gives the phase of server startup that the plugin should be loaded.
			 * 
			 * Possible values are in PluginLoadOrder.
			 * Defaults to PluginLoadOrder.POSTWORLD.
			 * Certain caveats apply to each phase.
			 * When different, getDepend(), getSoftDepend(), and
			 * getLoadBefore() become relative in order loaded per-phase.
			 * If a plugin loads at STARTUP, but a dependency loads
			 * at POSTWORLD, the dependency will not be loaded before
			 * the plugin is loaded.
			 * 
			 * 
			 * In the plugin.yml, this entry is named load.
			 * 
			 * Example:load: STARTUP
			 */
			getLoad(): org.bukkit.plugin.PluginLoadOrder;

			/**
			 * Gives the list of authors for the plugin.
			 * 
			 * Gives credit to the developer.
			 * Used in some server error messages to provide helpful feedback on
			 * who to contact when an error occurs.
			 * A SpigotMC forum handle or email address is recommended.
			 * Is displayed when a user types /version PluginName
			 * authors must be in YAML list
			 * format.
			 * 
			 * 
			 * In the plugin.yml, this has two entries, author and
			 * authors.
			 * 
			 * Single author example:
			 * author: CaptainInflamo
			 * Multiple author example:
			 * authors: [Cogito, verrier, EvilSeph]
			 * When both are specified, author will be the first entry in the list, so
			 * this example:
			 * author: Grum
			 * authors:
			 * - feildmaster
			 * - amaranth
			 * Is equivilant to this example:
			 * authors: [Grum, feildmaster, aramanth]
			 */
			getAuthors(): globalThis.java.util.List<string>;

			/**
			 * Gives the list of contributors for the plugin.
			 * 
			 * Gives credit to those that have contributed to the plugin, though
			 * not enough so to warrant authorship.
			 * Unlike getAuthors(), contributors will not be mentioned in
			 * server error messages as a means of contact.
			 * A SpigotMC forum handle or email address is recommended.
			 * Is displayed when a user types /version PluginName
			 * contributors must be in YAML list
			 * format.
			 * 
			 * 
			 * Example:
			 * authors: [Choco, md_5]
			 */
			getContributors(): globalThis.java.util.List<string>;

			/**
			 * Gives the plugin's or plugin's author's website.
			 * 
			 * A link to the Curse page that includes documentation and downloads
			 * is highly recommended.
			 * Displayed when a user types /version PluginName
			 * 
			 * 
			 * In the plugin.yml, this entry is named website.
			 * 
			 * Example:
			 * website: http://www.curse.com/server-mods/minecraft/myplugin
			 */
			getWebsite(): (string | null);

			/**
			 * Gives a list of other plugins that the plugin requires.
			 * 
			 * Use the value in the getName() of the target plugin to
			 * specify the dependency.
			 * If any plugin listed here is not found, your plugin will fail to
			 * load at startup.
			 * If multiple plugins list each other in depend,
			 * creating a network with no individual plugin does not list another
			 * plugin in the network,
			 * all plugins in that network will fail.
			 * depend must be in YAML list
			 * format.
			 * 
			 * 
			 * In the plugin.yml, this entry is named depend.
			 * 
			 * Example:
			 * depend:
			 * - OnePlugin
			 * - AnotherPlugin
			 */
			getDepend(): globalThis.java.util.List<string>;

			/**
			 * Gives a list of other plugins that the plugin requires for full
			 * functionality. The PluginManager will make best effort to treat
			 * all entries here as if they were a dependency, but
			 * will never fail because of one of these entries.
			 * 
			 * Use the value in the getName() of the target plugin to
			 * specify the dependency.
			 * When an unresolvable plugin is listed, it will be ignored and does
			 * not affect load order.
			 * When a circular dependency occurs (a network of plugins depending
			 * or soft-dependending each other), it will arbitrarily choose a
			 * plugin that can be resolved when ignoring soft-dependencies.
			 * softdepend must be in YAML list
			 * format.
			 * 
			 * 
			 * In the plugin.yml, this entry is named softdepend.
			 * 
			 * Example:
			 * softdepend: [OnePlugin, AnotherPlugin]
			 */
			getSoftDepend(): globalThis.java.util.List<string>;

			/**
			 * Gets the list of plugins that should consider this plugin a
			 * soft-dependency.
			 * 
			 * Use the value in the getName() of the target plugin to
			 * specify the dependency.
			 * The plugin should load before any other plugins listed here.
			 * Specifying another plugin here is strictly equivalent to having the
			 * specified plugin's getSoftDepend() include this plugin.
			 * loadbefore must be in YAML list
			 * format.
			 * 
			 * 
			 * In the plugin.yml, this entry is named loadbefore.
			 * 
			 * Example:
			 * loadbefore:
			 * - OnePlugin
			 * - AnotherPlugin
			 */
			getLoadBefore(): globalThis.java.util.List<string>;

			/**
			 * Gives the token to prefix plugin-specific logging messages with.
			 * 
			 * This includes all messages using Plugin.getLogger().
			 * If not specified, the server uses the plugin's name.
			 * This should clearly indicate what plugin is being logged.
			 * 
			 * 
			 * In the plugin.yml, this entry is named prefix.
			 * 
			 * Example:prefix: ex-why-zee
			 */
			getPrefix(): (string | null);

			/**
			 * Gives the map of command-name to command-properties. Each entry in this
			 * map corresponds to a single command and the respective values are the
			 * properties of the command. Each property, with the exception of
			 * aliases, can be defined at runtime using methods in PluginCommand and are defined here only as a convenience.
			 * 
			 * The command section's description
			 * 
			 * Node
			 * Method
			 * Type
			 * Description
			 * Example
			 * 
			 * description
			 * Command.setDescription(String)
			 * String
			 * A user-friendly description for a command. It is useful for
			 * documentation purposes as well as in-game help.
			 * description: Set yourself on fire
			 * 
			 * aliases
			 * Command.setAliases(List)
			 * String or List of
			 * strings
			 * Alternative command names, with special usefulness for commands
			 * that are already registered. Aliases are not effective when
			 * defined at runtime, so the plugin description file is the
			 * only way to have them properly defined.
			 * 
			 * Note: Command aliases may not have a colon in them.
			 * Single alias format:
			 * aliases: combust_me or
			 * multiple alias format:
			 * aliases: [combust_me, combustMe]
			 * 
			 * permission
			 * Command.setPermission(String)
			 * String
			 * The name of the Permission required to use the command.
			 * A user without the permission will receive the specified
			 * message (see below), or a
			 * standard one if no specific message is defined. Without the
			 * permission node, no CommandExecutor or
			 * PluginCommand.setTabCompleter(TabCompleter) will be called.
			 * permission: inferno.flagrate
			 * 
			 * permission-message
			 * Command.setPermissionMessage(String)
			 * String
			 * 
			 * Displayed to a player that attempts to use a command, but
			 * does not have the required permission. See above.
			 * <permission> is a macro that is replaced with the
			 * permission node required to use the command.
			 * Using empty quotes is a valid way to indicate nothing
			 * should be displayed to a player.
			 * 
			 * permission-message: You do not have /<permission>
			 * 
			 * usage
			 * Command.setUsage(String)
			 * String
			 * This message is displayed to a player when the PluginCommand.setExecutor(CommandExecutor) returns false.
			 * <command> is a macro that is replaced the command issued.
			 * usage: Syntax error! Perhaps you meant /<command> PlayerName?
			 * It is worth noting that to use a colon in a yaml, like
			 * `usage: Usage: /god [player]', you need to
			 * surround
			 * the message with double-quote:
			 * usage: "Usage: /god [player]"
			 * 
			 * 
			 * The commands are structured as a hiearchy of nested mappings.
			 * The primary (top-level, no intendentation) node is
			 * `commands', while each individual command name is
			 * indented, indicating it maps to some value (in our case, the
			 * properties of the table above).
			 * 
			 * Here is an example bringing together the piecemeal examples above, as
			 * well as few more definitions:commands:
			 * flagrate:
			 * description: Set yourself on fire.
			 * aliases: [combust_me, combustMe]
			 * permission: inferno.flagrate
			 * permission-message: You do not have /<permission>
			 * usage: Syntax error! Perhaps you meant /<command> PlayerName?
			 * burningdeaths:
			 * description: List how many times you have died by fire.
			 * aliases:
			 * - burning_deaths
			 * - burningDeaths
			 * permission: inferno.burningdeaths
			 * usage: |
			 * /<command> [player]
			 * Example: /<command> - see how many times you have burned to death
			 * Example: /<command> CaptainIce - see how many times CaptainIce has burned to death
			 * # The next command has no description, aliases, etc. defined, but is still valid
			 * # Having an empty declaration is useful for defining the description, permission, and messages from a configuration dynamically
			 * apocalypse:
			 * 
			 * Note: Command names may not have a colon in their name.
			 */
			getCommands(): globalThis.java.util.Map<string>;

			/**
			 * Gives the list of permissions the plugin will register at runtime,
			 * immediately proceding enabling. The format for defining permissions is
			 * a map from permission name to properties. To represent a map without
			 * any specific property, empty curly-braces (
			 * {} ) may be used (as a null value is not
			 * accepted, unlike the commands above).
			 * 
			 * A list of optional properties for permissions:
			 * 
			 * The permission section's description
			 * 
			 * Node
			 * Description
			 * Example
			 * 
			 * description
			 * Plaintext (user-friendly) description of what the permission
			 * is for.
			 * description: Allows you to set yourself on fire
			 * 
			 * default
			 * The default state for the permission, as defined by Permission.getDefault(). If not defined, it will be set to
			 * the value of getPermissionDefault().
			 * 
			 * For reference:
			 * true - Represents a positive assignment to
			 * permissibles.
			 * false - Represents no assignment to permissibles.
			 * op - Represents a positive assignment to
			 * operator permissibles.
			 * notop - Represents a positive assignment to
			 * non-operator permissibiles.
			 * 
			 * default: true
			 * 
			 * children
			 * Allows other permissions to be set as a relation to the parent permission.
			 * When a parent permissions is assigned, child permissions are
			 * respectively assigned as well.
			 * 
			 * When a parent permission is assigned negatively, child
			 * permissions are assigned based on an inversion of their
			 * association.
			 * When a parent permission is assigned positively, child
			 * permissions are assigned based on their association.
			 * 
			 * 
			 * Child permissions may be defined in a number of ways:
			 * Children may be defined as a list of
			 * names. Using a list will treat all children associated
			 * positively to their parent.
			 * Children may be defined as a map. Each permission name maps
			 * to either a boolean (representing the association), or a
			 * nested permission definition (just as another permission).
			 * Using a nested definition treats the child as a positive
			 * association.
			 * A nested permission definition must be a map of these same
			 * properties. To define a valid nested permission without
			 * defining any specific property, empty curly-braces (
			 * {} ) must be used.
			 * A nested permission may carry it's own nested permissions
			 * as children, as they may also have nested permissions, and
			 * so forth. There is no direct limit to how deep the
			 * permission tree is defined.
			 * 
			 * As a list:
			 * children: [inferno.flagrate, inferno.burningdeaths]
			 * Or as a mapping:
			 * children:
			 * inferno.flagrate: true
			 * inferno.burningdeaths: true
			 * An additional example showing basic nested values can be seen
			 * here.
			 * 
			 * 
			 * 
			 * The permissions are structured as a hiearchy of nested mappings.
			 * The primary (top-level, no intendentation) node is
			 * `permissions', while each individual permission name is
			 * indented, indicating it maps to some value (in our case, the
			 * properties of the table above).
			 * 
			 * Here is an example using some of the properties:permissions:
			 * inferno.*:
			 * description: Gives access to all Inferno commands
			 * children:
			 * inferno.flagrate: true
			 * inferno.burningdeaths: true
			 * inferno.flagate:
			 * description: Allows you to ignite yourself
			 * default: true
			 * inferno.burningdeaths:
			 * description: Allows you to see how many times you have burned to death
			 * default: true
			 * 
			 * Another example, with nested definitions, can be found here.
			 */
			getPermissions(): globalThis.java.util.List<org.bukkit.permissions.Permission>;

			/**
			 * Gives the default default state of
			 * permissions registered for the plugin.
			 * 
			 * If not specified, it will be PermissionDefault.OP.
			 * It is matched using PermissionDefault.getByName(String)
			 * It only affects permissions that do not define the
			 * default node.
			 * It may be any value in PermissionDefault.
			 * 
			 * 
			 * In the plugin.yml, this entry is named default-permission.
			 * 
			 * Example:default-permission: NOT_OP
			 */
			getPermissionDefault(): org.bukkit.permissions.PermissionDefault;

			/**
			 * Gives a set of every PluginAwareness for a plugin. An awareness
			 * dictates something that a plugin developer acknowledges when the plugin
			 * is compiled. Some implementions may define extra awarenesses that are
			 * not included in the API. Any unrecognized
			 * awareness (one unsupported or in a future version) will cause a dummy
			 * object to be created instead of failing.
			 * 
			 * Currently only supports the enumerated values in PluginAwareness.Flags.
			 * Each awareness starts the identifier with bang-at
			 * (!@).
			 * Unrecognized (future / unimplemented) entries are quietly replaced
			 * by a generic object that implements PluginAwareness.
			 * A type of awareness must be defined by the runtime and acknowledged
			 * by the API, effectively discluding any derived type from any
			 * plugin's classpath.
			 * awareness must be in YAML list
			 * format.
			 * 
			 * 
			 * In the plugin.yml, this entry is named awareness.
			 * 
			 * Example:awareness:
			 * - !@UTF8
			 * 
			 * Note: Although unknown versions of some future awareness are
			 * gracefully substituted, previous versions of Bukkit (ones prior to the
			 * first implementation of awareness) will fail to load a plugin that
			 * defines any awareness.
			 */
			getAwareness(): globalThis.java.util.Set<org.bukkit.plugin.PluginAwareness>;

			/**
			 * Returns the name of a plugin, including the version. This method is
			 * provided for convenience; it uses the getName() and getVersion() entries.
			 */
			getFullName(): string;

			/**
			 * Gives the API version which this plugin is designed to support. No
			 * specific format is guaranteed.
			 * 
			 * Refer to release notes for supported API versions.
			 * 
			 * 
			 * In the plugin.yml, this entry is named api-version.
			 * 
			 * Example:api-version: 1.13
			 */
			getAPIVersion(): (string | null);

			/**
			 * Gets the libraries this plugin requires. This is a preview feature.
			 * 
			 * Libraries must be GAV specifiers and are loaded from Maven Central.
			 * 
			 * 
			 * Example:libraries:
			 * - com.squareup.okhttp3:okhttp:4.9.0
			 */
			getLibraries(): globalThis.java.util.List<string>;

			getClassLoaderOf(): (string | null);

			/**
			 * Saves this PluginDescriptionFile to the given writer
			 */
			save(writer: any /* java.io.Writer */): void;

			getRawName(): string;

		}
		class PluginDescriptionFile {
			constructor(stream: any /* java.io.InputStream */);

			/**
			 * Loads a PluginDescriptionFile from the specified reader
			 */
			constructor(reader: any /* java.io.Reader */);

			/**
			 * Creates a new PluginDescriptionFile with the given detailed
			 */
			constructor(pluginName: string, pluginVersion: string, mainClass: string);

		}
		interface PluginLoadOrder {}
		namespace PluginLoadOrder {
			/**
			 * Indicates that the plugin will be loaded at startup
			 */
			const STARTUP: org.bukkit.plugin.PluginLoadOrder;

			/**
			 * Indicates that the plugin will be loaded after the first/default world
			 * was created
			 */
			const POSTWORLD: org.bukkit.plugin.PluginLoadOrder;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.plugin.PluginLoadOrder;

		}
		interface PluginLoader {
			/**
			 * Loads the plugin contained in the specified file
			 */
			loadPlugin(file: any /* java.io.File */): org.bukkit.plugin.Plugin;

			/**
			 * Loads a PluginDescriptionFile from the specified file
			 */
			getPluginDescription(file: any /* java.io.File */): org.bukkit.plugin.PluginDescriptionFile;

			/**
			 * Creates and returns registered listeners for the event classes used in
			 * this listener
			 */
			createRegisteredListeners(listener: org.bukkit.event.Listener, plugin: org.bukkit.plugin.Plugin): globalThis.java.util.Map<globalThis.java.lang.Class<org.bukkit.event.Event>, globalThis.java.util.Set<org.bukkit.plugin.RegisteredListener>>;

			/**
			 * Enables the specified plugin
			 * 
			 * Attempting to enable a plugin that is already enabled will have no
			 * effect
			 */
			enablePlugin(plugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Disables the specified plugin
			 * 
			 * Attempting to disable a plugin that is not enabled will have no effect
			 */
			disablePlugin(plugin: org.bukkit.plugin.Plugin): void;

		}
		interface PluginLogger {
			log(logRecord: globalThis.java.util.logging.LogRecord): void;

		}
		class PluginLogger {
			/**
			 * Creates a new PluginLogger that extracts the name from a plugin.
			 */
			constructor(context: org.bukkit.plugin.Plugin);

		}
		interface PluginManager {
			/**
			 * Registers the specified plugin loader
			 */
			registerInterface(loader: globalThis.java.lang.Class<org.bukkit.plugin.PluginLoader>): void;

			/**
			 * Checks if the given plugin is loaded and returns it when applicable
			 * 
			 * Please note that the name of the plugin is case-sensitive
			 */
			getPlugin(name: string): (org.bukkit.plugin.Plugin | null);

			/**
			 * Checks if the given plugin is enabled or not
			 * 
			 * Please note that the name of the plugin is case-sensitive.
			 */
			isPluginEnabled(name: string): boolean;

			/**
			 * Checks if the given plugin is enabled or not
			 */
			isPluginEnabled(plugin: (org.bukkit.plugin.Plugin | null)): boolean;

			/**
			 * Loads the plugin in the specified file
			 * 
			 * File must be valid according to the current enabled Plugin interfaces
			 */
			loadPlugin(file: any /* java.io.File */): (org.bukkit.plugin.Plugin | null);

			/**
			 * Disables all the loaded plugins
			 */
			disablePlugins(): void;

			/**
			 * Disables and removes all plugins
			 */
			clearPlugins(): void;

			/**
			 * Calls an event with the given details
			 */
			callEvent(event: org.bukkit.event.Event): void;

			/**
			 * Registers all the events in the given listener class
			 */
			registerEvents(listener: org.bukkit.event.Listener, plugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Registers the specified executor to the given event class
			 */
			registerEvent(event: globalThis.java.lang.Class<org.bukkit.event.Event>, listener: org.bukkit.event.Listener, priority: org.bukkit.event.EventPriority, executor: org.bukkit.plugin.EventExecutor, plugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Registers the specified executor to the given event class
			 */
			registerEvent(event: globalThis.java.lang.Class<org.bukkit.event.Event>, listener: org.bukkit.event.Listener, priority: org.bukkit.event.EventPriority, executor: org.bukkit.plugin.EventExecutor, plugin: org.bukkit.plugin.Plugin, ignoreCancelled: boolean): void;

			/**
			 * Enables the specified plugin
			 * 
			 * Attempting to enable a plugin that is already enabled will have no
			 * effect
			 */
			enablePlugin(plugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Disables the specified plugin
			 * 
			 * Attempting to disable a plugin that is not enabled will have no effect
			 */
			disablePlugin(plugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Gets a Permission from its fully qualified name
			 */
			getPermission(name: string): (org.bukkit.permissions.Permission | null);

			/**
			 * Adds a Permission to this plugin manager.
			 * 
			 * If a permission is already defined with the given name of the new
			 * permission, an exception will be thrown.
			 */
			addPermission(perm: org.bukkit.permissions.Permission): void;

			/**
			 * Removes a Permission registration from this plugin manager.
			 * 
			 * If the specified permission does not exist in this plugin manager,
			 * nothing will happen.
			 * 
			 * Removing a permission registration will not remove the
			 * permission from any Permissibles that have it.
			 */
			removePermission(perm: org.bukkit.permissions.Permission): void;

			/**
			 * Removes a Permission registration from this plugin manager.
			 * 
			 * If the specified permission does not exist in this plugin manager,
			 * nothing will happen.
			 * 
			 * Removing a permission registration will not remove the
			 * permission from any Permissibles that have it.
			 */
			removePermission(name: string): void;

			/**
			 * Gets the default permissions for the given op status
			 */
			getDefaultPermissions(op: boolean): globalThis.java.util.Set<org.bukkit.permissions.Permission>;

			/**
			 * Recalculates the defaults for the given Permission.
			 * 
			 * This will have no effect if the specified permission is not registered
			 * here.
			 */
			recalculatePermissionDefaults(perm: org.bukkit.permissions.Permission): void;

			/**
			 * Subscribes the given Permissible for information about the requested
			 * Permission, by name.
			 * 
			 * If the specified Permission changes in any form, the Permissible will
			 * be asked to recalculate.
			 */
			subscribeToPermission(permission: string, permissible: org.bukkit.permissions.Permissible): void;

			/**
			 * Unsubscribes the given Permissible for information about the requested
			 * Permission, by name.
			 */
			unsubscribeFromPermission(permission: string, permissible: org.bukkit.permissions.Permissible): void;

			/**
			 * Gets a set containing all subscribed Permissibles to the given
			 * permission, by name
			 */
			getPermissionSubscriptions(permission: string): globalThis.java.util.Set<org.bukkit.permissions.Permissible>;

			/**
			 * Subscribes to the given Default permissions by operator status
			 * 
			 * If the specified defaults change in any form, the Permissible will be
			 * asked to recalculate.
			 */
			subscribeToDefaultPerms(op: boolean, permissible: org.bukkit.permissions.Permissible): void;

			/**
			 * Unsubscribes from the given Default permissions by operator status
			 */
			unsubscribeFromDefaultPerms(op: boolean, permissible: org.bukkit.permissions.Permissible): void;

			/**
			 * Gets a set containing all subscribed Permissibles to the given
			 * default list, by op status
			 */
			getDefaultPermSubscriptions(op: boolean): globalThis.java.util.Set<org.bukkit.permissions.Permissible>;

			/**
			 * Gets a set of all registered permissions.
			 * 
			 * This set is a copy and will not be modified live.
			 */
			getPermissions(): globalThis.java.util.Set<org.bukkit.permissions.Permission>;

			/**
			 * Returns whether or not timing code should be used for event calls
			 */
			useTimings(): boolean;

		}
		interface RegisteredListener {
			/**
			 * Gets the listener for this registration
			 */
			getListener(): org.bukkit.event.Listener;

			/**
			 * Gets the plugin for this registration
			 */
			getPlugin(): org.bukkit.plugin.Plugin;

			/**
			 * Gets the priority for this registration
			 */
			getPriority(): org.bukkit.event.EventPriority;

			/**
			 * Calls the event executor
			 */
			callEvent(event: org.bukkit.event.Event): void;

			/**
			 * Whether this listener accepts cancelled events
			 */
			isIgnoringCancelled(): boolean;

		}
		class RegisteredListener {
			constructor(listener: org.bukkit.event.Listener, executor: org.bukkit.plugin.EventExecutor, priority: org.bukkit.event.EventPriority, plugin: org.bukkit.plugin.Plugin, ignoreCancelled: boolean);

		}
		interface RegisteredServiceProvider<T = any> {
			getService(): globalThis.java.lang.Class<T>;

			getPlugin(): org.bukkit.plugin.Plugin;

			getProvider(): T;

			getPriority(): org.bukkit.plugin.ServicePriority;

			compareTo(other: org.bukkit.plugin.RegisteredServiceProvider): number;

		}
		class RegisteredServiceProvider<T = any> {
			constructor(service: globalThis.java.lang.Class<T>, provider: T, priority: org.bukkit.plugin.ServicePriority, plugin: org.bukkit.plugin.Plugin);

		}
		interface ServicePriority {}
		namespace ServicePriority {
			const Lowest: org.bukkit.plugin.ServicePriority;

			const Low: org.bukkit.plugin.ServicePriority;

			const Normal: org.bukkit.plugin.ServicePriority;

			const High: org.bukkit.plugin.ServicePriority;

			const Highest: org.bukkit.plugin.ServicePriority;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.plugin.ServicePriority;

		}
		interface ServicesManager {
			/**
			 * Register a provider of a service.
			 */
			register<T = any>(service: globalThis.java.lang.Class<T>, provider: T, plugin: org.bukkit.plugin.Plugin, priority: org.bukkit.plugin.ServicePriority): void;

			/**
			 * Unregister all the providers registered by a particular plugin.
			 */
			unregisterAll(plugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Unregister a particular provider for a particular service.
			 */
			unregister(service: globalThis.java.lang.Class, provider: any): void;

			/**
			 * Unregister a particular provider.
			 */
			unregister(provider: any): void;

			/**
			 * Queries for a provider. This may return null if no provider has been
			 * registered for a service. The highest priority provider is returned.
			 */
			load<T = any>(service: globalThis.java.lang.Class<T>): (T | null);

			/**
			 * Queries for a provider registration. This may return null if no provider
			 * has been registered for a service.
			 */
			getRegistration<T = any>(service: globalThis.java.lang.Class<T>): (org.bukkit.plugin.RegisteredServiceProvider<T> | null);

			/**
			 * Get registrations of providers for a plugin.
			 */
			getRegistrations(plugin: org.bukkit.plugin.Plugin): globalThis.java.util.List<org.bukkit.plugin.RegisteredServiceProvider>;

			/**
			 * Get registrations of providers for a service. The returned list is
			 * unmodifiable.
			 */
			getRegistrations<T = any>(service: globalThis.java.lang.Class<T>): globalThis.java.util.Collection<org.bukkit.plugin.RegisteredServiceProvider<T>>;

			/**
			 * Get a list of known services. A service is known if it has registered
			 * providers for it.
			 */
			getKnownServices(): globalThis.java.util.Collection<globalThis.java.lang.Class>;

			/**
			 * Returns whether a provider has been registered for a service. Do not
			 * check this first only to call load(service) later, as that
			 * would be a non-thread safe situation.
			 */
			isProvidedFor<T = any>(service: globalThis.java.lang.Class<T>): boolean;

		}
		interface SimplePluginManager {
			/**
			 * Registers the specified plugin loader
			 */
			registerInterface(loader: globalThis.java.lang.Class<org.bukkit.plugin.PluginLoader>): void;

			/**
			 * Loads the plugin in the specified file
			 * 
			 * File must be valid according to the current enabled Plugin interfaces
			 */
			loadPlugin(file: any /* java.io.File */): (org.bukkit.plugin.Plugin | null);

			/**
			 * Checks if the given plugin is loaded and returns it when applicable
			 * 
			 * Please note that the name of the plugin is case-sensitive
			 */
			getPlugin(name: string): (org.bukkit.plugin.Plugin | null);

			/**
			 * Checks if the given plugin is enabled or not
			 * 
			 * Please note that the name of the plugin is case-sensitive.
			 */
			isPluginEnabled(name: string): boolean;

			/**
			 * Checks if the given plugin is enabled or not
			 */
			isPluginEnabled(plugin: (org.bukkit.plugin.Plugin | null)): boolean;

			/**
			 * Description copied from interface:Â PluginManager
			 */
			enablePlugin(plugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Description copied from interface:Â PluginManager
			 */
			disablePlugins(): void;

			/**
			 * Description copied from interface:Â PluginManager
			 */
			disablePlugin(plugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Description copied from interface:Â PluginManager
			 */
			clearPlugins(): void;

			/**
			 * Calls an event with the given details.
			 */
			callEvent(event: org.bukkit.event.Event): void;

			/**
			 * Description copied from interface:Â PluginManager
			 */
			registerEvents(listener: org.bukkit.event.Listener, plugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Description copied from interface:Â PluginManager
			 */
			registerEvent(event: globalThis.java.lang.Class<org.bukkit.event.Event>, listener: org.bukkit.event.Listener, priority: org.bukkit.event.EventPriority, executor: org.bukkit.plugin.EventExecutor, plugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Registers the given event to the specified listener using a directly
			 * passed EventExecutor
			 */
			registerEvent(event: globalThis.java.lang.Class<org.bukkit.event.Event>, listener: org.bukkit.event.Listener, priority: org.bukkit.event.EventPriority, executor: org.bukkit.plugin.EventExecutor, plugin: org.bukkit.plugin.Plugin, ignoreCancelled: boolean): void;

			/**
			 * Description copied from interface:Â PluginManager
			 */
			getPermission(name: string): (org.bukkit.permissions.Permission | null);

			/**
			 * Description copied from interface:Â PluginManager
			 */
			addPermission(perm: org.bukkit.permissions.Permission): void;

			addPermission(perm: org.bukkit.permissions.Permission, dirty: boolean): void;

			/**
			 * Description copied from interface:Â PluginManager
			 */
			getDefaultPermissions(op: boolean): globalThis.java.util.Set<org.bukkit.permissions.Permission>;

			/**
			 * Description copied from interface:Â PluginManager
			 */
			removePermission(perm: org.bukkit.permissions.Permission): void;

			/**
			 * Description copied from interface:Â PluginManager
			 */
			removePermission(name: string): void;

			/**
			 * Description copied from interface:Â PluginManager
			 */
			recalculatePermissionDefaults(perm: org.bukkit.permissions.Permission): void;

			dirtyPermissibles(): void;

			/**
			 * Description copied from interface:Â PluginManager
			 */
			subscribeToPermission(permission: string, permissible: org.bukkit.permissions.Permissible): void;

			/**
			 * Description copied from interface:Â PluginManager
			 */
			unsubscribeFromPermission(permission: string, permissible: org.bukkit.permissions.Permissible): void;

			/**
			 * Description copied from interface:Â PluginManager
			 */
			getPermissionSubscriptions(permission: string): globalThis.java.util.Set<org.bukkit.permissions.Permissible>;

			/**
			 * Description copied from interface:Â PluginManager
			 */
			subscribeToDefaultPerms(op: boolean, permissible: org.bukkit.permissions.Permissible): void;

			/**
			 * Description copied from interface:Â PluginManager
			 */
			unsubscribeFromDefaultPerms(op: boolean, permissible: org.bukkit.permissions.Permissible): void;

			/**
			 * Description copied from interface:Â PluginManager
			 */
			getDefaultPermSubscriptions(op: boolean): globalThis.java.util.Set<org.bukkit.permissions.Permissible>;

			/**
			 * Description copied from interface:Â PluginManager
			 */
			getPermissions(): globalThis.java.util.Set<org.bukkit.permissions.Permission>;

			isTransitiveDepend(plugin: org.bukkit.plugin.PluginDescriptionFile, depend: org.bukkit.plugin.PluginDescriptionFile): boolean;

			/**
			 * Description copied from interface:Â PluginManager
			 */
			useTimings(): boolean;

			/**
			 * Sets whether or not per event timing code should be used
			 */
			useTimings(use: boolean): void;

		}
		class SimplePluginManager {
			constructor(instance: org.bukkit.Server, commandMap: org.bukkit.command.SimpleCommandMap);

		}
		interface SimpleServicesManager {
			/**
			 * Register a provider of a service.
			 */
			register<T = any>(service: globalThis.java.lang.Class<T>, provider: T, plugin: org.bukkit.plugin.Plugin, priority: org.bukkit.plugin.ServicePriority): void;

			/**
			 * Unregister all the providers registered by a particular plugin.
			 */
			unregisterAll(plugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Unregister a particular provider for a particular service.
			 */
			unregister(service: globalThis.java.lang.Class, provider: any): void;

			/**
			 * Unregister a particular provider.
			 */
			unregister(provider: any): void;

			/**
			 * Queries for a provider. This may return if no provider has been
			 * registered for a service. The highest priority provider is returned.
			 */
			load<T = any>(service: globalThis.java.lang.Class<T>): (T | null);

			/**
			 * Queries for a provider registration. This may return if no provider
			 * has been registered for a service.
			 */
			getRegistration<T = any>(service: globalThis.java.lang.Class<T>): (org.bukkit.plugin.RegisteredServiceProvider<T> | null);

			/**
			 * Get registrations of providers for a plugin.
			 */
			getRegistrations(plugin: org.bukkit.plugin.Plugin): globalThis.java.util.List<org.bukkit.plugin.RegisteredServiceProvider>;

			/**
			 * Get registrations of providers for a service. The returned list is
			 * an unmodifiable copy.
			 */
			getRegistrations<T = any>(service: globalThis.java.lang.Class<T>): globalThis.java.util.List<org.bukkit.plugin.RegisteredServiceProvider<T>>;

			/**
			 * Get a list of known services. A service is known if it has registered
			 * providers for it.
			 */
			getKnownServices(): globalThis.java.util.Set<globalThis.java.lang.Class>;

			/**
			 * Returns whether a provider has been registered for a service.
			 */
			isProvidedFor<T = any>(service: globalThis.java.lang.Class<T>): boolean;

		}
		class SimpleServicesManager {
			constructor();

		}
		interface TimedRegisteredListener extends Modify<org.bukkit.plugin.RegisteredListener, {
			/**
			 * Description copied from class:Â RegisteredListener
			 */
			callEvent(event: org.bukkit.event.Event): void;

			/**
			 * Resets the call count and total time for this listener
			 */
			reset(): void;

			/**
			 * Gets the total times this listener has been called
			 */
			getCount(): number;

			/**
			 * Gets the total time calls to this listener have taken
			 */
			getTotalTime(): number;

			/**
			 * Gets the class of the events this listener handled. If it handled
			 * multiple classes of event, the closest shared superclass will be
			 * returned, such that for any event this listener has handled,
			 * this.getEventClass().isAssignableFrom(event.getClass())
			 * and no class this.getEventClass().isAssignableFrom(clazz)
			 * && this.getEventClass() != clazz &&
			 * event.getClass().isAssignableFrom(clazz) for all handled events.
			 */
			getEventClass(): (globalThis.java.lang.Class<org.bukkit.event.Event> | null);

			/**
			 * Gets whether this listener has handled multiple events, such that for
			 * some two events, eventA.getClass() != eventB.getClass().
			 */
			hasMultiple(): boolean;

		}> {}
		class TimedRegisteredListener {
			constructor(pluginListener: org.bukkit.event.Listener, eventExecutor: org.bukkit.plugin.EventExecutor, eventPriority: org.bukkit.event.EventPriority, registeredPlugin: org.bukkit.plugin.Plugin, listenCancelled: boolean);

		}
		interface UnknownDependencyException {
		}
		class UnknownDependencyException {
			/**
			 * Constructs a new UnknownDependencyException based on the given
			 * Exception
			 */
			constructor(throwable: globalThis.java.lang.Throwable);

			/**
			 * Constructs a new UnknownDependencyException with the given message
			 */
			constructor(message: string);

			/**
			 * Constructs a new UnknownDependencyException based on the given
			 * Exception
			 */
			constructor(throwable: globalThis.java.lang.Throwable, message: string);

			/**
			 * Constructs a new UnknownDependencyException
			 */
			constructor();

		}
	}
	namespace org.bukkit.block {
		interface Banner extends Modify<org.bukkit.block.TileState, {
			/**
			 * Returns the base color for this banner
			 */
			getBaseColor(): org.bukkit.DyeColor;

			/**
			 * Sets the base color for this banner.
			 * Only valid for shield pseudo banners, otherwise base depends on block
			 * type
			 */
			setBaseColor(color: org.bukkit.DyeColor): void;

			/**
			 * Returns a list of patterns on this banner
			 */
			getPatterns(): globalThis.java.util.List<org.bukkit.block.banner.Pattern>;

			/**
			 * Sets the patterns used on this banner
			 */
			setPatterns(patterns: globalThis.java.util.List<org.bukkit.block.banner.Pattern>): void;

			/**
			 * Adds a new pattern on top of the existing
			 * patterns
			 */
			addPattern(pattern: org.bukkit.block.banner.Pattern): void;

			/**
			 * Returns the pattern at the specified index
			 */
			getPattern(i: number): org.bukkit.block.banner.Pattern;

			/**
			 * Removes the pattern at the specified index
			 */
			removePattern(i: number): org.bukkit.block.banner.Pattern;

			/**
			 * Sets the pattern at the specified index
			 */
			setPattern(i: number, pattern: org.bukkit.block.banner.Pattern): void;

			/**
			 * Returns the number of patterns on this
			 * banner
			 */
			numberOfPatterns(): number;

		}> {}
		interface Barrel extends Modify<org.bukkit.block.Container & org.bukkit.loot.Lootable & org.bukkit.block.Lidded, {}> {}
		interface Beacon extends Modify<org.bukkit.block.TileState & org.bukkit.block.Lockable & org.bukkit.Nameable, {
			/**
			 * Returns the list of players within the beacon's range of effect.
			 * 
			 * This will return an empty list if the block represented by this state is
			 * no longer a beacon.
			 */
			getEntitiesInRange(): globalThis.java.util.Collection<org.bukkit.entity.LivingEntity>;

			/**
			 * Returns the tier of the beacon pyramid (0-4). The tier refers to the
			 * beacon's power level, based on how many layers of blocks are in the
			 * pyramid. Tier 1 refers to a beacon with one layer of 9 blocks under it.
			 */
			getTier(): number;

			/**
			 * Returns the primary effect set on the beacon
			 */
			getPrimaryEffect(): (org.bukkit.potion.PotionEffect | null);

			/**
			 * Set the primary effect on this beacon, or null to clear.
			 */
			setPrimaryEffect(effect: (org.bukkit.potion.PotionEffectType | null)): void;

			/**
			 * Returns the secondary effect set on the beacon.
			 */
			getSecondaryEffect(): (org.bukkit.potion.PotionEffect | null);

			/**
			 * Set the secondary effect on this beacon, or null to clear. Note that tier
			 * must be >= 4 for this effect to be active.
			 */
			setSecondaryEffect(effect: (org.bukkit.potion.PotionEffectType | null)): void;

		}> {}
		interface Bed extends Modify<org.bukkit.block.TileState & org.bukkit.material.Colorable, {}> {}
		interface Beehive extends Modify<org.bukkit.block.EntityBlockStorage<org.bukkit.entity.Bee>, {
			/**
			 * Get the hive's flower location.
			 */
			getFlower(): (org.bukkit.Location | null);

			/**
			 * Set the hive's flower location.
			 */
			setFlower(location: (org.bukkit.Location | null)): void;

			/**
			 * Check if the hive is sedated due to smoke from a nearby campfire.
			 */
			isSedated(): boolean;

		}> {}
		interface Bell extends Modify<org.bukkit.block.TileState, {
			/**
			 * Ring this bell. This will call a BellRingEvent.
			 */
			ring(entity: (org.bukkit.entity.Entity | null), direction: (org.bukkit.block.BlockFace | null)): boolean;

			/**
			 * Ring this bell in the direction that the bell is facing. This will call a
			 * BellRingEvent.
			 */
			ring(entity: (org.bukkit.entity.Entity | null)): boolean;

			/**
			 * Ring this bell. This will call a BellRingEvent.
			 */
			ring(direction: (org.bukkit.block.BlockFace | null)): boolean;

			/**
			 * Ring this bell in the direction that the bell is facing. This will call a
			 * BellRingEvent.
			 */
			ring(): boolean;

			/**
			 * Check whether or not this bell is shaking. A bell is considered to be
			 * shaking if it was recently rung.
			 * 
			 * A bell will typically shake for 50 ticks.
			 */
			isShaking(): boolean;

			/**
			 * Get the amount of ticks since this bell has been shaking, or 0 if the
			 * bell is not currently shaking.
			 * 
			 * A bell will typically shake for 50 ticks.
			 */
			getShakingTicks(): number;

			/**
			 * Check whether or not this bell is resonating. A bell is considered to be
			 * resonating if while shaking, raiders were detected
			 * in the area and are ready to be highlighted to nearby players.
			 * 
			 * A bell will typically resonate for 40 ticks.
			 */
			isResonating(): boolean;

			/**
			 * Get the amount of ticks since this bell has been resonating, or 0 if the
			 * bell is not currently resonating.
			 * 
			 * A bell will typically resonate for 40 ticks.
			 */
			getResonatingTicks(): number;

		}> {}
		interface Biome {
			/**
			 * Description copied from interface:Â Keyed
			 */
			getKey(): org.bukkit.NamespacedKey;

		}
		namespace Biome {
			const OCEAN: org.bukkit.block.Biome;

			const PLAINS: org.bukkit.block.Biome;

			const DESERT: org.bukkit.block.Biome;

			const WINDSWEPT_HILLS: org.bukkit.block.Biome;

			const FOREST: org.bukkit.block.Biome;

			const TAIGA: org.bukkit.block.Biome;

			const SWAMP: org.bukkit.block.Biome;

			const MANGROVE_SWAMP: org.bukkit.block.Biome;

			const RIVER: org.bukkit.block.Biome;

			const NETHER_WASTES: org.bukkit.block.Biome;

			const THE_END: org.bukkit.block.Biome;

			const FROZEN_OCEAN: org.bukkit.block.Biome;

			const FROZEN_RIVER: org.bukkit.block.Biome;

			const SNOWY_PLAINS: org.bukkit.block.Biome;

			const MUSHROOM_FIELDS: org.bukkit.block.Biome;

			const BEACH: org.bukkit.block.Biome;

			const JUNGLE: org.bukkit.block.Biome;

			const SPARSE_JUNGLE: org.bukkit.block.Biome;

			const DEEP_OCEAN: org.bukkit.block.Biome;

			const STONY_SHORE: org.bukkit.block.Biome;

			const SNOWY_BEACH: org.bukkit.block.Biome;

			const BIRCH_FOREST: org.bukkit.block.Biome;

			const DARK_FOREST: org.bukkit.block.Biome;

			const SNOWY_TAIGA: org.bukkit.block.Biome;

			const OLD_GROWTH_PINE_TAIGA: org.bukkit.block.Biome;

			const WINDSWEPT_FOREST: org.bukkit.block.Biome;

			const SAVANNA: org.bukkit.block.Biome;

			const SAVANNA_PLATEAU: org.bukkit.block.Biome;

			const BADLANDS: org.bukkit.block.Biome;

			const WOODED_BADLANDS: org.bukkit.block.Biome;

			const SMALL_END_ISLANDS: org.bukkit.block.Biome;

			const END_MIDLANDS: org.bukkit.block.Biome;

			const END_HIGHLANDS: org.bukkit.block.Biome;

			const END_BARRENS: org.bukkit.block.Biome;

			const WARM_OCEAN: org.bukkit.block.Biome;

			const LUKEWARM_OCEAN: org.bukkit.block.Biome;

			const COLD_OCEAN: org.bukkit.block.Biome;

			const DEEP_LUKEWARM_OCEAN: org.bukkit.block.Biome;

			const DEEP_COLD_OCEAN: org.bukkit.block.Biome;

			const DEEP_FROZEN_OCEAN: org.bukkit.block.Biome;

			const THE_VOID: org.bukkit.block.Biome;

			const SUNFLOWER_PLAINS: org.bukkit.block.Biome;

			const WINDSWEPT_GRAVELLY_HILLS: org.bukkit.block.Biome;

			const FLOWER_FOREST: org.bukkit.block.Biome;

			const ICE_SPIKES: org.bukkit.block.Biome;

			const OLD_GROWTH_BIRCH_FOREST: org.bukkit.block.Biome;

			const OLD_GROWTH_SPRUCE_TAIGA: org.bukkit.block.Biome;

			const WINDSWEPT_SAVANNA: org.bukkit.block.Biome;

			const ERODED_BADLANDS: org.bukkit.block.Biome;

			const BAMBOO_JUNGLE: org.bukkit.block.Biome;

			const SOUL_SAND_VALLEY: org.bukkit.block.Biome;

			const CRIMSON_FOREST: org.bukkit.block.Biome;

			const WARPED_FOREST: org.bukkit.block.Biome;

			const BASALT_DELTAS: org.bukkit.block.Biome;

			const DRIPSTONE_CAVES: org.bukkit.block.Biome;

			const LUSH_CAVES: org.bukkit.block.Biome;

			const DEEP_DARK: org.bukkit.block.Biome;

			const MEADOW: org.bukkit.block.Biome;

			const GROVE: org.bukkit.block.Biome;

			const SNOWY_SLOPES: org.bukkit.block.Biome;

			const FROZEN_PEAKS: org.bukkit.block.Biome;

			const JAGGED_PEAKS: org.bukkit.block.Biome;

			const STONY_PEAKS: org.bukkit.block.Biome;

			const CHERRY_GROVE: org.bukkit.block.Biome;

			/**
			 * Represents a custom Biome
			 */
			const CUSTOM: org.bukkit.block.Biome;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.block.Biome;

		}
		interface BlastFurnace extends Modify<org.bukkit.block.Furnace, {}> {}
		interface Block extends Modify<org.bukkit.metadata.Metadatable & org.bukkit.Translatable, {
			/**
			 * Gets the metadata for this block
			 */
			getData(): any /* byte */;

			/**
			 * Gets the complete block data for this block
			 */
			getBlockData(): org.bukkit.block.data.BlockData;

			/**
			 * Gets the block at the given offsets
			 */
			getRelative(modX: number, modY: number, modZ: number): org.bukkit.block.Block;

			/**
			 * Gets the block at the given face
			 * 
			 * This method is equal to getRelative(face, 1)
			 */
			getRelative(face: org.bukkit.block.BlockFace): org.bukkit.block.Block;

			/**
			 * Gets the block at the given distance of the given face
			 * 
			 * For example, the following method places water at 100,102,100; two
			 * blocks above 100,100,100.
			 * Block block = world.getBlockAt(100, 100, 100);
			 * Block shower = block.getRelative(BlockFace.UP, 2);
			 * shower.setType(Material.WATER);
			 * 
			 */
			getRelative(face: org.bukkit.block.BlockFace, distance: number): org.bukkit.block.Block;

			/**
			 * Gets the type of this block
			 */
			getType(): org.bukkit.Material;

			/**
			 * Gets the light level between 0-15
			 */
			getLightLevel(): any /* byte */;

			/**
			 * Get the amount of light at this block from the sky.
			 * 
			 * Any light given from other sources (such as blocks like torches) will
			 * be ignored.
			 */
			getLightFromSky(): any /* byte */;

			/**
			 * Get the amount of light at this block from nearby blocks.
			 * 
			 * Any light given from other sources (such as the sun) will be ignored.
			 */
			getLightFromBlocks(): any /* byte */;

			/**
			 * Gets the world which contains this Block
			 */
			getWorld(): org.bukkit.World;

			/**
			 * Gets the x-coordinate of this block
			 */
			getX(): number;

			/**
			 * Gets the y-coordinate of this block
			 */
			getY(): number;

			/**
			 * Gets the z-coordinate of this block
			 */
			getZ(): number;

			/**
			 * Gets the Location of the block
			 */
			getLocation(): org.bukkit.Location;

			/**
			 * Stores the location of the block in the provided Location object.
			 * 
			 * If the provided Location is null this method does nothing and returns
			 * null.
			 */
			getLocation(loc: (org.bukkit.Location | null)): (org.bukkit.Location | null);

			/**
			 * Gets the chunk which contains this block
			 */
			getChunk(): org.bukkit.Chunk;

			/**
			 * Sets the complete data for this block
			 */
			setBlockData(data: org.bukkit.block.data.BlockData): void;

			/**
			 * Sets the complete data for this block
			 * 
			 * Note that applyPhysics = false is not in general safe. It should only be
			 * used when you need to avoid triggering a physics update of neighboring
			 * blocks, for example when creating a Bisected block. If you are
			 * using a custom populator, then this parameter may also be required to
			 * prevent triggering infinite chunk loads on border blocks. This method
			 * should NOT be used to "hack" physics by placing blocks in impossible
			 * locations. Such blocks are liable to be removed on various events such as
			 * world upgrades. Furthermore setting large amounts of such blocks in close
			 * proximity may overload the server physics engine if an update is
			 * triggered at a later point. If this occurs, the resulting behavior is
			 * undefined.
			 */
			setBlockData(data: org.bukkit.block.data.BlockData, applyPhysics: boolean): void;

			/**
			 * Sets the type of this block
			 */
			setType(type: org.bukkit.Material): void;

			/**
			 * Sets the type of this block
			 * 
			 * Note that applyPhysics = false is not in general safe. It should only be
			 * used when you need to avoid triggering a physics update of neighboring
			 * blocks, for example when creating a Bisected block. If you are
			 * using a custom populator, then this parameter may also be required to
			 * prevent triggering infinite chunk loads on border blocks. This method
			 * should NOT be used to "hack" physics by placing blocks in impossible
			 * locations. Such blocks are liable to be removed on various events such as
			 * world upgrades. Furthermore setting large amounts of such blocks in close
			 * proximity may overload the server physics engine if an update is
			 * triggered at a later point. If this occurs, the resulting behavior is
			 * undefined.
			 */
			setType(type: org.bukkit.Material, applyPhysics: boolean): void;

			/**
			 * Gets the face relation of this block compared to the given block.
			 * 
			 * For example:
			 * 
			 * Block current = world.getBlockAt(100, 100, 100);
			 * Block target = world.getBlockAt(100, 101, 100);
			 * 
			 * current.getFace(target) == BlockFace.Up;
			 * 
			 * 
			 * If the given block is not connected to this block, null may be returned
			 */
			getFace(block: org.bukkit.block.Block): (org.bukkit.block.BlockFace | null);

			/**
			 * Captures the current state of this block. You may then cast that state
			 * into any accepted type, such as Furnace or Sign.
			 * 
			 * The returned object will never be updated, and you are not guaranteed
			 * that (for example) a sign is still a sign after you capture its state.
			 */
			getState(): org.bukkit.block.BlockState;

			/**
			 * Returns the biome that this block resides in
			 */
			getBiome(): org.bukkit.block.Biome;

			/**
			 * Sets the biome that this block resides in
			 */
			setBiome(bio: org.bukkit.block.Biome): void;

			/**
			 * Returns true if the block is being powered by Redstone.
			 */
			isBlockPowered(): boolean;

			/**
			 * Returns true if the block is being indirectly powered by Redstone.
			 */
			isBlockIndirectlyPowered(): boolean;

			/**
			 * Returns true if the block face is being powered by Redstone.
			 */
			isBlockFacePowered(face: org.bukkit.block.BlockFace): boolean;

			/**
			 * Returns true if the block face is being indirectly powered by Redstone.
			 */
			isBlockFaceIndirectlyPowered(face: org.bukkit.block.BlockFace): boolean;

			/**
			 * Returns the redstone power being provided to this block face
			 */
			getBlockPower(face: org.bukkit.block.BlockFace): number;

			/**
			 * Returns the redstone power being provided to this block
			 */
			getBlockPower(): number;

			/**
			 * Checks if this block is empty.
			 * 
			 * A block is considered empty when getType() returns Material.AIR.
			 */
			isEmpty(): boolean;

			/**
			 * Checks if this block is liquid.
			 * 
			 * A block is considered liquid when getType() returns Material.WATER or Material.LAVA.
			 */
			isLiquid(): boolean;

			/**
			 * Gets the temperature of this block.
			 * 
			 * If the raw biome temperature without adjusting for height effects is
			 * required then please use World.getTemperature(int, int).
			 */
			getTemperature(): number;

			/**
			 * Gets the humidity of the biome of this block
			 */
			getHumidity(): number;

			/**
			 * Returns the reaction of the block when moved by a piston
			 */
			getPistonMoveReaction(): org.bukkit.block.PistonMoveReaction;

			/**
			 * Breaks the block and spawns items as if a player had digged it regardless
			 * of the tool.
			 */
			breakNaturally(): boolean;

			/**
			 * Breaks the block and spawns items as if a player had digged it with a
			 * specific tool
			 */
			breakNaturally(tool: (org.bukkit.inventory.ItemStack | null)): boolean;

			/**
			 * Simulate bone meal application to this block (if possible).
			 */
			applyBoneMeal(face: org.bukkit.block.BlockFace): boolean;

			/**
			 * Returns a list of items which would drop by destroying this block
			 */
			getDrops(): globalThis.java.util.Collection<org.bukkit.inventory.ItemStack>;

			/**
			 * Returns a list of items which would drop by destroying this block with
			 * a specific tool
			 */
			getDrops(tool: (org.bukkit.inventory.ItemStack | null)): globalThis.java.util.Collection<org.bukkit.inventory.ItemStack>;

			/**
			 * Returns a list of items which would drop by the entity destroying this
			 * block with a specific tool
			 */
			getDrops(tool: org.bukkit.inventory.ItemStack, entity: (org.bukkit.entity.Entity | null)): globalThis.java.util.Collection<org.bukkit.inventory.ItemStack>;

			/**
			 * Returns if the given item is a preferred choice to break this Block.
			 * In some cases this determines if a block will drop anything or extra
			 * loot.
			 */
			isPreferredTool(tool: org.bukkit.inventory.ItemStack): boolean;

			/**
			 * Gets the speed at which the given player would break this block, taking
			 * into account tools, potion effects, whether or not the player is in
			 * water, enchantments, etc.
			 * The returned value is the amount of progress made in breaking the block
			 * each tick. When the total breaking progress reaches 1.0f, the
			 * block is broken. Note that the break speed can change in the course of
			 * breaking a block, e.g. if a potion effect is applied or expires, or the
			 * player jumps/enters water.
			 */
			getBreakSpeed(player: org.bukkit.entity.Player): number;

			/**
			 * Checks if this block is passable.
			 * 
			 * A block is passable if it has no colliding parts that would prevent
			 * players from moving through it.
			 * 
			 * Examples: Tall grass, flowers, signs, etc. are passable, but open doors,
			 * fence gates, trap doors, etc. are not because they still have parts that
			 * can be collided with.
			 */
			isPassable(): boolean;

			/**
			 * Performs a ray trace that checks for collision with this specific block
			 * in its current state using its precise collision shape.
			 */
			rayTrace(start: org.bukkit.Location, direction: org.bukkit.util.Vector, maxDistance: number, fluidCollisionMode: org.bukkit.FluidCollisionMode): (org.bukkit.util.RayTraceResult | null);

			/**
			 * Gets the approximate bounding box for this block.
			 * 
			 * This isn't exact as some blocks Stairs
			 * contain many bounding boxes to establish their complete form.
			 * Also, the box may not be exactly the same as the collision shape (such as
			 * cactus, which is 16/16 of a block with 15/16 collisional bounds).
			 * This method will return an empty bounding box if the geometric shape of
			 * the block is empty (such as air blocks).
			 */
			getBoundingBox(): org.bukkit.util.BoundingBox;

			/**
			 * Gets the collision shape of this block.
			 */
			getCollisionShape(): org.bukkit.util.VoxelShape;

			/**
			 * Checks if this block is a valid placement location for the specified
			 * block data.
			 */
			canPlace(data: org.bukkit.block.data.BlockData): boolean;

		}> {}
		interface BlockFace {
			/**
			 * Get the amount of X-coordinates to modify to get the represented block
			 */
			getModX(): number;

			/**
			 * Get the amount of Y-coordinates to modify to get the represented block
			 */
			getModY(): number;

			/**
			 * Get the amount of Z-coordinates to modify to get the represented block
			 */
			getModZ(): number;

			/**
			 * Gets the normal vector corresponding to this block face.
			 */
			getDirection(): org.bukkit.util.Vector;

			/**
			 * Returns true if this face is aligned with one of the unit axes in 3D
			 * Cartesian space (ie NORTH, SOUTH, EAST, WEST, UP, DOWN).
			 */
			isCartesian(): boolean;

			getOppositeFace(): org.bukkit.block.BlockFace;

		}
		namespace BlockFace {
			const NORTH: org.bukkit.block.BlockFace;

			const EAST: org.bukkit.block.BlockFace;

			const SOUTH: org.bukkit.block.BlockFace;

			const WEST: org.bukkit.block.BlockFace;

			const UP: org.bukkit.block.BlockFace;

			const DOWN: org.bukkit.block.BlockFace;

			const NORTH_EAST: org.bukkit.block.BlockFace;

			const NORTH_WEST: org.bukkit.block.BlockFace;

			const SOUTH_EAST: org.bukkit.block.BlockFace;

			const SOUTH_WEST: org.bukkit.block.BlockFace;

			const WEST_NORTH_WEST: org.bukkit.block.BlockFace;

			const NORTH_NORTH_WEST: org.bukkit.block.BlockFace;

			const NORTH_NORTH_EAST: org.bukkit.block.BlockFace;

			const EAST_NORTH_EAST: org.bukkit.block.BlockFace;

			const EAST_SOUTH_EAST: org.bukkit.block.BlockFace;

			const SOUTH_SOUTH_EAST: org.bukkit.block.BlockFace;

			const SOUTH_SOUTH_WEST: org.bukkit.block.BlockFace;

			const WEST_SOUTH_WEST: org.bukkit.block.BlockFace;

			const SELF: org.bukkit.block.BlockFace;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.block.BlockFace;

		}
		interface BlockState extends Modify<org.bukkit.metadata.Metadatable, {
			/**
			 * Gets the block represented by this block state.
			 */
			getBlock(): org.bukkit.block.Block;

			/**
			 * Gets the metadata for this block state.
			 */
			getData(): org.bukkit.material.MaterialData;

			/**
			 * Gets the data for this block state.
			 */
			getBlockData(): org.bukkit.block.data.BlockData;

			/**
			 * Returns a copy of this BlockState as an unplaced BlockState.
			 */
			copy(): org.bukkit.block.BlockState;

			/**
			 * Copies the state to another block as an unplaced BlockState.
			 */
			copy(location: org.bukkit.Location): org.bukkit.block.BlockState;

			/**
			 * Gets the type of this block state.
			 */
			getType(): org.bukkit.Material;

			/**
			 * Gets the current light level of the block represented by this block state.
			 */
			getLightLevel(): any /* byte */;

			/**
			 * Gets the world which contains the block represented by this block state.
			 */
			getWorld(): org.bukkit.World;

			/**
			 * Gets the x-coordinate of this block state.
			 */
			getX(): number;

			/**
			 * Gets the y-coordinate of this block state.
			 */
			getY(): number;

			/**
			 * Gets the z-coordinate of this block state.
			 */
			getZ(): number;

			/**
			 * Gets the location of this block state.
			 * 
			 * If this block state is not placed the location's world will be null!
			 */
			getLocation(): org.bukkit.Location;

			/**
			 * Stores the location of this block state in the provided Location object.
			 * 
			 * If the provided Location is null this method does nothing and returns
			 * null.
			 * 
			 * If this block state is not placed the location's world will be null!
			 */
			getLocation(loc: (org.bukkit.Location | null)): (org.bukkit.Location | null);

			/**
			 * Gets the chunk which contains the block represented by this block state.
			 */
			getChunk(): org.bukkit.Chunk;

			/**
			 * Sets the metadata for this block state.
			 */
			setData(data: org.bukkit.material.MaterialData): void;

			/**
			 * Sets the data for this block state.
			 */
			setBlockData(data: org.bukkit.block.data.BlockData): void;

			/**
			 * Sets the type of this block state.
			 */
			setType(type: org.bukkit.Material): void;

			/**
			 * Attempts to update the block represented by this state, setting it to
			 * the new values as defined by this state.
			 * 
			 * This has the same effect as calling update(false). That is to say,
			 * this will not modify the state of a block if it is no longer the same
			 * type as it was when this state was taken. It will return false in this
			 * eventuality.
			 */
			update(): boolean;

			/**
			 * Attempts to update the block represented by this state, setting it to
			 * the new values as defined by this state.
			 * 
			 * This has the same effect as calling update(force, true). That is to
			 * say, this will trigger a physics update to surrounding blocks.
			 */
			update(force: boolean): boolean;

			/**
			 * Attempts to update the block represented by this state, setting it to
			 * the new values as defined by this state.
			 * 
			 * If this state is not placed, this will have no effect and return true.
			 * 
			 * Unless force is true, this will not modify the state of a block if it
			 * is no longer the same type as it was when this state was taken. It will
			 * return false in this eventuality.
			 * 
			 * If force is true, it will set the type of the block to match the new
			 * state, set the state data and then return true.
			 * 
			 * If applyPhysics is true, it will trigger a physics update on
			 * surrounding blocks which could cause them to update or disappear.
			 */
			update(force: boolean, applyPhysics: boolean): boolean;

			getRawData(): any /* byte */;

			setRawData(data: any /* byte */): void;

			/**
			 * Returns whether this state is placed in the world.
			 * 
			 * Some methods will not work if the block state isn't
			 * placed in the world.
			 */
			isPlaced(): boolean;

		}> {}
		interface BlockSupport {}
		namespace BlockSupport {
			/**
			 * The face is treated as a full block. For example, the side of a stair is
			 * not a full face and cannot support a wall torch, whereas the
			 * back and bottom of a stair are considered full.
			 */
			const FULL: org.bukkit.block.BlockSupport;

			/**
			 * The face is capable of supporting blocks towards the center. For example, a
			 * wall or a fence post can support a standing torch as there is a solid component
			 * in the middle of the block.
			 */
			const CENTER: org.bukkit.block.BlockSupport;

			/**
			 * The face is capable of supporting fragile blocks such as rails. Most
			 * full-supportable top faces are rigid, unlike walls and posts, or the side of a
			 * stone block, none of which are rigid.
			 */
			const RIGID: org.bukkit.block.BlockSupport;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.block.BlockSupport;

		}
		interface BlockType extends Modify<org.bukkit.Keyed & org.bukkit.Translatable, {
			/**
			 * Yields this block type as a typed version of itself with a plain BlockData representing it.
			 */
			typed(): org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * Yields this block type as a typed version of itself with a specific BlockData representing it.
			 */
			typed<B = any>(blockDataType: globalThis.java.lang.Class<B>): org.bukkit.block.BlockType.Typed<B>;

			/**
			 * Returns true if this BlockType has a corresponding ItemType.
			 */
			hasItemType(): boolean;

			/**
			 * Returns the corresponding ItemType for the given BlockType.
			 * 
			 * If there is no corresponding ItemType an error will be thrown.
			 */
			getItemType(): org.bukkit.inventory.ItemType;

			/**
			 * Gets the BlockData class of this BlockType
			 */
			getBlockDataClass(): globalThis.java.lang.Class<org.bukkit.block.data.BlockData>;

			/**
			 * Creates a new BlockData instance for this block type, with all
			 * properties initialized to unspecified defaults.
			 */
			createBlockData(): org.bukkit.block.data.BlockData;

			/**
			 * Creates a new BlockData instance for this block type, with all
			 * properties initialized to unspecified defaults, except for those provided
			 * in data.
			 */
			createBlockData(data: (string | null)): org.bukkit.block.data.BlockData;

			/**
			 * Check if the blockt type is solid (can be built upon)
			 */
			isSolid(): boolean;

			/**
			 * Check if the block type can catch fire
			 */
			isFlammable(): boolean;

			/**
			 * Check if the block type can burn away
			 */
			isBurnable(): boolean;

			/**
			 * Check if the block type is occludes light in the lighting engine.
			 * 
			 * Generally speaking, most full blocks will occlude light. Non-full blocks are
			 * not occluding (e.g. anvils, chests, tall grass, stairs, etc.), nor are specific
			 * full blocks such as barriers or spawners which block light despite their texture.
			 * 
			 * An occluding block will have the following effects:
			 * 
			 * Chests cannot be opened if an occluding block is above it.
			 * Mobs cannot spawn inside of occluding blocks.
			 * Only occluding blocks can be "powered" (Block.isBlockPowered()).
			 * 
			 * This list may be inconclusive. For a full list of the side effects of an occluding
			 * block, see the Minecraft Wiki.
			 */
			isOccluding(): boolean;

			hasGravity(): boolean;

			/**
			 * Checks if this block type can be interacted with.
			 * 
			 * Interactable block types include those with functionality when they are
			 * interacted with by a player such as chests, furnaces, etc.
			 * 
			 * Some blocks such as piston heads and stairs are considered interactable
			 * though may not perform any additional functionality.
			 * 
			 * Note that the interactability of some block types may be dependant on their
			 * state as well. This method will return true if there is at least one
			 * state in which additional interact handling is performed for the
			 * block type.
			 */
			isInteractable(): boolean;

			/**
			 * Obtains the block's hardness level (also known as "strength").
			 * 
			 * This number is used to calculate the time required to break each block.
			 */
			getHardness(): number;

			/**
			 * Obtains the blast resistance value (also known as block "durability").
			 * 
			 * This value is used in explosions to calculate whether a block should be
			 * broken or not.
			 */
			getBlastResistance(): number;

			/**
			 * Returns a value that represents how 'slippery' the block is.
			 * 
			 * Blocks with higher slipperiness, like ICE can be slid on
			 * further by the player and other entities.
			 * 
			 * Most blocks have a default slipperiness of 0.6f.
			 */
			getSlipperiness(): number;

			/**
			 * Check if the block type is an air block.
			 */
			isAir(): boolean;

			/**
			 * Gets if the BlockType is enabled by the features in a world.
			 */
			isEnabledByFeature(world: org.bukkit.World): boolean;

			/**
			 * Tries to convert this BlockType into a Material
			 */
			asMaterial(): (org.bukkit.Material | null);

		}> {}
		namespace BlockType {
			const AIR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const STONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const GRANITE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POLISHED_GRANITE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const DIORITE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POLISHED_DIORITE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const ANDESITE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POLISHED_ANDESITE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Snowable
			 */
			const GRASS_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Snowable>;

			const DIRT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const COARSE_DIRT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Snowable
			 */
			const PODZOL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Snowable>;

			const COBBLESTONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const OAK_PLANKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const SPRUCE_PLANKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BIRCH_PLANKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const JUNGLE_PLANKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const ACACIA_PLANKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CHERRY_PLANKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const DARK_OAK_PLANKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const MANGROVE_PLANKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BAMBOO_PLANKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BAMBOO_MOSAIC: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Sapling
			 */
			const OAK_SAPLING: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Sapling>;

			/**
			 * BlockData: Sapling
			 */
			const SPRUCE_SAPLING: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Sapling>;

			/**
			 * BlockData: Sapling
			 */
			const BIRCH_SAPLING: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Sapling>;

			/**
			 * BlockData: Sapling
			 */
			const JUNGLE_SAPLING: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Sapling>;

			/**
			 * BlockData: Sapling
			 */
			const ACACIA_SAPLING: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Sapling>;

			/**
			 * BlockData: Sapling
			 */
			const CHERRY_SAPLING: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Sapling>;

			/**
			 * BlockData: Sapling
			 */
			const DARK_OAK_SAPLING: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Sapling>;

			/**
			 * BlockData: MangrovePropagule
			 */
			const MANGROVE_PROPAGULE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.MangrovePropagule>;

			const BEDROCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Levelled
			 */
			const WATER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Levelled>;

			/**
			 * BlockData: Levelled
			 */
			const LAVA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Levelled>;

			const SAND: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Brushable
			 */
			const SUSPICIOUS_SAND: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Brushable>;

			const RED_SAND: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const GRAVEL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Brushable
			 */
			const SUSPICIOUS_GRAVEL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Brushable>;

			const GOLD_ORE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const DEEPSLATE_GOLD_ORE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const IRON_ORE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const DEEPSLATE_IRON_ORE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const COAL_ORE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const DEEPSLATE_COAL_ORE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const NETHER_GOLD_ORE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Orientable
			 */
			const OAK_LOG: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const SPRUCE_LOG: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const BIRCH_LOG: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const JUNGLE_LOG: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const ACACIA_LOG: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const CHERRY_LOG: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const DARK_OAK_LOG: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const MANGROVE_LOG: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Waterlogged
			 */
			const MANGROVE_ROOTS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Orientable
			 */
			const MUDDY_MANGROVE_ROOTS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const BAMBOO_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_SPRUCE_LOG: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_BIRCH_LOG: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_JUNGLE_LOG: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_ACACIA_LOG: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_CHERRY_LOG: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_DARK_OAK_LOG: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_OAK_LOG: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_MANGROVE_LOG: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_BAMBOO_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const OAK_WOOD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const SPRUCE_WOOD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const BIRCH_WOOD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const JUNGLE_WOOD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const ACACIA_WOOD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const CHERRY_WOOD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const DARK_OAK_WOOD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const MANGROVE_WOOD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_OAK_WOOD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_SPRUCE_WOOD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_BIRCH_WOOD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_JUNGLE_WOOD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_ACACIA_WOOD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_CHERRY_WOOD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_DARK_OAK_WOOD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_MANGROVE_WOOD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Leaves
			 */
			const OAK_LEAVES: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Leaves>;

			/**
			 * BlockData: Leaves
			 */
			const SPRUCE_LEAVES: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Leaves>;

			/**
			 * BlockData: Leaves
			 */
			const BIRCH_LEAVES: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Leaves>;

			/**
			 * BlockData: Leaves
			 */
			const JUNGLE_LEAVES: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Leaves>;

			/**
			 * BlockData: Leaves
			 */
			const ACACIA_LEAVES: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Leaves>;

			/**
			 * BlockData: Leaves
			 */
			const CHERRY_LEAVES: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Leaves>;

			/**
			 * BlockData: Leaves
			 */
			const DARK_OAK_LEAVES: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Leaves>;

			/**
			 * BlockData: Leaves
			 */
			const MANGROVE_LEAVES: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Leaves>;

			/**
			 * BlockData: Leaves
			 */
			const AZALEA_LEAVES: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Leaves>;

			/**
			 * BlockData: Leaves
			 */
			const FLOWERING_AZALEA_LEAVES: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Leaves>;

			const SPONGE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WET_SPONGE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const GLASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LAPIS_ORE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const DEEPSLATE_LAPIS_ORE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LAPIS_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Dispenser
			 */
			const DISPENSER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Dispenser>;

			const SANDSTONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CHISELED_SANDSTONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CUT_SANDSTONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: NoteBlock
			 */
			const NOTE_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.NoteBlock>;

			/**
			 * BlockData: Bed
			 */
			const WHITE_BED: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Bed>;

			/**
			 * BlockData: Bed
			 */
			const ORANGE_BED: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Bed>;

			/**
			 * BlockData: Bed
			 */
			const MAGENTA_BED: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Bed>;

			/**
			 * BlockData: Bed
			 */
			const LIGHT_BLUE_BED: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Bed>;

			/**
			 * BlockData: Bed
			 */
			const YELLOW_BED: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Bed>;

			/**
			 * BlockData: Bed
			 */
			const LIME_BED: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Bed>;

			/**
			 * BlockData: Bed
			 */
			const PINK_BED: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Bed>;

			/**
			 * BlockData: Bed
			 */
			const GRAY_BED: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Bed>;

			/**
			 * BlockData: Bed
			 */
			const LIGHT_GRAY_BED: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Bed>;

			/**
			 * BlockData: Bed
			 */
			const CYAN_BED: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Bed>;

			/**
			 * BlockData: Bed
			 */
			const PURPLE_BED: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Bed>;

			/**
			 * BlockData: Bed
			 */
			const BLUE_BED: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Bed>;

			/**
			 * BlockData: Bed
			 */
			const BROWN_BED: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Bed>;

			/**
			 * BlockData: Bed
			 */
			const GREEN_BED: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Bed>;

			/**
			 * BlockData: Bed
			 */
			const RED_BED: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Bed>;

			/**
			 * BlockData: Bed
			 */
			const BLACK_BED: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Bed>;

			/**
			 * BlockData: RedstoneRail
			 */
			const POWERED_RAIL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.RedstoneRail>;

			/**
			 * BlockData: RedstoneRail
			 */
			const DETECTOR_RAIL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.RedstoneRail>;

			/**
			 * BlockData: Piston
			 */
			const STICKY_PISTON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Piston>;

			const COBWEB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const SHORT_GRASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const FERN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const DEAD_BUSH: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const SEAGRASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Bisected
			 */
			const TALL_SEAGRASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Bisected>;

			/**
			 * BlockData: Piston
			 */
			const PISTON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Piston>;

			/**
			 * BlockData: PistonHead
			 */
			const PISTON_HEAD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.PistonHead>;

			const WHITE_WOOL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const ORANGE_WOOL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const MAGENTA_WOOL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LIGHT_BLUE_WOOL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const YELLOW_WOOL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LIME_WOOL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const PINK_WOOL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const GRAY_WOOL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LIGHT_GRAY_WOOL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CYAN_WOOL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const PURPLE_WOOL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BLUE_WOOL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BROWN_WOOL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const GREEN_WOOL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const RED_WOOL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BLACK_WOOL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: TechnicalPiston
			 */
			const MOVING_PISTON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TechnicalPiston>;

			const DANDELION: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const TORCHFLOWER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POPPY: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BLUE_ORCHID: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const ALLIUM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const AZURE_BLUET: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const RED_TULIP: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const ORANGE_TULIP: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WHITE_TULIP: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const PINK_TULIP: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const OXEYE_DAISY: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CORNFLOWER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WITHER_ROSE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LILY_OF_THE_VALLEY: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BROWN_MUSHROOM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const RED_MUSHROOM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const GOLD_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const IRON_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: TNT
			 */
			const TNT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TNT>;

			const BOOKSHELF: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: ChiseledBookshelf
			 */
			const CHISELED_BOOKSHELF: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.ChiseledBookshelf>;

			const MOSSY_COBBLESTONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const OBSIDIAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const TORCH: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Directional
			 */
			const WALL_TORCH: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Fire
			 */
			const FIRE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Fire>;

			const SOUL_FIRE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const SPAWNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Stairs
			 */
			const OAK_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Chest
			 */
			const CHEST: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Chest>;

			/**
			 * BlockData: RedstoneWire
			 */
			const REDSTONE_WIRE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.RedstoneWire>;

			const DIAMOND_ORE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const DEEPSLATE_DIAMOND_ORE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const DIAMOND_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CRAFTING_TABLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Ageable
			 */
			const WHEAT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Ageable>;

			/**
			 * BlockData: Farmland
			 */
			const FARMLAND: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Farmland>;

			/**
			 * BlockData: Furnace
			 */
			const FURNACE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Furnace>;

			/**
			 * BlockData: Sign
			 */
			const OAK_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Sign>;

			/**
			 * BlockData: Sign
			 */
			const SPRUCE_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Sign>;

			/**
			 * BlockData: Sign
			 */
			const BIRCH_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Sign>;

			/**
			 * BlockData: Sign
			 */
			const ACACIA_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Sign>;

			/**
			 * BlockData: Sign
			 */
			const CHERRY_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Sign>;

			/**
			 * BlockData: Sign
			 */
			const JUNGLE_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Sign>;

			/**
			 * BlockData: Sign
			 */
			const DARK_OAK_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Sign>;

			/**
			 * BlockData: Sign
			 */
			const MANGROVE_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Sign>;

			/**
			 * BlockData: Sign
			 */
			const BAMBOO_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Sign>;

			/**
			 * BlockData: Door
			 */
			const OAK_DOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Door>;

			/**
			 * BlockData: Ladder
			 */
			const LADDER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Ladder>;

			/**
			 * BlockData: Rail
			 */
			const RAIL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rail>;

			/**
			 * BlockData: Stairs
			 */
			const COBBLESTONE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: WallSign
			 */
			const OAK_WALL_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallSign>;

			/**
			 * BlockData: WallSign
			 */
			const SPRUCE_WALL_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallSign>;

			/**
			 * BlockData: WallSign
			 */
			const BIRCH_WALL_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallSign>;

			/**
			 * BlockData: WallSign
			 */
			const ACACIA_WALL_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallSign>;

			/**
			 * BlockData: WallSign
			 */
			const CHERRY_WALL_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallSign>;

			/**
			 * BlockData: WallSign
			 */
			const JUNGLE_WALL_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallSign>;

			/**
			 * BlockData: WallSign
			 */
			const DARK_OAK_WALL_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallSign>;

			/**
			 * BlockData: WallSign
			 */
			const MANGROVE_WALL_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallSign>;

			/**
			 * BlockData: WallSign
			 */
			const BAMBOO_WALL_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallSign>;

			/**
			 * BlockData: HangingSign
			 */
			const OAK_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.HangingSign>;

			/**
			 * BlockData: HangingSign
			 */
			const SPRUCE_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.HangingSign>;

			/**
			 * BlockData: HangingSign
			 */
			const BIRCH_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.HangingSign>;

			/**
			 * BlockData: HangingSign
			 */
			const ACACIA_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.HangingSign>;

			/**
			 * BlockData: HangingSign
			 */
			const CHERRY_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.HangingSign>;

			/**
			 * BlockData: HangingSign
			 */
			const JUNGLE_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.HangingSign>;

			/**
			 * BlockData: HangingSign
			 */
			const DARK_OAK_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.HangingSign>;

			/**
			 * BlockData: HangingSign
			 */
			const CRIMSON_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.HangingSign>;

			/**
			 * BlockData: HangingSign
			 */
			const WARPED_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.HangingSign>;

			/**
			 * BlockData: HangingSign
			 */
			const MANGROVE_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.HangingSign>;

			/**
			 * BlockData: HangingSign
			 */
			const BAMBOO_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.HangingSign>;

			/**
			 * BlockData: WallHangingSign
			 */
			const OAK_WALL_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallHangingSign>;

			/**
			 * BlockData: WallHangingSign
			 */
			const SPRUCE_WALL_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallHangingSign>;

			/**
			 * BlockData: WallHangingSign
			 */
			const BIRCH_WALL_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallHangingSign>;

			/**
			 * BlockData: WallHangingSign
			 */
			const ACACIA_WALL_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallHangingSign>;

			/**
			 * BlockData: WallHangingSign
			 */
			const CHERRY_WALL_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallHangingSign>;

			/**
			 * BlockData: WallHangingSign
			 */
			const JUNGLE_WALL_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallHangingSign>;

			/**
			 * BlockData: WallHangingSign
			 */
			const DARK_OAK_WALL_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallHangingSign>;

			/**
			 * BlockData: WallHangingSign
			 */
			const MANGROVE_WALL_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallHangingSign>;

			/**
			 * BlockData: WallHangingSign
			 */
			const CRIMSON_WALL_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallHangingSign>;

			/**
			 * BlockData: WallHangingSign
			 */
			const WARPED_WALL_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallHangingSign>;

			/**
			 * BlockData: WallHangingSign
			 */
			const BAMBOO_WALL_HANGING_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallHangingSign>;

			/**
			 * BlockData: Switch
			 */
			const LEVER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Switch>;

			/**
			 * BlockData: Powerable
			 */
			const STONE_PRESSURE_PLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Powerable>;

			/**
			 * BlockData: Door
			 */
			const IRON_DOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Door>;

			/**
			 * BlockData: Powerable
			 */
			const OAK_PRESSURE_PLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Powerable>;

			/**
			 * BlockData: Powerable
			 */
			const SPRUCE_PRESSURE_PLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Powerable>;

			/**
			 * BlockData: Powerable
			 */
			const BIRCH_PRESSURE_PLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Powerable>;

			/**
			 * BlockData: Powerable
			 */
			const JUNGLE_PRESSURE_PLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Powerable>;

			/**
			 * BlockData: Powerable
			 */
			const ACACIA_PRESSURE_PLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Powerable>;

			/**
			 * BlockData: Powerable
			 */
			const CHERRY_PRESSURE_PLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Powerable>;

			/**
			 * BlockData: Powerable
			 */
			const DARK_OAK_PRESSURE_PLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Powerable>;

			/**
			 * BlockData: Powerable
			 */
			const MANGROVE_PRESSURE_PLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Powerable>;

			/**
			 * BlockData: Powerable
			 */
			const BAMBOO_PRESSURE_PLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Powerable>;

			/**
			 * BlockData: Lightable
			 */
			const REDSTONE_ORE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			/**
			 * BlockData: Lightable
			 */
			const DEEPSLATE_REDSTONE_ORE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			/**
			 * BlockData: Lightable
			 */
			const REDSTONE_TORCH: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			/**
			 * BlockData: RedstoneWallTorch
			 */
			const REDSTONE_WALL_TORCH: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.RedstoneWallTorch>;

			/**
			 * BlockData: Switch
			 */
			const STONE_BUTTON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Switch>;

			/**
			 * BlockData: Snow
			 */
			const SNOW: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Snow>;

			const ICE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const SNOW_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Ageable
			 */
			const CACTUS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Ageable>;

			const CLAY: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Ageable
			 */
			const SUGAR_CANE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Ageable>;

			/**
			 * BlockData: Jukebox
			 */
			const JUKEBOX: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Jukebox>;

			/**
			 * BlockData: Fence
			 */
			const OAK_FENCE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Fence>;

			const NETHERRACK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const SOUL_SAND: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const SOUL_SOIL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Orientable
			 */
			const BASALT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const POLISHED_BASALT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			const SOUL_TORCH: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Directional
			 */
			const SOUL_WALL_TORCH: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			const GLOWSTONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Orientable
			 */
			const NETHER_PORTAL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Directional
			 */
			const CARVED_PUMPKIN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const JACK_O_LANTERN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Cake
			 */
			const CAKE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Cake>;

			/**
			 * BlockData: Repeater
			 */
			const REPEATER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Repeater>;

			const WHITE_STAINED_GLASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const ORANGE_STAINED_GLASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const MAGENTA_STAINED_GLASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LIGHT_BLUE_STAINED_GLASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const YELLOW_STAINED_GLASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LIME_STAINED_GLASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const PINK_STAINED_GLASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const GRAY_STAINED_GLASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LIGHT_GRAY_STAINED_GLASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CYAN_STAINED_GLASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const PURPLE_STAINED_GLASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BLUE_STAINED_GLASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BROWN_STAINED_GLASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const GREEN_STAINED_GLASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const RED_STAINED_GLASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BLACK_STAINED_GLASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: TrapDoor
			 */
			const OAK_TRAPDOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrapDoor>;

			/**
			 * BlockData: TrapDoor
			 */
			const SPRUCE_TRAPDOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrapDoor>;

			/**
			 * BlockData: TrapDoor
			 */
			const BIRCH_TRAPDOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrapDoor>;

			/**
			 * BlockData: TrapDoor
			 */
			const JUNGLE_TRAPDOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrapDoor>;

			/**
			 * BlockData: TrapDoor
			 */
			const ACACIA_TRAPDOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrapDoor>;

			/**
			 * BlockData: TrapDoor
			 */
			const CHERRY_TRAPDOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrapDoor>;

			/**
			 * BlockData: TrapDoor
			 */
			const DARK_OAK_TRAPDOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrapDoor>;

			/**
			 * BlockData: TrapDoor
			 */
			const MANGROVE_TRAPDOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrapDoor>;

			/**
			 * BlockData: TrapDoor
			 */
			const BAMBOO_TRAPDOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrapDoor>;

			const STONE_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const MOSSY_STONE_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CRACKED_STONE_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CHISELED_STONE_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const PACKED_MUD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const MUD_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const INFESTED_STONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const INFESTED_COBBLESTONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const INFESTED_STONE_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const INFESTED_MOSSY_STONE_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const INFESTED_CRACKED_STONE_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const INFESTED_CHISELED_STONE_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: MultipleFacing
			 */
			const BROWN_MUSHROOM_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.MultipleFacing>;

			/**
			 * BlockData: MultipleFacing
			 */
			const RED_MUSHROOM_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.MultipleFacing>;

			/**
			 * BlockData: MultipleFacing
			 */
			const MUSHROOM_STEM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.MultipleFacing>;

			/**
			 * BlockData: Fence
			 */
			const IRON_BARS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Fence>;

			/**
			 * BlockData: Chain
			 */
			const CHAIN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Chain>;

			/**
			 * BlockData: Fence
			 */
			const GLASS_PANE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Fence>;

			const PUMPKIN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const MELON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Directional
			 */
			const ATTACHED_PUMPKIN_STEM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const ATTACHED_MELON_STEM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Ageable
			 */
			const PUMPKIN_STEM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Ageable>;

			/**
			 * BlockData: Ageable
			 */
			const MELON_STEM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Ageable>;

			/**
			 * BlockData: MultipleFacing
			 */
			const VINE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.MultipleFacing>;

			/**
			 * BlockData: GlowLichen
			 */
			const GLOW_LICHEN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.GlowLichen>;

			/**
			 * BlockData: Gate
			 */
			const OAK_FENCE_GATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Gate>;

			/**
			 * BlockData: Stairs
			 */
			const BRICK_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const STONE_BRICK_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const MUD_BRICK_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Snowable
			 */
			const MYCELIUM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Snowable>;

			const LILY_PAD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const NETHER_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Fence
			 */
			const NETHER_BRICK_FENCE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Fence>;

			/**
			 * BlockData: Stairs
			 */
			const NETHER_BRICK_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Ageable
			 */
			const NETHER_WART: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Ageable>;

			const ENCHANTING_TABLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: BrewingStand
			 */
			const BREWING_STAND: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.BrewingStand>;

			const CAULDRON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Levelled
			 */
			const WATER_CAULDRON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Levelled>;

			const LAVA_CAULDRON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Levelled
			 */
			const POWDER_SNOW_CAULDRON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Levelled>;

			const END_PORTAL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: EndPortalFrame
			 */
			const END_PORTAL_FRAME: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.EndPortalFrame>;

			const END_STONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const DRAGON_EGG: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Lightable
			 */
			const REDSTONE_LAMP: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			/**
			 * BlockData: Cocoa
			 */
			const COCOA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Cocoa>;

			/**
			 * BlockData: Stairs
			 */
			const SANDSTONE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			const EMERALD_ORE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const DEEPSLATE_EMERALD_ORE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: EnderChest
			 */
			const ENDER_CHEST: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.EnderChest>;

			/**
			 * BlockData: TripwireHook
			 */
			const TRIPWIRE_HOOK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TripwireHook>;

			/**
			 * BlockData: Tripwire
			 */
			const TRIPWIRE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Tripwire>;

			const EMERALD_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Stairs
			 */
			const SPRUCE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const BIRCH_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const JUNGLE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: CommandBlock
			 */
			const COMMAND_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CommandBlock>;

			const BEACON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Wall
			 */
			const COBBLESTONE_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			/**
			 * BlockData: Wall
			 */
			const MOSSY_COBBLESTONE_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			const FLOWER_POT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_TORCHFLOWER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_OAK_SAPLING: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_SPRUCE_SAPLING: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_BIRCH_SAPLING: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_JUNGLE_SAPLING: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_ACACIA_SAPLING: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_CHERRY_SAPLING: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_DARK_OAK_SAPLING: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_MANGROVE_PROPAGULE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_FERN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_DANDELION: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_POPPY: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_BLUE_ORCHID: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_ALLIUM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_AZURE_BLUET: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_RED_TULIP: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_ORANGE_TULIP: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_WHITE_TULIP: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_PINK_TULIP: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_OXEYE_DAISY: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_CORNFLOWER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_LILY_OF_THE_VALLEY: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_WITHER_ROSE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_RED_MUSHROOM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_BROWN_MUSHROOM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_DEAD_BUSH: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_CACTUS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Ageable
			 */
			const CARROTS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Ageable>;

			/**
			 * BlockData: Ageable
			 */
			const POTATOES: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Ageable>;

			/**
			 * BlockData: Switch
			 */
			const OAK_BUTTON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Switch>;

			/**
			 * BlockData: Switch
			 */
			const SPRUCE_BUTTON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Switch>;

			/**
			 * BlockData: Switch
			 */
			const BIRCH_BUTTON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Switch>;

			/**
			 * BlockData: Switch
			 */
			const JUNGLE_BUTTON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Switch>;

			/**
			 * BlockData: Switch
			 */
			const ACACIA_BUTTON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Switch>;

			/**
			 * BlockData: Switch
			 */
			const CHERRY_BUTTON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Switch>;

			/**
			 * BlockData: Switch
			 */
			const DARK_OAK_BUTTON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Switch>;

			/**
			 * BlockData: Switch
			 */
			const MANGROVE_BUTTON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Switch>;

			/**
			 * BlockData: Switch
			 */
			const BAMBOO_BUTTON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Switch>;

			/**
			 * BlockData: Rotatable
			 */
			const SKELETON_SKULL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Directional
			 */
			const SKELETON_WALL_SKULL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Rotatable
			 */
			const WITHER_SKELETON_SKULL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Directional
			 */
			const WITHER_SKELETON_WALL_SKULL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Rotatable
			 */
			const ZOMBIE_HEAD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Directional
			 */
			const ZOMBIE_WALL_HEAD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Rotatable
			 */
			const PLAYER_HEAD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Directional
			 */
			const PLAYER_WALL_HEAD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Rotatable
			 */
			const CREEPER_HEAD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Directional
			 */
			const CREEPER_WALL_HEAD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Rotatable
			 */
			const DRAGON_HEAD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Directional
			 */
			const DRAGON_WALL_HEAD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Rotatable
			 */
			const PIGLIN_HEAD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Directional
			 */
			const PIGLIN_WALL_HEAD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const ANVIL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const CHIPPED_ANVIL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const DAMAGED_ANVIL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Chest
			 */
			const TRAPPED_CHEST: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Chest>;

			/**
			 * BlockData: AnaloguePowerable
			 */
			const LIGHT_WEIGHTED_PRESSURE_PLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.AnaloguePowerable>;

			/**
			 * BlockData: AnaloguePowerable
			 */
			const HEAVY_WEIGHTED_PRESSURE_PLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.AnaloguePowerable>;

			/**
			 * BlockData: Comparator
			 */
			const COMPARATOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Comparator>;

			/**
			 * BlockData: DaylightDetector
			 */
			const DAYLIGHT_DETECTOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.DaylightDetector>;

			const REDSTONE_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const NETHER_QUARTZ_ORE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Hopper
			 */
			const HOPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Hopper>;

			const QUARTZ_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CHISELED_QUARTZ_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Orientable
			 */
			const QUARTZ_PILLAR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Stairs
			 */
			const QUARTZ_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: RedstoneRail
			 */
			const ACTIVATOR_RAIL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.RedstoneRail>;

			/**
			 * BlockData: Dispenser
			 */
			const DROPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Dispenser>;

			const WHITE_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const ORANGE_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const MAGENTA_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LIGHT_BLUE_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const YELLOW_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LIME_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const PINK_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const GRAY_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LIGHT_GRAY_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CYAN_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const PURPLE_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BLUE_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BROWN_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const GREEN_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const RED_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BLACK_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: GlassPane
			 */
			const WHITE_STAINED_GLASS_PANE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.GlassPane>;

			/**
			 * BlockData: GlassPane
			 */
			const ORANGE_STAINED_GLASS_PANE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.GlassPane>;

			/**
			 * BlockData: GlassPane
			 */
			const MAGENTA_STAINED_GLASS_PANE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.GlassPane>;

			/**
			 * BlockData: GlassPane
			 */
			const LIGHT_BLUE_STAINED_GLASS_PANE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.GlassPane>;

			/**
			 * BlockData: GlassPane
			 */
			const YELLOW_STAINED_GLASS_PANE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.GlassPane>;

			/**
			 * BlockData: GlassPane
			 */
			const LIME_STAINED_GLASS_PANE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.GlassPane>;

			/**
			 * BlockData: GlassPane
			 */
			const PINK_STAINED_GLASS_PANE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.GlassPane>;

			/**
			 * BlockData: GlassPane
			 */
			const GRAY_STAINED_GLASS_PANE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.GlassPane>;

			/**
			 * BlockData: GlassPane
			 */
			const LIGHT_GRAY_STAINED_GLASS_PANE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.GlassPane>;

			/**
			 * BlockData: GlassPane
			 */
			const CYAN_STAINED_GLASS_PANE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.GlassPane>;

			/**
			 * BlockData: GlassPane
			 */
			const PURPLE_STAINED_GLASS_PANE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.GlassPane>;

			/**
			 * BlockData: GlassPane
			 */
			const BLUE_STAINED_GLASS_PANE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.GlassPane>;

			/**
			 * BlockData: GlassPane
			 */
			const BROWN_STAINED_GLASS_PANE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.GlassPane>;

			/**
			 * BlockData: GlassPane
			 */
			const GREEN_STAINED_GLASS_PANE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.GlassPane>;

			/**
			 * BlockData: GlassPane
			 */
			const RED_STAINED_GLASS_PANE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.GlassPane>;

			/**
			 * BlockData: GlassPane
			 */
			const BLACK_STAINED_GLASS_PANE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.GlassPane>;

			/**
			 * BlockData: Stairs
			 */
			const ACACIA_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const CHERRY_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const DARK_OAK_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const MANGROVE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const BAMBOO_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const BAMBOO_MOSAIC_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			const SLIME_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Waterlogged
			 */
			const BARRIER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Light
			 */
			const LIGHT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Light>;

			/**
			 * BlockData: TrapDoor
			 */
			const IRON_TRAPDOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrapDoor>;

			const PRISMARINE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const PRISMARINE_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const DARK_PRISMARINE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Stairs
			 */
			const PRISMARINE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const PRISMARINE_BRICK_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const DARK_PRISMARINE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Slab
			 */
			const PRISMARINE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const PRISMARINE_BRICK_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const DARK_PRISMARINE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			const SEA_LANTERN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Orientable
			 */
			const HAY_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			const WHITE_CARPET: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const ORANGE_CARPET: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const MAGENTA_CARPET: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LIGHT_BLUE_CARPET: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const YELLOW_CARPET: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LIME_CARPET: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const PINK_CARPET: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const GRAY_CARPET: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LIGHT_GRAY_CARPET: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CYAN_CARPET: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const PURPLE_CARPET: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BLUE_CARPET: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BROWN_CARPET: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const GREEN_CARPET: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const RED_CARPET: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BLACK_CARPET: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const COAL_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const PACKED_ICE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Bisected
			 */
			const SUNFLOWER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Bisected>;

			/**
			 * BlockData: Bisected
			 */
			const LILAC: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Bisected>;

			/**
			 * BlockData: Bisected
			 */
			const ROSE_BUSH: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Bisected>;

			/**
			 * BlockData: Bisected
			 */
			const PEONY: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Bisected>;

			/**
			 * BlockData: Bisected
			 */
			const TALL_GRASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Bisected>;

			/**
			 * BlockData: Bisected
			 */
			const LARGE_FERN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Bisected>;

			/**
			 * BlockData: Rotatable
			 */
			const WHITE_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Rotatable
			 */
			const ORANGE_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Rotatable
			 */
			const MAGENTA_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Rotatable
			 */
			const LIGHT_BLUE_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Rotatable
			 */
			const YELLOW_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Rotatable
			 */
			const LIME_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Rotatable
			 */
			const PINK_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Rotatable
			 */
			const GRAY_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Rotatable
			 */
			const LIGHT_GRAY_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Rotatable
			 */
			const CYAN_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Rotatable
			 */
			const PURPLE_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Rotatable
			 */
			const BLUE_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Rotatable
			 */
			const BROWN_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Rotatable
			 */
			const GREEN_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Rotatable
			 */
			const RED_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Rotatable
			 */
			const BLACK_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Rotatable>;

			/**
			 * BlockData: Directional
			 */
			const WHITE_WALL_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const ORANGE_WALL_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const MAGENTA_WALL_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const LIGHT_BLUE_WALL_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const YELLOW_WALL_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const LIME_WALL_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const PINK_WALL_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const GRAY_WALL_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const LIGHT_GRAY_WALL_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const CYAN_WALL_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const PURPLE_WALL_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const BLUE_WALL_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const BROWN_WALL_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const GREEN_WALL_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const RED_WALL_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const BLACK_WALL_BANNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			const RED_SANDSTONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CHISELED_RED_SANDSTONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CUT_RED_SANDSTONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Stairs
			 */
			const RED_SANDSTONE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Slab
			 */
			const OAK_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const SPRUCE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const BIRCH_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const JUNGLE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const ACACIA_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const CHERRY_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const DARK_OAK_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const MANGROVE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const BAMBOO_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const BAMBOO_MOSAIC_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const STONE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const SMOOTH_STONE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const SANDSTONE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const CUT_SANDSTONE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const PETRIFIED_OAK_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const COBBLESTONE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const BRICK_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const STONE_BRICK_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const MUD_BRICK_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const NETHER_BRICK_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const QUARTZ_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const RED_SANDSTONE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const CUT_RED_SANDSTONE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const PURPUR_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			const SMOOTH_STONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const SMOOTH_SANDSTONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const SMOOTH_QUARTZ: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const SMOOTH_RED_SANDSTONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Gate
			 */
			const SPRUCE_FENCE_GATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Gate>;

			/**
			 * BlockData: Gate
			 */
			const BIRCH_FENCE_GATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Gate>;

			/**
			 * BlockData: Gate
			 */
			const JUNGLE_FENCE_GATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Gate>;

			/**
			 * BlockData: Gate
			 */
			const ACACIA_FENCE_GATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Gate>;

			/**
			 * BlockData: Gate
			 */
			const CHERRY_FENCE_GATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Gate>;

			/**
			 * BlockData: Gate
			 */
			const DARK_OAK_FENCE_GATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Gate>;

			/**
			 * BlockData: Gate
			 */
			const MANGROVE_FENCE_GATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Gate>;

			/**
			 * BlockData: Gate
			 */
			const BAMBOO_FENCE_GATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Gate>;

			/**
			 * BlockData: Fence
			 */
			const SPRUCE_FENCE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Fence>;

			/**
			 * BlockData: Fence
			 */
			const BIRCH_FENCE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Fence>;

			/**
			 * BlockData: Fence
			 */
			const JUNGLE_FENCE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Fence>;

			/**
			 * BlockData: Fence
			 */
			const ACACIA_FENCE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Fence>;

			/**
			 * BlockData: Fence
			 */
			const CHERRY_FENCE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Fence>;

			/**
			 * BlockData: Fence
			 */
			const DARK_OAK_FENCE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Fence>;

			/**
			 * BlockData: Fence
			 */
			const MANGROVE_FENCE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Fence>;

			/**
			 * BlockData: Fence
			 */
			const BAMBOO_FENCE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Fence>;

			/**
			 * BlockData: Door
			 */
			const SPRUCE_DOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Door>;

			/**
			 * BlockData: Door
			 */
			const BIRCH_DOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Door>;

			/**
			 * BlockData: Door
			 */
			const JUNGLE_DOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Door>;

			/**
			 * BlockData: Door
			 */
			const ACACIA_DOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Door>;

			/**
			 * BlockData: Door
			 */
			const CHERRY_DOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Door>;

			/**
			 * BlockData: Door
			 */
			const DARK_OAK_DOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Door>;

			/**
			 * BlockData: Door
			 */
			const MANGROVE_DOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Door>;

			/**
			 * BlockData: Door
			 */
			const BAMBOO_DOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Door>;

			/**
			 * BlockData: Directional
			 */
			const END_ROD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: MultipleFacing
			 */
			const CHORUS_PLANT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.MultipleFacing>;

			/**
			 * BlockData: Ageable
			 */
			const CHORUS_FLOWER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Ageable>;

			const PURPUR_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Orientable
			 */
			const PURPUR_PILLAR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Stairs
			 */
			const PURPUR_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			const END_STONE_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Ageable
			 */
			const TORCHFLOWER_CROP: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Ageable>;

			/**
			 * BlockData: PitcherCrop
			 */
			const PITCHER_CROP: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.PitcherCrop>;

			/**
			 * BlockData: Bisected
			 */
			const PITCHER_PLANT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Bisected>;

			/**
			 * BlockData: Ageable
			 */
			const BEETROOTS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Ageable>;

			const DIRT_PATH: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const END_GATEWAY: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: CommandBlock
			 */
			const REPEATING_COMMAND_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CommandBlock>;

			/**
			 * BlockData: CommandBlock
			 */
			const CHAIN_COMMAND_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CommandBlock>;

			/**
			 * BlockData: Ageable
			 */
			const FROSTED_ICE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Ageable>;

			const MAGMA_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const NETHER_WART_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const RED_NETHER_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Orientable
			 */
			const BONE_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			const STRUCTURE_VOID: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Observer
			 */
			const OBSERVER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Observer>;

			/**
			 * BlockData: Directional
			 */
			const SHULKER_BOX: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const WHITE_SHULKER_BOX: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const ORANGE_SHULKER_BOX: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const MAGENTA_SHULKER_BOX: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const LIGHT_BLUE_SHULKER_BOX: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const YELLOW_SHULKER_BOX: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const LIME_SHULKER_BOX: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const PINK_SHULKER_BOX: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const GRAY_SHULKER_BOX: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const LIGHT_GRAY_SHULKER_BOX: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const CYAN_SHULKER_BOX: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const PURPLE_SHULKER_BOX: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const BLUE_SHULKER_BOX: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const BROWN_SHULKER_BOX: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const GREEN_SHULKER_BOX: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const RED_SHULKER_BOX: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const BLACK_SHULKER_BOX: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const WHITE_GLAZED_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const ORANGE_GLAZED_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const MAGENTA_GLAZED_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const LIGHT_BLUE_GLAZED_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const YELLOW_GLAZED_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const LIME_GLAZED_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const PINK_GLAZED_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const GRAY_GLAZED_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const LIGHT_GRAY_GLAZED_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const CYAN_GLAZED_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const PURPLE_GLAZED_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const BLUE_GLAZED_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const BROWN_GLAZED_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const GREEN_GLAZED_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const RED_GLAZED_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Directional
			 */
			const BLACK_GLAZED_TERRACOTTA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			const WHITE_CONCRETE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const ORANGE_CONCRETE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const MAGENTA_CONCRETE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LIGHT_BLUE_CONCRETE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const YELLOW_CONCRETE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LIME_CONCRETE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const PINK_CONCRETE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const GRAY_CONCRETE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LIGHT_GRAY_CONCRETE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CYAN_CONCRETE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const PURPLE_CONCRETE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BLUE_CONCRETE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BROWN_CONCRETE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const GREEN_CONCRETE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const RED_CONCRETE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BLACK_CONCRETE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WHITE_CONCRETE_POWDER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const ORANGE_CONCRETE_POWDER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const MAGENTA_CONCRETE_POWDER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LIGHT_BLUE_CONCRETE_POWDER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const YELLOW_CONCRETE_POWDER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LIME_CONCRETE_POWDER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const PINK_CONCRETE_POWDER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const GRAY_CONCRETE_POWDER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LIGHT_GRAY_CONCRETE_POWDER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CYAN_CONCRETE_POWDER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const PURPLE_CONCRETE_POWDER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BLUE_CONCRETE_POWDER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BROWN_CONCRETE_POWDER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const GREEN_CONCRETE_POWDER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const RED_CONCRETE_POWDER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BLACK_CONCRETE_POWDER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Ageable
			 */
			const KELP: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Ageable>;

			const KELP_PLANT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const DRIED_KELP_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: TurtleEgg
			 */
			const TURTLE_EGG: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TurtleEgg>;

			/**
			 * BlockData: Hatchable
			 */
			const SNIFFER_EGG: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Hatchable>;

			const DEAD_TUBE_CORAL_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const DEAD_BRAIN_CORAL_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const DEAD_BUBBLE_CORAL_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const DEAD_FIRE_CORAL_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const DEAD_HORN_CORAL_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const TUBE_CORAL_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BRAIN_CORAL_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BUBBLE_CORAL_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const FIRE_CORAL_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const HORN_CORAL_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Waterlogged
			 */
			const DEAD_TUBE_CORAL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const DEAD_BRAIN_CORAL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const DEAD_BUBBLE_CORAL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const DEAD_FIRE_CORAL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const DEAD_HORN_CORAL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const TUBE_CORAL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const BRAIN_CORAL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const BUBBLE_CORAL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const FIRE_CORAL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const HORN_CORAL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const DEAD_TUBE_CORAL_FAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const DEAD_BRAIN_CORAL_FAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const DEAD_BUBBLE_CORAL_FAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const DEAD_FIRE_CORAL_FAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const DEAD_HORN_CORAL_FAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const TUBE_CORAL_FAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const BRAIN_CORAL_FAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const BUBBLE_CORAL_FAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const FIRE_CORAL_FAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const HORN_CORAL_FAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: CoralWallFan
			 */
			const DEAD_TUBE_CORAL_WALL_FAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CoralWallFan>;

			/**
			 * BlockData: CoralWallFan
			 */
			const DEAD_BRAIN_CORAL_WALL_FAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CoralWallFan>;

			/**
			 * BlockData: CoralWallFan
			 */
			const DEAD_BUBBLE_CORAL_WALL_FAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CoralWallFan>;

			/**
			 * BlockData: CoralWallFan
			 */
			const DEAD_FIRE_CORAL_WALL_FAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CoralWallFan>;

			/**
			 * BlockData: CoralWallFan
			 */
			const DEAD_HORN_CORAL_WALL_FAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CoralWallFan>;

			/**
			 * BlockData: CoralWallFan
			 */
			const TUBE_CORAL_WALL_FAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CoralWallFan>;

			/**
			 * BlockData: CoralWallFan
			 */
			const BRAIN_CORAL_WALL_FAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CoralWallFan>;

			/**
			 * BlockData: CoralWallFan
			 */
			const BUBBLE_CORAL_WALL_FAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CoralWallFan>;

			/**
			 * BlockData: CoralWallFan
			 */
			const FIRE_CORAL_WALL_FAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CoralWallFan>;

			/**
			 * BlockData: CoralWallFan
			 */
			const HORN_CORAL_WALL_FAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CoralWallFan>;

			/**
			 * BlockData: SeaPickle
			 */
			const SEA_PICKLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.SeaPickle>;

			const BLUE_ICE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Waterlogged
			 */
			const CONDUIT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			const BAMBOO_SAPLING: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Bamboo
			 */
			const BAMBOO: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Bamboo>;

			const POTTED_BAMBOO: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const VOID_AIR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CAVE_AIR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: BubbleColumn
			 */
			const BUBBLE_COLUMN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.BubbleColumn>;

			/**
			 * BlockData: Stairs
			 */
			const POLISHED_GRANITE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const SMOOTH_RED_SANDSTONE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const MOSSY_STONE_BRICK_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const POLISHED_DIORITE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const MOSSY_COBBLESTONE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const END_STONE_BRICK_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const STONE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const SMOOTH_SANDSTONE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const SMOOTH_QUARTZ_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const GRANITE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const ANDESITE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const RED_NETHER_BRICK_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const POLISHED_ANDESITE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const DIORITE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Slab
			 */
			const POLISHED_GRANITE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const SMOOTH_RED_SANDSTONE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const MOSSY_STONE_BRICK_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const POLISHED_DIORITE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const MOSSY_COBBLESTONE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const END_STONE_BRICK_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const SMOOTH_SANDSTONE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const SMOOTH_QUARTZ_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const GRANITE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const ANDESITE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const RED_NETHER_BRICK_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const POLISHED_ANDESITE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const DIORITE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Wall
			 */
			const BRICK_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			/**
			 * BlockData: Wall
			 */
			const PRISMARINE_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			/**
			 * BlockData: Wall
			 */
			const RED_SANDSTONE_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			/**
			 * BlockData: Wall
			 */
			const MOSSY_STONE_BRICK_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			/**
			 * BlockData: Wall
			 */
			const GRANITE_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			/**
			 * BlockData: Wall
			 */
			const STONE_BRICK_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			/**
			 * BlockData: Wall
			 */
			const MUD_BRICK_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			/**
			 * BlockData: Wall
			 */
			const NETHER_BRICK_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			/**
			 * BlockData: Wall
			 */
			const ANDESITE_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			/**
			 * BlockData: Wall
			 */
			const RED_NETHER_BRICK_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			/**
			 * BlockData: Wall
			 */
			const SANDSTONE_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			/**
			 * BlockData: Wall
			 */
			const END_STONE_BRICK_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			/**
			 * BlockData: Wall
			 */
			const DIORITE_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			/**
			 * BlockData: Scaffolding
			 */
			const SCAFFOLDING: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Scaffolding>;

			/**
			 * BlockData: Directional
			 */
			const LOOM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Barrel
			 */
			const BARREL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Barrel>;

			/**
			 * BlockData: Furnace
			 */
			const SMOKER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Furnace>;

			/**
			 * BlockData: Furnace
			 */
			const BLAST_FURNACE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Furnace>;

			const CARTOGRAPHY_TABLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const FLETCHING_TABLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Grindstone
			 */
			const GRINDSTONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Grindstone>;

			/**
			 * BlockData: Lectern
			 */
			const LECTERN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Lectern>;

			const SMITHING_TABLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Directional
			 */
			const STONECUTTER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Directional>;

			/**
			 * BlockData: Bell
			 */
			const BELL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Bell>;

			/**
			 * BlockData: Lantern
			 */
			const LANTERN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Lantern>;

			/**
			 * BlockData: Lantern
			 */
			const SOUL_LANTERN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Lantern>;

			/**
			 * BlockData: Campfire
			 */
			const CAMPFIRE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Campfire>;

			/**
			 * BlockData: Campfire
			 */
			const SOUL_CAMPFIRE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Campfire>;

			/**
			 * BlockData: Ageable
			 */
			const SWEET_BERRY_BUSH: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Ageable>;

			/**
			 * BlockData: Orientable
			 */
			const WARPED_STEM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_WARPED_STEM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const WARPED_HYPHAE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_WARPED_HYPHAE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			const WARPED_NYLIUM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WARPED_FUNGUS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WARPED_WART_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WARPED_ROOTS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const NETHER_SPROUTS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Orientable
			 */
			const CRIMSON_STEM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_CRIMSON_STEM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const CRIMSON_HYPHAE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const STRIPPED_CRIMSON_HYPHAE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			const CRIMSON_NYLIUM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CRIMSON_FUNGUS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const SHROOMLIGHT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Ageable
			 */
			const WEEPING_VINES: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Ageable>;

			const WEEPING_VINES_PLANT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Ageable
			 */
			const TWISTING_VINES: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Ageable>;

			const TWISTING_VINES_PLANT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CRIMSON_ROOTS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CRIMSON_PLANKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WARPED_PLANKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Slab
			 */
			const CRIMSON_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const WARPED_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Powerable
			 */
			const CRIMSON_PRESSURE_PLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Powerable>;

			/**
			 * BlockData: Powerable
			 */
			const WARPED_PRESSURE_PLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Powerable>;

			/**
			 * BlockData: Fence
			 */
			const CRIMSON_FENCE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Fence>;

			/**
			 * BlockData: Fence
			 */
			const WARPED_FENCE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Fence>;

			/**
			 * BlockData: TrapDoor
			 */
			const CRIMSON_TRAPDOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrapDoor>;

			/**
			 * BlockData: TrapDoor
			 */
			const WARPED_TRAPDOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrapDoor>;

			/**
			 * BlockData: Gate
			 */
			const CRIMSON_FENCE_GATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Gate>;

			/**
			 * BlockData: Gate
			 */
			const WARPED_FENCE_GATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Gate>;

			/**
			 * BlockData: Stairs
			 */
			const CRIMSON_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const WARPED_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Switch
			 */
			const CRIMSON_BUTTON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Switch>;

			/**
			 * BlockData: Switch
			 */
			const WARPED_BUTTON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Switch>;

			/**
			 * BlockData: Door
			 */
			const CRIMSON_DOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Door>;

			/**
			 * BlockData: Door
			 */
			const WARPED_DOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Door>;

			/**
			 * BlockData: Sign
			 */
			const CRIMSON_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Sign>;

			/**
			 * BlockData: Sign
			 */
			const WARPED_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Sign>;

			/**
			 * BlockData: WallSign
			 */
			const CRIMSON_WALL_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallSign>;

			/**
			 * BlockData: WallSign
			 */
			const WARPED_WALL_SIGN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.WallSign>;

			/**
			 * BlockData: StructureBlock
			 */
			const STRUCTURE_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.StructureBlock>;

			/**
			 * BlockData: Jigsaw
			 */
			const JIGSAW: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Jigsaw>;

			/**
			 * BlockData: Levelled
			 */
			const COMPOSTER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Levelled>;

			/**
			 * BlockData: AnaloguePowerable
			 */
			const TARGET: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.AnaloguePowerable>;

			/**
			 * BlockData: Beehive
			 */
			const BEE_NEST: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Beehive>;

			/**
			 * BlockData: Beehive
			 */
			const BEEHIVE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Beehive>;

			const HONEY_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const HONEYCOMB_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const NETHERITE_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const ANCIENT_DEBRIS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CRYING_OBSIDIAN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: RespawnAnchor
			 */
			const RESPAWN_ANCHOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.RespawnAnchor>;

			const POTTED_CRIMSON_FUNGUS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_WARPED_FUNGUS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_CRIMSON_ROOTS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_WARPED_ROOTS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const LODESTONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BLACKSTONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Stairs
			 */
			const BLACKSTONE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Wall
			 */
			const BLACKSTONE_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			/**
			 * BlockData: Slab
			 */
			const BLACKSTONE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			const POLISHED_BLACKSTONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POLISHED_BLACKSTONE_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CRACKED_POLISHED_BLACKSTONE_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CHISELED_POLISHED_BLACKSTONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Slab
			 */
			const POLISHED_BLACKSTONE_BRICK_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Stairs
			 */
			const POLISHED_BLACKSTONE_BRICK_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Wall
			 */
			const POLISHED_BLACKSTONE_BRICK_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			const GILDED_BLACKSTONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Stairs
			 */
			const POLISHED_BLACKSTONE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Slab
			 */
			const POLISHED_BLACKSTONE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Powerable
			 */
			const POLISHED_BLACKSTONE_PRESSURE_PLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Powerable>;

			/**
			 * BlockData: Switch
			 */
			const POLISHED_BLACKSTONE_BUTTON: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Switch>;

			/**
			 * BlockData: Wall
			 */
			const POLISHED_BLACKSTONE_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			const CHISELED_NETHER_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CRACKED_NETHER_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const QUARTZ_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Candle
			 */
			const CANDLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Candle>;

			/**
			 * BlockData: Candle
			 */
			const WHITE_CANDLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Candle>;

			/**
			 * BlockData: Candle
			 */
			const ORANGE_CANDLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Candle>;

			/**
			 * BlockData: Candle
			 */
			const MAGENTA_CANDLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Candle>;

			/**
			 * BlockData: Candle
			 */
			const LIGHT_BLUE_CANDLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Candle>;

			/**
			 * BlockData: Candle
			 */
			const YELLOW_CANDLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Candle>;

			/**
			 * BlockData: Candle
			 */
			const LIME_CANDLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Candle>;

			/**
			 * BlockData: Candle
			 */
			const PINK_CANDLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Candle>;

			/**
			 * BlockData: Candle
			 */
			const GRAY_CANDLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Candle>;

			/**
			 * BlockData: Candle
			 */
			const LIGHT_GRAY_CANDLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Candle>;

			/**
			 * BlockData: Candle
			 */
			const CYAN_CANDLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Candle>;

			/**
			 * BlockData: Candle
			 */
			const PURPLE_CANDLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Candle>;

			/**
			 * BlockData: Candle
			 */
			const BLUE_CANDLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Candle>;

			/**
			 * BlockData: Candle
			 */
			const BROWN_CANDLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Candle>;

			/**
			 * BlockData: Candle
			 */
			const GREEN_CANDLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Candle>;

			/**
			 * BlockData: Candle
			 */
			const RED_CANDLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Candle>;

			/**
			 * BlockData: Candle
			 */
			const BLACK_CANDLE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Candle>;

			/**
			 * BlockData: Lightable
			 */
			const CANDLE_CAKE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			/**
			 * BlockData: Lightable
			 */
			const WHITE_CANDLE_CAKE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			/**
			 * BlockData: Lightable
			 */
			const ORANGE_CANDLE_CAKE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			/**
			 * BlockData: Lightable
			 */
			const MAGENTA_CANDLE_CAKE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			/**
			 * BlockData: Lightable
			 */
			const LIGHT_BLUE_CANDLE_CAKE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			/**
			 * BlockData: Lightable
			 */
			const YELLOW_CANDLE_CAKE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			/**
			 * BlockData: Lightable
			 */
			const LIME_CANDLE_CAKE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			/**
			 * BlockData: Lightable
			 */
			const PINK_CANDLE_CAKE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			/**
			 * BlockData: Lightable
			 */
			const GRAY_CANDLE_CAKE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			/**
			 * BlockData: Lightable
			 */
			const LIGHT_GRAY_CANDLE_CAKE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			/**
			 * BlockData: Lightable
			 */
			const CYAN_CANDLE_CAKE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			/**
			 * BlockData: Lightable
			 */
			const PURPLE_CANDLE_CAKE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			/**
			 * BlockData: Lightable
			 */
			const BLUE_CANDLE_CAKE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			/**
			 * BlockData: Lightable
			 */
			const BROWN_CANDLE_CAKE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			/**
			 * BlockData: Lightable
			 */
			const GREEN_CANDLE_CAKE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			/**
			 * BlockData: Lightable
			 */
			const RED_CANDLE_CAKE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			/**
			 * BlockData: Lightable
			 */
			const BLACK_CANDLE_CAKE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Lightable>;

			const AMETHYST_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const BUDDING_AMETHYST: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: AmethystCluster
			 */
			const AMETHYST_CLUSTER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.AmethystCluster>;

			/**
			 * BlockData: AmethystCluster
			 */
			const LARGE_AMETHYST_BUD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.AmethystCluster>;

			/**
			 * BlockData: AmethystCluster
			 */
			const MEDIUM_AMETHYST_BUD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.AmethystCluster>;

			/**
			 * BlockData: AmethystCluster
			 */
			const SMALL_AMETHYST_BUD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.AmethystCluster>;

			const TUFF: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Slab
			 */
			const TUFF_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Stairs
			 */
			const TUFF_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Wall
			 */
			const TUFF_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			const POLISHED_TUFF: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Slab
			 */
			const POLISHED_TUFF_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Stairs
			 */
			const POLISHED_TUFF_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Wall
			 */
			const POLISHED_TUFF_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			const CHISELED_TUFF: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const TUFF_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Slab
			 */
			const TUFF_BRICK_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Stairs
			 */
			const TUFF_BRICK_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Wall
			 */
			const TUFF_BRICK_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			const CHISELED_TUFF_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CALCITE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const TINTED_GLASS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POWDER_SNOW: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: SculkSensor
			 */
			const SCULK_SENSOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.SculkSensor>;

			/**
			 * BlockData: CalibratedSculkSensor
			 */
			const CALIBRATED_SCULK_SENSOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CalibratedSculkSensor>;

			const SCULK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: SculkVein
			 */
			const SCULK_VEIN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.SculkVein>;

			/**
			 * BlockData: SculkCatalyst
			 */
			const SCULK_CATALYST: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.SculkCatalyst>;

			/**
			 * BlockData: SculkShrieker
			 */
			const SCULK_SHRIEKER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.SculkShrieker>;

			const COPPER_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const EXPOSED_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WEATHERED_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const OXIDIZED_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const COPPER_ORE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const DEEPSLATE_COPPER_ORE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const OXIDIZED_CUT_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WEATHERED_CUT_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const EXPOSED_CUT_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CUT_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const OXIDIZED_CHISELED_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WEATHERED_CHISELED_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const EXPOSED_CHISELED_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CHISELED_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WAXED_OXIDIZED_CHISELED_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WAXED_WEATHERED_CHISELED_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WAXED_EXPOSED_CHISELED_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WAXED_CHISELED_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Stairs
			 */
			const OXIDIZED_CUT_COPPER_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const WEATHERED_CUT_COPPER_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const EXPOSED_CUT_COPPER_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const CUT_COPPER_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Slab
			 */
			const OXIDIZED_CUT_COPPER_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const WEATHERED_CUT_COPPER_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const EXPOSED_CUT_COPPER_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const CUT_COPPER_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			const WAXED_COPPER_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WAXED_WEATHERED_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WAXED_EXPOSED_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WAXED_OXIDIZED_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WAXED_OXIDIZED_CUT_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WAXED_WEATHERED_CUT_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WAXED_EXPOSED_CUT_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const WAXED_CUT_COPPER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Stairs
			 */
			const WAXED_OXIDIZED_CUT_COPPER_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const WAXED_WEATHERED_CUT_COPPER_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const WAXED_EXPOSED_CUT_COPPER_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Stairs
			 */
			const WAXED_CUT_COPPER_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Slab
			 */
			const WAXED_OXIDIZED_CUT_COPPER_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const WAXED_WEATHERED_CUT_COPPER_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const WAXED_EXPOSED_CUT_COPPER_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Slab
			 */
			const WAXED_CUT_COPPER_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Door
			 */
			const COPPER_DOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Door>;

			/**
			 * BlockData: Door
			 */
			const EXPOSED_COPPER_DOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Door>;

			/**
			 * BlockData: Door
			 */
			const OXIDIZED_COPPER_DOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Door>;

			/**
			 * BlockData: Door
			 */
			const WEATHERED_COPPER_DOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Door>;

			/**
			 * BlockData: Door
			 */
			const WAXED_COPPER_DOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Door>;

			/**
			 * BlockData: Door
			 */
			const WAXED_EXPOSED_COPPER_DOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Door>;

			/**
			 * BlockData: Door
			 */
			const WAXED_OXIDIZED_COPPER_DOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Door>;

			/**
			 * BlockData: Door
			 */
			const WAXED_WEATHERED_COPPER_DOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Door>;

			/**
			 * BlockData: TrapDoor
			 */
			const COPPER_TRAPDOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrapDoor>;

			/**
			 * BlockData: TrapDoor
			 */
			const EXPOSED_COPPER_TRAPDOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrapDoor>;

			/**
			 * BlockData: TrapDoor
			 */
			const OXIDIZED_COPPER_TRAPDOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrapDoor>;

			/**
			 * BlockData: TrapDoor
			 */
			const WEATHERED_COPPER_TRAPDOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrapDoor>;

			/**
			 * BlockData: TrapDoor
			 */
			const WAXED_COPPER_TRAPDOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrapDoor>;

			/**
			 * BlockData: TrapDoor
			 */
			const WAXED_EXPOSED_COPPER_TRAPDOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrapDoor>;

			/**
			 * BlockData: TrapDoor
			 */
			const WAXED_OXIDIZED_COPPER_TRAPDOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrapDoor>;

			/**
			 * BlockData: TrapDoor
			 */
			const WAXED_WEATHERED_COPPER_TRAPDOOR: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrapDoor>;

			/**
			 * BlockData: Waterlogged
			 */
			const COPPER_GRATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const EXPOSED_COPPER_GRATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const WEATHERED_COPPER_GRATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const OXIDIZED_COPPER_GRATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const WAXED_COPPER_GRATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const WAXED_EXPOSED_COPPER_GRATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const WAXED_WEATHERED_COPPER_GRATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: Waterlogged
			 */
			const WAXED_OXIDIZED_COPPER_GRATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			/**
			 * BlockData: CopperBulb
			 */
			const COPPER_BULB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CopperBulb>;

			/**
			 * BlockData: CopperBulb
			 */
			const EXPOSED_COPPER_BULB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CopperBulb>;

			/**
			 * BlockData: CopperBulb
			 */
			const WEATHERED_COPPER_BULB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CopperBulb>;

			/**
			 * BlockData: CopperBulb
			 */
			const OXIDIZED_COPPER_BULB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CopperBulb>;

			/**
			 * BlockData: CopperBulb
			 */
			const WAXED_COPPER_BULB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CopperBulb>;

			/**
			 * BlockData: CopperBulb
			 */
			const WAXED_EXPOSED_COPPER_BULB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CopperBulb>;

			/**
			 * BlockData: CopperBulb
			 */
			const WAXED_WEATHERED_COPPER_BULB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CopperBulb>;

			/**
			 * BlockData: CopperBulb
			 */
			const WAXED_OXIDIZED_COPPER_BULB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CopperBulb>;

			/**
			 * BlockData: LightningRod
			 */
			const LIGHTNING_ROD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.LightningRod>;

			/**
			 * BlockData: PointedDripstone
			 */
			const POINTED_DRIPSTONE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.PointedDripstone>;

			const DRIPSTONE_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: CaveVines
			 */
			const CAVE_VINES: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CaveVines>;

			/**
			 * BlockData: CaveVinesPlant
			 */
			const CAVE_VINES_PLANT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.CaveVinesPlant>;

			const SPORE_BLOSSOM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const AZALEA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const FLOWERING_AZALEA: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const MOSS_CARPET: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: PinkPetals
			 */
			const PINK_PETALS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.PinkPetals>;

			const MOSS_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: BigDripleaf
			 */
			const BIG_DRIPLEAF: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.BigDripleaf>;

			/**
			 * BlockData: Dripleaf
			 */
			const BIG_DRIPLEAF_STEM: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Dripleaf>;

			/**
			 * BlockData: SmallDripleaf
			 */
			const SMALL_DRIPLEAF: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.SmallDripleaf>;

			/**
			 * BlockData: Waterlogged
			 */
			const HANGING_ROOTS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Waterlogged>;

			const ROOTED_DIRT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const MUD: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Orientable
			 */
			const DEEPSLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			const COBBLED_DEEPSLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Stairs
			 */
			const COBBLED_DEEPSLATE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Slab
			 */
			const COBBLED_DEEPSLATE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Wall
			 */
			const COBBLED_DEEPSLATE_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			const POLISHED_DEEPSLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Stairs
			 */
			const POLISHED_DEEPSLATE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Slab
			 */
			const POLISHED_DEEPSLATE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Wall
			 */
			const POLISHED_DEEPSLATE_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			const DEEPSLATE_TILES: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Stairs
			 */
			const DEEPSLATE_TILE_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Slab
			 */
			const DEEPSLATE_TILE_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Wall
			 */
			const DEEPSLATE_TILE_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			const DEEPSLATE_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Stairs
			 */
			const DEEPSLATE_BRICK_STAIRS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Stairs>;

			/**
			 * BlockData: Slab
			 */
			const DEEPSLATE_BRICK_SLAB: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Slab>;

			/**
			 * BlockData: Wall
			 */
			const DEEPSLATE_BRICK_WALL: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Wall>;

			const CHISELED_DEEPSLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CRACKED_DEEPSLATE_BRICKS: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const CRACKED_DEEPSLATE_TILES: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Orientable
			 */
			const INFESTED_DEEPSLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			const SMOOTH_BASALT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const RAW_IRON_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const RAW_COPPER_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const RAW_GOLD_BLOCK: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_AZALEA_BUSH: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const POTTED_FLOWERING_AZALEA_BUSH: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: Orientable
			 */
			const OCHRE_FROGLIGHT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const VERDANT_FROGLIGHT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			/**
			 * BlockData: Orientable
			 */
			const PEARLESCENT_FROGLIGHT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.Orientable>;

			const FROGSPAWN: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			const REINFORCED_DEEPSLATE: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.BlockData>;

			/**
			 * BlockData: DecoratedPot
			 */
			const DECORATED_POT: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.DecoratedPot>;

			/**
			 * BlockData: Crafter
			 */
			const CRAFTER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.Crafter>;

			/**
			 * BlockData: TrialSpawner
			 */
			const TRIAL_SPAWNER: org.bukkit.block.BlockType.Typed<org.bukkit.block.data.type.TrialSpawner>;

		}
		namespace BlockType {
			interface Typed<B = any> extends Modify<org.bukkit.block.BlockType, {
				/**
				 * Gets the BlockData class of this BlockType
				 */
				getBlockDataClass(): globalThis.java.lang.Class<B>;

				/**
				 * Creates a new BlockData instance for this block type, with
				 * all properties initialized to unspecified defaults.
				 */
				createBlockData(consumer: ((value: B) => void | null)): B;

				/**
				 * Creates a new BlockData instance for this block type, with all
				 * properties initialized to unspecified defaults.
				 */
				createBlockData(): B;

				/**
				 * Creates a new BlockData instance for this block type, with all
				 * properties initialized to unspecified defaults, except for those provided
				 * in data.
				 */
				createBlockData(data: (string | null)): B;

			}> {}
		}
		interface BrewingStand extends Modify<org.bukkit.block.Container, {
			/**
			 * How much time is left in the brewing cycle.
			 */
			getBrewingTime(): number;

			/**
			 * Set the time left before brewing completes.
			 */
			setBrewingTime(brewTime: number): void;

			/**
			 * Get the level of current fuel for brewing.
			 */
			getFuelLevel(): number;

			/**
			 * Set the level of current fuel for brewing.
			 */
			setFuelLevel(level: number): void;

			/**
			 * Description copied from interface:Â Container
			 */
			getInventory(): org.bukkit.inventory.BrewerInventory;

			/**
			 * Description copied from interface:Â Container
			 */
			getSnapshotInventory(): org.bukkit.inventory.BrewerInventory;

		}> {}
		interface BrushableBlock extends Modify<org.bukkit.loot.Lootable & org.bukkit.block.TileState, {
			/**
			 * Get the item which will be revealed when the sand is fully brushed away
			 * and uncovered.
			 */
			getItem(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Sets the item which will be revealed when the sand is fully brushed away
			 * and uncovered.
			 */
			setItem(item: (org.bukkit.inventory.ItemStack | null)): void;

		}> {}
		interface CalibratedSculkSensor extends Modify<org.bukkit.block.SculkSensor, {}> {}
		interface Campfire extends Modify<org.bukkit.block.TileState, {
			getSize(): number;

			getItem(index: number): (org.bukkit.inventory.ItemStack | null);

			setItem(index: number, item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Get cook time.
			 * This is the amount of time the item has been cooking for.
			 */
			getCookTime(index: number): number;

			/**
			 * Set cook time.
			 * This is the amount of time the item has been cooking for.
			 */
			setCookTime(index: number, cookTime: number): void;

			/**
			 * Get cook time total.
			 * This is the amount of time the item is required to cook for.
			 */
			getCookTimeTotal(index: number): number;

			/**
			 * Set cook time.
			 * This is the amount of time the item is required to cook for.
			 */
			setCookTimeTotal(index: number, cookTimeTotal: number): void;

		}> {}
		interface Chest extends Modify<org.bukkit.block.Container & org.bukkit.loot.Lootable & org.bukkit.block.Lidded, {
			/**
			 * Gets the inventory of the chest block represented by this block state.
			 * 
			 * If the chest is a double chest, it returns just the portion of the
			 * inventory linked to the half of the chest corresponding to this block state.
			 * 
			 * If the block was changed to a different type in the meantime, the
			 * returned inventory might no longer be valid.
			 * 
			 * If this block state is not placed this will return the captured
			 * inventory snapshot instead.
			 */
			getBlockInventory(): org.bukkit.inventory.Inventory;

		}> {}
		interface ChiseledBookshelf extends Modify<org.bukkit.block.TileState & org.bukkit.inventory.BlockInventoryHolder, {
			/**
			 * Gets the last interacted inventory slot.
			 */
			getLastInteractedSlot(): number;

			/**
			 * Sets the last interacted inventory slot.
			 */
			setLastInteractedSlot(lastInteractedSlot: number): void;

			/**
			 * Description copied from interface:Â InventoryHolder
			 */
			getInventory(): org.bukkit.inventory.ChiseledBookshelfInventory;

			getSnapshotInventory(): org.bukkit.inventory.ChiseledBookshelfInventory;

			/**
			 * Gets the appropriate slot based on a vector relative to this block.
			 * Will return -1 if the given vector is not within the bounds of any slot.
			 * 
			 * The supplied vector should only contain components with values between 0.0
			 * and 1.0, inclusive.
			 */
			getSlot(position: org.bukkit.util.Vector): number;

		}> {}
		interface CommandBlock extends Modify<org.bukkit.block.TileState, {
			/**
			 * Gets the command that this CommandBlock will run when powered.
			 * This will never return null. If the CommandBlock does not have a
			 * command, an empty String will be returned instead.
			 */
			getCommand(): string;

			/**
			 * Sets the command that this CommandBlock will run when powered.
			 * Setting the command to null is the same as setting it to an empty
			 * String.
			 */
			setCommand(command: (string | null)): void;

			/**
			 * Gets the name of this CommandBlock. The name is used with commands
			 * that this CommandBlock executes. This name will never be null, and
			 * by default is "@".
			 */
			getName(): string;

			/**
			 * Sets the name of this CommandBlock. The name is used with commands
			 * that this CommandBlock executes. Setting the name to null is the
			 * same as setting it to "@".
			 */
			setName(name: (string | null)): void;

		}> {}
		interface Comparator extends Modify<org.bukkit.block.TileState, {}> {}
		interface Conduit extends Modify<org.bukkit.block.TileState, {
			/**
			 * Checks whether or not this conduit is active.
			 * 
			 * A conduit is considered active if there are at least 16 valid frame
			 * blocks surrounding it and the conduit is surrounded by a 3x3x3 area of
			 * water source blocks (or waterlogged blocks), at which point its animation
			 * will activate, start spinning, and apply effects to nearby players.
			 */
			isActive(): boolean;

			/**
			 * Get whether or not this conduit is actively hunting for nearby hostile
			 * creatures.
			 * 
			 * A conduit will hunt if it is active (see isActive()) and its
			 * frame is complete (it is surrounded by at least 42 valid frame blocks).
			 * While hunting, the conduit's target, if within its hunting area,
			 * will be damaged every 2 seconds.
			 */
			isHunting(): boolean;

			/**
			 * Get a Collection of all Blocks that make up the
			 * frame of this conduit. The returned collection will contain only blocks
			 * that match the types required by the conduit to make up a valid frame,
			 * not the blocks at which the conduit is searching,
			 * meaning it will be of variable size depending on how many valid frames
			 * are surrounding the conduit at the time of invocation.
			 */
			getFrameBlocks(): globalThis.java.util.Collection<org.bukkit.block.Block>;

			/**
			 * Get the amount of valid frame blocks that are currently surrounding the
			 * conduit.
			 */
			getFrameBlockCount(): number;

			/**
			 * Get the range (measured in blocks) within which players will receive the
			 * conduit's benefits.
			 */
			getRange(): number;

			/**
			 * Set the conduit's hunting target.
			 * 
			 * Note that the value set by this method may be overwritten by the
			 * conduit's periodic hunting logic. If the target is ever set to
			 * null, the conduit will continue to look for a new target.
			 * Additionally, if the target is set to an entity that does not meet a
			 * conduit's hunting conditions (e.g. the entity is not within the
			 * hunting area, has already been killed, etc.)
			 * then the passed entity will be ignored and the conduit will also continue
			 * to look for a new target.
			 */
			setTarget(target: (org.bukkit.entity.LivingEntity | null)): boolean;

			/**
			 * Get the conduit's hunting target.
			 */
			getTarget(): (org.bukkit.entity.LivingEntity | null);

			/**
			 * Check whether or not this conduit has an active (alive) hunting target.
			 */
			hasTarget(): boolean;

			/**
			 * Get a BoundingBox (relative to real-world coordinates) in which
			 * the conduit will search for hostile entities to target.
			 */
			getHuntingArea(): org.bukkit.util.BoundingBox;

		}> {}
		interface Container extends Modify<org.bukkit.block.TileState & org.bukkit.inventory.BlockInventoryHolder & org.bukkit.block.Lockable & org.bukkit.Nameable, {
			/**
			 * Gets the inventory of the block represented by this block state.
			 * 
			 * If the block was changed to a different type in the meantime, the
			 * returned inventory might no longer be valid.
			 * 
			 * If this block state is not placed this will return the captured inventory
			 * snapshot instead.
			 */
			getInventory(): org.bukkit.inventory.Inventory;

			/**
			 * Gets the captured inventory snapshot of this container.
			 * 
			 * The returned inventory is not linked to any block. Any modifications to
			 * the returned inventory will not be applied to the block represented by
			 * this block state up until BlockState.update(boolean, boolean) has been
			 * called.
			 */
			getSnapshotInventory(): org.bukkit.inventory.Inventory;

		}> {}
		interface Crafter extends Modify<org.bukkit.block.Container & org.bukkit.loot.Lootable, {
			/**
			 * Gets the number of ticks which this block will remain in the crafting
			 * state for.
			 */
			getCraftingTicks(): number;

			/**
			 * Sets the number of ticks which this block will remain in the crafting
			 * state for.
			 */
			setCraftingTicks(ticks: number): void;

			/**
			 * Gets whether the slot at the specified index is disabled and will not
			 * have items placed in it.
			 */
			isSlotDisabled(slot: number): boolean;

			/**
			 * Sets whether the slot at the specified index is disabled and will not
			 * have items placed in it.
			 */
			setSlotDisabled(slot: number, disabled: boolean): void;

			/**
			 * Gets whether this Crafter is powered.
			 */
			isTriggered(): boolean;

			/**
			 * Sets whether this Crafter is powered.
			 */
			setTriggered(triggered: boolean): void;

		}> {}
		interface CreatureSpawner extends Modify<org.bukkit.block.TileState, {
			/**
			 * Get the spawner's creature type.
			 */
			getSpawnedType(): (org.bukkit.entity.EntityType | null);

			/**
			 * Set the spawner's creature type.
			 * This will override any entities that have been added with addPotentialSpawn(org.bukkit.entity.EntitySnapshot, int, org.bukkit.block.spawner.SpawnRule)
			 */
			setSpawnedType(creatureType: (org.bukkit.entity.EntityType | null)): void;

			/**
			 * Set the spawner mob type.
			 */
			setCreatureTypeByName(creatureType: (string | null)): void;

			/**
			 * Get the spawner's creature type.
			 */
			getCreatureTypeName(): (string | null);

			/**
			 * Get the spawner's delay.
			 * 
			 * This is the delay, in ticks, until the spawner will spawn its next mob.
			 */
			getDelay(): number;

			/**
			 * Set the spawner's delay.
			 * 
			 * If set to -1, the spawn delay will be reset to a random value between
			 * getMinSpawnDelay() and getMaxSpawnDelay().
			 */
			setDelay(delay: number): void;

			/**
			 * The minimum spawn delay amount (in ticks).
			 * 
			 * This value is used when the spawner resets its delay (for any reason).
			 * It will choose a random number between getMinSpawnDelay()
			 * and getMaxSpawnDelay() for its next getDelay().
			 * 
			 * Default value is 200 ticks.
			 */
			getMinSpawnDelay(): number;

			/**
			 * Set the minimum spawn delay amount (in ticks).
			 */
			setMinSpawnDelay(delay: number): void;

			/**
			 * The maximum spawn delay amount (in ticks).
			 * 
			 * This value is used when the spawner resets its delay (for any reason).
			 * It will choose a random number between getMinSpawnDelay()
			 * and getMaxSpawnDelay() for its next getDelay().
			 * 
			 * This value must be greater than 0 and less than or equal to
			 * getMaxSpawnDelay().
			 * 
			 * Default value is 800 ticks.
			 */
			getMaxSpawnDelay(): number;

			/**
			 * Set the maximum spawn delay amount (in ticks).
			 * 
			 * This value must be greater than 0, as well as greater than or
			 * equal to getMinSpawnDelay()
			 */
			setMaxSpawnDelay(delay: number): void;

			/**
			 * Get how many mobs attempt to spawn.
			 * 
			 * Default value is 4.
			 */
			getSpawnCount(): number;

			/**
			 * Set how many mobs attempt to spawn.
			 */
			setSpawnCount(spawnCount: number): void;

			/**
			 * Set the new maximum amount of similar entities that are allowed to be
			 * within spawning range of this spawner.
			 * 
			 * If more than the maximum number of entities are within range, the spawner
			 * will not spawn and try again with a new getDelay().
			 * 
			 * Default value is 16.
			 */
			getMaxNearbyEntities(): number;

			/**
			 * Set the maximum number of similar entities that are allowed to be within
			 * spawning range of this spawner.
			 * 
			 * Similar entities are entities that are of the same EntityType
			 */
			setMaxNearbyEntities(maxNearbyEntities: number): void;

			/**
			 * Get the maximum distance(squared) a player can be in order for this
			 * spawner to be active.
			 * 
			 * If this value is less than or equal to 0, this spawner is always active
			 * (given that there are players online).
			 * 
			 * Default value is 16.
			 */
			getRequiredPlayerRange(): number;

			/**
			 * Set the maximum distance (squared) a player can be in order for this
			 * spawner to be active.
			 * 
			 * Setting this value to less than or equal to 0 will make this spawner
			 * always active (given that there are players online).
			 */
			setRequiredPlayerRange(requiredPlayerRange: number): void;

			/**
			 * Get the radius around which the spawner will attempt to spawn mobs in.
			 * 
			 * This area is square, includes the block the spawner is in, and is
			 * centered on the spawner's x,z coordinates - not the spawner itself.
			 * 
			 * It is 2 blocks high, centered on the spawner's y-coordinate (its bottom);
			 * thus allowing mobs to spawn as high as its top surface and as low
			 * as 1 block below its bottom surface.
			 * 
			 * Default value is 4.
			 */
			getSpawnRange(): number;

			/**
			 * Set the new spawn range.
			 * 
			 */
			setSpawnRange(spawnRange: number): void;

			/**
			 * Gets the EntitySnapshot that will be spawned by this spawner or null
			 * if no entities have been assigned to this spawner.
			 * 
			 * All applicable data from the spawner will be copied, such as custom name,
			 * health, and velocity.
			 */
			getSpawnedEntity(): (org.bukkit.entity.EntitySnapshot | null);

			/**
			 * Sets the entity that will be spawned by this spawner.
			 * This will override any previous entries that have been added with
			 * addPotentialSpawn(org.bukkit.entity.EntitySnapshot, int, org.bukkit.block.spawner.SpawnRule)
			 * 
			 * All applicable data from the snapshot will be copied, such as custom name,
			 * health, and velocity.
			 */
			setSpawnedEntity(snapshot: org.bukkit.entity.EntitySnapshot): void;

			/**
			 * Adds a new EntitySnapshot to the list of entities this spawner can
			 * spawn.
			 * 
			 * The weight will determine how often this entry is chosen to spawn, higher
			 * weighted entries will spawn more often than lower weighted ones.
			 * The SpawnRule will determine under what conditions this entry can
			 * spawn, passing null will use the default conditions for the given entity.
			 */
			addPotentialSpawn(snapshot: org.bukkit.entity.EntitySnapshot, weight: number, spawnRule: (org.bukkit.block.spawner.SpawnRule | null)): void;

			/**
			 * Adds a new SpawnerEntry to the list of entities this spawner can
			 * spawn.
			 */
			addPotentialSpawn(spawnerEntry: org.bukkit.block.spawner.SpawnerEntry): void;

			/**
			 * Sets the list of SpawnerEntry this spawner can spawn.
			 * This will override any previous entries added with
			 * addPotentialSpawn(org.bukkit.entity.EntitySnapshot, int, org.bukkit.block.spawner.SpawnRule)
			 */
			setPotentialSpawns(entries: globalThis.java.util.Collection<org.bukkit.block.spawner.SpawnerEntry>): void;

			/**
			 * Gets a list of potential spawns from this spawner or an empty list if no
			 * entities have been assigned to this spawner.
			 * Changes made to the returned list will not be reflected in the spawner unless
			 * applied with setPotentialSpawns(java.util.Collection<org.bukkit.block.spawner.SpawnerEntry>)
			 */
			getPotentialSpawns(): globalThis.java.util.List<org.bukkit.block.spawner.SpawnerEntry>;

		}> {}
		interface DaylightDetector extends Modify<org.bukkit.block.TileState, {}> {}
		interface DecoratedPot extends Modify<org.bukkit.block.TileState & org.bukkit.inventory.BlockInventoryHolder, {
			/**
			 * Set the sherd on the provided side.
			 */
			setSherd(side: org.bukkit.block.DecoratedPot.Side, sherd: (org.bukkit.Material | null)): void;

			/**
			 * Get the sherd on the provided side.
			 */
			getSherd(side: org.bukkit.block.DecoratedPot.Side): org.bukkit.Material;

			/**
			 * Gets a Map of all sides on this decorated pot and the sherds on them.
			 * If a side does not have a specific sherd on it, Material.BRICK
			 * will be the value of that side.
			 */
			getSherds(): globalThis.java.util.Map<org.bukkit.block.DecoratedPot.Side, org.bukkit.Material>;

			/**
			 * Gets the sherds on this decorated pot. For faces without a specific sherd,
			 * Material.BRICK is used in its place.
			 */
			getShards(): globalThis.java.util.List<org.bukkit.Material>;

			/**
			 * Description copied from interface:Â InventoryHolder
			 */
			getInventory(): org.bukkit.inventory.DecoratedPotInventory;

			getSnapshotInventory(): org.bukkit.inventory.DecoratedPotInventory;

		}> {}
		namespace DecoratedPot {
			interface Side {}
			namespace Side {
				const BACK: org.bukkit.block.DecoratedPot.Side;

				const LEFT: org.bukkit.block.DecoratedPot.Side;

				const RIGHT: org.bukkit.block.DecoratedPot.Side;

				const FRONT: org.bukkit.block.DecoratedPot.Side;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.block.DecoratedPot.Side;

			}
		}
		interface Dispenser extends Modify<org.bukkit.block.Container & org.bukkit.Nameable & org.bukkit.loot.Lootable, {
			/**
			 * Gets the BlockProjectileSource object for the dispenser.
			 * 
			 * If the block represented by this state is no longer a dispenser, this
			 * will return null.
			 */
			getBlockProjectileSource(): (org.bukkit.projectiles.BlockProjectileSource | null);

			/**
			 * Attempts to dispense the contents of the dispenser.
			 * 
			 * If the block represented by this state is no longer a dispenser, this
			 * will return false.
			 */
			dispense(): boolean;

		}> {}
		interface DoubleChest {
			/**
			 * Description copied from interface:Â InventoryHolder
			 */
			getInventory(): org.bukkit.inventory.Inventory;

			getLeftSide(): (org.bukkit.inventory.InventoryHolder | null);

			getRightSide(): (org.bukkit.inventory.InventoryHolder | null);

			getLocation(): org.bukkit.Location;

			getWorld(): (org.bukkit.World | null);

			getX(): number;

			getY(): number;

			getZ(): number;

		}
		class DoubleChest {
			constructor(chest: org.bukkit.inventory.DoubleChestInventory);

		}
		interface Dropper extends Modify<org.bukkit.block.Container & org.bukkit.loot.Lootable, {
			/**
			 * Tries to drop a randomly selected item from the dropper's inventory,
			 * following the normal behavior of a dropper.
			 * 
			 * Normal behavior of a dropper is as follows:
			 * 
			 * If the block that the dropper is facing is an InventoryHolder,
			 * the randomly selected ItemStack is placed within that
			 * Inventory in the first slot that's available, starting with 0 and
			 * counting up. If the inventory is full, nothing happens.
			 * 
			 * If the block that the dropper is facing is not an InventoryHolder,
			 * the randomly selected ItemStack is dropped on
			 * the ground in the form of an Item.
			 * 
			 * If the block represented by this state is no longer a dropper, this will
			 * do nothing.
			 */
			drop(): void;

		}> {}
		interface EnchantingTable extends Modify<org.bukkit.block.TileState & org.bukkit.Nameable, {}> {}
		interface EndGateway extends Modify<org.bukkit.block.TileState, {
			/**
			 * Gets the location that entities are teleported to when
			 * entering the gateway portal.
			 * 
			 * If this block state is not placed the location's world will be null.
			 */
			getExitLocation(): (org.bukkit.Location | null);

			/**
			 * Sets the exit location that entities are teleported to when
			 * they enter the gateway portal.
			 * 
			 * If this block state is not placed the location's world has to be null.
			 */
			setExitLocation(location: (org.bukkit.Location | null)): void;

			/**
			 * Gets whether this gateway will teleport entities directly to
			 * the exit location instead of finding a nearby location.
			 */
			isExactTeleport(): boolean;

			/**
			 * Sets whether this gateway will teleport entities directly to
			 * the exit location instead of finding a nearby location.
			 */
			setExactTeleport(exact: boolean): void;

			/**
			 * Gets the age in ticks of the gateway.
			 * 
			 * If the age is less than 200 ticks a magenta beam will be emitted, whilst
			 * if it is a multiple of 2400 ticks a purple beam will be emitted.
			 */
			getAge(): number;

			/**
			 * Sets the age in ticks of the gateway.
			 * 
			 * If the age is less than 200 ticks a magenta beam will be emitted, whilst
			 * if it is a multiple of 2400 ticks a purple beam will be emitted.
			 */
			setAge(age: number): void;

		}> {}
		interface EnderChest extends Modify<org.bukkit.block.Lidded & org.bukkit.block.TileState, {}> {}
		interface EntityBlockStorage<T = any> extends Modify<org.bukkit.block.TileState, {
			/**
			 * Check if the block is completely full of entities.
			 */
			isFull(): boolean;

			/**
			 * Get the amount of entities currently in this block.
			 */
			getEntityCount(): number;

			/**
			 * Get the maximum amount of entities this block can hold.
			 */
			getMaxEntities(): number;

			/**
			 * Set the maximum amount of entities this block can hold.
			 */
			setMaxEntities(max: number): void;

			/**
			 * Release all the entities currently stored in the block.
			 */
			releaseEntities(): globalThis.java.util.List<T>;

			/**
			 * Add an entity to the block.
			 */
			addEntity(entity: T): void;

		}> {}
		interface Furnace extends Modify<org.bukkit.block.Container, {
			/**
			 * Get burn time.
			 */
			getBurnTime(): number;

			/**
			 * Set burn time.
			 * A burn time greater than 0 will cause this block to be lit, whilst a time
			 * less than 0 will extinguish it.
			 */
			setBurnTime(burnTime: number): void;

			/**
			 * Get cook time.
			 * This is the amount of time the item has been cooking for.
			 */
			getCookTime(): number;

			/**
			 * Set cook time.
			 * This is the amount of time the item has been cooking for.
			 */
			setCookTime(cookTime: number): void;

			/**
			 * Get cook time total.
			 * This is the amount of time the item is required to cook for.
			 */
			getCookTimeTotal(): number;

			/**
			 * Set cook time.
			 * This is the amount of time the item is required to cook for.
			 */
			setCookTimeTotal(cookTimeTotal: number): void;

			/**
			 * Get the recipes used in this furnace.
			 * Note: These recipes used are reset when the result item is
			 * manually taken from the furnace.
			 */
			getRecipesUsed(): globalThis.java.util.Map<org.bukkit.inventory.CookingRecipe, number>;

			/**
			 * Description copied from interface:Â Container
			 */
			getInventory(): org.bukkit.inventory.FurnaceInventory;

			/**
			 * Description copied from interface:Â Container
			 */
			getSnapshotInventory(): org.bukkit.inventory.FurnaceInventory;

		}> {}
		interface HangingSign extends Modify<org.bukkit.block.Sign, {}> {}
		interface Hopper extends Modify<org.bukkit.block.Container & org.bukkit.loot.Lootable, {}> {}
		interface Jigsaw extends Modify<org.bukkit.block.TileState, {}> {}
		interface Jukebox extends Modify<org.bukkit.block.TileState & org.bukkit.inventory.BlockInventoryHolder, {
			/**
			 * Gets the record inserted into the jukebox.
			 */
			getPlaying(): org.bukkit.Material;

			/**
			 * Sets the record being played.
			 */
			setPlaying(record: (org.bukkit.Material | null)): void;

			/**
			 * Gets whether or not this jukebox has a record.
			 * 
			 * A jukebox can have a record but not be playing
			 * if it was stopped with stopPlaying() or if a record has
			 * finished playing.
			 */
			hasRecord(): boolean;

			/**
			 * Gets the record item inserted into the jukebox.
			 */
			getRecord(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the record being played. The jukebox will start playing automatically.
			 */
			setRecord(record: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Checks if the jukebox is playing a record.
			 */
			isPlaying(): boolean;

			/**
			 * Starts the jukebox playing if there is a record.
			 */
			startPlaying(): boolean;

			/**
			 * Stops the jukebox playing without ejecting the record.
			 */
			stopPlaying(): void;

			/**
			 * Stops the jukebox playing and ejects the current record.
			 * 
			 * If the block represented by this state is no longer a jukebox, this will
			 * do nothing and return false.
			 */
			eject(): boolean;

			/**
			 * Description copied from interface:Â InventoryHolder
			 */
			getInventory(): org.bukkit.inventory.JukeboxInventory;

			getSnapshotInventory(): org.bukkit.inventory.JukeboxInventory;

		}> {}
		interface Lectern extends Modify<org.bukkit.block.TileState & org.bukkit.inventory.BlockInventoryHolder, {
			/**
			 * Get the current lectern page.
			 */
			getPage(): number;

			/**
			 * Set the current lectern page.
			 * If the page is greater than the number of pages of the book currently in
			 * the inventory, then behavior is undefined.
			 */
			setPage(page: number): void;

			/**
			 * Description copied from interface:Â InventoryHolder
			 */
			getInventory(): org.bukkit.inventory.Inventory;

			getSnapshotInventory(): org.bukkit.inventory.Inventory;

		}> {}
		interface Lidded {
			/**
			 * Sets the block's animated state to open and prevents it from being closed
			 * until close() is called.
			 */
			open(): void;

			/**
			 * Sets the block's animated state to closed even if a player is currently
			 * viewing this block.
			 */
			close(): void;

		}
		interface Lockable {
			/**
			 * Checks if the container has a valid (non empty) key.
			 */
			isLocked(): boolean;

			/**
			 * Gets the key needed to access the container.
			 */
			getLock(): string;

			/**
			 * Sets the key required to access this container. Set to null (or empty
			 * string) to remove key.
			 */
			setLock(key: (string | null)): void;

		}
		interface PistonMoveReaction {
			getId(): number;

		}
		namespace PistonMoveReaction {
			/**
			 * Indicates that the block can be pushed or pulled.
			 */
			const MOVE: org.bukkit.block.PistonMoveReaction;

			/**
			 * Indicates the block is fragile and will break if pushed on.
			 */
			const BREAK: org.bukkit.block.PistonMoveReaction;

			/**
			 * Indicates that the block will resist being pushed or pulled.
			 */
			const BLOCK: org.bukkit.block.PistonMoveReaction;

			/**
			 * Indicates that the entity will ignore any interaction(s) with
			 * pistons.
			 * 
			 * Blocks should use BLOCK.
			 */
			const IGNORE: org.bukkit.block.PistonMoveReaction;

			/**
			 * Indicates that the block can only be pushed by pistons, not pulled.
			 */
			const PUSH_ONLY: org.bukkit.block.PistonMoveReaction;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.block.PistonMoveReaction;

			function getById(id: number): (org.bukkit.block.PistonMoveReaction | null);

		}
		interface SculkCatalyst extends Modify<org.bukkit.block.TileState, {
			/**
			 * Causes a new sculk bloom, as if an entity just died around this catalyst.
			 * 
			 * Typically, charges should be set to the exp reward of a mob
			 * (EntityDeathEvent.getDroppedExp()), which is usually
			 * 3-5 for animals, and 5-10 for the average mob (up to 50 for
			 * wither skeletons). Roughly speaking, for each charge, 1 more
			 * sculk block will be placed.
			 * 
			 * If charges > 1000, multiple cursors will be spawned in the
			 * block.
			 */
			bloom(block: org.bukkit.block.Block, charges: number): void;

		}> {}
		interface SculkSensor extends Modify<org.bukkit.block.TileState, {
			/**
			 * Gets the last vibration frequency of this sensor.
			 * Different activities detected by the sensor will produce different
			 * frequencies and dictate the output of connected comparators.
			 */
			getLastVibrationFrequency(): number;

			/**
			 * Sets the last vibration frequency of this sensor.
			 * Different activities detected by the sensor will produce different
			 * frequencies and dictate the output of connected comparators.
			 */
			setLastVibrationFrequency(lastVibrationFrequency: number): void;

		}> {}
		interface SculkShrieker extends Modify<org.bukkit.block.TileState, {
			/**
			 * Gets the most recent warning level of this block.
			 * When the warning level reaches 4, the shrieker will attempt to spawn a
			 * Warden.
			 */
			getWarningLevel(): number;

			/**
			 * Sets the most recent warning level of this block.
			 * When the warning level reaches 4, the shrieker will attempt to spawn a
			 * Warden.
			 */
			setWarningLevel(level: number): void;

			/**
			 * Simulates a player causing a vibration.
			 */
			tryShriek(player: (org.bukkit.entity.Player | null)): void;

		}> {}
		interface ShulkerBox extends Modify<org.bukkit.block.Container & org.bukkit.loot.Lootable & org.bukkit.block.Lidded, {
			/**
			 * Get the DyeColor corresponding to this ShulkerBox
			 */
			getColor(): (org.bukkit.DyeColor | null);

		}> {}
		interface Sign extends Modify<org.bukkit.block.TileState & org.bukkit.material.Colorable, {
			/**
			 * Gets the line of text at the specified index.
			 * 
			 * For example, getLine(0) will return the first line of text on the Side.FRONT.
			 */
			getLine(index: number): string;

			/**
			 * Sets the line of text at the specified index.
			 * 
			 * For example, setLine(0, "Line One") will set the first line of text to
			 * "Line One".
			 */
			setLine(index: number, line: string): void;

			/**
			 * Marks whether this sign can be edited by players.
			 */
			isEditable(): boolean;

			/**
			 * Marks whether this sign can be edited by players.
			 */
			setEditable(editable: boolean): void;

			/**
			 * Gets whether or not this sign has been waxed. If a sign has been waxed, it
			 * cannot be edited by a player.
			 */
			isWaxed(): boolean;

			/**
			 * Sets whether or not this sign has been waxed. If a sign has been waxed, it
			 * cannot be edited by a player.
			 */
			setWaxed(waxed: boolean): void;

			/**
			 * Gets whether this sign has glowing text. Only affects the Side.FRONT.
			 */
			isGlowingText(): boolean;

			/**
			 * Sets whether this sign has glowing text. Only affects the Side.FRONT.
			 */
			setGlowingText(glowing: boolean): void;

			/**
			 * Gets the color of this object.
			 * 
			 * This may be null to represent the default color of an object, if the
			 * object has a special default color (e.g Shulkers).
			 */
			getColor(): org.bukkit.DyeColor;

			/**
			 * Sets the color of this object to the specified DyeColor.
			 * 
			 * This may be null to represent the default color of an object, if the
			 * object has a special default color (e.g Shulkers).
			 */
			setColor(color: org.bukkit.DyeColor): void;

			/**
			 * Return the side of the sign.
			 */
			getSide(side: org.bukkit.block.sign.Side): org.bukkit.block.sign.SignSide;

			/**
			 * Gets the side of this sign the given player is currently standing on.
			 */
			getTargetSide(player: org.bukkit.entity.Player): org.bukkit.block.sign.SignSide;

			/**
			 * Gets the player that is currently allowed to edit this sign.
			 * Edits from other players will be rejected if this value is not null.
			 */
			getAllowedEditor(): (org.bukkit.entity.Player | null);

		}> {}
		interface Skull extends Modify<org.bukkit.block.TileState, {
			/**
			 * Checks to see if the skull has an owner
			 */
			hasOwner(): boolean;

			/**
			 * Gets the owner of the skull, if one exists
			 */
			getOwner(): (string | null);

			/**
			 * Sets the owner of the skull
			 * 
			 * Involves a potentially blocking web request to acquire the profile data for
			 * the provided name.
			 */
			setOwner(name: (string | null)): boolean;

			/**
			 * Get the player which owns the skull. This player may appear as the
			 * texture depending on skull type.
			 */
			getOwningPlayer(): (org.bukkit.OfflinePlayer | null);

			/**
			 * Set the player which owns the skull. This player may appear as the
			 * texture depending on skull type.
			 */
			setOwningPlayer(player: org.bukkit.OfflinePlayer): void;

			/**
			 * Gets the profile of the player who owns the skull. This player profile
			 * may appear as the texture depending on skull type.
			 */
			getOwnerProfile(): (org.bukkit.profile.PlayerProfile | null);

			/**
			 * Sets the profile of the player who owns the skull. This player profile
			 * may appear as the texture depending on skull type.
			 * 
			 * The profile must contain both a unique id and a skin texture. If either
			 * of these is missing, the profile must contain a name by which the server
			 * will then attempt to look up the unique id and skin texture.
			 */
			setOwnerProfile(profile: (org.bukkit.profile.PlayerProfile | null)): void;

			/**
			 * Gets the sound to play if the skull is placed on a note block.
			 * 
			 * Note: This only works for player heads. For other heads,
			 * see Instrument.
			 */
			getNoteBlockSound(): (org.bukkit.NamespacedKey | null);

			/**
			 * Sets the sound to play if the skull is placed on a note block.
			 * 
			 * Note: This only works for player heads. For other heads,
			 * see Instrument.
			 */
			setNoteBlockSound(noteBlockSound: (org.bukkit.NamespacedKey | null)): void;

			/**
			 * Gets the rotation of the skull in the world (or facing direction if this
			 * is a wall mounted skull).
			 */
			getRotation(): org.bukkit.block.BlockFace;

			/**
			 * Sets the rotation of the skull in the world (or facing direction if this
			 * is a wall mounted skull).
			 */
			setRotation(rotation: org.bukkit.block.BlockFace): void;

			/**
			 * Gets the type of skull
			 */
			getSkullType(): org.bukkit.SkullType;

			/**
			 * Sets the type of skull
			 */
			setSkullType(skullType: org.bukkit.SkullType): void;

		}> {}
		interface Smoker extends Modify<org.bukkit.block.Furnace, {}> {}
		interface Structure extends Modify<org.bukkit.block.TileState, {
			/**
			 * The name of this structure.
			 */
			getStructureName(): string;

			/**
			 * Set the name of this structure. This is case-sensitive. The name of the
			 * structure in the UsageMode.SAVE structure block MUST match the
			 * name within the UsageMode.CORNER block or the size calculation
			 * will fail.
			 */
			setStructureName(name: string): void;

			/**
			 * Get the name of who created this structure.
			 */
			getAuthor(): string;

			/**
			 * Set the name of whoever created this structure.
			 */
			setAuthor(author: string): void;

			/**
			 * Set the name of whoever created this structure using a
			 * LivingEntity.
			 */
			setAuthor(livingEntity: org.bukkit.entity.LivingEntity): void;

			/**
			 * The relative position of the structure outline based on the position of
			 * the structure block. Maximum allowed distance is 48 blocks in any
			 * direction.
			 */
			getRelativePosition(): org.bukkit.util.BlockVector;

			/**
			 * Set the relative position from the structure block. Maximum allowed
			 * distance is 48 blocks in any direction.
			 */
			setRelativePosition(vector: org.bukkit.util.BlockVector): void;

			/**
			 * The distance to the opposite corner of this structure. The maximum
			 * structure size is 48x48x48. When a structure has successfully been
			 * calculated (i.e. it is within the maximum allowed distance) a white
			 * border surrounds the structure.
			 */
			getStructureSize(): org.bukkit.util.BlockVector;

			/**
			 * Set the maximum size of this structure from the origin point. Maximum
			 * allowed size is 48x48x48.
			 */
			setStructureSize(vector: org.bukkit.util.BlockVector): void;

			/**
			 * Sets the mirroring of the structure.
			 */
			setMirror(mirror: org.bukkit.block.structure.Mirror): void;

			/**
			 * How this structure is mirrored.
			 */
			getMirror(): org.bukkit.block.structure.Mirror;

			/**
			 * Set how this structure is rotated.
			 */
			setRotation(rotation: org.bukkit.block.structure.StructureRotation): void;

			/**
			 * Get how this structure is rotated.
			 */
			getRotation(): org.bukkit.block.structure.StructureRotation;

			/**
			 * Set the UsageMode of this structure block.
			 */
			setUsageMode(mode: org.bukkit.block.structure.UsageMode): void;

			/**
			 * Get the UsageMode of this structure block.
			 */
			getUsageMode(): org.bukkit.block.structure.UsageMode;

			/**
			 * While in UsageMode.SAVE mode, this will ignore any entities when
			 * saving the structure.
			 * 
			 * While in UsageMode.LOAD mode this will ignore any entities that
			 * were saved to file.
			 */
			setIgnoreEntities(ignoreEntities: boolean): void;

			/**
			 * Get if this structure block should ignore entities.
			 */
			isIgnoreEntities(): boolean;

			/**
			 * Set if the structure outline should show air blocks.
			 */
			setShowAir(showAir: boolean): void;

			/**
			 * Check if this structure block is currently showing all air blocks
			 */
			isShowAir(): boolean;

			/**
			 * Set if this structure box should show the bounding box.
			 */
			setBoundingBoxVisible(showBoundingBox: boolean): void;

			/**
			 * Get if this structure block is currently showing the bounding box.
			 */
			isBoundingBoxVisible(): boolean;

			/**
			 * Set the integrity of the structure. Integrity must be between 0.0 and 1.0
			 * Lower integrity values will result in more blocks being removed when
			 * loading a structure. Integrity and getSeed() are used together
			 * to determine which blocks are randomly removed to mimic "decay."
			 */
			setIntegrity(integrity: number): void;

			/**
			 * Get the integrity of this structure.
			 */
			getIntegrity(): number;

			/**
			 * The seed used to determine which blocks will be removed upon loading.
			 * getIntegrity() and seed are used together to determine which
			 * blocks are randomly removed to mimic "decay."
			 */
			setSeed(seed: number): void;

			/**
			 * The seed used to determine how many blocks are removed upon loading of
			 * this structure.
			 */
			getSeed(): number;

			/**
			 * Only applicable while in UsageMode.DATA. Metadata are specific
			 * functions that can be applied to the structure location. Consult the
			 * Minecraft
			 * wiki for more information.
			 */
			setMetadata(metadata: string): void;

			/**
			 * Get the metadata function this structure block will perform when
			 * activated. Consult the
			 * Minecraft
			 * Wiki for more information.
			 */
			getMetadata(): string;

		}> {}
		interface SuspiciousSand extends Modify<org.bukkit.block.BrushableBlock, {}> {}
		interface TileState extends Modify<org.bukkit.block.BlockState & org.bukkit.persistence.PersistentDataHolder, {
			/**
			 * Returns a custom tag container capable of storing tags on the object.
			 * Note that the tags stored on this container are all stored under their
			 * own custom namespace therefore modifying default tags using this
			 * PersistentDataHolder is impossible.
			 * 
			 * This PersistentDataHolder is only linked to the snapshot instance
			 * stored by the BlockState.
			 * When storing changes on the PersistentDataHolder, the updated
			 * content will only be applied to the actual tile entity after one of the
			 * BlockState.update() methods is called.
			 */
			getPersistentDataContainer(): org.bukkit.persistence.PersistentDataContainer;

		}> {}
		interface TrialSpawner extends Modify<org.bukkit.block.TileState, {}> {}
		interface Vault extends Modify<org.bukkit.block.TileState, {}> {}
	}
	namespace org.bukkit.boss {
		interface BarColor {}
		namespace BarColor {
			const PINK: org.bukkit.boss.BarColor;

			const BLUE: org.bukkit.boss.BarColor;

			const RED: org.bukkit.boss.BarColor;

			const GREEN: org.bukkit.boss.BarColor;

			const YELLOW: org.bukkit.boss.BarColor;

			const PURPLE: org.bukkit.boss.BarColor;

			const WHITE: org.bukkit.boss.BarColor;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.boss.BarColor;

		}
		interface BarFlag {}
		namespace BarFlag {
			/**
			 * Darkens the sky like during fighting a wither.
			 */
			const DARKEN_SKY: org.bukkit.boss.BarFlag;

			/**
			 * Tells the client to play the Ender Dragon boss music.
			 */
			const PLAY_BOSS_MUSIC: org.bukkit.boss.BarFlag;

			/**
			 * Creates fog around the world.
			 */
			const CREATE_FOG: org.bukkit.boss.BarFlag;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.boss.BarFlag;

		}
		interface BarStyle {}
		namespace BarStyle {
			/**
			 * Makes the boss bar solid (no segments)
			 */
			const SOLID: org.bukkit.boss.BarStyle;

			/**
			 * Splits the boss bar into 6 segments
			 */
			const SEGMENTED_6: org.bukkit.boss.BarStyle;

			/**
			 * Splits the boss bar into 10 segments
			 */
			const SEGMENTED_10: org.bukkit.boss.BarStyle;

			/**
			 * Splits the boss bar into 12 segments
			 */
			const SEGMENTED_12: org.bukkit.boss.BarStyle;

			/**
			 * Splits the boss bar into 20 segments
			 */
			const SEGMENTED_20: org.bukkit.boss.BarStyle;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.boss.BarStyle;

		}
		interface BossBar {
			/**
			 * Returns the title of this boss bar
			 */
			getTitle(): string;

			/**
			 * Sets the title of this boss bar
			 */
			setTitle(title: (string | null)): void;

			/**
			 * Returns the color of this boss bar
			 */
			getColor(): org.bukkit.boss.BarColor;

			/**
			 * Sets the color of this boss bar.
			 */
			setColor(color: org.bukkit.boss.BarColor): void;

			/**
			 * Returns the style of this boss bar
			 */
			getStyle(): org.bukkit.boss.BarStyle;

			/**
			 * Sets the bar style of this boss bar
			 */
			setStyle(style: org.bukkit.boss.BarStyle): void;

			/**
			 * Remove an existing flag on this boss bar
			 */
			removeFlag(flag: org.bukkit.boss.BarFlag): void;

			/**
			 * Add an optional flag to this boss bar
			 */
			addFlag(flag: org.bukkit.boss.BarFlag): void;

			/**
			 * Returns whether this boss bar as the passed flag set
			 */
			hasFlag(flag: org.bukkit.boss.BarFlag): boolean;

			/**
			 * Sets the progress of the bar. Values should be between 0.0 (empty) and
			 * 1.0 (full)
			 */
			setProgress(progress: number): void;

			/**
			 * Returns the progress of the bar between 0.0 and 1.0
			 */
			getProgress(): number;

			/**
			 * Adds the player to this boss bar causing it to display on their screen.
			 */
			addPlayer(player: org.bukkit.entity.Player): void;

			/**
			 * Removes the player from this boss bar causing it to be removed from their
			 * screen.
			 */
			removePlayer(player: org.bukkit.entity.Player): void;

			/**
			 * Removes all players from this boss bar
			 */
			removeAll(): void;

			/**
			 * Returns all players viewing this boss bar
			 */
			getPlayers(): globalThis.java.util.List<org.bukkit.entity.Player>;

			/**
			 * Set if the boss bar is displayed to attached players.
			 */
			setVisible(visible: boolean): void;

			/**
			 * Return if the boss bar is displayed to attached players.
			 */
			isVisible(): boolean;

			/**
			 * Shows the previously hidden boss bar to all attached players
			 */
			show(): void;

			/**
			 * Hides this boss bar from all attached players
			 */
			hide(): void;

		}
		interface DragonBattle {
			/**
			 * Get the EnderDragon active in this battle.
			 * 
			 * Will return null if the dragon has been slain.
			 */
			getEnderDragon(): (org.bukkit.entity.EnderDragon | null);

			/**
			 * Get the boss bar to be displayed for this dragon battle.
			 */
			getBossBar(): org.bukkit.boss.BossBar;

			/**
			 * Get the location of the end portal.
			 * 
			 * This location will be at the center of the base (bottom) of the portal.
			 */
			getEndPortalLocation(): (org.bukkit.Location | null);

			/**
			 * Generate the end portal.
			 */
			generateEndPortal(withPortals: boolean): boolean;

			/**
			 * Check whether the first dragon has been killed already.
			 */
			hasBeenPreviouslyKilled(): boolean;

			/**
			 * Sets whether the first dragon has been killed already.
			 * 
			 * If the dragon has not previously been killed, a portal will be generated
			 * when it is finally killed.
			 */
			setPreviouslyKilled(previouslyKilled: boolean): void;

			/**
			 * Try to initiate a respawn sequence to summon the dragon as though a player has
			 * placed 4 end crystals on the portal.
			 */
			initiateRespawn(): void;

			/**
			 * Try to initiate a respawn sequence to summon the dragon.
			 */
			initiateRespawn(enderCrystals: (globalThis.java.util.Collection<org.bukkit.entity.EnderCrystal> | null)): boolean;

			/**
			 * Get this battle's current respawn phase.
			 */
			getRespawnPhase(): org.bukkit.boss.DragonBattle.RespawnPhase;

			/**
			 * Set the dragon's respawn phase.
			 * 
			 * This method will is unsuccessful if a dragon respawn is not in progress.
			 */
			setRespawnPhase(phase: org.bukkit.boss.DragonBattle.RespawnPhase): boolean;

			/**
			 * Reset the crystals located on the obsidian pillars (remove their beam
			 * targets and invulnerability).
			 */
			resetCrystals(): void;

		}
		namespace DragonBattle {
			interface RespawnPhase {}
			namespace RespawnPhase {
				/**
				 * The crystal beams are directed upwards into the sky.
				 */
				const START: org.bukkit.boss.DragonBattle.RespawnPhase;

				/**
				 * The crystal beams remain directed upwards.
				 */
				const PREPARING_TO_SUMMON_PILLARS: org.bukkit.boss.DragonBattle.RespawnPhase;

				/**
				 * The crystal beams are directed from pillar to pillar, regenerating
				 * their crystals if necessary.
				 */
				const SUMMONING_PILLARS: org.bukkit.boss.DragonBattle.RespawnPhase;

				/**
				 * All crystals (including those from the pillars) are aimed towards the
				 * sky. Shortly thereafter summoning the dragon and destroying the
				 * crystals used to initiate the dragon's respawn.
				 */
				const SUMMONING_DRAGON: org.bukkit.boss.DragonBattle.RespawnPhase;

				/**
				 * The end of the respawn sequence. The dragon is actually summoned.
				 */
				const END: org.bukkit.boss.DragonBattle.RespawnPhase;

				/**
				 * No respawn is in progress.
				 */
				const NONE: org.bukkit.boss.DragonBattle.RespawnPhase;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.boss.DragonBattle.RespawnPhase;

			}
		}
		interface KeyedBossBar extends Modify<org.bukkit.boss.BossBar & org.bukkit.Keyed, {}> {}
	}
	namespace org.bukkit.generator {
		interface BiomeParameterPoint {
			/**
			 * Gets the temperature of the biome at this point that is suggested by the
			 * NoiseGenerator.
			 */
			getTemperature(): number;

			/**
			 * Gets the maximum temperature that is possible.
			 */
			getMaxTemperature(): number;

			/**
			 * Gets the minimum temperature that is possible.
			 */
			getMinTemperature(): number;

			/**
			 * Gets the humidity of the biome at this point that is suggested by the
			 * NoiseGenerator.
			 */
			getHumidity(): number;

			/**
			 * Gets the maximum humidity that is possible.
			 */
			getMaxHumidity(): number;

			/**
			 * Gets the minimum humidity that is possible.
			 */
			getMinHumidity(): number;

			/**
			 * Gets the continentalness of the biome at this point that is suggested by
			 * the NoiseGenerator.
			 */
			getContinentalness(): number;

			/**
			 * Gets the maximum continentalness that is possible.
			 */
			getMaxContinentalness(): number;

			/**
			 * Gets the minimum continentalness that is possible.
			 */
			getMinContinentalness(): number;

			/**
			 * Gets the erosion of the biome at this point that is suggested by the
			 * NoiseGenerator.
			 */
			getErosion(): number;

			/**
			 * Gets the maximum erosion that is possible.
			 */
			getMaxErosion(): number;

			/**
			 * Gets the minimum erosion that is possible.
			 */
			getMinErosion(): number;

			/**
			 * Gets the depth of the biome at this point that is suggested by the
			 * NoiseGenerator.
			 */
			getDepth(): number;

			/**
			 * Gets the maximum depth that is possible.
			 */
			getMaxDepth(): number;

			/**
			 * Gets the minimum depth that is possible.
			 */
			getMinDepth(): number;

			/**
			 * Gets the weirdness of the biome at this point that is suggested by the
			 * NoiseGenerator.
			 */
			getWeirdness(): number;

			/**
			 * Gets the maximum weirdness that is possible.
			 */
			getMaxWeirdness(): number;

			/**
			 * Gets the minimum weirdness that is possible.
			 */
			getMinWeirdness(): number;

		}
		interface BiomeProvider {
			/**
			 * Return the Biome which should be present at the provided location.
			 * 
			 * Notes:
			 * 
			 * This method must be completely thread safe and able to handle
			 * multiple concurrent callers.
			 * 
			 * This method should only return biomes which are present in the list
			 * returned by getBiomes(WorldInfo)
			 * 
			 * This method should never return Biome.CUSTOM.
			 */
			getBiome(worldInfo: org.bukkit.generator.WorldInfo, x: number, y: number, z: number): org.bukkit.block.Biome;

			/**
			 * Return the Biome which should be present at the provided location.
			 * 
			 * Notes:
			 * 
			 * This method must be completely thread safe and able to handle
			 * multiple concurrent callers.
			 * 
			 * This method should only return biomes which are present in the list
			 * returned by getBiomes(WorldInfo)
			 * 
			 * This method should never return Biome.CUSTOM.
			 * Only this method is called if both this and
			 * getBiome(WorldInfo, int, int, int) are overridden.
			 */
			getBiome(worldInfo: org.bukkit.generator.WorldInfo, x: number, y: number, z: number, biomeParameterPoint: org.bukkit.generator.BiomeParameterPoint): org.bukkit.block.Biome;

			/**
			 * Returns a list with every biome the BiomeProvider will use for
			 * the given world.
			 * 
			 * Notes:
			 * 
			 * This method only gets called once, when the world is loaded. Returning
			 * another list or modifying the values from the initial returned list later
			 * one, are not respected.
			 * 
			 * This method should never return a list which contains
			 * Biome.CUSTOM.
			 */
			getBiomes(worldInfo: org.bukkit.generator.WorldInfo): globalThis.java.util.List<org.bukkit.block.Biome>;

		}
		class BiomeProvider {
			constructor();

		}
		interface BlockPopulator {
			/**
			 * Populates an area of blocks at or around the given chunk.
			 * 
			 * The chunks on each side of the specified chunk must already exist; that
			 * is, there must be one north, east, south and west of the specified
			 * chunk. The "corner" chunks may not exist, in which scenario the
			 * populator should record any changes required for those chunks and
			 * perform the changes when they are ready.
			 */
			populate(world: org.bukkit.World, random: globalThis.java.util.Random, source: org.bukkit.Chunk): void;

			/**
			 * Populates an area of blocks at or around the given chunk.
			 * 
			 * Notes:
			 * 
			 * This method should never attempt to get the Chunk at the passed
			 * coordinates, as doing so may cause an infinite loop
			 * 
			 * This method should never modify a LimitedRegion at a later
			 * point of time.
			 * 
			 * This method must be completely thread safe and able to handle
			 * multiple concurrent callers.
			 * 
			 * No physics are applied, whether or not it is set to true in
			 * BlockState.update(boolean, boolean)
			 * 
			 * Only use the BlockState returned by
			 * LimitedRegion,
			 * never use methods from a World to modify the chunk.
			 */
			populate(worldInfo: org.bukkit.generator.WorldInfo, random: globalThis.java.util.Random, chunkX: number, chunkZ: number, limitedRegion: org.bukkit.generator.LimitedRegion): void;

		}
		class BlockPopulator {
			constructor();

		}
		interface ChunkGenerator {
			/**
			 * Shapes the Chunk noise for the given coordinates.
			 * 
			 * Notes:
			 * 
			 * This method should never attempt to get the Chunk at the passed
			 * coordinates, as doing so may cause an infinite loop.
			 * 
			 * This method should never modify the ChunkGenerator.ChunkData at a later
			 * point of time.
			 * 
			 * The Y-coordinate range should never be hardcoded, to get the
			 * Y-coordinate range use the methods ChunkGenerator.ChunkData.getMinHeight() and
			 * ChunkGenerator.ChunkData.getMaxHeight().
			 * 
			 * If shouldGenerateNoise() is set to true, the given
			 * ChunkGenerator.ChunkData contains already the Vanilla noise generation.
			 */
			generateNoise(worldInfo: org.bukkit.generator.WorldInfo, random: globalThis.java.util.Random, chunkX: number, chunkZ: number, chunkData: org.bukkit.generator.ChunkGenerator.ChunkData): void;

			/**
			 * Shapes the Chunk surface for the given coordinates.
			 * 
			 * Notes:
			 * 
			 * This method should never attempt to get the Chunk at the passed
			 * coordinates, as doing so may cause an infinite loop.
			 * 
			 * This method should never modify the ChunkGenerator.ChunkData at a later
			 * point of time.
			 * 
			 * The Y-coordinate range should never be hardcoded, to get the
			 * Y-coordinate range use the methods ChunkGenerator.ChunkData.getMinHeight() and
			 * ChunkGenerator.ChunkData.getMaxHeight().
			 * 
			 * If shouldGenerateSurface() is set to true, the given
			 * ChunkGenerator.ChunkData contains already the Vanilla surface generation.
			 */
			generateSurface(worldInfo: org.bukkit.generator.WorldInfo, random: globalThis.java.util.Random, chunkX: number, chunkZ: number, chunkData: org.bukkit.generator.ChunkGenerator.ChunkData): void;

			/**
			 * Shapes the Chunk bedrock layer for the given coordinates.
			 * 
			 * Notes:
			 * 
			 * This method should never attempt to get the Chunk at the passed
			 * coordinates, as doing so may cause an infinite loop.
			 * 
			 * This method should never modify the ChunkGenerator.ChunkData at a later
			 * point of time.
			 * 
			 * The Y-coordinate range should never be hardcoded, to get the
			 * Y-coordinate range use the methods ChunkGenerator.ChunkData.getMinHeight() and
			 * ChunkGenerator.ChunkData.getMaxHeight().
			 * 
			 */
			generateBedrock(worldInfo: org.bukkit.generator.WorldInfo, random: globalThis.java.util.Random, chunkX: number, chunkZ: number, chunkData: org.bukkit.generator.ChunkGenerator.ChunkData): void;

			/**
			 * Shapes the Chunk caves for the given coordinates.
			 * 
			 * Notes:
			 * 
			 * This method should never attempt to get the Chunk at the passed
			 * coordinates, as doing so may cause an infinite loop.
			 * 
			 * This method should never modify the ChunkGenerator.ChunkData at a later
			 * point of time.
			 * 
			 * The Y-coordinate range should never be hardcoded, to get the
			 * Y-coordinate range use the methods ChunkGenerator.ChunkData.getMinHeight() and
			 * ChunkGenerator.ChunkData.getMaxHeight().
			 * 
			 * If shouldGenerateCaves() is set to true, the given
			 * ChunkGenerator.ChunkData contains already the Vanilla cave generation.
			 */
			generateCaves(worldInfo: org.bukkit.generator.WorldInfo, random: globalThis.java.util.Random, chunkX: number, chunkZ: number, chunkData: org.bukkit.generator.ChunkGenerator.ChunkData): void;

			/**
			 * Gets called when no BiomeProvider is set in
			 * WorldCreator or via the server configuration files. It
			 * is therefore possible that one plugin can provide the Biomes and another
			 * one the generation.
			 * 
			 * Notes:
			 * 
			 * If null is returned, than Vanilla biomes are used.
			 * 
			 * This method only gets called once when the world is loaded. Returning
			 * another BiomeProvider later one is not respected.
			 */
			getDefaultBiomeProvider(worldInfo: org.bukkit.generator.WorldInfo): (org.bukkit.generator.BiomeProvider | null);

			/**
			 * This method is similar to
			 * World.getHighestBlockAt(int, int, HeightMap). With the difference
			 * being, that the highest y coordinate should be the block before any
			 * surface, bedrock, caves or decoration is applied. Or in other words the
			 * highest block when only the noise is present at the chunk.
			 * 
			 * Notes:
			 * 
			 * When this method is not overridden, the Vanilla base height is used.
			 * 
			 * This method should never attempt to get the Chunk at the passed
			 * coordinates, or use the method
			 * World.getHighestBlockAt(int, int, HeightMap), as doing so may
			 * cause an infinite loop.
			 */
			getBaseHeight(worldInfo: org.bukkit.generator.WorldInfo, random: globalThis.java.util.Random, x: number, z: number, heightMap: org.bukkit.HeightMap): number;

			/**
			 * Shapes the chunk for the given coordinates.
			 * This method must return a ChunkData.
			 * 
			 * Notes:
			 * 
			 * This method should never attempt to get the Chunk at
			 * the passed coordinates, as doing so may cause an infinite loop
			 * 
			 * This method should never modify a ChunkData after it has
			 * been returned.
			 * 
			 * This method must return a ChunkData returned by createChunkData(org.bukkit.World)
			 */
			generateChunkData(world: org.bukkit.World, random: globalThis.java.util.Random, x: number, z: number, biome: org.bukkit.generator.ChunkGenerator.BiomeGrid): org.bukkit.generator.ChunkGenerator.ChunkData;

			/**
			 * Tests if the specified location is valid for a natural spawn position
			 */
			canSpawn(world: org.bukkit.World, x: number, z: number): boolean;

			/**
			 * Gets a list of default BlockPopulators to apply to a given
			 * world
			 */
			getDefaultPopulators(world: org.bukkit.World): globalThis.java.util.List<org.bukkit.generator.BlockPopulator>;

			/**
			 * Gets a fixed spawn location to use for a given world.
			 * 
			 * A null value is returned if a world should not use a fixed spawn point,
			 * and will instead attempt to find one randomly.
			 */
			getFixedSpawnLocation(world: org.bukkit.World, random: globalThis.java.util.Random): (org.bukkit.Location | null);

			/**
			 * Gets if this ChunkGenerator is parallel capable.
			 * See ChunkGenerator for more information.
			 */
			isParallelCapable(): boolean;

			/**
			 * Gets if the server should generate Vanilla noise.
			 * 
			 * The Vanilla noise is generated before
			 * generateNoise(WorldInfo, Random, int, int, ChunkData) is called.
			 * 
			 * This is method is not called (and has therefore no effect), if
			 * shouldGenerateNoise(WorldInfo, Random, int, int) is overridden.
			 */
			shouldGenerateNoise(): boolean;

			/**
			 * Gets if the server should generate Vanilla noise.
			 * 
			 * The Vanilla noise is generated before
			 * generateNoise(WorldInfo, Random, int, int, ChunkData) is called.
			 * 
			 * Only this method is called if both this and
			 * shouldGenerateNoise() are overridden.
			 */
			shouldGenerateNoise(worldInfo: org.bukkit.generator.WorldInfo, random: globalThis.java.util.Random, chunkX: number, chunkZ: number): boolean;

			/**
			 * Gets if the server should generate Vanilla surface.
			 * 
			 * The Vanilla surface is generated before
			 * generateSurface(WorldInfo, Random, int, int, ChunkData) is
			 * called.
			 * 
			 * This is method is not called (and has therefore no effect), if
			 * shouldGenerateSurface(WorldInfo, Random, int, int) is overridden.
			 */
			shouldGenerateSurface(): boolean;

			/**
			 * Gets if the server should generate Vanilla surface.
			 * 
			 * The Vanilla surface is generated before
			 * generateSurface(WorldInfo, Random, int, int, ChunkData) is
			 * called.
			 * 
			 * Only this method is called if both this and
			 * shouldGenerateSurface() are overridden.
			 */
			shouldGenerateSurface(worldInfo: org.bukkit.generator.WorldInfo, random: globalThis.java.util.Random, chunkX: number, chunkZ: number): boolean;

			/**
			 * Gets if the server should generate Vanilla bedrock.
			 * 
			 * The Vanilla bedrock is generated before
			 * generateBedrock(WorldInfo, Random, int, int, ChunkData) is
			 * called.
			 */
			shouldGenerateBedrock(): boolean;

			/**
			 * Gets if the server should generate Vanilla caves.
			 * 
			 * The Vanilla caves are generated before
			 * generateCaves(WorldInfo, Random, int, int, ChunkData) is called.
			 * 
			 * This is method is not called (and has therefore no effect), if
			 * shouldGenerateCaves(WorldInfo, Random, int, int) is overridden.
			 */
			shouldGenerateCaves(): boolean;

			/**
			 * Gets if the server should generate Vanilla caves.
			 * 
			 * The Vanilla caves are generated before
			 * generateCaves(WorldInfo, Random, int, int, ChunkData) is called.
			 * 
			 * Only this method is called if both this and
			 * shouldGenerateCaves() are overridden.
			 */
			shouldGenerateCaves(worldInfo: org.bukkit.generator.WorldInfo, random: globalThis.java.util.Random, chunkX: number, chunkZ: number): boolean;

			/**
			 * Gets if the server should generate Vanilla decorations after this
			 * ChunkGenerator.
			 * 
			 * The Vanilla decoration are generated before any
			 * BlockPopulator are called.
			 * 
			 * This is method is not called (and has therefore no effect), if
			 * shouldGenerateDecorations(WorldInfo, Random, int, int) is overridden.
			 */
			shouldGenerateDecorations(): boolean;

			/**
			 * Gets if the server should generate Vanilla decorations after this
			 * ChunkGenerator.
			 * 
			 * The Vanilla decoration are generated before any
			 * BlockPopulator are called.
			 * 
			 * Only this method is called if both this and
			 * shouldGenerateDecorations() are overridden.
			 */
			shouldGenerateDecorations(worldInfo: org.bukkit.generator.WorldInfo, random: globalThis.java.util.Random, chunkX: number, chunkZ: number): boolean;

			/**
			 * Gets if the server should generate Vanilla mobs after this
			 * ChunkGenerator.
			 * 
			 * This is method is not called (and has therefore no effect), if
			 * shouldGenerateMobs(WorldInfo, Random, int, int) is overridden.
			 */
			shouldGenerateMobs(): boolean;

			/**
			 * Gets if the server should generate Vanilla mobs after this
			 * ChunkGenerator.
			 * 
			 * Only this method is called if both this and
			 * shouldGenerateMobs() are overridden.
			 */
			shouldGenerateMobs(worldInfo: org.bukkit.generator.WorldInfo, random: globalThis.java.util.Random, chunkX: number, chunkZ: number): boolean;

			/**
			 * Gets if the server should generate Vanilla structures after this
			 * ChunkGenerator.
			 * 
			 * This is method is not called (and has therefore no effect), if
			 * shouldGenerateStructures(WorldInfo, Random, int, int) is overridden.
			 */
			shouldGenerateStructures(): boolean;

			/**
			 * Gets if the server should generate Vanilla structures after this
			 * ChunkGenerator.
			 * 
			 * Only this method is called if both this and
			 * shouldGenerateStructures() are overridden.
			 */
			shouldGenerateStructures(worldInfo: org.bukkit.generator.WorldInfo, random: globalThis.java.util.Random, chunkX: number, chunkZ: number): boolean;

		}
		class ChunkGenerator {
			constructor();

		}
		namespace ChunkGenerator {
			interface BiomeGrid {
				/**
				 * Get biome at x, z within chunk being generated
				 */
				getBiome(x: number, z: number): org.bukkit.block.Biome;

				/**
				 * Get biome at x, z within chunk being generated
				 */
				getBiome(x: number, y: number, z: number): org.bukkit.block.Biome;

				/**
				 * Set biome at x, z within chunk being generated
				 */
				setBiome(x: number, z: number, bio: org.bukkit.block.Biome): void;

				/**
				 * Set biome at x, z within chunk being generated
				 */
				setBiome(x: number, y: number, z: number, bio: org.bukkit.block.Biome): void;

			}
		}
		namespace ChunkGenerator {
			interface ChunkData {
				/**
				 * Get the minimum height for this ChunkData.
				 * 
				 * It is not guaranteed that this method will return the same value as
				 * WorldInfo.getMinHeight().
				 * 
				 * Setting blocks below this height will do nothing.
				 */
				getMinHeight(): number;

				/**
				 * Get the maximum height for this ChunkData.
				 * 
				 * It is not guaranteed that this method will return the same value as
				 * WorldInfo.getMaxHeight().
				 * 
				 * Setting blocks at or above this height will do nothing.
				 */
				getMaxHeight(): number;

				/**
				 * Get the biome at x, y, z within chunk being generated
				 */
				getBiome(x: number, y: number, z: number): org.bukkit.block.Biome;

				/**
				 * Set the block at x,y,z in the chunk data to material.
				 * Note: setting blocks outside the chunk's bounds does nothing.
				 */
				setBlock(x: number, y: number, z: number, material: org.bukkit.Material): void;

				/**
				 * Set the block at x,y,z in the chunk data to material.
				 * Setting blocks outside the chunk's bounds does nothing.
				 */
				setBlock(x: number, y: number, z: number, material: org.bukkit.material.MaterialData): void;

				/**
				 * Set the block at x,y,z in the chunk data to material.
				 * Setting blocks outside the chunk's bounds does nothing.
				 */
				setBlock(x: number, y: number, z: number, blockData: org.bukkit.block.data.BlockData): void;

				/**
				 * Set a region of this chunk from xMin, yMin, zMin (inclusive)
				 * to xMax, yMax, zMax (exclusive) to material.
				 * Setting blocks outside the chunk's bounds does nothing.
				 */
				setRegion(xMin: number, yMin: number, zMin: number, xMax: number, yMax: number, zMax: number, material: org.bukkit.Material): void;

				/**
				 * Set a region of this chunk from xMin, yMin, zMin (inclusive)
				 * to xMax, yMax, zMax (exclusive) to material.
				 * Setting blocks outside the chunk's bounds does nothing.
				 */
				setRegion(xMin: number, yMin: number, zMin: number, xMax: number, yMax: number, zMax: number, material: org.bukkit.material.MaterialData): void;

				/**
				 * Set a region of this chunk from xMin, yMin, zMin (inclusive) to xMax,
				 * yMax, zMax (exclusive) to material.
				 * Setting blocks outside the chunk's bounds does nothing.
				 */
				setRegion(xMin: number, yMin: number, zMin: number, xMax: number, yMax: number, zMax: number, blockData: org.bukkit.block.data.BlockData): void;

				/**
				 * Get the type of the block at x, y, z.
				 * Getting blocks outside the chunk's bounds returns air.
				 */
				getType(x: number, y: number, z: number): org.bukkit.Material;

				/**
				 * Get the type and data of the block at x, y, z.
				 * Getting blocks outside the chunk's bounds returns air.
				 */
				getTypeAndData(x: number, y: number, z: number): org.bukkit.material.MaterialData;

				/**
				 * Get the type and data of the block at x, y, z.
				 * Getting blocks outside the chunk's bounds returns air.
				 */
				getBlockData(x: number, y: number, z: number): org.bukkit.block.data.BlockData;

				/**
				 * Get the block data at x,y,z in the chunk data.
				 * Getting blocks outside the chunk's bounds returns 0.
				 */
				getData(x: number, y: number, z: number): any /* byte */;

			}
		}
		interface LimitedRegion extends Modify<org.bukkit.RegionAccessor, {
			/**
			 * Gets the buffer around the central chunk which is accessible.
			 * The returned value is in normal world coordinate scale.
			 * 
			 * For example: If the method returns 16 you have a working area of 48x48.
			 */
			getBuffer(): number;

			/**
			 * Checks if the given Location is in the region.
			 */
			isInRegion(location: org.bukkit.Location): boolean;

			/**
			 * Checks if the given coordinates are in the region.
			 */
			isInRegion(x: number, y: number, z: number): boolean;

			/**
			 * Gets a list of all tile entities in the limited region including the
			 * buffer zone.
			 */
			getTileEntities(): globalThis.java.util.List<org.bukkit.block.BlockState>;

		}> {}
		interface WorldInfo {
			/**
			 * Gets the unique name of this world
			 */
			getName(): string;

			/**
			 * Gets the Unique ID of this world
			 */
			getUID(): globalThis.java.util.UUID;

			/**
			 * Gets the World.Environment type of this world
			 */
			getEnvironment(): org.bukkit.World.Environment;

			/**
			 * Gets the Seed for this world.
			 */
			getSeed(): number;

			/**
			 * Gets the minimum height of this world.
			 * 
			 * If the min height is 0, there are only blocks from y=0.
			 */
			getMinHeight(): number;

			/**
			 * Gets the maximum height of this world.
			 * 
			 * If the max height is 100, there are only blocks from y=0 to y=99.
			 */
			getMaxHeight(): number;

		}
	}
	namespace org.bukkit.util {
		interface BiomeSearchResult {
			/**
			 * Return the biome which was found.
			 */
			getBiome(): org.bukkit.block.Biome;

			/**
			 * Return the location of the biome.
			 */
			getLocation(): org.bukkit.Location;

		}
		interface BlockIterator {
			/**
			 * Returns true if the iteration has more elements
			 */
			hasNext(): boolean;

			/**
			 * Returns the next Block in the trace
			 */
			next(): org.bukkit.block.Block;

			remove(): void;

		}
		class BlockIterator {
			/**
			 * Constructs the BlockIterator.
			 * 
			 * This considers all blocks as 1x1x1 in size.
			 */
			constructor(world: org.bukkit.World, start: org.bukkit.util.Vector, direction: org.bukkit.util.Vector, yOffset: number, maxDistance: number);

			/**
			 * Constructs the BlockIterator.
			 * 
			 * This considers all blocks as 1x1x1 in size.
			 */
			constructor(loc: org.bukkit.Location, yOffset: number, maxDistance: number);

			/**
			 * Constructs the BlockIterator.
			 * 
			 * This considers all blocks as 1x1x1 in size.
			 */
			constructor(loc: org.bukkit.Location, yOffset: number);

			/**
			 * Constructs the BlockIterator.
			 * 
			 * This considers all blocks as 1x1x1 in size.
			 */
			constructor(loc: org.bukkit.Location);

			/**
			 * Constructs the BlockIterator.
			 * 
			 * This considers all blocks as 1x1x1 in size.
			 */
			constructor(entity: org.bukkit.entity.LivingEntity, maxDistance: number);

			/**
			 * Constructs the BlockIterator.
			 * 
			 * This considers all blocks as 1x1x1 in size.
			 */
			constructor(entity: org.bukkit.entity.LivingEntity);

		}
		interface BlockTransformer {
			/**
			 * Transforms a block in a structure.
			 * NOTE: The usage of BlockData.createBlockState() can provide even
			 * more flexibility to return the exact block state you might want to
			 * return.
			 */
			transform(region: org.bukkit.generator.LimitedRegion, x: number, y: number, z: number, current: org.bukkit.block.BlockState, state: org.bukkit.util.BlockTransformer.TransformationState): org.bukkit.block.BlockState;

		}
		namespace BlockTransformer {
			interface TransformationState {
				/**
				 * Creates a clone of the original block state that a structure wanted
				 * to place and caches it for the current transformer.
				 */
				getOriginal(): org.bukkit.block.BlockState;

				/**
				 * Creates a clone of the block state that was at the location of the
				 * currently modified block at the start of the transformation process
				 * and caches it for the current transformer.
				 */
				getWorld(): org.bukkit.block.BlockState;

			}
		}
		interface BlockVector extends Modify<org.bukkit.util.Vector, {
			/**
			 * Checks if another object is equivalent.
			 */
			equals(obj: any): boolean;

			/**
			 * Returns a hash code for this vector.
			 */
			hashCode(): number;

			/**
			 * Get a new block vector.
			 */
			clone(): org.bukkit.util.BlockVector;

		}> {}
		class BlockVector {
			/**
			 * Construct the vector with all components as 0.
			 */
			constructor();

			/**
			 * Construct the vector with another vector.
			 */
			constructor(vec: org.bukkit.util.Vector);

			/**
			 * Construct the vector with provided integer components.
			 */
			constructor(x: number, y: number, z: number);

			/**
			 * Construct the vector with provided double components.
			 */
			constructor(x: number, y: number, z: number);

			/**
			 * Construct the vector with provided float components.
			 */
			constructor(x: number, y: number, z: number);

		}
		namespace BlockVector {
			function deserialize(args: globalThis.java.util.Map<string, any>): org.bukkit.util.BlockVector;

		}
		interface BoundingBox {
			/**
			 * Resizes this bounding box.
			 */
			resize(x1: number, y1: number, z1: number, x2: number, y2: number, z2: number): org.bukkit.util.BoundingBox;

			/**
			 * Gets the minimum x value.
			 */
			getMinX(): number;

			/**
			 * Gets the minimum y value.
			 */
			getMinY(): number;

			/**
			 * Gets the minimum z value.
			 */
			getMinZ(): number;

			/**
			 * Gets the minimum corner as vector.
			 */
			getMin(): org.bukkit.util.Vector;

			/**
			 * Gets the maximum x value.
			 */
			getMaxX(): number;

			/**
			 * Gets the maximum y value.
			 */
			getMaxY(): number;

			/**
			 * Gets the maximum z value.
			 */
			getMaxZ(): number;

			/**
			 * Gets the maximum corner as vector.
			 */
			getMax(): org.bukkit.util.Vector;

			/**
			 * Gets the width of the bounding box in the x direction.
			 */
			getWidthX(): number;

			/**
			 * Gets the width of the bounding box in the z direction.
			 */
			getWidthZ(): number;

			/**
			 * Gets the height of the bounding box.
			 */
			getHeight(): number;

			/**
			 * Gets the volume of the bounding box.
			 */
			getVolume(): number;

			/**
			 * Gets the x coordinate of the center of the bounding box.
			 */
			getCenterX(): number;

			/**
			 * Gets the y coordinate of the center of the bounding box.
			 */
			getCenterY(): number;

			/**
			 * Gets the z coordinate of the center of the bounding box.
			 */
			getCenterZ(): number;

			/**
			 * Gets the center of the bounding box.
			 */
			getCenter(): org.bukkit.util.Vector;

			/**
			 * Copies another bounding box.
			 */
			copy(other: org.bukkit.util.BoundingBox): org.bukkit.util.BoundingBox;

			/**
			 * Expands this bounding box by the given values in the corresponding
			 * directions.
			 * 
			 * Negative values will shrink the bounding box in the corresponding
			 * direction. Shrinking will be limited to the point where the affected
			 * opposite faces would meet if the they shrank at uniform speeds.
			 */
			expand(negativeX: number, negativeY: number, negativeZ: number, positiveX: number, positiveY: number, positiveZ: number): org.bukkit.util.BoundingBox;

			/**
			 * Expands this bounding box uniformly by the given values in both positive
			 * and negative directions.
			 * 
			 * Negative values will shrink the bounding box. Shrinking will be limited
			 * to the bounding box's current size.
			 */
			expand(x: number, y: number, z: number): org.bukkit.util.BoundingBox;

			/**
			 * Expands this bounding box uniformly by the given values in both positive
			 * and negative directions.
			 * 
			 * Negative values will shrink the bounding box. Shrinking will be limited
			 * to the bounding box's current size.
			 */
			expand(expansion: org.bukkit.util.Vector): org.bukkit.util.BoundingBox;

			/**
			 * Expands this bounding box uniformly by the given value in all directions.
			 * 
			 * A negative value will shrink the bounding box. Shrinking will be limited
			 * to the bounding box's current size.
			 */
			expand(expansion: number): org.bukkit.util.BoundingBox;

			/**
			 * Expands this bounding box in the specified direction.
			 * 
			 * The magnitude of the direction will scale the expansion. A negative
			 * expansion value will shrink the bounding box in this direction. Shrinking
			 * will be limited to the bounding box's current size.
			 */
			expand(dirX: number, dirY: number, dirZ: number, expansion: number): org.bukkit.util.BoundingBox;

			/**
			 * Expands this bounding box in the specified direction.
			 * 
			 * The magnitude of the direction will scale the expansion. A negative
			 * expansion value will shrink the bounding box in this direction. Shrinking
			 * will be limited to the bounding box's current size.
			 */
			expand(direction: org.bukkit.util.Vector, expansion: number): org.bukkit.util.BoundingBox;

			/**
			 * Expands this bounding box in the direction specified by the given block
			 * face.
			 * 
			 * A negative expansion value will shrink the bounding box in this
			 * direction. Shrinking will be limited to the bounding box's current size.
			 */
			expand(blockFace: org.bukkit.block.BlockFace, expansion: number): org.bukkit.util.BoundingBox;

			/**
			 * Expands this bounding box in the specified direction.
			 * 
			 * Negative values will expand the bounding box in the negative direction,
			 * positive values will expand it in the positive direction. The magnitudes
			 * of the direction components determine the corresponding amounts of
			 * expansion.
			 */
			expandDirectional(dirX: number, dirY: number, dirZ: number): org.bukkit.util.BoundingBox;

			/**
			 * Expands this bounding box in the specified direction.
			 * 
			 * Negative values will expand the bounding box in the negative direction,
			 * positive values will expand it in the positive direction. The magnitude
			 * of the direction vector determines the amount of expansion.
			 */
			expandDirectional(direction: org.bukkit.util.Vector): org.bukkit.util.BoundingBox;

			/**
			 * Expands this bounding box to contain (or border) the specified position.
			 */
			union(posX: number, posY: number, posZ: number): org.bukkit.util.BoundingBox;

			/**
			 * Expands this bounding box to contain (or border) the specified position.
			 */
			union(position: org.bukkit.util.Vector): org.bukkit.util.BoundingBox;

			/**
			 * Expands this bounding box to contain (or border) the specified position.
			 */
			union(position: org.bukkit.Location): org.bukkit.util.BoundingBox;

			/**
			 * Expands this bounding box to contain both this and the given bounding
			 * box.
			 */
			union(other: org.bukkit.util.BoundingBox): org.bukkit.util.BoundingBox;

			/**
			 * Resizes this bounding box to represent the intersection of this and the
			 * given bounding box.
			 */
			intersection(other: org.bukkit.util.BoundingBox): org.bukkit.util.BoundingBox;

			/**
			 * Shifts this bounding box by the given amounts.
			 */
			shift(shiftX: number, shiftY: number, shiftZ: number): org.bukkit.util.BoundingBox;

			/**
			 * Shifts this bounding box by the given amounts.
			 */
			shift(shift: org.bukkit.util.Vector): org.bukkit.util.BoundingBox;

			/**
			 * Shifts this bounding box by the given amounts.
			 */
			shift(shift: org.bukkit.Location): org.bukkit.util.BoundingBox;

			/**
			 * Checks if this bounding box overlaps with the given bounding box.
			 * 
			 * Bounding boxes that are only intersecting at the borders are not
			 * considered overlapping.
			 */
			overlaps(other: org.bukkit.util.BoundingBox): boolean;

			/**
			 * Checks if this bounding box overlaps with the bounding box that is
			 * defined by the given corners.
			 * 
			 * Bounding boxes that are only intersecting at the borders are not
			 * considered overlapping.
			 */
			overlaps(min: org.bukkit.util.Vector, max: org.bukkit.util.Vector): boolean;

			/**
			 * Checks if this bounding box contains the specified position.
			 * 
			 * Positions exactly on the minimum borders of the bounding box are
			 * considered to be inside the bounding box, while positions exactly on the
			 * maximum borders are considered to be outside. This allows bounding boxes
			 * to reside directly next to each other with positions always only residing
			 * in exactly one of them.
			 */
			contains(x: number, y: number, z: number): boolean;

			/**
			 * Checks if this bounding box contains the specified position.
			 * 
			 * Positions exactly on the minimum borders of the bounding box are
			 * considered to be inside the bounding box, while positions exactly on the
			 * maximum borders are considered to be outside. This allows bounding boxes
			 * to reside directly next to each other with positions always only residing
			 * in exactly one of them.
			 */
			contains(position: org.bukkit.util.Vector): boolean;

			/**
			 * Checks if this bounding box fully contains the given bounding box.
			 */
			contains(other: org.bukkit.util.BoundingBox): boolean;

			/**
			 * Checks if this bounding box fully contains the bounding box that is
			 * defined by the given corners.
			 */
			contains(min: org.bukkit.util.Vector, max: org.bukkit.util.Vector): boolean;

			/**
			 * Calculates the intersection of this bounding box with the specified line
			 * segment.
			 * 
			 * Intersections at edges and corners yield one of the affected block faces
			 * as hit result, but it is not defined which of them.
			 */
			rayTrace(start: org.bukkit.util.Vector, direction: org.bukkit.util.Vector, maxDistance: number): (org.bukkit.util.RayTraceResult | null);

			hashCode(): number;

			equals(obj: any): boolean;

			toString(): string;

			/**
			 * Creates a copy of this bounding box.
			 */
			clone(): org.bukkit.util.BoundingBox;

			/**
			 * Description copied from interface:Â ConfigurationSerializable
			 */
			serialize(): globalThis.java.util.Map<string, any>;

		}
		class BoundingBox {
			/**
			 * Creates a new (degenerate) bounding box with all corner coordinates at
			 * 0.
			 */
			constructor();

			/**
			 * Creates a new bounding box from the given corner coordinates.
			 */
			constructor(x1: number, y1: number, z1: number, x2: number, y2: number, z2: number);

		}
		namespace BoundingBox {
			/**
			 * Creates a new bounding box using the coordinates of the given vectors as
			 * corners.
			 */
			function of(corner1: org.bukkit.util.Vector, corner2: org.bukkit.util.Vector): org.bukkit.util.BoundingBox;

			/**
			 * Creates a new bounding box using the coordinates of the given locations
			 * as corners.
			 */
			function of(corner1: org.bukkit.Location, corner2: org.bukkit.Location): org.bukkit.util.BoundingBox;

			/**
			 * Creates a new bounding box using the coordinates of the given blocks as
			 * corners.
			 * 
			 * The bounding box will be sized to fully contain both blocks.
			 */
			function of(corner1: org.bukkit.block.Block, corner2: org.bukkit.block.Block): org.bukkit.util.BoundingBox;

			/**
			 * Creates a new 1x1x1 sized bounding box containing the given block.
			 */
			function of(block: org.bukkit.block.Block): org.bukkit.util.BoundingBox;

			/**
			 * Creates a new bounding box using the given center and extents.
			 */
			function of(center: org.bukkit.util.Vector, x: number, y: number, z: number): org.bukkit.util.BoundingBox;

			/**
			 * Creates a new bounding box using the given center and extents.
			 */
			function of(center: org.bukkit.Location, x: number, y: number, z: number): org.bukkit.util.BoundingBox;

			function deserialize(args: globalThis.java.util.Map<string, any>): org.bukkit.util.BoundingBox;

		}
		interface CachedServerIcon {}
		interface ChatPaginator {
		}
		class ChatPaginator {
			constructor();

		}
		namespace ChatPaginator {
			const GUARANTEED_NO_WRAP_CHAT_PAGE_WIDTH: number;

			const AVERAGE_CHAT_PAGE_WIDTH: number;

			const UNBOUNDED_PAGE_WIDTH: number;

			const OPEN_CHAT_PAGE_HEIGHT: number;

			const CLOSED_CHAT_PAGE_HEIGHT: number;

			const UNBOUNDED_PAGE_HEIGHT: number;

			/**
			 * Breaks a raw string up into pages using the default width and height.
			 */
			function paginate(unpaginatedString: (string | null), pageNumber: number): org.bukkit.util.ChatPaginator.ChatPage;

			/**
			 * Breaks a raw string up into pages using a provided width and height.
			 */
			function paginate(unpaginatedString: (string | null), pageNumber: number, lineLength: number, pageHeight: number): org.bukkit.util.ChatPaginator.ChatPage;

		}
		namespace ChatPaginator {
			interface ChatPage {
				getPageNumber(): number;

				getTotalPages(): number;

			}
			class ChatPage {
				constructor(lines: string[], pageNumber: number, totalPages: number);

			}
		}
		interface Consumer<T = any> {
			/**
			 * Performs this operation on the given argument.
			 */
			accept(t: T): void;

		}
		interface EntityTransformer {
			/**
			 * Transforms a entity in a structure.
			 */
			transform(region: org.bukkit.generator.LimitedRegion, x: number, y: number, z: number, entity: org.bukkit.entity.Entity, allowedToSpawn: boolean): boolean;

		}
		interface EulerAngle {
			/**
			 * Returns the angle on the x axis in radians
			 */
			getX(): number;

			/**
			 * Returns the angle on the y axis in radians
			 */
			getY(): number;

			/**
			 * Returns the angle on the z axis in radians
			 */
			getZ(): number;

			/**
			 * Return a EulerAngle which is the result of changing
			 * the x axis to the passed angle
			 */
			setX(x: number): org.bukkit.util.EulerAngle;

			/**
			 * Return a EulerAngle which is the result of changing
			 * the y axis to the passed angle
			 */
			setY(y: number): org.bukkit.util.EulerAngle;

			/**
			 * Return a EulerAngle which is the result of changing
			 * the z axis to the passed angle
			 */
			setZ(z: number): org.bukkit.util.EulerAngle;

			/**
			 * Creates a new EulerAngle which is the result of adding
			 * the x, y, z components to this EulerAngle
			 */
			add(x: number, y: number, z: number): org.bukkit.util.EulerAngle;

			/**
			 * Creates a new EulerAngle which is the result of subtracting
			 * the x, y, z components to this EulerAngle
			 */
			subtract(x: number, y: number, z: number): org.bukkit.util.EulerAngle;

			equals(o: any): boolean;

			hashCode(): number;

		}
		class EulerAngle {
			/**
			 * Creates a EularAngle with each axis set to the
			 * passed angle in radians
			 */
			constructor(x: number, y: number, z: number);

		}
		namespace EulerAngle {
			/**
			 * A EulerAngle with every axis set to 0
			 */
			const ZERO: org.bukkit.util.EulerAngle;

		}
		interface FileUtil {
		}
		class FileUtil {
			constructor();

		}
		namespace FileUtil {
			/**
			 * This method copies one file to another location
			 */
			function copy(inFile: any /* java.io.File */, outFile: any /* java.io.File */): boolean;

		}
		interface NumberConversions {}
		namespace NumberConversions {
			function floor(num: number): number;

			function ceil(num: number): number;

			function round(num: number): number;

			function square(num: number): number;

			function toInt(object: (any | null)): number;

			function toFloat(object: (any | null)): number;

			function toDouble(object: (any | null)): number;

			function toLong(object: (any | null)): number;

			function toShort(object: (any | null)): number;

			function toByte(object: (any | null)): any /* byte */;

			function isFinite(d: number): boolean;

			function isFinite(f: number): boolean;

			function checkFinite(d: number, message: string): void;

			function checkFinite(d: number, message: string): void;

		}
		interface RayTraceResult {
			/**
			 * Gets the exact position of the hit.
			 */
			getHitPosition(): org.bukkit.util.Vector;

			/**
			 * Gets the hit block.
			 */
			getHitBlock(): (org.bukkit.block.Block | null);

			/**
			 * Gets the hit block face.
			 */
			getHitBlockFace(): (org.bukkit.block.BlockFace | null);

			/**
			 * Gets the hit entity.
			 */
			getHitEntity(): (org.bukkit.entity.Entity | null);

			hashCode(): number;

			equals(obj: any): boolean;

			toString(): string;

		}
		class RayTraceResult {
			/**
			 * Creates a RayTraceResult.
			 */
			constructor(hitPosition: org.bukkit.util.Vector);

			/**
			 * Creates a RayTraceResult.
			 */
			constructor(hitPosition: org.bukkit.util.Vector, hitBlockFace: (org.bukkit.block.BlockFace | null));

			/**
			 * Creates a RayTraceResult.
			 */
			constructor(hitPosition: org.bukkit.util.Vector, hitBlock: (org.bukkit.block.Block | null), hitBlockFace: (org.bukkit.block.BlockFace | null));

			/**
			 * Creates a RayTraceResult.
			 */
			constructor(hitPosition: org.bukkit.util.Vector, hitEntity: (org.bukkit.entity.Entity | null));

			/**
			 * Creates a RayTraceResult.
			 */
			constructor(hitPosition: org.bukkit.util.Vector, hitEntity: (org.bukkit.entity.Entity | null), hitBlockFace: (org.bukkit.block.BlockFace | null));

		}
		interface StringUtil {
		}
		class StringUtil {
			constructor();

		}
		namespace StringUtil {
			/**
			 * Copies all elements from the iterable collection of originals to the
			 * collection provided.
			 */
			function copyPartialMatches<T = any>(token: string, originals: globalThis.java.lang.Iterable<string>, collection: T): T;

			/**
			 * This method uses a region to check case-insensitive equality. This
			 * means the internal array does not need to be copied like a
			 * toLowerCase() call would.
			 */
			function startsWithIgnoreCase(string: string, prefix: string): boolean;

		}
		interface StructureSearchResult {
			/**
			 * Return the structure which was found.
			 */
			getStructure(): org.bukkit.generator.structure.Structure;

			/**
			 * Return the location of the structure.
			 */
			getLocation(): org.bukkit.Location;

		}
		interface Transformation {
			/**
			 * Gets the translation component of this transformation.
			 */
			getTranslation(): any /* org.joml.Vector3f */;

			/**
			 * Gets the left rotation component of this transformation.
			 */
			getLeftRotation(): any /* org.joml.Quaternionf */;

			/**
			 * Gets the scale component of this transformation.
			 */
			getScale(): any /* org.joml.Vector3f */;

			/**
			 * Gets the right rotation component of this transformation.
			 */
			getRightRotation(): any /* org.joml.Quaternionf */;

			hashCode(): number;

			equals(obj: any): boolean;

			toString(): string;

		}
		class Transformation {
			constructor(translation: any /* org.joml.Vector3f */, leftRotation: any /* org.joml.AxisAngle4f */, scale: any /* org.joml.Vector3f */, rightRotation: any /* org.joml.AxisAngle4f */);

			constructor(translation: any /* org.joml.Vector3f */, leftRotation: any /* org.joml.Quaternionf */, scale: any /* org.joml.Vector3f */, rightRotation: any /* org.joml.Quaternionf */);

		}
		interface Vector {
			/**
			 * Adds a vector to this one
			 */
			add(vec: org.bukkit.util.Vector): org.bukkit.util.Vector;

			/**
			 * Subtracts a vector from this one.
			 */
			subtract(vec: org.bukkit.util.Vector): org.bukkit.util.Vector;

			/**
			 * Multiplies the vector by another.
			 */
			multiply(vec: org.bukkit.util.Vector): org.bukkit.util.Vector;

			/**
			 * Divides the vector by another.
			 */
			divide(vec: org.bukkit.util.Vector): org.bukkit.util.Vector;

			/**
			 * Copies another vector
			 */
			copy(vec: org.bukkit.util.Vector): org.bukkit.util.Vector;

			/**
			 * Gets the magnitude of the vector, defined as sqrt(x^2+y^2+z^2). The
			 * value of this method is not cached and uses a costly square-root
			 * function, so do not repeatedly call this method to get the vector's
			 * magnitude. NaN will be returned if the inner result of the sqrt()
			 * function overflows, which will be caused if the length is too long.
			 */
			length(): number;

			/**
			 * Gets the magnitude of the vector squared.
			 */
			lengthSquared(): number;

			/**
			 * Get the distance between this vector and another. The value of this
			 * method is not cached and uses a costly square-root function, so do not
			 * repeatedly call this method to get the vector's magnitude. NaN will be
			 * returned if the inner result of the sqrt() function overflows, which
			 * will be caused if the distance is too long.
			 */
			distance(o: org.bukkit.util.Vector): number;

			/**
			 * Get the squared distance between this vector and another.
			 */
			distanceSquared(o: org.bukkit.util.Vector): number;

			/**
			 * Gets the angle between this vector and another in radians.
			 */
			angle(other: org.bukkit.util.Vector): number;

			/**
			 * Sets this vector to the midpoint between this vector and another.
			 */
			midpoint(other: org.bukkit.util.Vector): org.bukkit.util.Vector;

			/**
			 * Gets a new midpoint vector between this vector and another.
			 */
			getMidpoint(other: org.bukkit.util.Vector): org.bukkit.util.Vector;

			/**
			 * Performs scalar multiplication, multiplying all components with a
			 * scalar.
			 */
			multiply(m: number): org.bukkit.util.Vector;

			/**
			 * Performs scalar multiplication, multiplying all components with a
			 * scalar.
			 */
			multiply(m: number): org.bukkit.util.Vector;

			/**
			 * Performs scalar multiplication, multiplying all components with a
			 * scalar.
			 */
			multiply(m: number): org.bukkit.util.Vector;

			/**
			 * Calculates the dot product of this vector with another. The dot product
			 * is defined as x1*x2+y1*y2+z1*z2. The returned value is a scalar.
			 */
			dot(other: org.bukkit.util.Vector): number;

			/**
			 * Calculates the cross product of this vector with another. The cross
			 * product is defined as:
			 * 
			 * x = y1 * z2 - y2 * z1
			 * y = z1 * x2 - z2 * x1
			 * z = x1 * y2 - x2 * y1
			 * 
			 */
			crossProduct(o: org.bukkit.util.Vector): org.bukkit.util.Vector;

			/**
			 * Calculates the cross product of this vector with another without mutating
			 * the original. The cross product is defined as:
			 * 
			 * x = y1 * z2 - y2 * z1
			 * y = z1 * x2 - z2 * x1
			 * z = x1 * y2 - x2 * y1
			 * 
			 */
			getCrossProduct(o: org.bukkit.util.Vector): org.bukkit.util.Vector;

			/**
			 * Converts this vector to a unit vector (a vector with length of 1).
			 */
			normalize(): org.bukkit.util.Vector;

			/**
			 * Zero this vector's components.
			 */
			zero(): org.bukkit.util.Vector;

			/**
			 * Check whether or not each component of this vector is equal to 0.
			 */
			isZero(): boolean;

			/**
			 * Returns whether this vector is in an axis-aligned bounding box.
			 * 
			 * The minimum and maximum vectors given must be truly the minimum and
			 * maximum X, Y and Z components.
			 */
			isInAABB(min: org.bukkit.util.Vector, max: org.bukkit.util.Vector): boolean;

			/**
			 * Returns whether this vector is within a sphere.
			 */
			isInSphere(origin: org.bukkit.util.Vector, radius: number): boolean;

			/**
			 * Returns if a vector is normalized
			 */
			isNormalized(): boolean;

			/**
			 * Rotates the vector around the x axis.
			 * 
			 * This piece of math is based on the standard rotation matrix for vectors
			 * in three dimensional space. This matrix can be found here:
			 * Rotation
			 * Matrix.
			 */
			rotateAroundX(angle: number): org.bukkit.util.Vector;

			/**
			 * Rotates the vector around the y axis.
			 * 
			 * This piece of math is based on the standard rotation matrix for vectors
			 * in three dimensional space. This matrix can be found here:
			 * Rotation
			 * Matrix.
			 */
			rotateAroundY(angle: number): org.bukkit.util.Vector;

			/**
			 * Rotates the vector around the z axis
			 * 
			 * This piece of math is based on the standard rotation matrix for vectors
			 * in three dimensional space. This matrix can be found here:
			 * Rotation
			 * Matrix.
			 */
			rotateAroundZ(angle: number): org.bukkit.util.Vector;

			/**
			 * Rotates the vector around a given arbitrary axis in 3 dimensional space.
			 * 
			 * Rotation will follow the general Right-Hand-Rule, which means rotation
			 * will be counterclockwise when the axis is pointing towards the observer.
			 * 
			 * This method will always make sure the provided axis is a unit vector, to
			 * not modify the length of the vector when rotating. If you are experienced
			 * with the scaling of a non-unit axis vector, you can use
			 * rotateAroundNonUnitAxis(Vector, double).
			 */
			rotateAroundAxis(axis: org.bukkit.util.Vector, angle: number): org.bukkit.util.Vector;

			/**
			 * Rotates the vector around a given arbitrary axis in 3 dimensional space.
			 * 
			 * Rotation will follow the general Right-Hand-Rule, which means rotation
			 * will be counterclockwise when the axis is pointing towards the observer.
			 * 
			 * Note that the vector length will change accordingly to the axis vector
			 * length. If the provided axis is not a unit vector, the rotated vector
			 * will not have its previous length. The scaled length of the resulting
			 * vector will be related to the axis vector. If you are not perfectly sure
			 * about the scaling of the vector, use
			 * rotateAroundAxis(Vector, double)
			 */
			rotateAroundNonUnitAxis(axis: org.bukkit.util.Vector, angle: number): org.bukkit.util.Vector;

			/**
			 * Gets the X component.
			 */
			getX(): number;

			/**
			 * Gets the floored value of the X component, indicating the block that
			 * this vector is contained with.
			 */
			getBlockX(): number;

			/**
			 * Gets the Y component.
			 */
			getY(): number;

			/**
			 * Gets the floored value of the Y component, indicating the block that
			 * this vector is contained with.
			 */
			getBlockY(): number;

			/**
			 * Gets the Z component.
			 */
			getZ(): number;

			/**
			 * Gets the floored value of the Z component, indicating the block that
			 * this vector is contained with.
			 */
			getBlockZ(): number;

			/**
			 * Set the X component.
			 */
			setX(x: number): org.bukkit.util.Vector;

			/**
			 * Set the X component.
			 */
			setX(x: number): org.bukkit.util.Vector;

			/**
			 * Set the X component.
			 */
			setX(x: number): org.bukkit.util.Vector;

			/**
			 * Set the Y component.
			 */
			setY(y: number): org.bukkit.util.Vector;

			/**
			 * Set the Y component.
			 */
			setY(y: number): org.bukkit.util.Vector;

			/**
			 * Set the Y component.
			 */
			setY(y: number): org.bukkit.util.Vector;

			/**
			 * Set the Z component.
			 */
			setZ(z: number): org.bukkit.util.Vector;

			/**
			 * Set the Z component.
			 */
			setZ(z: number): org.bukkit.util.Vector;

			/**
			 * Set the Z component.
			 */
			setZ(z: number): org.bukkit.util.Vector;

			/**
			 * Checks to see if two objects are equal.
			 * 
			 * Only two Vectors can ever return true. This method uses a fuzzy match
			 * to account for floating point errors. The epsilon can be retrieved
			 * with epsilon.
			 */
			equals(obj: any): boolean;

			/**
			 * Returns a hash code for this vector
			 */
			hashCode(): number;

			/**
			 * Get a new vector.
			 */
			clone(): org.bukkit.util.Vector;

			/**
			 * Returns this vector's components as x,y,z.
			 */
			toString(): string;

			/**
			 * Gets a Location version of this vector with yaw and pitch being 0.
			 */
			toLocation(world: org.bukkit.World): org.bukkit.Location;

			/**
			 * Gets a Location version of this vector.
			 */
			toLocation(world: org.bukkit.World, yaw: number, pitch: number): org.bukkit.Location;

			/**
			 * Get the block vector of this vector.
			 */
			toBlockVector(): org.bukkit.util.BlockVector;

			/**
			 * Get this vector as a JOML Vector3f.
			 */
			toVector3f(): any /* org.joml.Vector3f */;

			/**
			 * Get this vector as a JOML Vector3d.
			 */
			toVector3d(): any /* org.joml.Vector3d */;

			/**
			 * Get this vector as a JOML Vector3i.
			 */
			toVector3i(roundingMode: number): any /* org.joml.Vector3i */;

			/**
			 * Get this vector as a JOML Vector3i with its components floored.
			 */
			toVector3i(): any /* org.joml.Vector3i */;

			/**
			 * Check if each component of this Vector is finite.
			 */
			checkFinite(): void;

			/**
			 * Description copied from interface:Â ConfigurationSerializable
			 */
			serialize(): globalThis.java.util.Map<string, any>;

		}
		class Vector {
			/**
			 * Construct the vector with all components as 0.
			 */
			constructor();

			/**
			 * Construct the vector with provided integer components.
			 */
			constructor(x: number, y: number, z: number);

			/**
			 * Construct the vector with provided double components.
			 */
			constructor(x: number, y: number, z: number);

			/**
			 * Construct the vector with provided float components.
			 */
			constructor(x: number, y: number, z: number);

		}
		namespace Vector {
			/**
			 * Get the threshold used for equals().
			 */
			function getEpsilon(): number;

			/**
			 * Gets the minimum components of two vectors.
			 */
			function getMinimum(v1: org.bukkit.util.Vector, v2: org.bukkit.util.Vector): org.bukkit.util.Vector;

			/**
			 * Gets the maximum components of two vectors.
			 */
			function getMaximum(v1: org.bukkit.util.Vector, v2: org.bukkit.util.Vector): org.bukkit.util.Vector;

			/**
			 * Gets a random vector with components having a random value between 0
			 * and 1.
			 */
			function getRandom(): org.bukkit.util.Vector;

			/**
			 * Gets a vector with components that match the provided JOML Vector3f.
			 */
			function fromJOML(vector: any /* org.joml.Vector3f */): org.bukkit.util.Vector;

			/**
			 * Gets a vector with components that match the provided JOML Vector3d.
			 */
			function fromJOML(vector: any /* org.joml.Vector3d */): org.bukkit.util.Vector;

			/**
			 * Gets a vector with components that match the provided JOML Vector3i.
			 */
			function fromJOML(vector: any /* org.joml.Vector3i */): org.bukkit.util.Vector;

			/**
			 * Gets a vector with components that match the provided JOML Vector3fc.
			 */
			function fromJOML(vector: any /* org.joml.Vector3fc */): org.bukkit.util.Vector;

			/**
			 * Gets a vector with components that match the provided JOML Vector3dc.
			 */
			function fromJOML(vector: any /* org.joml.Vector3dc */): org.bukkit.util.Vector;

			/**
			 * Gets a vector with components that match the provided JOML Vector3ic.
			 */
			function fromJOML(vector: any /* org.joml.Vector3ic */): org.bukkit.util.Vector;

			function deserialize(args: globalThis.java.util.Map<string, any>): org.bukkit.util.Vector;

		}
		interface VoxelShape {
			/**
			 * Converts this shape into a collection of BoundingBox equivalent
			 * to the shape: a bounding box intersects with this block shape if it
			 * intersects with any of the shape's bounding boxes.
			 */
			getBoundingBoxes(): globalThis.java.util.Collection<org.bukkit.util.BoundingBox>;

			/**
			 * Checks if the given bounding box intersects this block shape.
			 */
			overlaps(other: org.bukkit.util.BoundingBox): boolean;

		}
	}
	namespace org.bukkit.command {
		interface BlockCommandSender extends Modify<org.bukkit.command.CommandSender, {
			/**
			 * Returns the block this command sender belongs to
			 */
			getBlock(): org.bukkit.block.Block;

		}> {}
		interface Command {
			timings: any /* org.spigotmc.CustomTimingsHandler */;

			/**
			 * Executes the command, returning its success
			 */
			execute(sender: org.bukkit.command.CommandSender, commandLabel: string, args: string[]): boolean;

			/**
			 * Executed on tab completion for this command, returning a list of
			 * options the player can tab through.
			 */
			tabComplete(sender: org.bukkit.command.CommandSender, alias: string, args: string[]): globalThis.java.util.List<string>;

			/**
			 * Executed on tab completion for this command, returning a list of
			 * options the player can tab through.
			 */
			tabComplete(sender: org.bukkit.command.CommandSender, alias: string, args: string[], location: (org.bukkit.Location | null)): globalThis.java.util.List<string>;

			/**
			 * Returns the name of this command
			 */
			getName(): string;

			/**
			 * Sets the name of this command.
			 * 
			 * May only be used before registering the command.
			 * Will return true if the new name is set, and false
			 * if the command has already been registered.
			 */
			setName(name: string): boolean;

			/**
			 * Gets the permission required by users to be able to perform this
			 * command
			 */
			getPermission(): (string | null);

			/**
			 * Sets the permission required by users to be able to perform this
			 * command
			 */
			setPermission(permission: (string | null)): void;

			/**
			 * Tests the given CommandSender to see if they can perform this
			 * command.
			 * 
			 * If they do not have permission, they will be informed that they cannot
			 * do this.
			 */
			testPermission(target: org.bukkit.command.CommandSender): boolean;

			/**
			 * Tests the given CommandSender to see if they can perform this
			 * command.
			 * 
			 * No error is sent to the sender.
			 */
			testPermissionSilent(target: org.bukkit.command.CommandSender): boolean;

			/**
			 * Returns the label for this command
			 */
			getLabel(): string;

			/**
			 * Sets the label of this command.
			 * 
			 * May only be used before registering the command.
			 * Will return true if the new name is set, and false
			 * if the command has already been registered.
			 */
			setLabel(name: string): boolean;

			/**
			 * Registers this command to a CommandMap.
			 * Once called it only allows changes the registered CommandMap
			 */
			register(commandMap: org.bukkit.command.CommandMap): boolean;

			/**
			 * Unregisters this command from the passed CommandMap applying any
			 * outstanding changes
			 */
			unregister(commandMap: org.bukkit.command.CommandMap): boolean;

			/**
			 * Returns the current registered state of this command
			 */
			isRegistered(): boolean;

			/**
			 * Returns a list of active aliases of this command
			 */
			getAliases(): globalThis.java.util.List<string>;

			/**
			 * Returns a message to be displayed on a failed permission check for this
			 * command
			 */
			getPermissionMessage(): (string | null);

			/**
			 * Gets a brief description of this command
			 */
			getDescription(): string;

			/**
			 * Gets an example usage of this command
			 */
			getUsage(): string;

			/**
			 * Sets the list of aliases to request on registration for this command.
			 * This is not effective outside of defining aliases in the PluginDescriptionFile.getCommands() (under the
			 * `aliases' node) is equivalent to this method.
			 */
			setAliases(aliases: globalThis.java.util.List<string>): org.bukkit.command.Command;

			/**
			 * Sets a brief description of this command. Defining a description in the
			 * PluginDescriptionFile.getCommands() (under the
			 * `description' node) is equivalent to this method.
			 */
			setDescription(description: string): org.bukkit.command.Command;

			/**
			 * Sets the message sent when a permission check fails
			 */
			setPermissionMessage(permissionMessage: (string | null)): org.bukkit.command.Command;

			/**
			 * Sets the example usage of this command
			 */
			setUsage(usage: string): org.bukkit.command.Command;

			toString(): string;

		}
		namespace Command {
			function broadcastCommandMessage(source: org.bukkit.command.CommandSender, message: string): void;

			function broadcastCommandMessage(source: org.bukkit.command.CommandSender, message: string, sendToSource: boolean): void;

		}
		interface CommandException {
		}
		class CommandException {
			/**
			 * Creates a new instance of CommandException without detail
			 * message.
			 */
			constructor();

			/**
			 * Constructs an instance of CommandException with the
			 * specified detail message.
			 */
			constructor(msg: string);

			constructor(msg: string, cause: globalThis.java.lang.Throwable);

		}
		interface CommandExecutor {
			/**
			 * Executes the given command, returning its success.
			 * 
			 * If false is returned, then the "usage" plugin.yml entry for this command
			 * (if defined) will be sent to the player.
			 */
			onCommand(sender: org.bukkit.command.CommandSender, command: org.bukkit.command.Command, label: string, args: string[]): boolean;

		}
		interface CommandMap {
			/**
			 * Registers all the commands belonging to a certain plugin.
			 * 
			 * Caller can use:-
			 * 
			 * command.getName() to determine the label registered for this
			 * command
			 * command.getAliases() to determine the aliases which where
			 * registered
			 * 
			 */
			registerAll(fallbackPrefix: string, commands: globalThis.java.util.List<org.bukkit.command.Command>): void;

			/**
			 * Registers a command. Returns true on success; false if name is already
			 * taken and fallback had to be used.
			 * 
			 * Caller can use:-
			 * 
			 * command.getName() to determine the label registered for this
			 * command
			 * command.getAliases() to determine the aliases which where
			 * registered
			 * 
			 */
			register(label: string, fallbackPrefix: string, command: org.bukkit.command.Command): boolean;

			/**
			 * Registers a command. Returns true on success; false if name is already
			 * taken and fallback had to be used.
			 * 
			 * Caller can use:-
			 * 
			 * command.getName() to determine the label registered for this
			 * command
			 * command.getAliases() to determine the aliases which where
			 * registered
			 * 
			 */
			register(fallbackPrefix: string, command: org.bukkit.command.Command): boolean;

			/**
			 * Looks for the requested command and executes it if found.
			 */
			dispatch(sender: org.bukkit.command.CommandSender, cmdLine: string): boolean;

			/**
			 * Clears all registered commands.
			 */
			clearCommands(): void;

			/**
			 * Gets the command registered to the specified name
			 */
			getCommand(name: string): (org.bukkit.command.Command | null);

			/**
			 * Looks for the requested command and executes an appropriate
			 * tab-completer if found. This method will also tab-complete partial
			 * commands.
			 */
			tabComplete(sender: org.bukkit.command.CommandSender, cmdLine: string): (globalThis.java.util.List<string> | null);

			/**
			 * Looks for the requested command and executes an appropriate
			 * tab-completer if found. This method will also tab-complete partial
			 * commands.
			 */
			tabComplete(sender: org.bukkit.command.CommandSender, cmdLine: string, location: (org.bukkit.Location | null)): (globalThis.java.util.List<string> | null);

		}
		interface CommandSender extends Modify<org.bukkit.permissions.Permissible, {
			/**
			 * Sends this sender a message
			 */
			sendMessage(message: string): void;

			/**
			 * Sends this sender multiple messages
			 */
			sendMessage(...messages: string[]): void;

			/**
			 * Sends this sender a message
			 */
			sendMessage(sender: (globalThis.java.util.UUID | null), message: string): void;

			/**
			 * Sends this sender multiple messages
			 */
			sendMessage(sender: (globalThis.java.util.UUID | null), ...messages: string[]): void;

			/**
			 * Returns the server instance that this command is running on
			 */
			getServer(): org.bukkit.Server;

			/**
			 * Gets the name of this command sender
			 */
			getName(): string;

		}> {}
		interface ConsoleCommandSender extends Modify<org.bukkit.command.CommandSender & org.bukkit.conversations.Conversable, {}> {}
		interface FormattedCommandAlias extends Modify<org.bukkit.command.Command, {
			/**
			 * Description copied from class:Â Command
			 */
			execute(sender: org.bukkit.command.CommandSender, commandLabel: string, args: string[]): boolean;

		}> {}
		class FormattedCommandAlias {
			constructor(alias: string, formatStrings: string[]);

		}
		interface MultipleCommandAlias extends Modify<org.bukkit.command.Command, {
			/**
			 * Description copied from class:Â Command
			 */
			execute(sender: org.bukkit.command.CommandSender, commandLabel: string, args: string[]): boolean;

		}> {}
		class MultipleCommandAlias {
			constructor(name: string, commands: org.bukkit.command.Command[]);

		}
		interface PluginCommand extends Modify<org.bukkit.command.Command, {
			/**
			 * Executes the command, returning its success
			 */
			execute(sender: org.bukkit.command.CommandSender, commandLabel: string, args: string[]): boolean;

			/**
			 * Sets the CommandExecutor to run when parsing this command
			 */
			setExecutor(executor: (org.bukkit.command.CommandExecutor | null)): void;

			/**
			 * Gets the CommandExecutor associated with this command
			 */
			getExecutor(): org.bukkit.command.CommandExecutor;

			/**
			 * Sets the TabCompleter to run when tab-completing this command.
			 * 
			 * If no TabCompleter is specified, and the command's executor implements
			 * TabCompleter, then the executor will be used for tab completion.
			 */
			setTabCompleter(completer: (org.bukkit.command.TabCompleter | null)): void;

			/**
			 * Gets the TabCompleter associated with this command.
			 */
			getTabCompleter(): (org.bukkit.command.TabCompleter | null);

			/**
			 * Gets the owner of this PluginCommand
			 */
			getPlugin(): org.bukkit.plugin.Plugin;

			/**
			 * Executed on tab completion for this command, returning a list of
			 * options the player can tab through.
			 * 
			 * Delegates to the tab completer if present.
			 * 
			 * If it is not present or returns null, will delegate to the current
			 * command executor if it implements TabCompleter. If a non-null
			 * list has not been found, will default to standard player name
			 * completion in Command.tabComplete(CommandSender, String, String[]).
			 * 
			 * This method does not consider permissions.
			 */
			tabComplete(sender: org.bukkit.command.CommandSender, alias: string, args: string[]): globalThis.java.util.List<string>;

			toString(): string;

		}> {}
		interface PluginCommandYamlParser {
		}
		class PluginCommandYamlParser {
			constructor();

		}
		namespace PluginCommandYamlParser {
			function parse(plugin: org.bukkit.plugin.Plugin): globalThis.java.util.List<org.bukkit.command.Command>;

		}
		interface PluginIdentifiableCommand {
			/**
			 * Gets the owner of this PluginIdentifiableCommand.
			 */
			getPlugin(): org.bukkit.plugin.Plugin;

		}
		interface ProxiedCommandSender extends Modify<org.bukkit.command.CommandSender, {
			/**
			 * Returns the CommandSender which triggered this proxied command
			 */
			getCaller(): org.bukkit.command.CommandSender;

			/**
			 * Returns the CommandSender which is being used to call the command
			 */
			getCallee(): org.bukkit.command.CommandSender;

		}> {}
		interface RemoteConsoleCommandSender extends Modify<org.bukkit.command.CommandSender, {
			/**
			 * Gets the socket address of this remote sender.
			 */
			getAddress(): any /* java.net.SocketAddress */;

		}> {}
		interface SimpleCommandMap {
			setFallbackCommands(): void;

			/**
			 * Registers all the commands belonging to a certain plugin.
			 * 
			 * Caller can use:-
			 * 
			 * command.getName() to determine the label registered for this
			 * command
			 * command.getAliases() to determine the aliases which where
			 * registered
			 * 
			 */
			registerAll(fallbackPrefix: string, commands: globalThis.java.util.List<org.bukkit.command.Command>): void;

			/**
			 * Registers a command. Returns true on success; false if name is already
			 * taken and fallback had to be used.
			 * 
			 * Caller can use:-
			 * 
			 * command.getName() to determine the label registered for this
			 * command
			 * command.getAliases() to determine the aliases which where
			 * registered
			 * 
			 */
			register(fallbackPrefix: string, command: org.bukkit.command.Command): boolean;

			/**
			 * Registers a command. Returns true on success; false if name is already
			 * taken and fallback had to be used.
			 * 
			 * Caller can use:-
			 * 
			 * command.getName() to determine the label registered for this
			 * command
			 * command.getAliases() to determine the aliases which where
			 * registered
			 * 
			 */
			register(label: string, fallbackPrefix: string, command: org.bukkit.command.Command): boolean;

			/**
			 * Looks for the requested command and executes it if found.
			 */
			dispatch(sender: org.bukkit.command.CommandSender, commandLine: string): boolean;

			/**
			 * Description copied from interface:Â CommandMap
			 */
			clearCommands(): void;

			/**
			 * Description copied from interface:Â CommandMap
			 */
			getCommand(name: string): (org.bukkit.command.Command | null);

			/**
			 * Description copied from interface:Â CommandMap
			 */
			tabComplete(sender: org.bukkit.command.CommandSender, cmdLine: string): (globalThis.java.util.List<string> | null);

			/**
			 * Description copied from interface:Â CommandMap
			 */
			tabComplete(sender: org.bukkit.command.CommandSender, cmdLine: string, location: (org.bukkit.Location | null)): (globalThis.java.util.List<string> | null);

			getCommands(): globalThis.java.util.Collection<org.bukkit.command.Command>;

			registerServerAliases(): void;

		}
		class SimpleCommandMap {
			constructor(server: org.bukkit.Server);

		}
		interface TabCompleter {
			/**
			 * Requests a list of possible completions for a command argument.
			 */
			onTabComplete(sender: org.bukkit.command.CommandSender, command: org.bukkit.command.Command, label: string, args: string[]): (globalThis.java.util.List<string> | null);

		}
		interface TabExecutor extends Modify<org.bukkit.command.TabCompleter & org.bukkit.command.CommandExecutor, {}> {}
	}
	namespace org.bukkit.projectiles {
		interface BlockProjectileSource extends Modify<org.bukkit.projectiles.ProjectileSource, {
			/**
			 * Gets the block this projectile source belongs to.
			 */
			getBlock(): org.bukkit.block.Block;

		}> {}
		interface ProjectileSource {
			/**
			 * Launches a Projectile from the ProjectileSource.
			 */
			launchProjectile<T = any>(projectile: globalThis.java.lang.Class<T>): T;

			/**
			 * Launches a Projectile from the ProjectileSource with an
			 * initial velocity.
			 */
			launchProjectile<T = any>(projectile: globalThis.java.lang.Class<T>, velocity: (org.bukkit.util.Vector | null)): T;

		}
	}
	namespace org.bukkit.persistence {
		interface ListPersistentDataType<P = any, C = any> extends Modify<org.bukkit.persistence.PersistentDataType<globalThis.java.util.List, globalThis.java.util.List>, {
			/**
			 * Provides the persistent data type of the elements found in the list.
			 */
			elementType(): org.bukkit.persistence.PersistentDataType<P, C>;

		}> {}
		interface ListPersistentDataTypeProvider {
			/**
			 * Provides a shared ListPersistentDataType that is capable of
			 * storing lists of bytes.
			 */
			bytes(): org.bukkit.persistence.ListPersistentDataType<number, number>;

			/**
			 * Provides a shared ListPersistentDataType that is capable of
			 * storing lists of shorts.
			 */
			shorts(): org.bukkit.persistence.ListPersistentDataType<number, number>;

			/**
			 * Provides a shared ListPersistentDataType that is capable of
			 * storing lists of integers.
			 */
			integers(): org.bukkit.persistence.ListPersistentDataType<number, number>;

			/**
			 * Provides a shared ListPersistentDataType that is capable of
			 * storing lists of longs.
			 */
			longs(): org.bukkit.persistence.ListPersistentDataType<number, number>;

			/**
			 * Provides a shared ListPersistentDataType that is capable of
			 * storing lists of floats.
			 */
			floats(): org.bukkit.persistence.ListPersistentDataType<number, number>;

			/**
			 * Provides a shared ListPersistentDataType that is capable of
			 * storing lists of doubles.
			 */
			doubles(): org.bukkit.persistence.ListPersistentDataType<number, number>;

			/**
			 * Provides a shared ListPersistentDataType that is capable of
			 * storing lists of booleans.
			 */
			booleans(): org.bukkit.persistence.ListPersistentDataType<number, boolean>;

			/**
			 * Provides a shared ListPersistentDataType that is capable of
			 * storing lists of strings.
			 */
			strings(): org.bukkit.persistence.ListPersistentDataType<string, string>;

			/**
			 * Provides a shared ListPersistentDataType that is capable of
			 * storing lists of byte arrays.
			 */
			byteArrays(): org.bukkit.persistence.ListPersistentDataType;

			/**
			 * Provides a shared ListPersistentDataType that is capable of
			 * storing lists of int arrays.
			 */
			integerArrays(): org.bukkit.persistence.ListPersistentDataType;

			/**
			 * Provides a shared ListPersistentDataType that is capable of
			 * storing lists of long arrays.
			 */
			longArrays(): org.bukkit.persistence.ListPersistentDataType;

			/**
			 * Provides a shared ListPersistentDataType that is capable of
			 * persistent data containers..
			 */
			dataContainers(): org.bukkit.persistence.ListPersistentDataType<org.bukkit.persistence.PersistentDataContainer, org.bukkit.persistence.PersistentDataContainer>;

			/**
			 * Constructs a new list persistent data type given any persistent data type
			 * for its elements.
			 */
			listTypeFrom<P = any, C = any>(elementType: org.bukkit.persistence.PersistentDataType<P, C>): org.bukkit.persistence.ListPersistentDataType<P, C>;

		}
		interface PersistentDataAdapterContext {
			/**
			 * Creates a new and empty meta container instance.
			 */
			newPersistentDataContainer(): org.bukkit.persistence.PersistentDataContainer;

		}
		interface PersistentDataContainer {
			/**
			 * Stores a metadata value on the PersistentDataHolder instance.
			 * 
			 * This API cannot be used to manipulate minecraft data, as the values will
			 * be stored using your namespace. This method will override any existing
			 * value the PersistentDataHolder may have stored under the provided
			 * key.
			 */
			set<P = any, C = any>(key: org.bukkit.NamespacedKey, type: org.bukkit.persistence.PersistentDataType<P, C>, value: C): void;

			/**
			 * Returns if the persistent metadata provider has metadata registered
			 * matching the provided parameters.
			 * 
			 * This method will only return true if the found value has the same primitive
			 * data type as the provided key.
			 * 
			 * Storing a value using a custom PersistentDataType implementation
			 * will not store the complex data type. Therefore storing a UUID (by
			 * storing a byte[]) will match has("key" ,
			 * PersistentDataType.BYTE_ARRAY). Likewise a stored byte[] will
			 * always match your UUID PersistentDataType even if it is not 16
			 * bytes long.
			 * 
			 * This method is only usable for custom object keys. Overwriting existing
			 * tags, like the display name, will not work as the values are stored
			 * using your namespace.
			 */
			has<P = any, C = any>(key: org.bukkit.NamespacedKey, type: org.bukkit.persistence.PersistentDataType<P, C>): boolean;

			/**
			 * Returns if the persistent metadata provider has metadata registered matching
			 * the provided parameters.
			 * 
			 * This method will return true as long as a value with the given key exists,
			 * regardless of its type.
			 * 
			 * This method is only usable for custom object keys. Overwriting existing tags,
			 * like the display name, will not work as the values are stored using your
			 * namespace.
			 */
			has(key: org.bukkit.NamespacedKey): boolean;

			/**
			 * Returns the metadata value that is stored on the
			 * PersistentDataHolder instance.
			 */
			get<P = any, C = any>(key: org.bukkit.NamespacedKey, type: org.bukkit.persistence.PersistentDataType<P, C>): (C | null);

			/**
			 * Returns the metadata value that is stored on the
			 * PersistentDataHolder instance. If the value does not exist in the
			 * container, the default value provided is returned.
			 */
			getOrDefault<P = any, C = any>(key: org.bukkit.NamespacedKey, type: org.bukkit.persistence.PersistentDataType<P, C>, defaultValue: C): C;

			/**
			 * Get the set of keys present on this PersistentDataContainer
			 * instance.
			 * Any changes made to the returned set will not be reflected on the
			 * instance.
			 */
			getKeys(): globalThis.java.util.Set<org.bukkit.NamespacedKey>;

			/**
			 * Removes a custom key from the PersistentDataHolder instance.
			 */
			remove(key: org.bukkit.NamespacedKey): void;

			/**
			 * Returns if the container instance is empty, therefore has no entries
			 * inside it.
			 */
			isEmpty(): boolean;

			/**
			 * Copies all values from this PersistentDataContainer to the provided
			 * container.
			 * 
			 * This method only copies custom object keys. Existing tags, like the display
			 * name, will not be copied as the values are stored using your namespace.
			 */
			copyTo(other: org.bukkit.persistence.PersistentDataContainer, replace: boolean): void;

			/**
			 * Returns the adapter context this tag container uses.
			 */
			getAdapterContext(): org.bukkit.persistence.PersistentDataAdapterContext;

		}
		interface PersistentDataHolder {
			/**
			 * Returns a custom tag container capable of storing tags on the object.
			 * Note that the tags stored on this container are all stored under their
			 * own custom namespace therefore modifying default tags using this
			 * PersistentDataHolder is impossible.
			 */
			getPersistentDataContainer(): org.bukkit.persistence.PersistentDataContainer;

		}
		interface PersistentDataType<P = any, C = any> {
			/**
			 * Returns the primitive data type of this tag.
			 */
			getPrimitiveType(): globalThis.java.lang.Class<P>;

			/**
			 * Returns the complex object type the primitive value resembles.
			 */
			getComplexType(): globalThis.java.lang.Class<C>;

			/**
			 * Returns the primitive data that resembles the complex object passed to
			 * this method.
			 */
			toPrimitive(complex: C, context: org.bukkit.persistence.PersistentDataAdapterContext): P;

			/**
			 * Creates a complex object based of the passed primitive value
			 */
			fromPrimitive(primitive: P, context: org.bukkit.persistence.PersistentDataAdapterContext): C;

		}
		namespace PersistentDataType {
			const BYTE: org.bukkit.persistence.PersistentDataType<number, number>;

			const SHORT: org.bukkit.persistence.PersistentDataType<number, number>;

			const INTEGER: org.bukkit.persistence.PersistentDataType<number, number>;

			const LONG: org.bukkit.persistence.PersistentDataType<number, number>;

			const FLOAT: org.bukkit.persistence.PersistentDataType<number, number>;

			const DOUBLE: org.bukkit.persistence.PersistentDataType<number, number>;

			/**
			 * A convenience implementation to convert between Byte and Boolean as there is
			 * no native implementation for booleans.
			 * Any byte value not equal to 0 is considered to be true.
			 */
			const BOOLEAN: org.bukkit.persistence.PersistentDataType<number, boolean>;

			const STRING: org.bukkit.persistence.PersistentDataType<string, string>;

			const BYTE_ARRAY: org.bukkit.persistence.PersistentDataType;

			const INTEGER_ARRAY: org.bukkit.persistence.PersistentDataType;

			const LONG_ARRAY: org.bukkit.persistence.PersistentDataType;

			const TAG_CONTAINER_ARRAY: org.bukkit.persistence.PersistentDataType;

			const TAG_CONTAINER: org.bukkit.persistence.PersistentDataType<org.bukkit.persistence.PersistentDataContainer, org.bukkit.persistence.PersistentDataContainer>;

			/**
			 * A data type provider type that itself cannot be used as a
			 * PersistentDataType.
			 * ListPersistentDataTypeProvider exposes shared persistent data
			 * types for storing lists of other data types, however.
			 * 
			 * Its existence in the PersistentDataType interface does not permit
			 * List as a primitive type in combination with a plain
			 * PersistentDataType. Lists are only valid
			 * primitive types when used via a ListPersistentDataType.
			 */
			const LIST: org.bukkit.persistence.ListPersistentDataTypeProvider;

		}
		namespace PersistentDataType {
			interface BooleanPersistentDataType {
				/**
				 * Description copied from interface:Â PersistentDataType
				 */
				getPrimitiveType(): globalThis.java.lang.Class<number>;

				/**
				 * Description copied from interface:Â PersistentDataType
				 */
				getComplexType(): globalThis.java.lang.Class<boolean>;

				/**
				 * Description copied from interface:Â PersistentDataType
				 */
				toPrimitive(complex: boolean, context: org.bukkit.persistence.PersistentDataAdapterContext): number;

				/**
				 * Description copied from interface:Â PersistentDataType
				 */
				fromPrimitive(primitive: number, context: org.bukkit.persistence.PersistentDataAdapterContext): boolean;

			}
			class BooleanPersistentDataType {
				constructor();

			}
		}
		namespace PersistentDataType {
			interface PrimitivePersistentDataType<P = any> {
				/**
				 * Description copied from interface:Â PersistentDataType
				 */
				getPrimitiveType(): globalThis.java.lang.Class<P>;

				/**
				 * Description copied from interface:Â PersistentDataType
				 */
				getComplexType(): globalThis.java.lang.Class<P>;

				/**
				 * Description copied from interface:Â PersistentDataType
				 */
				toPrimitive(complex: P, context: org.bukkit.persistence.PersistentDataAdapterContext): P;

				/**
				 * Description copied from interface:Â PersistentDataType
				 */
				fromPrimitive(primitive: P, context: org.bukkit.persistence.PersistentDataAdapterContext): P;

			}
		}
	}
	namespace org.bukkit.conversations {
		interface BooleanPrompt extends Modify<org.bukkit.conversations.ValidatingPrompt, {
		}> {}
		class BooleanPrompt {
			constructor();

		}
		interface Conversable {
			/**
			 * Tests to see of a Conversable object is actively engaged in a
			 * conversation.
			 */
			isConversing(): boolean;

			/**
			 * Accepts input into the active conversation. If no conversation is in
			 * progress, this method does nothing.
			 */
			acceptConversationInput(input: string): void;

			/**
			 * Enters into a dialog with a Conversation object.
			 */
			beginConversation(conversation: org.bukkit.conversations.Conversation): boolean;

			/**
			 * Abandons an active conversation.
			 */
			abandonConversation(conversation: org.bukkit.conversations.Conversation): void;

			/**
			 * Abandons an active conversation.
			 */
			abandonConversation(conversation: org.bukkit.conversations.Conversation, details: org.bukkit.conversations.ConversationAbandonedEvent): void;

			/**
			 * Sends this sender a message raw
			 */
			sendRawMessage(message: string): void;

			/**
			 * Sends this sender a message raw
			 */
			sendRawMessage(sender: (globalThis.java.util.UUID | null), message: string): void;

		}
		interface Conversation {
			/**
			 * Gets the entity for whom this conversation is mediating.
			 */
			getForWhom(): org.bukkit.conversations.Conversable;

			/**
			 * Gets the modality of this conversation. If a conversation is modal, all
			 * messages directed to the player are suppressed for the duration of the
			 * conversation.
			 */
			isModal(): boolean;

			/**
			 * Gets the status of local echo for this conversation. If local echo is
			 * enabled, any text submitted to a conversation gets echoed back into the
			 * submitter's chat window.
			 */
			isLocalEchoEnabled(): boolean;

			/**
			 * Sets the status of local echo for this conversation. If local echo is
			 * enabled, any text submitted to a conversation gets echoed back into the
			 * submitter's chat window.
			 */
			setLocalEchoEnabled(localEchoEnabled: boolean): void;

			/**
			 * Gets the ConversationPrefix that prepends all output from this
			 * conversation.
			 */
			getPrefix(): org.bukkit.conversations.ConversationPrefix;

			/**
			 * Gets the list of ConversationCancellers
			 */
			getCancellers(): globalThis.java.util.List<org.bukkit.conversations.ConversationCanceller>;

			/**
			 * Returns the Conversation's ConversationContext.
			 */
			getContext(): org.bukkit.conversations.ConversationContext;

			/**
			 * Displays the first prompt of this conversation and begins redirecting
			 * the user's chat responses.
			 */
			begin(): void;

			/**
			 * Returns Returns the current state of the conversation.
			 */
			getState(): org.bukkit.conversations.Conversation.ConversationState;

			/**
			 * Passes player input into the current prompt. The next prompt (as
			 * determined by the current prompt) is then displayed to the user.
			 */
			acceptInput(input: string): void;

			/**
			 * Adds a ConversationAbandonedListener.
			 */
			addConversationAbandonedListener(listener: org.bukkit.conversations.ConversationAbandonedListener): void;

			/**
			 * Removes a ConversationAbandonedListener.
			 */
			removeConversationAbandonedListener(listener: org.bukkit.conversations.ConversationAbandonedListener): void;

			/**
			 * Abandons and resets the current conversation. Restores the user's
			 * normal chat behavior.
			 */
			abandon(): void;

			/**
			 * Abandons and resets the current conversation. Restores the user's
			 * normal chat behavior.
			 */
			abandon(details: org.bukkit.conversations.ConversationAbandonedEvent): void;

			/**
			 * Displays the next user prompt and abandons the conversation if the next
			 * prompt is null.
			 */
			outputNextPrompt(): void;

		}
		class Conversation {
			/**
			 * Initializes a new Conversation.
			 */
			constructor(plugin: (org.bukkit.plugin.Plugin | null), forWhom: org.bukkit.conversations.Conversable, firstPrompt: (org.bukkit.conversations.Prompt | null));

			/**
			 * Initializes a new Conversation.
			 */
			constructor(plugin: (org.bukkit.plugin.Plugin | null), forWhom: org.bukkit.conversations.Conversable, firstPrompt: (org.bukkit.conversations.Prompt | null), initialSessionData: globalThis.java.util.Map<any, any>);

		}
		namespace Conversation {
			interface ConversationState {}
			namespace ConversationState {
				const UNSTARTED: org.bukkit.conversations.Conversation.ConversationState;

				const STARTED: org.bukkit.conversations.Conversation.ConversationState;

				const ABANDONED: org.bukkit.conversations.Conversation.ConversationState;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.conversations.Conversation.ConversationState;

			}
		}
		interface ConversationAbandonedEvent {
			/**
			 * Gets the object that caused the conversation to be abandoned.
			 */
			getCanceller(): (org.bukkit.conversations.ConversationCanceller | null);

			/**
			 * Gets the abandoned conversation's conversation context.
			 */
			getContext(): org.bukkit.conversations.ConversationContext;

			/**
			 * Indicates how the conversation was abandoned - naturally as part of the
			 * prompt chain or prematurely via a ConversationCanceller.
			 */
			gracefulExit(): boolean;

		}
		class ConversationAbandonedEvent {
			constructor(conversation: org.bukkit.conversations.Conversation);

			constructor(conversation: org.bukkit.conversations.Conversation, canceller: (org.bukkit.conversations.ConversationCanceller | null));

		}
		interface ConversationAbandonedListener {
			/**
			 * Called whenever a Conversation is abandoned.
			 */
			conversationAbandoned(abandonedEvent: org.bukkit.conversations.ConversationAbandonedEvent): void;

		}
		interface ConversationCanceller {
			/**
			 * Sets the conversation this ConversationCanceller can optionally cancel.
			 */
			setConversation(conversation: org.bukkit.conversations.Conversation): void;

			/**
			 * Cancels a conversation based on user input.
			 */
			cancelBasedOnInput(context: org.bukkit.conversations.ConversationContext, input: string): boolean;

			/**
			 * Allows the ConversationFactory to duplicate this
			 * ConversationCanceller when creating a new Conversation.
			 * 
			 * Implementing this method should reset any internal object state.
			 */
			clone(): org.bukkit.conversations.ConversationCanceller;

		}
		interface ConversationContext {
			/**
			 * Gets the plugin that owns this conversation.
			 */
			getPlugin(): (org.bukkit.plugin.Plugin | null);

			/**
			 * Gets the subject of the conversation.
			 */
			getForWhom(): org.bukkit.conversations.Conversable;

			/**
			 * Gets the underlying sessionData map.
			 * May be directly modified to manipulate session data.
			 */
			getAllSessionData(): globalThis.java.util.Map<any, any>;

			/**
			 * Gets session data shared between all Prompt invocations. Use
			 * this as a way to pass data through each Prompt as the conversation
			 * develops.
			 */
			getSessionData(key: any): (any | null);

			/**
			 * Sets session data shared between all Prompt invocations. Use
			 * this as a way to pass data through each prompt as the conversation
			 * develops.
			 */
			setSessionData(key: any, value: (any | null)): void;

		}
		class ConversationContext {
			constructor(plugin: (org.bukkit.plugin.Plugin | null), forWhom: org.bukkit.conversations.Conversable, initialSessionData: globalThis.java.util.Map<any, any>);

		}
		interface ConversationFactory {
			/**
			 * Sets the modality of all Conversations created by this factory.
			 * If a conversation is modal, all messages directed to the player are
			 * suppressed for the duration of the conversation.
			 * 
			 * The default is True.
			 */
			withModality(modal: boolean): org.bukkit.conversations.ConversationFactory;

			/**
			 * Sets the local echo status for all Conversations created by
			 * this factory. If local echo is enabled, any text submitted to a
			 * conversation gets echoed back into the submitter's chat window.
			 */
			withLocalEcho(localEchoEnabled: boolean): org.bukkit.conversations.ConversationFactory;

			/**
			 * Sets the ConversationPrefix that prepends all output from all
			 * generated conversations.
			 * 
			 * The default is a NullConversationPrefix;
			 */
			withPrefix(prefix: org.bukkit.conversations.ConversationPrefix): org.bukkit.conversations.ConversationFactory;

			/**
			 * Sets the number of inactive seconds to wait before automatically
			 * abandoning all generated conversations.
			 * 
			 * The default is 600 seconds (5 minutes).
			 */
			withTimeout(timeoutSeconds: number): org.bukkit.conversations.ConversationFactory;

			/**
			 * Sets the first prompt to use in all generated conversations.
			 * 
			 * The default is Prompt.END_OF_CONVERSATION.
			 */
			withFirstPrompt(firstPrompt: (org.bukkit.conversations.Prompt | null)): org.bukkit.conversations.ConversationFactory;

			/**
			 * Sets any initial data with which to populate the conversation context
			 * sessionData map.
			 */
			withInitialSessionData(initialSessionData: globalThis.java.util.Map<any, any>): org.bukkit.conversations.ConversationFactory;

			/**
			 * Sets the player input that, when received, will immediately terminate
			 * the conversation.
			 */
			withEscapeSequence(escapeSequence: string): org.bukkit.conversations.ConversationFactory;

			/**
			 * Adds a ConversationCanceller to constructed conversations.
			 */
			withConversationCanceller(canceller: org.bukkit.conversations.ConversationCanceller): org.bukkit.conversations.ConversationFactory;

			/**
			 * Prevents this factory from creating a conversation for non-player
			 * Conversable objects.
			 */
			thatExcludesNonPlayersWithMessage(playerOnlyMessage: (string | null)): org.bukkit.conversations.ConversationFactory;

			/**
			 * Adds a ConversationAbandonedListener to all conversations
			 * constructed by this factory.
			 */
			addConversationAbandonedListener(listener: org.bukkit.conversations.ConversationAbandonedListener): org.bukkit.conversations.ConversationFactory;

			/**
			 * Constructs a Conversation in accordance with the defaults set
			 * for this factory.
			 */
			buildConversation(forWhom: org.bukkit.conversations.Conversable): org.bukkit.conversations.Conversation;

		}
		class ConversationFactory {
			/**
			 * Constructs a ConversationFactory.
			 */
			constructor(plugin: org.bukkit.plugin.Plugin);

		}
		interface ConversationPrefix {
			/**
			 * Gets the prefix to use before each message to the player.
			 */
			getPrefix(context: org.bukkit.conversations.ConversationContext): string;

		}
		interface ExactMatchConversationCanceller {
			/**
			 * Description copied from interface:Â ConversationCanceller
			 */
			setConversation(conversation: org.bukkit.conversations.Conversation): void;

			/**
			 * Description copied from interface:Â ConversationCanceller
			 */
			cancelBasedOnInput(context: org.bukkit.conversations.ConversationContext, input: string): boolean;

			/**
			 * Description copied from interface:Â ConversationCanceller
			 */
			clone(): org.bukkit.conversations.ConversationCanceller;

		}
		class ExactMatchConversationCanceller {
			/**
			 * Builds an ExactMatchConversationCanceller.
			 */
			constructor(escapeSequence: string);

		}
		interface FixedSetPrompt extends Modify<org.bukkit.conversations.ValidatingPrompt, {
		}> {}
		class FixedSetPrompt {
			/**
			 * Creates a FixedSetPrompt from a set of strings.
			 * 
			 * foo = new FixedSetPrompt("bar", "cheese", "panda");
			 */
			constructor(...fixedSet: string[]);

		}
		interface InactivityConversationCanceller {
			/**
			 * Description copied from interface:Â ConversationCanceller
			 */
			setConversation(conversation: org.bukkit.conversations.Conversation): void;

			/**
			 * Description copied from interface:Â ConversationCanceller
			 */
			cancelBasedOnInput(context: org.bukkit.conversations.ConversationContext, input: string): boolean;

			/**
			 * Description copied from interface:Â ConversationCanceller
			 */
			clone(): org.bukkit.conversations.ConversationCanceller;

		}
		class InactivityConversationCanceller {
			/**
			 * Creates an InactivityConversationCanceller.
			 */
			constructor(plugin: org.bukkit.plugin.Plugin, timeoutSeconds: number);

		}
		interface ManuallyAbandonedConversationCanceller {
			/**
			 * Description copied from interface:Â ConversationCanceller
			 */
			setConversation(conversation: org.bukkit.conversations.Conversation): void;

			/**
			 * Description copied from interface:Â ConversationCanceller
			 */
			cancelBasedOnInput(context: org.bukkit.conversations.ConversationContext, input: string): boolean;

			/**
			 * Description copied from interface:Â ConversationCanceller
			 */
			clone(): org.bukkit.conversations.ConversationCanceller;

		}
		class ManuallyAbandonedConversationCanceller {
			constructor();

		}
		interface MessagePrompt {
			/**
			 * Message prompts never wait for user input before continuing.
			 */
			blocksForInput(context: org.bukkit.conversations.ConversationContext): boolean;

			/**
			 * Accepts and ignores any user input, returning the next prompt in the
			 * prompt graph instead.
			 */
			acceptInput(context: org.bukkit.conversations.ConversationContext, input: (string | null)): (org.bukkit.conversations.Prompt | null);

		}
		class MessagePrompt {
			constructor();

		}
		interface NullConversationPrefix {
			/**
			 * Prepends each conversation message with an empty string.
			 */
			getPrefix(context: org.bukkit.conversations.ConversationContext): string;

		}
		class NullConversationPrefix {
			constructor();

		}
		interface NumericPrompt extends Modify<org.bukkit.conversations.ValidatingPrompt, {
		}> {}
		class NumericPrompt {
			constructor();

		}
		interface PlayerNamePrompt extends Modify<org.bukkit.conversations.ValidatingPrompt, {
		}> {}
		class PlayerNamePrompt {
			constructor(plugin: org.bukkit.plugin.Plugin);

		}
		interface PluginNameConversationPrefix {
			/**
			 * Prepends each conversation message with the plugin name.
			 */
			getPrefix(context: org.bukkit.conversations.ConversationContext): string;

		}
		class PluginNameConversationPrefix {
			constructor(plugin: org.bukkit.plugin.Plugin);

			constructor(plugin: org.bukkit.plugin.Plugin, separator: string, prefixColor: org.bukkit.ChatColor);

		}
		interface Prompt {
			/**
			 * Gets the text to display to the user when this prompt is first
			 * presented.
			 */
			getPromptText(context: org.bukkit.conversations.ConversationContext): string;

			/**
			 * Checks to see if this prompt implementation should wait for user input
			 * or immediately display the next prompt.
			 */
			blocksForInput(context: org.bukkit.conversations.ConversationContext): boolean;

			/**
			 * Accepts and processes input from the user. Using the input, the next
			 * Prompt in the prompt graph is returned.
			 */
			acceptInput(context: org.bukkit.conversations.ConversationContext, input: (string | null)): (org.bukkit.conversations.Prompt | null);

		}
		namespace Prompt {
			/**
			 * A convenience constant for indicating the end of a conversation.
			 */
			const END_OF_CONVERSATION: org.bukkit.conversations.Prompt;

		}
		interface RegexPrompt extends Modify<org.bukkit.conversations.ValidatingPrompt, {
		}> {}
		class RegexPrompt {
			constructor(regex: string);

			constructor(pattern: globalThis.java.util.regex.Pattern);

		}
		interface StringPrompt {
			/**
			 * Ensures that the prompt waits for the user to provide input.
			 */
			blocksForInput(context: org.bukkit.conversations.ConversationContext): boolean;

		}
		class StringPrompt {
			constructor();

		}
		interface ValidatingPrompt {
			/**
			 * Accepts and processes input from the user and validates it. If
			 * validation fails, this prompt is returned for re-execution, otherwise
			 * the next Prompt in the prompt graph is returned.
			 */
			acceptInput(context: org.bukkit.conversations.ConversationContext, input: (string | null)): (org.bukkit.conversations.Prompt | null);

			/**
			 * Ensures that the prompt waits for the user to provide input.
			 */
			blocksForInput(context: org.bukkit.conversations.ConversationContext): boolean;

		}
		class ValidatingPrompt {
			constructor();

		}
	}
	namespace org.bukkit.event.inventory {
		interface BrewEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets the contents of the Brewing Stand.
			 * Note: The brewer inventory still holds the items found prior to
			 * the finalization of the brewing process, e.g. the plain water bottles.
			 */
			getContents(): org.bukkit.inventory.BrewerInventory;

			/**
			 * Gets the remaining fuel level.
			 */
			getFuelLevel(): number;

			/**
			 * Gets the resulting items in the Brewing Stand.
			 * The returned list, in case of a server-created event instance, is
			 * mutable. Any changes in the returned list will reflect in the brewing
			 * result if the event is not cancelled. If the size of the list is reduced,
			 * remaining items will be set to air.
			 */
			getResults(): globalThis.java.util.List<org.bukkit.inventory.ItemStack>;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BrewEvent {
			constructor(brewer: org.bukkit.block.Block, contents: org.bukkit.inventory.BrewerInventory, results: globalThis.java.util.List<org.bukkit.inventory.ItemStack>, fuelLevel: number);

		}
		namespace BrewEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface BrewingStandFuelEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets the ItemStack of the fuel before the amount was subtracted.
			 */
			getFuel(): org.bukkit.inventory.ItemStack;

			/**
			 * Gets the fuel power for this fuel. Each unit of power can fuel one
			 * brewing operation.
			 */
			getFuelPower(): number;

			/**
			 * Sets the fuel power for this fuel. Each unit of power can fuel one
			 * brewing operation.
			 */
			setFuelPower(fuelPower: number): void;

			/**
			 * Gets whether the brewing stand's fuel will be reduced / consumed or not.
			 */
			isConsuming(): boolean;

			/**
			 * Sets whether the brewing stand's fuel will be reduced / consumed or not.
			 */
			setConsuming(consuming: boolean): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BrewingStandFuelEvent {
			constructor(brewingStand: org.bukkit.block.Block, fuel: org.bukkit.inventory.ItemStack, fuelPower: number);

		}
		namespace BrewingStandFuelEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface ClickType {
			/**
			 * Gets whether this ClickType represents the pressing of a key on a
			 * keyboard.
			 */
			isKeyboardClick(): boolean;

			/**
			 * Gets whether this ClickType represents the pressing of a mouse button
			 */
			isMouseClick(): boolean;

			/**
			 * Gets whether this ClickType represents an action that can only be
			 * performed by a Player in creative mode.
			 */
			isCreativeAction(): boolean;

			/**
			 * Gets whether this ClickType represents a right click.
			 */
			isRightClick(): boolean;

			/**
			 * Gets whether this ClickType represents a left click.
			 */
			isLeftClick(): boolean;

			/**
			 * Gets whether this ClickType indicates that the shift key was pressed
			 * down when the click was made.
			 */
			isShiftClick(): boolean;

		}
		namespace ClickType {
			/**
			 * The left (or primary) mouse button.
			 */
			const LEFT: org.bukkit.event.inventory.ClickType;

			/**
			 * Holding shift while pressing the left mouse button.
			 */
			const SHIFT_LEFT: org.bukkit.event.inventory.ClickType;

			/**
			 * The right mouse button.
			 */
			const RIGHT: org.bukkit.event.inventory.ClickType;

			/**
			 * Holding shift while pressing the right mouse button.
			 */
			const SHIFT_RIGHT: org.bukkit.event.inventory.ClickType;

			/**
			 * Clicking the left mouse button on the grey area around the inventory.
			 */
			const WINDOW_BORDER_LEFT: org.bukkit.event.inventory.ClickType;

			/**
			 * Clicking the right mouse button on the grey area around the inventory.
			 */
			const WINDOW_BORDER_RIGHT: org.bukkit.event.inventory.ClickType;

			/**
			 * The middle mouse button, or a "scrollwheel click".
			 */
			const MIDDLE: org.bukkit.event.inventory.ClickType;

			/**
			 * One of the number keys 1-9, correspond to slots on the hotbar.
			 */
			const NUMBER_KEY: org.bukkit.event.inventory.ClickType;

			/**
			 * Pressing the left mouse button twice in quick succession.
			 */
			const DOUBLE_CLICK: org.bukkit.event.inventory.ClickType;

			/**
			 * The "Drop" key (defaults to Q).
			 */
			const DROP: org.bukkit.event.inventory.ClickType;

			/**
			 * Holding Ctrl while pressing the "Drop" key (defaults to Q).
			 */
			const CONTROL_DROP: org.bukkit.event.inventory.ClickType;

			/**
			 * Any action done with the Creative inventory open.
			 */
			const CREATIVE: org.bukkit.event.inventory.ClickType;

			/**
			 * The "swap item with offhand" key (defaults to F).
			 */
			const SWAP_OFFHAND: org.bukkit.event.inventory.ClickType;

			/**
			 * A type of inventory manipulation not yet recognized by Bukkit.
			 * 
			 * This is only for transitional purposes on a new Minecraft update, and
			 * should never be relied upon.
			 * 
			 * Any ClickType.UNKNOWN is called on a best-effort basis.
			 */
			const UNKNOWN: org.bukkit.event.inventory.ClickType;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.event.inventory.ClickType;

		}
		interface CraftItemEvent extends Modify<org.bukkit.event.inventory.InventoryClickEvent, {
			getRecipe(): org.bukkit.inventory.Recipe;

			/**
			 * Description copied from class:Â InventoryEvent
			 */
			getInventory(): org.bukkit.inventory.CraftingInventory;

		}> {}
		class CraftItemEvent {
			constructor(recipe: org.bukkit.inventory.Recipe, what: org.bukkit.inventory.InventoryView, type: org.bukkit.event.inventory.InventoryType.SlotType, slot: number, click: org.bukkit.event.inventory.ClickType, action: org.bukkit.event.inventory.InventoryAction);

			constructor(recipe: org.bukkit.inventory.Recipe, what: org.bukkit.inventory.InventoryView, type: org.bukkit.event.inventory.InventoryType.SlotType, slot: number, click: org.bukkit.event.inventory.ClickType, action: org.bukkit.event.inventory.InventoryAction, key: number);

		}
		interface DragType {}
		namespace DragType {
			/**
			 * One item from the cursor is placed in each selected slot.
			 */
			const SINGLE: org.bukkit.event.inventory.DragType;

			/**
			 * The cursor is split evenly across all selected slots, not to exceed the
			 * Material's max stack size, with the remainder going to the cursor.
			 */
			const EVEN: org.bukkit.event.inventory.DragType;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.event.inventory.DragType;

		}
		interface FurnaceBurnEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Gets the fuel ItemStack for this event
			 */
			getFuel(): org.bukkit.inventory.ItemStack;

			/**
			 * Gets the burn time for this fuel
			 */
			getBurnTime(): number;

			/**
			 * Sets the burn time for this fuel
			 */
			setBurnTime(burnTime: number): void;

			/**
			 * Gets whether the furnace's fuel is burning or not.
			 */
			isBurning(): boolean;

			/**
			 * Sets whether the furnace's fuel is burning or not.
			 */
			setBurning(burning: boolean): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class FurnaceBurnEvent {
			constructor(furnace: org.bukkit.block.Block, fuel: org.bukkit.inventory.ItemStack, burnTime: number);

		}
		namespace FurnaceBurnEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface FurnaceExtractEvent extends Modify<org.bukkit.event.block.BlockExpEvent, {
			/**
			 * Get the player that triggered the event
			 */
			getPlayer(): org.bukkit.entity.Player;

			/**
			 * Get the Material of the item being retrieved
			 */
			getItemType(): org.bukkit.Material;

			/**
			 * Get the item count being retrieved
			 */
			getItemAmount(): number;

		}> {}
		class FurnaceExtractEvent {
			constructor(player: org.bukkit.entity.Player, block: org.bukkit.block.Block, itemType: org.bukkit.Material, itemAmount: number, exp: number);

		}
		interface FurnaceSmeltEvent extends Modify<org.bukkit.event.block.BlockCookEvent, {
		}> {}
		class FurnaceSmeltEvent {
			constructor(furnace: org.bukkit.block.Block, source: org.bukkit.inventory.ItemStack, result: org.bukkit.inventory.ItemStack);

		}
		interface FurnaceStartSmeltEvent extends Modify<org.bukkit.event.block.InventoryBlockStartEvent, {
			/**
			 * Gets the FurnaceRecipe associated with this event
			 */
			getRecipe(): org.bukkit.inventory.CookingRecipe;

			/**
			 * Gets the total cook time associated with this event
			 */
			getTotalCookTime(): number;

			/**
			 * Sets the total cook time for this event
			 */
			setTotalCookTime(cookTime: number): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class FurnaceStartSmeltEvent {
			constructor(furnace: org.bukkit.block.Block, source: org.bukkit.inventory.ItemStack, recipe: org.bukkit.inventory.CookingRecipe);

		}
		namespace FurnaceStartSmeltEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface HopperInventorySearchEvent extends Modify<org.bukkit.event.block.BlockEvent, {
			/**
			 * Set the Inventory that the Hopper will use for its
			 * source/attached Container.
			 */
			setInventory(inventory: (org.bukkit.inventory.Inventory | null)): void;

			/**
			 * Gets the Inventory that the Hopper will use for its
			 * source/attached Container.
			 */
			getInventory(): (org.bukkit.inventory.Inventory | null);

			/**
			 * Gets the Container type the Hopper is searching for.
			 */
			getContainerType(): org.bukkit.event.inventory.HopperInventorySearchEvent.ContainerType;

			/**
			 * Gets the Block that is being searched for an inventory.
			 */
			getSearchBlock(): org.bukkit.block.Block;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class HopperInventorySearchEvent {
			constructor(inventory: org.bukkit.inventory.Inventory, containerType: org.bukkit.event.inventory.HopperInventorySearchEvent.ContainerType, hopper: org.bukkit.block.Block, searchBlock: org.bukkit.block.Block);

		}
		namespace HopperInventorySearchEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace HopperInventorySearchEvent {
			interface ContainerType {}
			namespace ContainerType {
				/**
				 * The source container the hopper is looking for.
				 * This is the Inventory above the Hopper where it extracts items from.
				 */
				const SOURCE: org.bukkit.event.inventory.HopperInventorySearchEvent.ContainerType;

				/**
				 * The container the hopper is attached to.
				 * This is the Inventory the Hopper pushes items into.
				 */
				const DESTINATION: org.bukkit.event.inventory.HopperInventorySearchEvent.ContainerType;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.inventory.HopperInventorySearchEvent.ContainerType;

			}
		}
		interface InventoryAction {}
		namespace InventoryAction {
			/**
			 * Nothing will happen from the click.
			 * 
			 * There may be cases where nothing will happen and this is value is not
			 * provided, but it is guaranteed that this value is accurate when given.
			 */
			const NOTHING: org.bukkit.event.inventory.InventoryAction;

			/**
			 * All of the items on the clicked slot are moved to the cursor.
			 */
			const PICKUP_ALL: org.bukkit.event.inventory.InventoryAction;

			/**
			 * Some of the items on the clicked slot are moved to the cursor.
			 */
			const PICKUP_SOME: org.bukkit.event.inventory.InventoryAction;

			/**
			 * Half of the items on the clicked slot are moved to the cursor.
			 */
			const PICKUP_HALF: org.bukkit.event.inventory.InventoryAction;

			/**
			 * One of the items on the clicked slot are moved to the cursor.
			 */
			const PICKUP_ONE: org.bukkit.event.inventory.InventoryAction;

			/**
			 * All of the items on the cursor are moved to the clicked slot.
			 */
			const PLACE_ALL: org.bukkit.event.inventory.InventoryAction;

			/**
			 * Some of the items from the cursor are moved to the clicked slot
			 * (usually up to the max stack size).
			 */
			const PLACE_SOME: org.bukkit.event.inventory.InventoryAction;

			/**
			 * A single item from the cursor is moved to the clicked slot.
			 */
			const PLACE_ONE: org.bukkit.event.inventory.InventoryAction;

			/**
			 * The clicked item and the cursor are exchanged.
			 */
			const SWAP_WITH_CURSOR: org.bukkit.event.inventory.InventoryAction;

			/**
			 * The entire cursor item is dropped.
			 */
			const DROP_ALL_CURSOR: org.bukkit.event.inventory.InventoryAction;

			/**
			 * One item is dropped from the cursor.
			 */
			const DROP_ONE_CURSOR: org.bukkit.event.inventory.InventoryAction;

			/**
			 * The entire clicked slot is dropped.
			 */
			const DROP_ALL_SLOT: org.bukkit.event.inventory.InventoryAction;

			/**
			 * One item is dropped from the clicked slot.
			 */
			const DROP_ONE_SLOT: org.bukkit.event.inventory.InventoryAction;

			/**
			 * The item is moved to the opposite inventory if a space is found.
			 */
			const MOVE_TO_OTHER_INVENTORY: org.bukkit.event.inventory.InventoryAction;

			/**
			 * The clicked item is moved to the hotbar, and the item currently there
			 * is re-added to the player's inventory.
			 * The hotbar includes the player's off hand.
			 */
			const HOTBAR_MOVE_AND_READD: org.bukkit.event.inventory.InventoryAction;

			/**
			 * The clicked slot and the picked hotbar slot are swapped.
			 * The hotbar includes the player's off hand.
			 */
			const HOTBAR_SWAP: org.bukkit.event.inventory.InventoryAction;

			/**
			 * A max-size stack of the clicked item is put on the cursor.
			 */
			const CLONE_STACK: org.bukkit.event.inventory.InventoryAction;

			/**
			 * The inventory is searched for the same material, and they are put on
			 * the cursor up to Material.getMaxStackSize().
			 */
			const COLLECT_TO_CURSOR: org.bukkit.event.inventory.InventoryAction;

			/**
			 * An unrecognized ClickType.
			 */
			const UNKNOWN: org.bukkit.event.inventory.InventoryAction;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.event.inventory.InventoryAction;

		}
		interface InventoryClickEvent extends Modify<org.bukkit.event.inventory.InventoryInteractEvent, {
			/**
			 * Gets the type of slot that was clicked.
			 */
			getSlotType(): org.bukkit.event.inventory.InventoryType.SlotType;

			/**
			 * Gets the current ItemStack on the cursor.
			 */
			getCursor(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Gets the ItemStack currently in the clicked slot.
			 */
			getCurrentItem(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Gets whether or not the ClickType for this event represents a right
			 * click.
			 */
			isRightClick(): boolean;

			/**
			 * Gets whether or not the ClickType for this event represents a left
			 * click.
			 */
			isLeftClick(): boolean;

			/**
			 * Gets whether the ClickType for this event indicates that the key was
			 * pressed down when the click was made.
			 */
			isShiftClick(): boolean;

			/**
			 * Sets the item on the cursor.
			 */
			setCursor(stack: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Sets the ItemStack currently in the clicked slot.
			 */
			setCurrentItem(stack: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Gets the inventory corresponding to the clicked slot.
			 */
			getClickedInventory(): (org.bukkit.inventory.Inventory | null);

			/**
			 * The slot number that was clicked, ready for passing to
			 * Inventory.getItem(int). Note that there may be two slots with
			 * the same slot number, since a view links two different inventories.
			 */
			getSlot(): number;

			/**
			 * The raw slot number clicked, ready for passing to #getItem(int) This slot number is unique for the view.
			 */
			getRawSlot(): number;

			/**
			 * If the ClickType is NUMBER_KEY, this method will return the index of
			 * the pressed key (0-8).
			 */
			getHotbarButton(): number;

			/**
			 * Gets the InventoryAction that triggered this event.
			 * 
			 * This action cannot be changed, and represents what the normal outcome
			 * of the event will be. To change the behavior of this
			 * InventoryClickEvent, changes must be manually applied.
			 */
			getAction(): org.bukkit.event.inventory.InventoryAction;

			/**
			 * Gets the ClickType for this event.
			 * 
			 * This is insulated against changes to the inventory by other plugins.
			 */
			getClick(): org.bukkit.event.inventory.ClickType;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class InventoryClickEvent {
			constructor(view: org.bukkit.inventory.InventoryView, type: org.bukkit.event.inventory.InventoryType.SlotType, slot: number, click: org.bukkit.event.inventory.ClickType, action: org.bukkit.event.inventory.InventoryAction);

			constructor(view: org.bukkit.inventory.InventoryView, type: org.bukkit.event.inventory.InventoryType.SlotType, slot: number, click: org.bukkit.event.inventory.ClickType, action: org.bukkit.event.inventory.InventoryAction, key: number);

		}
		namespace InventoryClickEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface InventoryCloseEvent extends Modify<org.bukkit.event.inventory.InventoryEvent, {
			/**
			 * Returns the player involved in this event
			 */
			getPlayer(): org.bukkit.entity.HumanEntity;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class InventoryCloseEvent {
			constructor(transaction: org.bukkit.inventory.InventoryView);

		}
		namespace InventoryCloseEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface InventoryCreativeEvent extends Modify<org.bukkit.event.inventory.InventoryClickEvent, {
			/**
			 * Description copied from class:Â InventoryClickEvent
			 */
			getCursor(): org.bukkit.inventory.ItemStack;

			/**
			 * Description copied from class:Â InventoryClickEvent
			 */
			setCursor(item: org.bukkit.inventory.ItemStack): void;

		}> {}
		class InventoryCreativeEvent {
			constructor(what: org.bukkit.inventory.InventoryView, type: org.bukkit.event.inventory.InventoryType.SlotType, slot: number, newItem: org.bukkit.inventory.ItemStack);

		}
		interface InventoryDragEvent extends Modify<org.bukkit.event.inventory.InventoryInteractEvent, {
			/**
			 * Gets all items to be added to the inventory in this drag.
			 */
			getNewItems(): globalThis.java.util.Map<number, org.bukkit.inventory.ItemStack>;

			/**
			 * Gets the raw slot ids to be changed in this drag.
			 */
			getRawSlots(): globalThis.java.util.Set<number>;

			/**
			 * Gets the slots to be changed in this drag.
			 */
			getInventorySlots(): globalThis.java.util.Set<number>;

			/**
			 * Gets the result cursor after the drag is done. The returned value is
			 * mutable.
			 */
			getCursor(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Sets the result cursor after the drag is done.
			 * 
			 * Changing this item stack changes the cursor item. Note that changing
			 * the affected "dragged" slots does not change this ItemStack, nor does
			 * changing this ItemStack affect the "dragged" slots.
			 */
			setCursor(newCursor: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Gets an ItemStack representing the cursor prior to any modifications
			 * as a result of this drag.
			 */
			getOldCursor(): org.bukkit.inventory.ItemStack;

			/**
			 * Gets the DragType that describes the behavior of ItemStacks placed
			 * after this InventoryDragEvent.
			 * 
			 * The ItemStacks and the raw slots that they're being applied to can be
			 * found using getNewItems().
			 */
			getType(): org.bukkit.event.inventory.DragType;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class InventoryDragEvent {
			constructor(what: org.bukkit.inventory.InventoryView, newCursor: (org.bukkit.inventory.ItemStack | null), oldCursor: org.bukkit.inventory.ItemStack, right: boolean, slots: globalThis.java.util.Map<number, org.bukkit.inventory.ItemStack>);

		}
		namespace InventoryDragEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface InventoryEvent extends Modify<org.bukkit.event.Event, {
			/**
			 * Gets the primary Inventory involved in this transaction
			 */
			getInventory(): org.bukkit.inventory.Inventory;

			/**
			 * Gets the list of players viewing the primary (upper) inventory involved
			 * in this event
			 */
			getViewers(): globalThis.java.util.List<org.bukkit.entity.HumanEntity>;

			/**
			 * Gets the view object itself
			 */
			getView(): org.bukkit.inventory.InventoryView;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class InventoryEvent {
			constructor(transaction: org.bukkit.inventory.InventoryView);

		}
		namespace InventoryEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface InventoryInteractEvent extends Modify<org.bukkit.event.inventory.InventoryEvent, {
			/**
			 * Gets the player who performed the click.
			 */
			getWhoClicked(): org.bukkit.entity.HumanEntity;

			/**
			 * Sets the result of this event. This will change whether or not this
			 * event is considered cancelled.
			 */
			setResult(newResult: org.bukkit.event.Event.Result): void;

			/**
			 * Gets the Event.Result of this event. The Result describes the
			 * behavior that will be applied to the inventory in relation to this
			 * event.
			 */
			getResult(): org.bukkit.event.Event.Result;

			/**
			 * Gets whether or not this event is cancelled. This is based off of the
			 * Result value returned by getResult(). Result.ALLOW and
			 * Result.DEFAULT will result in a returned value of false, but
			 * Result.DENY will result in a returned value of true.
			 * 
			 * Gets the cancellation state of this event. A cancelled event will not
			 * be executed in the server, but will still pass to other plugins
			 */
			isCancelled(): boolean;

			/**
			 * Proxy method to setResult(org.bukkit.event.Event.Result) for the Cancellable
			 * interface. setResult(org.bukkit.event.Event.Result) is preferred, as it allows
			 * you to specify the Result beyond Result.DENY and Result.ALLOW.
			 * 
			 * Sets the cancellation state of this event. A cancelled event will not
			 * be executed in the server, but will still pass to other plugins.
			 */
			setCancelled(toCancel: boolean): void;

		}> {}
		class InventoryInteractEvent {
			constructor(transaction: org.bukkit.inventory.InventoryView);

		}
		interface InventoryMoveItemEvent extends Modify<org.bukkit.event.Event, {
			/**
			 * Gets the Inventory that the ItemStack is being taken from
			 */
			getSource(): org.bukkit.inventory.Inventory;

			/**
			 * Gets the ItemStack being moved; if modified, the original item will not
			 * be removed from the source inventory.
			 */
			getItem(): org.bukkit.inventory.ItemStack;

			/**
			 * Sets the ItemStack being moved; if this is different from the original
			 * ItemStack, the original item will not be removed from the source
			 * inventory.
			 */
			setItem(itemStack: org.bukkit.inventory.ItemStack): void;

			/**
			 * Gets the Inventory that the ItemStack is being put into
			 */
			getDestination(): org.bukkit.inventory.Inventory;

			/**
			 * Gets the Inventory that initiated the transfer. This will always be
			 * either the destination or source Inventory.
			 */
			getInitiator(): org.bukkit.inventory.Inventory;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class InventoryMoveItemEvent {
			constructor(sourceInventory: org.bukkit.inventory.Inventory, itemStack: org.bukkit.inventory.ItemStack, destinationInventory: org.bukkit.inventory.Inventory, didSourceInitiate: boolean);

		}
		namespace InventoryMoveItemEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface InventoryOpenEvent extends Modify<org.bukkit.event.inventory.InventoryEvent, {
			/**
			 * Returns the player involved in this event
			 */
			getPlayer(): org.bukkit.entity.HumanEntity;

			/**
			 * Gets the cancellation state of this event. A cancelled event will not
			 * be executed in the server, but will still pass to other plugins.
			 * 
			 * If an inventory open event is cancelled, the inventory screen will not
			 * show.
			 */
			isCancelled(): boolean;

			/**
			 * Sets the cancellation state of this event. A cancelled event will not
			 * be executed in the server, but will still pass to other plugins.
			 * 
			 * If an inventory open event is cancelled, the inventory screen will not
			 * show.
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class InventoryOpenEvent {
			constructor(transaction: org.bukkit.inventory.InventoryView);

		}
		namespace InventoryOpenEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface InventoryPickupItemEvent extends Modify<org.bukkit.event.Event, {
			/**
			 * Gets the Inventory that picked up the item
			 */
			getInventory(): org.bukkit.inventory.Inventory;

			/**
			 * Gets the Item entity that was picked up
			 */
			getItem(): org.bukkit.entity.Item;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class InventoryPickupItemEvent {
			constructor(inventory: org.bukkit.inventory.Inventory, item: org.bukkit.entity.Item);

		}
		namespace InventoryPickupItemEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface InventoryType {
			getDefaultSize(): number;

			getDefaultTitle(): string;

			/**
			 * Denotes that this InventoryType can be created via the normal
			 * Bukkit.createInventory(org.bukkit.inventory.InventoryHolder, org.bukkit.event.inventory.InventoryType) methods.
			 */
			isCreatable(): boolean;

		}
		namespace InventoryType {
			/**
			 * A chest inventory, with 0, 9, 18, 27, 36, 45, or 54 slots of type
			 * CONTAINER.
			 */
			const CHEST: org.bukkit.event.inventory.InventoryType;

			/**
			 * A dispenser inventory, with 9 slots of type CONTAINER.
			 */
			const DISPENSER: org.bukkit.event.inventory.InventoryType;

			/**
			 * A dropper inventory, with 9 slots of type CONTAINER.
			 */
			const DROPPER: org.bukkit.event.inventory.InventoryType;

			/**
			 * A furnace inventory, with a RESULT slot, a CRAFTING slot, and a FUEL
			 * slot.
			 */
			const FURNACE: org.bukkit.event.inventory.InventoryType;

			/**
			 * A workbench inventory, with 9 CRAFTING slots and a RESULT slot.
			 */
			const WORKBENCH: org.bukkit.event.inventory.InventoryType;

			/**
			 * A player's crafting inventory, with 4 CRAFTING slots and a RESULT slot.
			 * Also implies that the 4 ARMOR slots are accessible.
			 */
			const CRAFTING: org.bukkit.event.inventory.InventoryType;

			/**
			 * An enchantment table inventory, with two CRAFTING slots and three
			 * enchanting buttons.
			 */
			const ENCHANTING: org.bukkit.event.inventory.InventoryType;

			/**
			 * A brewing stand inventory, with one FUEL slot and four CRAFTING slots.
			 */
			const BREWING: org.bukkit.event.inventory.InventoryType;

			/**
			 * A player's inventory, with 9 QUICKBAR slots, 27 CONTAINER slots, 4 ARMOR
			 * slots and 1 offhand slot. The ARMOR and offhand slots may not be visible
			 * to the player, though.
			 */
			const PLAYER: org.bukkit.event.inventory.InventoryType;

			/**
			 * The creative mode inventory, with only 9 QUICKBAR slots and nothing
			 * else. (The actual creative interface with the items is client-side and
			 * cannot be altered by the server.)
			 */
			const CREATIVE: org.bukkit.event.inventory.InventoryType;

			/**
			 * The merchant inventory, with 2 CRAFTING slots, and 1 RESULT slot.
			 */
			const MERCHANT: org.bukkit.event.inventory.InventoryType;

			/**
			 * The ender chest inventory, with 27 slots.
			 */
			const ENDER_CHEST: org.bukkit.event.inventory.InventoryType;

			/**
			 * An anvil inventory, with 2 CRAFTING slots and 1 RESULT slot
			 */
			const ANVIL: org.bukkit.event.inventory.InventoryType;

			/**
			 * A smithing inventory, with 3 CRAFTING slots and 1 RESULT slot.
			 */
			const SMITHING: org.bukkit.event.inventory.InventoryType;

			/**
			 * A beacon inventory, with 1 CRAFTING slot
			 */
			const BEACON: org.bukkit.event.inventory.InventoryType;

			/**
			 * A hopper inventory, with 5 slots of type CONTAINER.
			 */
			const HOPPER: org.bukkit.event.inventory.InventoryType;

			/**
			 * A shulker box inventory, with 27 slots of type CONTAINER.
			 */
			const SHULKER_BOX: org.bukkit.event.inventory.InventoryType;

			/**
			 * A barrel box inventory, with 27 slots of type CONTAINER.
			 */
			const BARREL: org.bukkit.event.inventory.InventoryType;

			/**
			 * A blast furnace inventory, with a RESULT slot, a CRAFTING slot, and a
			 * FUEL slot.
			 */
			const BLAST_FURNACE: org.bukkit.event.inventory.InventoryType;

			/**
			 * A lectern inventory, with 1 BOOK slot.
			 */
			const LECTERN: org.bukkit.event.inventory.InventoryType;

			/**
			 * A smoker inventory, with a RESULT slot, a CRAFTING slot, and a FUEL slot.
			 */
			const SMOKER: org.bukkit.event.inventory.InventoryType;

			/**
			 * Loom inventory, with 3 CRAFTING slots, and 1 RESULT slot.
			 */
			const LOOM: org.bukkit.event.inventory.InventoryType;

			/**
			 * Cartography inventory with 2 CRAFTING slots, and 1 RESULT slot.
			 */
			const CARTOGRAPHY: org.bukkit.event.inventory.InventoryType;

			/**
			 * Grindstone inventory with 2 CRAFTING slots, and 1 RESULT slot.
			 */
			const GRINDSTONE: org.bukkit.event.inventory.InventoryType;

			/**
			 * Stonecutter inventory with 1 CRAFTING slot, and 1 RESULT slot.
			 */
			const STONECUTTER: org.bukkit.event.inventory.InventoryType;

			/**
			 * Pseudo composter inventory with 0 or 1 slots of undefined type.
			 */
			const COMPOSTER: org.bukkit.event.inventory.InventoryType;

			/**
			 * Pseudo chiseled bookshelf inventory, with 6 slots of undefined type.
			 */
			const CHISELED_BOOKSHELF: org.bukkit.event.inventory.InventoryType;

			/**
			 * Pseudo jukebox inventory with 1 slot of undefined type.
			 */
			const JUKEBOX: org.bukkit.event.inventory.InventoryType;

			/**
			 * A crafter inventory, with 9 CRAFTING slots.
			 */
			const CRAFTER: org.bukkit.event.inventory.InventoryType;

			/**
			 * The new smithing inventory, with 3 CRAFTING slots and 1 RESULT slot.
			 */
			const SMITHING_NEW: org.bukkit.event.inventory.InventoryType;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.event.inventory.InventoryType;

		}
		namespace InventoryType {
			interface SlotType {}
			namespace SlotType {
				/**
				 * A result slot in a furnace or crafting inventory.
				 */
				const RESULT: org.bukkit.event.inventory.InventoryType.SlotType;

				/**
				 * A slot in the crafting matrix, or an 'input' slot.
				 */
				const CRAFTING: org.bukkit.event.inventory.InventoryType.SlotType;

				/**
				 * An armour slot in the player's inventory.
				 */
				const ARMOR: org.bukkit.event.inventory.InventoryType.SlotType;

				/**
				 * A regular slot in the container or the player's inventory; anything
				 * not covered by the other enum values.
				 */
				const CONTAINER: org.bukkit.event.inventory.InventoryType.SlotType;

				/**
				 * A slot in the bottom row or quickbar.
				 */
				const QUICKBAR: org.bukkit.event.inventory.InventoryType.SlotType;

				/**
				 * A pseudo-slot representing the area outside the inventory window.
				 */
				const OUTSIDE: org.bukkit.event.inventory.InventoryType.SlotType;

				/**
				 * The fuel slot in a furnace inventory, or the ingredient slot in a
				 * brewing stand inventory.
				 */
				const FUEL: org.bukkit.event.inventory.InventoryType.SlotType;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.inventory.InventoryType.SlotType;

			}
		}
		interface PrepareAnvilEvent extends Modify<org.bukkit.event.inventory.PrepareInventoryResultEvent, {
			/**
			 * Description copied from class:Â InventoryEvent
			 */
			getInventory(): org.bukkit.inventory.AnvilInventory;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PrepareAnvilEvent {
			constructor(inventory: org.bukkit.inventory.InventoryView, result: (org.bukkit.inventory.ItemStack | null));

		}
		namespace PrepareAnvilEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PrepareGrindstoneEvent extends Modify<org.bukkit.event.inventory.PrepareInventoryResultEvent, {
			/**
			 * Description copied from class:Â InventoryEvent
			 */
			getInventory(): org.bukkit.inventory.GrindstoneInventory;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PrepareGrindstoneEvent {
			constructor(inventory: org.bukkit.inventory.InventoryView, result: (org.bukkit.inventory.ItemStack | null));

		}
		namespace PrepareGrindstoneEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PrepareInventoryResultEvent extends Modify<org.bukkit.event.inventory.InventoryEvent, {
			/**
			 * Get result item, may be null.
			 */
			getResult(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Set result item, may be null.
			 */
			setResult(result: (org.bukkit.inventory.ItemStack | null)): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PrepareInventoryResultEvent {
			constructor(inventory: org.bukkit.inventory.InventoryView, result: (org.bukkit.inventory.ItemStack | null));

		}
		namespace PrepareInventoryResultEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PrepareItemCraftEvent extends Modify<org.bukkit.event.inventory.InventoryEvent, {
			/**
			 * Get the recipe that has been formed. If this event was triggered by a
			 * tool repair, this will be a temporary shapeless recipe representing the
			 * repair.
			 */
			getRecipe(): (org.bukkit.inventory.Recipe | null);

			/**
			 * Description copied from class:Â InventoryEvent
			 */
			getInventory(): org.bukkit.inventory.CraftingInventory;

			/**
			 * Check if this event was triggered by a tool repair operation rather
			 * than a crafting recipe.
			 */
			isRepair(): boolean;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PrepareItemCraftEvent {
			constructor(what: org.bukkit.inventory.CraftingInventory, view: org.bukkit.inventory.InventoryView, isRepair: boolean);

		}
		namespace PrepareItemCraftEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PrepareSmithingEvent extends Modify<org.bukkit.event.inventory.PrepareInventoryResultEvent, {
			/**
			 * Description copied from class:Â InventoryEvent
			 */
			getInventory(): org.bukkit.inventory.SmithingInventory;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PrepareSmithingEvent {
			constructor(inventory: org.bukkit.inventory.InventoryView, result: (org.bukkit.inventory.ItemStack | null));

		}
		namespace PrepareSmithingEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface SmithItemEvent extends Modify<org.bukkit.event.inventory.InventoryClickEvent, {
			/**
			 * Description copied from class:Â InventoryEvent
			 */
			getInventory(): org.bukkit.inventory.SmithingInventory;

		}> {}
		class SmithItemEvent {
			constructor(view: org.bukkit.inventory.InventoryView, type: org.bukkit.event.inventory.InventoryType.SlotType, slot: number, click: org.bukkit.event.inventory.ClickType, action: org.bukkit.event.inventory.InventoryAction);

			constructor(view: org.bukkit.inventory.InventoryView, type: org.bukkit.event.inventory.InventoryType.SlotType, slot: number, click: org.bukkit.event.inventory.ClickType, action: org.bukkit.event.inventory.InventoryAction, key: number);

		}
		interface TradeSelectEvent extends Modify<org.bukkit.event.inventory.InventoryInteractEvent, {
			/**
			 * Used to get the index of the trade the player clicked on.
			 */
			getIndex(): number;

			/**
			 * Description copied from class:Â InventoryEvent
			 */
			getInventory(): org.bukkit.inventory.MerchantInventory;

			/**
			 * Get the Merchant involved.
			 */
			getMerchant(): org.bukkit.inventory.Merchant;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class TradeSelectEvent {
			constructor(transaction: org.bukkit.inventory.InventoryView, newIndex: number);

		}
		namespace TradeSelectEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
	}
	namespace org.bukkit.event.server {
		interface BroadcastMessageEvent extends Modify<org.bukkit.event.server.ServerEvent, {
			/**
			 * Get the message to broadcast.
			 */
			getMessage(): string;

			/**
			 * Set the message to broadcast.
			 */
			setMessage(message: string): void;

			/**
			 * Gets a set of recipients that this chat message will be displayed to.
			 * 
			 * The set returned is not guaranteed to be mutable and may auto-populate
			 * on access. Any listener accessing the returned set should be aware that
			 * it may reduce performance for a lazy set implementation.
			 * 
			 * Listeners should be aware that modifying the list may throw UnsupportedOperationException if the event caller provides an
			 * unmodifiable set.
			 */
			getRecipients(): globalThis.java.util.Set<org.bukkit.command.CommandSender>;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancelled: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class BroadcastMessageEvent {
			constructor(message: string, recipients: globalThis.java.util.Set<org.bukkit.command.CommandSender>);

			constructor(isAsync: boolean, message: string, recipients: globalThis.java.util.Set<org.bukkit.command.CommandSender>);

		}
		namespace BroadcastMessageEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface MapInitializeEvent extends Modify<org.bukkit.event.server.ServerEvent, {
			/**
			 * Gets the map initialized in this event.
			 */
			getMap(): org.bukkit.map.MapView;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class MapInitializeEvent {
			constructor(mapView: org.bukkit.map.MapView);

		}
		namespace MapInitializeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PluginDisableEvent extends Modify<org.bukkit.event.server.PluginEvent, {
			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PluginDisableEvent {
			constructor(plugin: org.bukkit.plugin.Plugin);

		}
		namespace PluginDisableEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PluginEnableEvent extends Modify<org.bukkit.event.server.PluginEvent, {
			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PluginEnableEvent {
			constructor(plugin: org.bukkit.plugin.Plugin);

		}
		namespace PluginEnableEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PluginEvent extends Modify<org.bukkit.event.server.ServerEvent, {
			/**
			 * Gets the plugin involved in this event
			 */
			getPlugin(): org.bukkit.plugin.Plugin;

		}> {}
		class PluginEvent {
			constructor(plugin: org.bukkit.plugin.Plugin);

		}
		interface RemoteServerCommandEvent extends Modify<org.bukkit.event.server.ServerCommandEvent, {
			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class RemoteServerCommandEvent {
			constructor(sender: org.bukkit.command.CommandSender, command: string);

		}
		namespace RemoteServerCommandEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface ServerCommandEvent extends Modify<org.bukkit.event.server.ServerEvent, {
			/**
			 * Gets the command that the user is attempting to execute from the
			 * console
			 */
			getCommand(): string;

			/**
			 * Sets the command that the server will execute
			 */
			setCommand(message: string): void;

			/**
			 * Get the command sender.
			 */
			getSender(): org.bukkit.command.CommandSender;

			getHandlers(): org.bukkit.event.HandlerList;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

		}> {}
		class ServerCommandEvent {
			constructor(sender: org.bukkit.command.CommandSender, command: string);

		}
		namespace ServerCommandEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface ServerEvent extends Modify<org.bukkit.event.Event, {
		}> {}
		class ServerEvent {
			constructor();

			constructor(isAsync: boolean);

		}
		interface ServerListPingEvent extends Modify<org.bukkit.event.server.ServerEvent, {
			/**
			 * Gets the hostname that the player used to connect to the server, or
			 * blank if unknown
			 */
			getHostname(): string;

			/**
			 * Get the address the ping is coming from.
			 */
			getAddress(): any /* java.net.InetAddress */;

			/**
			 * Get the message of the day message.
			 */
			getMotd(): string;

			/**
			 * Change the message of the day message.
			 */
			setMotd(motd: string): void;

			/**
			 * Get the number of players sent.
			 */
			getNumPlayers(): number;

			/**
			 * Get the maximum number of players sent.
			 */
			getMaxPlayers(): number;

			/**
			 * Gets whether the server needs to send a preview of the chat to the
			 * client.
			 */
			shouldSendChatPreviews(): boolean;

			/**
			 * Set the maximum number of players sent.
			 */
			setMaxPlayers(maxPlayers: number): void;

			/**
			 * Sets the server-icon sent to the client.
			 */
			setServerIcon(icon: org.bukkit.util.CachedServerIcon): void;

			getHandlers(): org.bukkit.event.HandlerList;

			/**
			 * 
			 * 
			 * Calling the Iterator.remove() method will force that particular
			 * player to not be displayed on the player list, decrease the size
			 * returned by getNumPlayers(), and will not be returned again by
			 * any new iterator.
			 * 
			 * Note: The players here will not be shown in the server info if
			 * Bukkit.getHideOnlinePlayers() is true.
			 */
			iterator(): globalThis.java.util.Iterator<org.bukkit.entity.Player>;

		}> {}
		class ServerListPingEvent {
			constructor(hostname: string, address: any /* java.net.InetAddress */, motd: string, numPlayers: number, maxPlayers: number);

		}
		namespace ServerListPingEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface ServerLoadEvent extends Modify<org.bukkit.event.server.ServerEvent, {
			/**
			 * Gets the context in which the server was loaded.
			 */
			getType(): org.bukkit.event.server.ServerLoadEvent.LoadType;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class ServerLoadEvent {
			/**
			 * Creates a ServerLoadEvent with a given loading type.
			 */
			constructor(type: org.bukkit.event.server.ServerLoadEvent.LoadType);

		}
		namespace ServerLoadEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace ServerLoadEvent {
			interface LoadType {}
			namespace LoadType {
				const STARTUP: org.bukkit.event.server.ServerLoadEvent.LoadType;

				const RELOAD: org.bukkit.event.server.ServerLoadEvent.LoadType;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.server.ServerLoadEvent.LoadType;

			}
		}
		interface ServiceEvent extends Modify<org.bukkit.event.server.ServerEvent, {
			getProvider(): org.bukkit.plugin.RegisteredServiceProvider;

		}> {}
		class ServiceEvent {
			constructor(provider: org.bukkit.plugin.RegisteredServiceProvider);

		}
		interface ServiceRegisterEvent extends Modify<org.bukkit.event.server.ServiceEvent, {
			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class ServiceRegisterEvent {
			constructor(registeredProvider: org.bukkit.plugin.RegisteredServiceProvider);

		}
		namespace ServiceRegisterEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface ServiceUnregisterEvent extends Modify<org.bukkit.event.server.ServiceEvent, {
			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class ServiceUnregisterEvent {
			constructor(serviceProvider: org.bukkit.plugin.RegisteredServiceProvider);

		}
		namespace ServiceUnregisterEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface TabCompleteEvent extends Modify<org.bukkit.event.Event, {
			/**
			 * Get the sender completing this command.
			 */
			getSender(): org.bukkit.command.CommandSender;

			/**
			 * Return the entire buffer which formed the basis of this completion.
			 */
			getBuffer(): string;

			/**
			 * The list of completions which will be offered to the sender, in order.
			 * This list is mutable and reflects what will be offered.
			 */
			getCompletions(): globalThis.java.util.List<string>;

			/**
			 * Set the completions offered, overriding any already set.
			 */
			setCompletions(completions: globalThis.java.util.List<string>): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancelled: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class TabCompleteEvent {
			constructor(sender: org.bukkit.command.CommandSender, buffer: string, completions: globalThis.java.util.List<string>);

		}
		namespace TabCompleteEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
	}
	namespace org.bukkit.util.permissions {
		interface BroadcastPermissions {}
		namespace BroadcastPermissions {
			function registerPermissions(parent: org.bukkit.permissions.Permission): org.bukkit.permissions.Permission;

		}
		interface CommandPermissions {}
		namespace CommandPermissions {
			function registerPermissions(parent: org.bukkit.permissions.Permission): org.bukkit.permissions.Permission;

		}
		interface DefaultPermissions {}
		namespace DefaultPermissions {
			function registerPermission(perm: org.bukkit.permissions.Permission): org.bukkit.permissions.Permission;

			function registerPermission(perm: org.bukkit.permissions.Permission, withLegacy: boolean): org.bukkit.permissions.Permission;

			function registerPermission(perm: org.bukkit.permissions.Permission, parent: org.bukkit.permissions.Permission): org.bukkit.permissions.Permission;

			function registerPermission(name: string, desc: (string | null)): org.bukkit.permissions.Permission;

			function registerPermission(name: string, desc: (string | null), parent: org.bukkit.permissions.Permission): org.bukkit.permissions.Permission;

			function registerPermission(name: string, desc: (string | null), def: (org.bukkit.permissions.PermissionDefault | null)): org.bukkit.permissions.Permission;

			function registerPermission(name: string, desc: (string | null), def: (org.bukkit.permissions.PermissionDefault | null), parent: org.bukkit.permissions.Permission): org.bukkit.permissions.Permission;

			function registerPermission(name: string, desc: (string | null), def: (org.bukkit.permissions.PermissionDefault | null), children: (globalThis.java.util.Map<string, boolean> | null)): org.bukkit.permissions.Permission;

			function registerPermission(name: string, desc: (string | null), def: (org.bukkit.permissions.PermissionDefault | null), children: (globalThis.java.util.Map<string, boolean> | null), parent: org.bukkit.permissions.Permission): org.bukkit.permissions.Permission;

			function registerCorePermissions(): void;

		}
	}
	namespace org.bukkit.damage {
		interface DamageEffect {
			/**
			 * Get the Sound played for this DamageEffect.
			 */
			getSound(): org.bukkit.Sound;

		}
		namespace DamageEffect {
			/**
			 * The default damage effect.
			 */
			const HURT: org.bukkit.damage.DamageEffect;

			/**
			 * Thorns.
			 */
			const THORNS: org.bukkit.damage.DamageEffect;

			/**
			 * Drowning.
			 */
			const DROWNING: org.bukkit.damage.DamageEffect;

			/**
			 * A single burn tick (fire, lava, etc.).
			 */
			const BURNING: org.bukkit.damage.DamageEffect;

			/**
			 * Poked by a berry bush.
			 */
			const POKING: org.bukkit.damage.DamageEffect;

			/**
			 * Freeze tick (powder snow).
			 */
			const FREEZING: org.bukkit.damage.DamageEffect;

		}
		interface DamageScaling {}
		namespace DamageScaling {
			/**
			 * Damage is not scaled.
			 */
			const NEVER: org.bukkit.damage.DamageScaling;

			/**
			 * Damage is scaled only when the
			 * causing entity is not a
			 * Player.
			 */
			const WHEN_CAUSED_BY_LIVING_NON_PLAYER: org.bukkit.damage.DamageScaling;

			/**
			 * Damage is always scaled.
			 */
			const ALWAYS: org.bukkit.damage.DamageScaling;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.damage.DamageScaling;

		}
		interface DamageSource {
			/**
			 * Get the DamageType.
			 */
			getDamageType(): org.bukkit.damage.DamageType;

			/**
			 * Get the Entity that caused the damage to occur.
			 * 
			 * Not to be confused with getDirectEntity(), the causing entity is
			 * the entity to which the damage is ultimately attributed if the receiver
			 * is killed. If, for example, the receiver was damaged by a projectile, the
			 * shooter/thrower would be returned.
			 */
			getCausingEntity(): (org.bukkit.entity.Entity | null);

			/**
			 * Get the Entity that directly caused the damage.
			 * 
			 * Not to be confused with getCausingEntity(), the direct entity is
			 * the entity that actually inflicted the damage. If, for example, the
			 * receiver was damaged by a projectile, the projectile would be returned.
			 */
			getDirectEntity(): (org.bukkit.entity.Entity | null);

			/**
			 * Get the Location from where the damage originated. This will only
			 * be present if an entity did not cause the damage.
			 */
			getDamageLocation(): (org.bukkit.Location | null);

			/**
			 * Get the Location from where the damage originated.
			 * 
			 * This is a convenience method to get the final location of the damage.
			 * This method will attempt to return
			 * the damage location. If this is null, the
			 * causing entity location will be returned.
			 * Finally if there is no damage location nor a causing entity, null will be
			 * returned.
			 */
			getSourceLocation(): (org.bukkit.Location | null);

			/**
			 * Get if this damage is indirect.
			 * 
			 * Damage is considered indirect if getCausingEntity() is not equal
			 * to getDirectEntity(). This will be the case, for example, if a
			 * skeleton shot an arrow or a player threw a potion.
			 */
			isIndirect(): boolean;

			/**
			 * Get the amount of hunger exhaustion caused by this damage.
			 */
			getFoodExhaustion(): number;

			/**
			 * Gets if this source of damage scales with difficulty.
			 */
			scalesWithDifficulty(): boolean;

		}
		namespace DamageSource {
			/**
			 * Create a new DamageSource.Builder.
			 */
			function builder(damageType: org.bukkit.damage.DamageType): org.bukkit.damage.DamageSource.Builder;

		}
		namespace DamageSource {
			interface Builder {
				/**
				 * Set the Entity that caused the damage.
				 */
				withCausingEntity(entity: org.bukkit.entity.Entity): org.bukkit.damage.DamageSource.Builder;

				/**
				 * Set the Entity that directly inflicted the damage.
				 */
				withDirectEntity(entity: org.bukkit.entity.Entity): org.bukkit.damage.DamageSource.Builder;

				/**
				 * Set the Location of the source of damage.
				 */
				withDamageLocation(location: org.bukkit.Location): org.bukkit.damage.DamageSource.Builder;

				/**
				 * Create a new DamageSource instance using the supplied
				 * parameters.
				 */
				build(): org.bukkit.damage.DamageSource;

			}
		}
		interface DamageType extends Modify<org.bukkit.Keyed & org.bukkit.Translatable, {
			/**
			 * Get the translation key, suitable for use in a translation component.
			 * 
			 * The returned key is that of the death message sent when this damage type
			 * is responsible for the death of an entity.
			 * 
			 * Note This translation key is only used if
			 * getDeathMessageType() is DeathMessageType.DEFAULT
			 */
			getTranslationKey(): string;

			/**
			 * Get the DamageScaling for this damage type.
			 */
			getDamageScaling(): org.bukkit.damage.DamageScaling;

			/**
			 * Get the DamageEffect for this damage type.
			 */
			getDamageEffect(): org.bukkit.damage.DamageEffect;

			/**
			 * Get the DeathMessageType for this damage type.
			 */
			getDeathMessageType(): org.bukkit.damage.DeathMessageType;

			/**
			 * Get the amount of hunger exhaustion caused by this damage type.
			 */
			getExhaustion(): number;

		}> {}
		namespace DamageType {
			const IN_FIRE: org.bukkit.damage.DamageType;

			const CAMPFIRE: org.bukkit.damage.DamageType;

			const LIGHTNING_BOLT: org.bukkit.damage.DamageType;

			const ON_FIRE: org.bukkit.damage.DamageType;

			const LAVA: org.bukkit.damage.DamageType;

			const HOT_FLOOR: org.bukkit.damage.DamageType;

			const IN_WALL: org.bukkit.damage.DamageType;

			const CRAMMING: org.bukkit.damage.DamageType;

			const DROWN: org.bukkit.damage.DamageType;

			const STARVE: org.bukkit.damage.DamageType;

			const CACTUS: org.bukkit.damage.DamageType;

			const FALL: org.bukkit.damage.DamageType;

			const FLY_INTO_WALL: org.bukkit.damage.DamageType;

			const OUT_OF_WORLD: org.bukkit.damage.DamageType;

			const GENERIC: org.bukkit.damage.DamageType;

			const MAGIC: org.bukkit.damage.DamageType;

			const WITHER: org.bukkit.damage.DamageType;

			const DRAGON_BREATH: org.bukkit.damage.DamageType;

			const DRY_OUT: org.bukkit.damage.DamageType;

			const SWEET_BERRY_BUSH: org.bukkit.damage.DamageType;

			const FREEZE: org.bukkit.damage.DamageType;

			const STALAGMITE: org.bukkit.damage.DamageType;

			const FALLING_BLOCK: org.bukkit.damage.DamageType;

			const FALLING_ANVIL: org.bukkit.damage.DamageType;

			const FALLING_STALACTITE: org.bukkit.damage.DamageType;

			const STING: org.bukkit.damage.DamageType;

			const MOB_ATTACK: org.bukkit.damage.DamageType;

			const MOB_ATTACK_NO_AGGRO: org.bukkit.damage.DamageType;

			const PLAYER_ATTACK: org.bukkit.damage.DamageType;

			const ARROW: org.bukkit.damage.DamageType;

			const TRIDENT: org.bukkit.damage.DamageType;

			const MOB_PROJECTILE: org.bukkit.damage.DamageType;

			const SPIT: org.bukkit.damage.DamageType;

			const FIREWORKS: org.bukkit.damage.DamageType;

			const FIREBALL: org.bukkit.damage.DamageType;

			const UNATTRIBUTED_FIREBALL: org.bukkit.damage.DamageType;

			const WITHER_SKULL: org.bukkit.damage.DamageType;

			const THROWN: org.bukkit.damage.DamageType;

			const INDIRECT_MAGIC: org.bukkit.damage.DamageType;

			const THORNS: org.bukkit.damage.DamageType;

			const EXPLOSION: org.bukkit.damage.DamageType;

			const PLAYER_EXPLOSION: org.bukkit.damage.DamageType;

			const SONIC_BOOM: org.bukkit.damage.DamageType;

			const BAD_RESPAWN_POINT: org.bukkit.damage.DamageType;

			const OUTSIDE_BORDER: org.bukkit.damage.DamageType;

			const GENERIC_KILL: org.bukkit.damage.DamageType;

		}
		interface DeathMessageType {}
		namespace DeathMessageType {
			/**
			 * No special death message logic is applied.
			 */
			const DEFAULT: org.bukkit.damage.DeathMessageType;

			/**
			 * Shows a variant of fall damage death instead of a regular death message.
			 * 
			 * Example: death.fell.assist.item
			 */
			const FALL_VARIANTS: org.bukkit.damage.DeathMessageType;

			/**
			 * Shows the intentional game design death message instead of a regular
			 * death message.
			 */
			const INTENTIONAL_GAME_DESIGN: org.bukkit.damage.DeathMessageType;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.damage.DeathMessageType;

		}
	}
	namespace org.bukkit.loot {
		interface LootContext {
			/**
			 * The Location to store where the loot will be generated.
			 */
			getLocation(): org.bukkit.Location;

			/**
			 * Represents the PotionEffectType.LUCK that an
			 * entity can have. The higher the value the better chance of receiving more
			 * loot.
			 */
			getLuck(): number;

			/**
			 * Represents the
			 * Enchantment.LOOTING the
			 * getKiller() entity has on their equipped item.
			 * This value is only set via
			 * LootContext.Builder.lootingModifier(int). If not set, the
			 * getKiller() entity's looting level will be used instead.
			 */
			getLootingModifier(): number;

			/**
			 * Get the Entity that was killed. Can be null.
			 */
			getLootedEntity(): (org.bukkit.entity.Entity | null);

			/**
			 * Get the HumanEntity who killed the getLootedEntity().
			 * Can be null.
			 */
			getKiller(): (org.bukkit.entity.HumanEntity | null);

		}
		namespace LootContext {
			const DEFAULT_LOOT_MODIFIER: number;

		}
		namespace LootContext {
			interface Builder {
				/**
				 * Set how much luck to have when generating loot.
				 */
				luck(luck: number): org.bukkit.loot.LootContext.Builder;

				/**
				 * Set the Enchantment.LOOTING
				 * level equivalent to use when generating loot. Values less than or
				 * equal to 0 will force the LootTable to only return a single
				 * ItemStack per pool.
				 */
				lootingModifier(modifier: number): org.bukkit.loot.LootContext.Builder;

				/**
				 * The entity that was killed.
				 */
				lootedEntity(lootedEntity: (org.bukkit.entity.Entity | null)): org.bukkit.loot.LootContext.Builder;

				/**
				 * Set the HumanEntity that killed
				 * LootContext.getLootedEntity(). This entity will be used to get the
				 * looting level if lootingModifier(int) is not set.
				 */
				killer(killer: (org.bukkit.entity.HumanEntity | null)): org.bukkit.loot.LootContext.Builder;

				/**
				 * Create a new LootContext instance using the supplied
				 * parameters.
				 */
				build(): org.bukkit.loot.LootContext;

			}
			class Builder {
				/**
				 * Creates a new LootContext.Builder instance to facilitate easy
				 * creation of LootContexts.
				 */
				constructor(location: org.bukkit.Location);

			}
		}
		interface LootTable extends Modify<org.bukkit.Keyed, {
			/**
			 * Returns a mutable list of loot generated by this LootTable.
			 */
			populateLoot(random: (globalThis.java.util.Random | null), context: org.bukkit.loot.LootContext): globalThis.java.util.Collection<org.bukkit.inventory.ItemStack>;

			/**
			 * Attempt to fill an inventory with this LootTable's loot.
			 */
			fillInventory(inventory: org.bukkit.inventory.Inventory, random: (globalThis.java.util.Random | null), context: org.bukkit.loot.LootContext): void;

		}> {}
		interface LootTables {
			/**
			 * Description copied from interface:Â Keyed
			 */
			getKey(): org.bukkit.NamespacedKey;

			/**
			 * Get the LootTable corresponding to this constant. This is
			 * equivalent to calling Bukkit.getLootTable(this.getKey());.
			 */
			getLootTable(): org.bukkit.loot.LootTable;

		}
		namespace LootTables {
			const EMPTY: org.bukkit.loot.LootTables;

			const ABANDONED_MINESHAFT: org.bukkit.loot.LootTables;

			const BURIED_TREASURE: org.bukkit.loot.LootTables;

			const DESERT_PYRAMID: org.bukkit.loot.LootTables;

			const END_CITY_TREASURE: org.bukkit.loot.LootTables;

			const IGLOO_CHEST: org.bukkit.loot.LootTables;

			const JUNGLE_TEMPLE: org.bukkit.loot.LootTables;

			const JUNGLE_TEMPLE_DISPENSER: org.bukkit.loot.LootTables;

			const NETHER_BRIDGE: org.bukkit.loot.LootTables;

			const PILLAGER_OUTPOST: org.bukkit.loot.LootTables;

			const BASTION_TREASURE: org.bukkit.loot.LootTables;

			const BASTION_OTHER: org.bukkit.loot.LootTables;

			const BASTION_BRIDGE: org.bukkit.loot.LootTables;

			const BASTION_HOGLIN_STABLE: org.bukkit.loot.LootTables;

			const ANCIENT_CITY: org.bukkit.loot.LootTables;

			const ANCIENT_CITY_ICE_BOX: org.bukkit.loot.LootTables;

			const RUINED_PORTAL: org.bukkit.loot.LootTables;

			const TRIAL_CHAMBERS_REWARD: org.bukkit.loot.LootTables;

			const TRIAL_CHAMBERS_REWARD_COMMON: org.bukkit.loot.LootTables;

			const TRIAL_CHAMBERS_REWARD_RARE: org.bukkit.loot.LootTables;

			const TRIAL_CHAMBERS_REWARD_UNIQUE: org.bukkit.loot.LootTables;

			const TRIAL_CHAMBERS_REWARD_OMINOUS: org.bukkit.loot.LootTables;

			const TRIAL_CHAMBERS_REWARD_OMINOUS_COMMON: org.bukkit.loot.LootTables;

			const TRIAL_CHAMBERS_REWARD_OMINOUS_RARE: org.bukkit.loot.LootTables;

			const TRIAL_CHAMBERS_REWARD_OMINOUS_UNIQUE: org.bukkit.loot.LootTables;

			const TRIAL_CHAMBERS_SUPPLY: org.bukkit.loot.LootTables;

			const TRIAL_CHAMBERS_CORRIDOR: org.bukkit.loot.LootTables;

			const TRIAL_CHAMBERS_INTERSECTION: org.bukkit.loot.LootTables;

			const TRIAL_CHAMBERS_INTERSECTION_BARREL: org.bukkit.loot.LootTables;

			const TRIAL_CHAMBERS_ENTRANCE: org.bukkit.loot.LootTables;

			const TRIAL_CHAMBERS_CORRIDOR_DISPENSER: org.bukkit.loot.LootTables;

			const TRIAL_CHAMBERS_CHAMBER_DISPENSER: org.bukkit.loot.LootTables;

			const TRIAL_CHAMBERS_WATER_DISPENSER: org.bukkit.loot.LootTables;

			const TRIAL_CHAMBERS_CORRIDOR_POT: org.bukkit.loot.LootTables;

			const EQUIPMENT_TRIAL_CHAMBER: org.bukkit.loot.LootTables;

			const EQUIPMENT_TRIAL_CHAMBER_RANGED: org.bukkit.loot.LootTables;

			const EQUIPMENT_TRIAL_CHAMBER_MELEE: org.bukkit.loot.LootTables;

			const SHIPWRECK_MAP: org.bukkit.loot.LootTables;

			const SHIPWRECK_SUPPLY: org.bukkit.loot.LootTables;

			const SHIPWRECK_TREASURE: org.bukkit.loot.LootTables;

			const SIMPLE_DUNGEON: org.bukkit.loot.LootTables;

			const SPAWN_BONUS_CHEST: org.bukkit.loot.LootTables;

			const STRONGHOLD_CORRIDOR: org.bukkit.loot.LootTables;

			const STRONGHOLD_CROSSING: org.bukkit.loot.LootTables;

			const STRONGHOLD_LIBRARY: org.bukkit.loot.LootTables;

			const UNDERWATER_RUIN_BIG: org.bukkit.loot.LootTables;

			const UNDERWATER_RUIN_SMALL: org.bukkit.loot.LootTables;

			const VILLAGE_ARMORER: org.bukkit.loot.LootTables;

			const VILLAGE_BUTCHER: org.bukkit.loot.LootTables;

			const VILLAGE_CARTOGRAPHER: org.bukkit.loot.LootTables;

			const VILLAGE_DESERT_HOUSE: org.bukkit.loot.LootTables;

			const VILLAGE_FISHER: org.bukkit.loot.LootTables;

			const VILLAGE_FLETCHER: org.bukkit.loot.LootTables;

			const VILLAGE_MASON: org.bukkit.loot.LootTables;

			const VILLAGE_PLAINS_HOUSE: org.bukkit.loot.LootTables;

			const VILLAGE_SAVANNA_HOUSE: org.bukkit.loot.LootTables;

			const VILLAGE_SHEPHERD: org.bukkit.loot.LootTables;

			const VILLAGE_SNOWY_HOUSE: org.bukkit.loot.LootTables;

			const VILLAGE_TAIGA_HOUSE: org.bukkit.loot.LootTables;

			const VILLAGE_TANNERY: org.bukkit.loot.LootTables;

			const VILLAGE_TEMPLE: org.bukkit.loot.LootTables;

			const VILLAGE_TOOLSMITH: org.bukkit.loot.LootTables;

			const VILLAGE_WEAPONSMITH: org.bukkit.loot.LootTables;

			const WOODLAND_MANSION: org.bukkit.loot.LootTables;

			const ARMOR_STAND: org.bukkit.loot.LootTables;

			const AXOLOTL: org.bukkit.loot.LootTables;

			const BAT: org.bukkit.loot.LootTables;

			const BEE: org.bukkit.loot.LootTables;

			const BLAZE: org.bukkit.loot.LootTables;

			const CAT: org.bukkit.loot.LootTables;

			const CAVE_SPIDER: org.bukkit.loot.LootTables;

			const CHICKEN: org.bukkit.loot.LootTables;

			const COD: org.bukkit.loot.LootTables;

			const COW: org.bukkit.loot.LootTables;

			const CREEPER: org.bukkit.loot.LootTables;

			const DOLPHIN: org.bukkit.loot.LootTables;

			const DONKEY: org.bukkit.loot.LootTables;

			const DROWNED: org.bukkit.loot.LootTables;

			const ELDER_GUARDIAN: org.bukkit.loot.LootTables;

			const ENDER_DRAGON: org.bukkit.loot.LootTables;

			const ENDERMAN: org.bukkit.loot.LootTables;

			const ENDERMITE: org.bukkit.loot.LootTables;

			const EVOKER: org.bukkit.loot.LootTables;

			const FOX: org.bukkit.loot.LootTables;

			const GHAST: org.bukkit.loot.LootTables;

			const GIANT: org.bukkit.loot.LootTables;

			const GLOW_SQUID: org.bukkit.loot.LootTables;

			const GOAT: org.bukkit.loot.LootTables;

			const GUARDIAN: org.bukkit.loot.LootTables;

			const HOGLIN: org.bukkit.loot.LootTables;

			const HORSE: org.bukkit.loot.LootTables;

			const HUSK: org.bukkit.loot.LootTables;

			const ILLUSIONER: org.bukkit.loot.LootTables;

			const IRON_GOLEM: org.bukkit.loot.LootTables;

			const LLAMA: org.bukkit.loot.LootTables;

			const MAGMA_CUBE: org.bukkit.loot.LootTables;

			const MOOSHROOM: org.bukkit.loot.LootTables;

			const MULE: org.bukkit.loot.LootTables;

			const OCELOT: org.bukkit.loot.LootTables;

			const PANDA: org.bukkit.loot.LootTables;

			const PARROT: org.bukkit.loot.LootTables;

			const PHANTOM: org.bukkit.loot.LootTables;

			const PIG: org.bukkit.loot.LootTables;

			const PIGLIN: org.bukkit.loot.LootTables;

			const PIGLIN_BRUTE: org.bukkit.loot.LootTables;

			const PILLAGER: org.bukkit.loot.LootTables;

			const PLAYER: org.bukkit.loot.LootTables;

			const POLAR_BEAR: org.bukkit.loot.LootTables;

			const PUFFERFISH: org.bukkit.loot.LootTables;

			const RABBIT: org.bukkit.loot.LootTables;

			const RAVAGER: org.bukkit.loot.LootTables;

			const SALMON: org.bukkit.loot.LootTables;

			const SHULKER: org.bukkit.loot.LootTables;

			const SILVERFISH: org.bukkit.loot.LootTables;

			const SKELETON: org.bukkit.loot.LootTables;

			const SKELETON_HORSE: org.bukkit.loot.LootTables;

			const SLIME: org.bukkit.loot.LootTables;

			const SNOW_GOLEM: org.bukkit.loot.LootTables;

			const SPIDER: org.bukkit.loot.LootTables;

			const SQUID: org.bukkit.loot.LootTables;

			const STRAY: org.bukkit.loot.LootTables;

			const STRIDER: org.bukkit.loot.LootTables;

			const TRADER_LLAMA: org.bukkit.loot.LootTables;

			const TROPICAL_FISH: org.bukkit.loot.LootTables;

			const TURTLE: org.bukkit.loot.LootTables;

			const VEX: org.bukkit.loot.LootTables;

			const VILLAGER: org.bukkit.loot.LootTables;

			const VINDICATOR: org.bukkit.loot.LootTables;

			const WANDERING_TRADER: org.bukkit.loot.LootTables;

			const WITCH: org.bukkit.loot.LootTables;

			const WITHER: org.bukkit.loot.LootTables;

			const WITHER_SKELETON: org.bukkit.loot.LootTables;

			const WOLF: org.bukkit.loot.LootTables;

			const ZOGLIN: org.bukkit.loot.LootTables;

			const ZOMBIE: org.bukkit.loot.LootTables;

			const ZOMBIE_HORSE: org.bukkit.loot.LootTables;

			const ZOMBIE_VILLAGER: org.bukkit.loot.LootTables;

			const ZOMBIFIED_PIGLIN: org.bukkit.loot.LootTables;

			const ARMORER_GIFT: org.bukkit.loot.LootTables;

			const BUTCHER_GIFT: org.bukkit.loot.LootTables;

			const CARTOGRAPHER_GIFT: org.bukkit.loot.LootTables;

			const CAT_MORNING_GIFT: org.bukkit.loot.LootTables;

			const CLERIC_GIFT: org.bukkit.loot.LootTables;

			const FARMER_GIFT: org.bukkit.loot.LootTables;

			const FISHERMAN_GIFT: org.bukkit.loot.LootTables;

			const FISHING: org.bukkit.loot.LootTables;

			const FISHING_FISH: org.bukkit.loot.LootTables;

			const FISHING_JUNK: org.bukkit.loot.LootTables;

			const FISHING_TREASURE: org.bukkit.loot.LootTables;

			const FLETCHER_GIFT: org.bukkit.loot.LootTables;

			const LEATHERWORKER_GIFT: org.bukkit.loot.LootTables;

			const LIBRARIAN_GIFT: org.bukkit.loot.LootTables;

			const MASON_GIFT: org.bukkit.loot.LootTables;

			const SHEPHERD_GIFT: org.bukkit.loot.LootTables;

			const TOOLSMITH_GIFT: org.bukkit.loot.LootTables;

			const WEAPONSMITH_GIFT: org.bukkit.loot.LootTables;

			const SNIFFER_DIGGING: org.bukkit.loot.LootTables;

			const PANDA_SNEEZE: org.bukkit.loot.LootTables;

			const PIGLIN_BARTERING: org.bukkit.loot.LootTables;

			const TRIAL_CHAMBER_KEY: org.bukkit.loot.LootTables;

			const TRIAL_CHAMBER_CONSUMABLES: org.bukkit.loot.LootTables;

			const OMINOUS_TRIAL_CHAMBER_KEY: org.bukkit.loot.LootTables;

			const OMINOUS_TRIAL_CHAMBER_CONSUMABLES: org.bukkit.loot.LootTables;

			const TRIAL_CHAMBER_ITEMS_TO_DROP_WHEN_OMINOUS: org.bukkit.loot.LootTables;

			const SHEARING_BOGGED: org.bukkit.loot.LootTables;

			const DESERT_WELL_ARCHAEOLOGY: org.bukkit.loot.LootTables;

			const DESERT_PYRAMID_ARCHAEOLOGY: org.bukkit.loot.LootTables;

			const TRAIL_RUINS_ARCHAEOLOGY_COMMON: org.bukkit.loot.LootTables;

			const TRAIL_RUINS_ARCHAEOLOGY_RARE: org.bukkit.loot.LootTables;

			const OCEAN_RUIN_WARM_ARCHAEOLOGY: org.bukkit.loot.LootTables;

			const OCEAN_RUIN_COLD_ARCHAEOLOGY: org.bukkit.loot.LootTables;

			const SHEEP: org.bukkit.loot.LootTables;

			const SHEEP_BLACK: org.bukkit.loot.LootTables;

			const SHEEP_BLUE: org.bukkit.loot.LootTables;

			const SHEEP_BROWN: org.bukkit.loot.LootTables;

			const SHEEP_CYAN: org.bukkit.loot.LootTables;

			const SHEEP_GRAY: org.bukkit.loot.LootTables;

			const SHEEP_GREEN: org.bukkit.loot.LootTables;

			const SHEEP_LIGHT_BLUE: org.bukkit.loot.LootTables;

			const SHEEP_LIGHT_GRAY: org.bukkit.loot.LootTables;

			const SHEEP_LIME: org.bukkit.loot.LootTables;

			const SHEEP_MAGENTA: org.bukkit.loot.LootTables;

			const SHEEP_ORANGE: org.bukkit.loot.LootTables;

			const SHEEP_PINK: org.bukkit.loot.LootTables;

			const SHEEP_PURPLE: org.bukkit.loot.LootTables;

			const SHEEP_RED: org.bukkit.loot.LootTables;

			const SHEEP_WHITE: org.bukkit.loot.LootTables;

			const SHEEP_YELLOW: org.bukkit.loot.LootTables;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.loot.LootTables;

		}
		interface Lootable {
			/**
			 * Set the loot table for a container or entity.
			 * 
			 * To remove a loot table use null. Do not use LootTables.EMPTY to
			 * clear a LootTable.
			 */
			setLootTable(table: (org.bukkit.loot.LootTable | null)): void;

			/**
			 * Gets the Loot Table attached to this block or entity.
			 * 
			 * If an block/entity does not have a loot table, this will return null, NOT
			 * an empty loot table.
			 */
			getLootTable(): (org.bukkit.loot.LootTable | null);

			/**
			 * Set the seed used when this Loot Table generates loot.
			 */
			setSeed(seed: number): void;

			/**
			 * Get the Loot Table's seed.
			 * 
			 * The seed is used when generating loot.
			 */
			getSeed(): number;

		}
	}
	namespace org.bukkit.command.defaults {
		interface BukkitCommand extends Modify<org.bukkit.command.Command, {}> {}
		interface HelpCommand extends Modify<org.bukkit.command.defaults.BukkitCommand, {
			/**
			 * Description copied from class:Â Command
			 */
			execute(sender: org.bukkit.command.CommandSender, currentAlias: string, args: string[]): boolean;

			/**
			 * Description copied from class:Â Command
			 */
			tabComplete(sender: org.bukkit.command.CommandSender, alias: string, args: string[]): globalThis.java.util.List<string>;

		}> {}
		class HelpCommand {
			constructor();

		}
		interface PluginsCommand extends Modify<org.bukkit.command.defaults.BukkitCommand, {
			/**
			 * Description copied from class:Â Command
			 */
			execute(sender: org.bukkit.command.CommandSender, currentAlias: string, args: string[]): boolean;

			/**
			 * Description copied from class:Â Command
			 */
			tabComplete(sender: org.bukkit.command.CommandSender, alias: string, args: string[]): globalThis.java.util.List<string>;

		}> {}
		class PluginsCommand {
			constructor(name: string);

		}
		interface ReloadCommand extends Modify<org.bukkit.command.defaults.BukkitCommand, {
			/**
			 * Description copied from class:Â Command
			 */
			execute(sender: org.bukkit.command.CommandSender, currentAlias: string, args: string[]): boolean;

			/**
			 * Description copied from class:Â Command
			 */
			tabComplete(sender: org.bukkit.command.CommandSender, alias: string, args: string[]): globalThis.java.util.List<string>;

		}> {}
		class ReloadCommand {
			constructor(name: string);

		}
		interface TimingsCommand extends Modify<org.bukkit.command.defaults.BukkitCommand, {
			/**
			 * Description copied from class:Â Command
			 */
			execute(sender: org.bukkit.command.CommandSender, currentAlias: string, args: string[]): boolean;

			/**
			 * Description copied from class:Â Command
			 */
			tabComplete(sender: org.bukkit.command.CommandSender, alias: string, args: string[]): globalThis.java.util.List<string>;

		}> {}
		class TimingsCommand {
			constructor(name: string);

		}
		namespace TimingsCommand {
			const timingStart: number;

		}
		interface VersionCommand extends Modify<org.bukkit.command.defaults.BukkitCommand, {
			/**
			 * Description copied from class:Â Command
			 */
			execute(sender: org.bukkit.command.CommandSender, currentAlias: string, args: string[]): boolean;

			/**
			 * Description copied from class:Â Command
			 */
			tabComplete(sender: org.bukkit.command.CommandSender, alias: string, args: string[]): globalThis.java.util.List<string>;

		}> {}
		class VersionCommand {
			constructor(name: string);

		}
	}
	namespace org.bukkit.util.io {
		interface BukkitObjectInputStream {
		}
		class BukkitObjectInputStream {
			/**
			 * Object input stream decoration constructor.
			 */
			constructor(_in: any /* java.io.InputStream */);

		}
		interface BukkitObjectOutputStream {
		}
		class BukkitObjectOutputStream {
			/**
			 * Object output stream decoration constructor.
			 */
			constructor(out: any /* java.io.OutputStream */);

		}
	}
	namespace org.bukkit.scheduler {
		interface BukkitRunnable {
			/**
			 * Returns true if this task has been cancelled.
			 */
			isCancelled(): boolean;

			/**
			 * Attempts to cancel this task.
			 */
			cancel(): void;

			/**
			 * Schedules this in the Bukkit scheduler to run on next tick.
			 */
			runTask(plugin: org.bukkit.plugin.Plugin): org.bukkit.scheduler.BukkitTask;

			/**
			 * Asynchronous tasks should never access any API in Bukkit. Great care
			 * should be taken to assure the thread-safety of asynchronous tasks.
			 * 
			 * Schedules this in the Bukkit scheduler to run asynchronously.
			 */
			runTaskAsynchronously(plugin: org.bukkit.plugin.Plugin): org.bukkit.scheduler.BukkitTask;

			/**
			 * Schedules this to run after the specified number of server ticks.
			 */
			runTaskLater(plugin: org.bukkit.plugin.Plugin, delay: number): org.bukkit.scheduler.BukkitTask;

			/**
			 * Asynchronous tasks should never access any API in Bukkit. Great care
			 * should be taken to assure the thread-safety of asynchronous tasks.
			 * 
			 * Schedules this to run asynchronously after the specified number of
			 * server ticks.
			 */
			runTaskLaterAsynchronously(plugin: org.bukkit.plugin.Plugin, delay: number): org.bukkit.scheduler.BukkitTask;

			/**
			 * Schedules this to repeatedly run until cancelled, starting after the
			 * specified number of server ticks.
			 */
			runTaskTimer(plugin: org.bukkit.plugin.Plugin, delay: number, period: number): org.bukkit.scheduler.BukkitTask;

			/**
			 * Asynchronous tasks should never access any API in Bukkit. Great care
			 * should be taken to assure the thread-safety of asynchronous tasks.
			 * 
			 * Schedules this to repeatedly run asynchronously until cancelled,
			 * starting after the specified number of server ticks.
			 */
			runTaskTimerAsynchronously(plugin: org.bukkit.plugin.Plugin, delay: number, period: number): org.bukkit.scheduler.BukkitTask;

			/**
			 * Gets the task id for this runnable.
			 */
			getTaskId(): number;

		}
		class BukkitRunnable {
			constructor();

		}
		interface BukkitScheduler {
			/**
			 * Schedules a once off task to occur after a delay.
			 * 
			 * This task will be executed by the main server thread.
			 */
			scheduleSyncDelayedTask(plugin: org.bukkit.plugin.Plugin, task: globalThis.java.lang.Runnable, delay: number): number;

			scheduleSyncDelayedTask(plugin: org.bukkit.plugin.Plugin, task: org.bukkit.scheduler.BukkitRunnable, delay: number): number;

			/**
			 * Schedules a once off task to occur as soon as possible.
			 * 
			 * This task will be executed by the main server thread.
			 */
			scheduleSyncDelayedTask(plugin: org.bukkit.plugin.Plugin, task: globalThis.java.lang.Runnable): number;

			scheduleSyncDelayedTask(plugin: org.bukkit.plugin.Plugin, task: org.bukkit.scheduler.BukkitRunnable): number;

			/**
			 * Schedules a repeating task.
			 * 
			 * This task will be executed by the main server thread.
			 */
			scheduleSyncRepeatingTask(plugin: org.bukkit.plugin.Plugin, task: globalThis.java.lang.Runnable, delay: number, period: number): number;

			scheduleSyncRepeatingTask(plugin: org.bukkit.plugin.Plugin, task: org.bukkit.scheduler.BukkitRunnable, delay: number, period: number): number;

			/**
			 * Asynchronous tasks should never access any API in Bukkit. Great care
			 * should be taken to assure the thread-safety of asynchronous tasks.
			 * 
			 * Schedules a once off task to occur after a delay. This task will be
			 * executed by a thread managed by the scheduler.
			 */
			scheduleAsyncDelayedTask(plugin: org.bukkit.plugin.Plugin, task: globalThis.java.lang.Runnable, delay: number): number;

			/**
			 * Asynchronous tasks should never access any API in Bukkit. Great care
			 * should be taken to assure the thread-safety of asynchronous tasks.
			 * 
			 * Schedules a once off task to occur as soon as possible. This task will
			 * be executed by a thread managed by the scheduler.
			 */
			scheduleAsyncDelayedTask(plugin: org.bukkit.plugin.Plugin, task: globalThis.java.lang.Runnable): number;

			/**
			 * Asynchronous tasks should never access any API in Bukkit. Great care
			 * should be taken to assure the thread-safety of asynchronous tasks.
			 * 
			 * Schedules a repeating task. This task will be executed by a thread
			 * managed by the scheduler.
			 */
			scheduleAsyncRepeatingTask(plugin: org.bukkit.plugin.Plugin, task: globalThis.java.lang.Runnable, delay: number, period: number): number;

			/**
			 * Calls a method on the main thread and returns a Future object. This
			 * task will be executed by the main server thread.
			 * 
			 * Note: The Future.get() methods must NOT be called from the main
			 * thread.
			 * Note2: There is at least an average of 10ms latency until the
			 * isDone() method returns true.
			 * 
			 */
			callSyncMethod<T = any>(plugin: org.bukkit.plugin.Plugin, task: globalThis.java.util.concurrent.Callable<T>): globalThis.java.util.concurrent.Future<T>;

			/**
			 * Removes task from scheduler.
			 */
			cancelTask(taskId: number): void;

			/**
			 * Removes all tasks associated with a particular plugin from the
			 * scheduler.
			 */
			cancelTasks(plugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Check if the task currently running.
			 * 
			 * A repeating task might not be running currently, but will be running in
			 * the future. A task that has finished, and does not repeat, will not be
			 * running ever again.
			 * 
			 * Explicitly, a task is running if there exists a thread for it, and that
			 * thread is alive.
			 */
			isCurrentlyRunning(taskId: number): boolean;

			/**
			 * Check if the task queued to be run later.
			 * 
			 * If a repeating task is currently running, it might not be queued now
			 * but could be in the future. A task that is not queued, and not running,
			 * will not be queued again.
			 */
			isQueued(taskId: number): boolean;

			/**
			 * Returns a list of all active workers.
			 * 
			 * This list contains asynch tasks that are being executed by separate
			 * threads.
			 */
			getActiveWorkers(): globalThis.java.util.List<org.bukkit.scheduler.BukkitWorker>;

			/**
			 * Returns a list of all pending tasks. The ordering of the tasks is not
			 * related to their order of execution.
			 */
			getPendingTasks(): globalThis.java.util.List<org.bukkit.scheduler.BukkitTask>;

			/**
			 * Returns a task that will run on the next server tick.
			 */
			runTask(plugin: org.bukkit.plugin.Plugin, task: globalThis.java.lang.Runnable): org.bukkit.scheduler.BukkitTask;

			/**
			 * Returns a task that will run on the next server tick.
			 */
			runTask(plugin: org.bukkit.plugin.Plugin, task: (value: org.bukkit.scheduler.BukkitTask) => void): void;

			runTask(plugin: org.bukkit.plugin.Plugin, task: org.bukkit.scheduler.BukkitRunnable): org.bukkit.scheduler.BukkitTask;

			/**
			 * Asynchronous tasks should never access any API in Bukkit. Great care
			 * should be taken to assure the thread-safety of asynchronous tasks.
			 * 
			 * Returns a task that will run asynchronously.
			 */
			runTaskAsynchronously(plugin: org.bukkit.plugin.Plugin, task: globalThis.java.lang.Runnable): org.bukkit.scheduler.BukkitTask;

			/**
			 * Asynchronous tasks should never access any API in Bukkit. Great care
			 * should be taken to assure the thread-safety of asynchronous tasks.
			 * 
			 * Returns a task that will run asynchronously.
			 */
			runTaskAsynchronously(plugin: org.bukkit.plugin.Plugin, task: (value: org.bukkit.scheduler.BukkitTask) => void): void;

			runTaskAsynchronously(plugin: org.bukkit.plugin.Plugin, task: org.bukkit.scheduler.BukkitRunnable): org.bukkit.scheduler.BukkitTask;

			/**
			 * Returns a task that will run after the specified number of server
			 * ticks.
			 */
			runTaskLater(plugin: org.bukkit.plugin.Plugin, task: globalThis.java.lang.Runnable, delay: number): org.bukkit.scheduler.BukkitTask;

			/**
			 * Returns a task that will run after the specified number of server
			 * ticks.
			 */
			runTaskLater(plugin: org.bukkit.plugin.Plugin, task: (value: org.bukkit.scheduler.BukkitTask) => void, delay: number): void;

			runTaskLater(plugin: org.bukkit.plugin.Plugin, task: org.bukkit.scheduler.BukkitRunnable, delay: number): org.bukkit.scheduler.BukkitTask;

			/**
			 * Asynchronous tasks should never access any API in Bukkit. Great care
			 * should be taken to assure the thread-safety of asynchronous tasks.
			 * 
			 * Returns a task that will run asynchronously after the specified number
			 * of server ticks.
			 */
			runTaskLaterAsynchronously(plugin: org.bukkit.plugin.Plugin, task: globalThis.java.lang.Runnable, delay: number): org.bukkit.scheduler.BukkitTask;

			/**
			 * Asynchronous tasks should never access any API in Bukkit. Great care
			 * should be taken to assure the thread-safety of asynchronous tasks.
			 * 
			 * Returns a task that will run asynchronously after the specified number
			 * of server ticks.
			 */
			runTaskLaterAsynchronously(plugin: org.bukkit.plugin.Plugin, task: (value: org.bukkit.scheduler.BukkitTask) => void, delay: number): void;

			runTaskLaterAsynchronously(plugin: org.bukkit.plugin.Plugin, task: org.bukkit.scheduler.BukkitRunnable, delay: number): org.bukkit.scheduler.BukkitTask;

			/**
			 * Returns a task that will repeatedly run until cancelled, starting after
			 * the specified number of server ticks.
			 */
			runTaskTimer(plugin: org.bukkit.plugin.Plugin, task: globalThis.java.lang.Runnable, delay: number, period: number): org.bukkit.scheduler.BukkitTask;

			/**
			 * Returns a task that will repeatedly run until cancelled, starting after
			 * the specified number of server ticks.
			 */
			runTaskTimer(plugin: org.bukkit.plugin.Plugin, task: (value: org.bukkit.scheduler.BukkitTask) => void, delay: number, period: number): void;

			runTaskTimer(plugin: org.bukkit.plugin.Plugin, task: org.bukkit.scheduler.BukkitRunnable, delay: number, period: number): org.bukkit.scheduler.BukkitTask;

			/**
			 * Asynchronous tasks should never access any API in Bukkit. Great care
			 * should be taken to assure the thread-safety of asynchronous tasks.
			 * 
			 * Returns a task that will repeatedly run asynchronously until cancelled,
			 * starting after the specified number of server ticks.
			 */
			runTaskTimerAsynchronously(plugin: org.bukkit.plugin.Plugin, task: globalThis.java.lang.Runnable, delay: number, period: number): org.bukkit.scheduler.BukkitTask;

			/**
			 * Asynchronous tasks should never access any API in Bukkit. Great care
			 * should be taken to assure the thread-safety of asynchronous tasks.
			 * 
			 * Returns a task that will repeatedly run asynchronously until cancelled,
			 * starting after the specified number of server ticks.
			 */
			runTaskTimerAsynchronously(plugin: org.bukkit.plugin.Plugin, task: (value: org.bukkit.scheduler.BukkitTask) => void, delay: number, period: number): void;

			runTaskTimerAsynchronously(plugin: org.bukkit.plugin.Plugin, task: org.bukkit.scheduler.BukkitRunnable, delay: number, period: number): org.bukkit.scheduler.BukkitTask;

		}
		interface BukkitTask {
			/**
			 * Returns the taskId for the task.
			 */
			getTaskId(): number;

			/**
			 * Returns the Plugin that owns this task.
			 */
			getOwner(): org.bukkit.plugin.Plugin;

			/**
			 * Returns true if the Task is a sync task.
			 */
			isSync(): boolean;

			/**
			 * Returns true if this task has been cancelled.
			 */
			isCancelled(): boolean;

			/**
			 * Will attempt to cancel this task.
			 */
			cancel(): void;

		}
		interface BukkitWorker {
			/**
			 * Returns the taskId for the task being executed by this worker.
			 */
			getTaskId(): number;

			/**
			 * Returns the Plugin that owns this task.
			 */
			getOwner(): org.bukkit.plugin.Plugin;

			/**
			 * Returns the thread for the worker.
			 */
			getThread(): globalThis.java.lang.Thread;

		}
	}
	namespace org.bukkit.metadata {
		interface FixedMetadataValue extends Modify<org.bukkit.metadata.LazyMetadataValue, {
			/**
			 * Description copied from interface:Â MetadataValue
			 */
			invalidate(): void;

			/**
			 * Description copied from interface:Â MetadataValue
			 */
			value(): (any | null);

		}> {}
		class FixedMetadataValue {
			/**
			 * Initializes a FixedMetadataValue with an Object
			 */
			constructor(owningPlugin: org.bukkit.plugin.Plugin, value: (any | null));

		}
		interface LazyMetadataValue extends Modify<org.bukkit.metadata.MetadataValueAdapter, {
			/**
			 * Description copied from interface:Â MetadataValue
			 */
			value(): (any | null);

			/**
			 * Description copied from interface:Â MetadataValue
			 */
			invalidate(): void;

		}> {}
		class LazyMetadataValue {
			/**
			 * Initialized a LazyMetadataValue object with the default
			 * CACHE_AFTER_FIRST_EVAL cache strategy.
			 */
			constructor(owningPlugin: org.bukkit.plugin.Plugin, lazyValue: globalThis.java.util.concurrent.Callable<any>);

			/**
			 * Initializes a LazyMetadataValue object with a specific cache strategy.
			 */
			constructor(owningPlugin: org.bukkit.plugin.Plugin, cacheStrategy: org.bukkit.metadata.LazyMetadataValue.CacheStrategy, lazyValue: globalThis.java.util.concurrent.Callable<any>);

		}
		namespace LazyMetadataValue {
			interface CacheStrategy {}
			namespace CacheStrategy {
				/**
				 * Once the metadata value has been evaluated, do not re-evaluate the
				 * value until it is manually invalidated.
				 */
				const CACHE_AFTER_FIRST_EVAL: org.bukkit.metadata.LazyMetadataValue.CacheStrategy;

				/**
				 * Re-evaluate the metadata item every time it is requested
				 */
				const NEVER_CACHE: org.bukkit.metadata.LazyMetadataValue.CacheStrategy;

				/**
				 * Once the metadata value has been evaluated, do not re-evaluate the
				 * value in spite of manual invalidation.
				 */
				const CACHE_ETERNALLY: org.bukkit.metadata.LazyMetadataValue.CacheStrategy;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.metadata.LazyMetadataValue.CacheStrategy;

			}
		}
		interface MetadataConversionException {}
		interface MetadataEvaluationException {}
		interface MetadataStore<T = any> {
			/**
			 * Adds a metadata value to an object.
			 */
			setMetadata(subject: T, metadataKey: string, newMetadataValue: org.bukkit.metadata.MetadataValue): void;

			/**
			 * Returns all metadata values attached to an object. If multiple plugins
			 * have attached metadata, each will value will be included.
			 */
			getMetadata(subject: T, metadataKey: string): globalThis.java.util.List<org.bukkit.metadata.MetadataValue>;

			/**
			 * Tests to see if a metadata attribute has been set on an object.
			 */
			hasMetadata(subject: T, metadataKey: string): boolean;

			/**
			 * Removes a metadata item owned by a plugin from a subject.
			 */
			removeMetadata(subject: T, metadataKey: string, owningPlugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Invalidates all metadata in the metadata store that originates from the
			 * given plugin. Doing this will force each invalidated metadata item to
			 * be recalculated the next time it is accessed.
			 */
			invalidateAll(owningPlugin: org.bukkit.plugin.Plugin): void;

		}
		interface MetadataStoreBase<T = any> {
			/**
			 * Adds a metadata value to an object. Each metadata value is owned by a
			 * specific Plugin. If a plugin has already added a metadata value
			 * to an object, that value will be replaced with the value of
			 * newMetadataValue. Multiple plugins can set independent values for the
			 * same metadataKey without conflict.
			 * 
			 * Implementation note: I considered using a ReadWriteLock for controlling access to
			 * metadataMap, but decided that the added overhead wasn't worth
			 * the finer grained access control.
			 * 
			 * Bukkit is almost entirely single threaded so locking overhead shouldn't
			 * pose a problem.
			 */
			setMetadata(subject: T, metadataKey: string, newMetadataValue: org.bukkit.metadata.MetadataValue): void;

			/**
			 * Returns all metadata values attached to an object. If multiple
			 * have attached metadata, each will value will be included.
			 */
			getMetadata(subject: T, metadataKey: string): globalThis.java.util.List<org.bukkit.metadata.MetadataValue>;

			/**
			 * Tests to see if a metadata attribute has been set on an object.
			 */
			hasMetadata(subject: T, metadataKey: string): boolean;

			/**
			 * Removes a metadata item owned by a plugin from a subject.
			 */
			removeMetadata(subject: T, metadataKey: string, owningPlugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Invalidates all metadata in the metadata store that originates from the
			 * given plugin. Doing this will force each invalidated metadata item to
			 * be recalculated the next time it is accessed.
			 */
			invalidateAll(owningPlugin: org.bukkit.plugin.Plugin): void;

		}
		class MetadataStoreBase<T = any> {
			constructor();

		}
		interface MetadataValue {
			/**
			 * Fetches the value of this metadata item.
			 */
			value(): (any | null);

			/**
			 * Attempts to convert the value of this metadata item into an int.
			 */
			asInt(): number;

			/**
			 * Attempts to convert the value of this metadata item into a float.
			 */
			asFloat(): number;

			/**
			 * Attempts to convert the value of this metadata item into a double.
			 */
			asDouble(): number;

			/**
			 * Attempts to convert the value of this metadata item into a long.
			 */
			asLong(): number;

			/**
			 * Attempts to convert the value of this metadata item into a short.
			 */
			asShort(): number;

			/**
			 * Attempts to convert the value of this metadata item into a byte.
			 */
			asByte(): any /* byte */;

			/**
			 * Attempts to convert the value of this metadata item into a boolean.
			 */
			asBoolean(): boolean;

			/**
			 * Attempts to convert the value of this metadata item into a string.
			 */
			asString(): string;

			/**
			 * Returns the Plugin that created this metadata item.
			 */
			getOwningPlugin(): (org.bukkit.plugin.Plugin | null);

			/**
			 * Invalidates this metadata item, forcing it to recompute when next
			 * accessed.
			 */
			invalidate(): void;

		}
		interface MetadataValueAdapter {
			/**
			 * Description copied from interface:Â MetadataValue
			 */
			getOwningPlugin(): (org.bukkit.plugin.Plugin | null);

			/**
			 * Description copied from interface:Â MetadataValue
			 */
			asInt(): number;

			/**
			 * Description copied from interface:Â MetadataValue
			 */
			asFloat(): number;

			/**
			 * Description copied from interface:Â MetadataValue
			 */
			asDouble(): number;

			/**
			 * Description copied from interface:Â MetadataValue
			 */
			asLong(): number;

			/**
			 * Description copied from interface:Â MetadataValue
			 */
			asShort(): number;

			/**
			 * Description copied from interface:Â MetadataValue
			 */
			asByte(): any /* byte */;

			/**
			 * Description copied from interface:Â MetadataValue
			 */
			asBoolean(): boolean;

			/**
			 * Description copied from interface:Â MetadataValue
			 */
			asString(): string;

		}
		interface Metadatable {
			/**
			 * Sets a metadata value in the implementing object's metadata store.
			 */
			setMetadata(metadataKey: string, newMetadataValue: org.bukkit.metadata.MetadataValue): void;

			/**
			 * Returns a list of previously set metadata values from the implementing
			 * object's metadata store.
			 */
			getMetadata(metadataKey: string): globalThis.java.util.List<org.bukkit.metadata.MetadataValue>;

			/**
			 * Tests to see whether the implementing object contains the given
			 * metadata value in its metadata store.
			 */
			hasMetadata(metadataKey: string): boolean;

			/**
			 * Removes the given metadata value from the implementing object's
			 * metadata store.
			 */
			removeMetadata(metadataKey: string, owningPlugin: org.bukkit.plugin.Plugin): void;

		}
	}
	namespace org.bukkit.event {
		interface Cancellable {
			/**
			 * Gets the cancellation state of this event. A cancelled event will not
			 * be executed in the server, but will still pass to other plugins
			 */
			isCancelled(): boolean;

			/**
			 * Sets the cancellation state of this event. A cancelled event will not
			 * be executed in the server, but will still pass to other plugins.
			 */
			setCancelled(cancel: boolean): void;

		}
		interface Event {
			/**
			 * Convenience method for providing a user-friendly identifier. By
			 * default, it is the event's class's simple name.
			 */
			getEventName(): string;

			getHandlers(): org.bukkit.event.HandlerList;

			/**
			 * Any custom event that should not by synchronized with other events must
			 * use the specific constructor. These are the caveats of using an
			 * asynchronous event:
			 * 
			 * The event is never fired from inside code triggered by a
			 * synchronous event. Attempting to do so results in an IllegalStateException.
			 * However, asynchronous event handlers may fire synchronous or
			 * asynchronous events
			 * The event may be fired multiple times simultaneously and in any
			 * order.
			 * Any newly registered or unregistered handler is ignored after an
			 * event starts execution.
			 * The handlers for this event may block for any length of time.
			 * Some implementations may selectively declare a specific event use
			 * as asynchronous. This behavior should be clearly defined.
			 * Asynchronous calls are not calculated in the plugin timing system.
			 * 
			 */
			isAsynchronous(): boolean;

		}
		class Event {
			/**
			 * The default constructor is defined for cleaner code. This constructor
			 * assumes the event is synchronous.
			 */
			constructor();

			/**
			 * This constructor is used to explicitly declare an event as synchronous
			 * or asynchronous.
			 */
			constructor(isAsync: boolean);

		}
		namespace Event {
			interface Result {}
			namespace Result {
				/**
				 * Deny the event. Depending on the event, the action indicated by the
				 * event will either not take place or will be reverted. Some actions
				 * may not be denied.
				 */
				const DENY: org.bukkit.event.Event.Result;

				/**
				 * Neither deny nor allow the event. The server will proceed with its
				 * normal handling.
				 */
				const DEFAULT: org.bukkit.event.Event.Result;

				/**
				 * Allow / Force the event. The action indicated by the event will
				 * take place if possible, even if the server would not normally allow
				 * the action. Some actions may not be allowed.
				 */
				const ALLOW: org.bukkit.event.Event.Result;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.Event.Result;

			}
		}
		interface EventException {
			/**
			 * If applicable, returns the Exception that triggered this Exception
			 */
			getCause(): globalThis.java.lang.Throwable;

		}
		class EventException {
			/**
			 * Constructs a new EventException based on the given Exception
			 */
			constructor(throwable: globalThis.java.lang.Throwable);

			/**
			 * Constructs a new EventException
			 */
			constructor();

			/**
			 * Constructs a new EventException with the given message
			 */
			constructor(cause: globalThis.java.lang.Throwable, message: string);

			/**
			 * Constructs a new EventException with the given message
			 */
			constructor(message: string);

		}
		interface EventHandler {}
		interface EventPriority {
			getSlot(): number;

		}
		namespace EventPriority {
			/**
			 * Event call is of very low importance and should be run first, to allow
			 * other plugins to further customise the outcome
			 */
			const LOWEST: org.bukkit.event.EventPriority;

			/**
			 * Event call is of low importance
			 */
			const LOW: org.bukkit.event.EventPriority;

			/**
			 * Event call is neither important nor unimportant, and may be run
			 * normally
			 */
			const NORMAL: org.bukkit.event.EventPriority;

			/**
			 * Event call is of high importance
			 */
			const HIGH: org.bukkit.event.EventPriority;

			/**
			 * Event call is critical and must have the final say in what happens
			 * to the event
			 */
			const HIGHEST: org.bukkit.event.EventPriority;

			/**
			 * Event is listened to purely for monitoring the outcome of an event.
			 * 
			 * No modifications to the event should be made under this priority
			 */
			const MONITOR: org.bukkit.event.EventPriority;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.event.EventPriority;

		}
		interface HandlerList {
			/**
			 * Register a new listener in this handler list
			 */
			register(listener: org.bukkit.plugin.RegisteredListener): void;

			/**
			 * Register a collection of new listeners in this handler list
			 */
			registerAll(listeners: globalThis.java.util.Collection<org.bukkit.plugin.RegisteredListener>): void;

			/**
			 * Remove a listener from a specific order slot
			 */
			unregister(listener: org.bukkit.plugin.RegisteredListener): void;

			/**
			 * Remove a specific plugin's listeners from this handler
			 */
			unregister(plugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Remove a specific listener from this handler
			 */
			unregister(listener: org.bukkit.event.Listener): void;

			/**
			 * Bake HashMap and ArrayLists to 2d array - does nothing if not necessary
			 */
			bake(): void;

		}
		class HandlerList {
			/**
			 * Create a new handler list and initialize using EventPriority.
			 * 
			 * The HandlerList is then added to meta-list for use in bakeAll()
			 */
			constructor();

		}
		namespace HandlerList {
			/**
			 * Bake all handler lists. Best used just after all normal event
			 * registration is complete, ie just after all plugins are loaded if
			 * you're using fevents in a plugin system.
			 */
			function bakeAll(): void;

			/**
			 * Unregister all listeners from all handler lists.
			 */
			function unregisterAll(): void;

			/**
			 * Unregister a specific plugin's listeners from all handler lists.
			 */
			function unregisterAll(plugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Unregister a specific listener from all handler lists.
			 */
			function unregisterAll(listener: org.bukkit.event.Listener): void;

			/**
			 * Get a specific plugin's registered listeners associated with this
			 * handler list
			 */
			function getRegisteredListeners(plugin: org.bukkit.plugin.Plugin): globalThis.java.util.ArrayList<org.bukkit.plugin.RegisteredListener>;

			/**
			 * Get a list of all handler lists for every event type
			 */
			function getHandlerLists(): globalThis.java.util.ArrayList<org.bukkit.event.HandlerList>;

		}
		interface Listener {}
	}
	namespace org.bukkit.event.weather {
		interface LightningStrikeEvent extends Modify<org.bukkit.event.weather.WeatherEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the bolt which is striking the earth.
			 */
			getLightning(): org.bukkit.entity.LightningStrike;

			/**
			 * Gets the cause of this lightning strike.
			 */
			getCause(): org.bukkit.event.weather.LightningStrikeEvent.Cause;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class LightningStrikeEvent {
			constructor(world: org.bukkit.World, bolt: org.bukkit.entity.LightningStrike);

			constructor(world: org.bukkit.World, bolt: org.bukkit.entity.LightningStrike, cause: org.bukkit.event.weather.LightningStrikeEvent.Cause);

		}
		namespace LightningStrikeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace LightningStrikeEvent {
			interface Cause {}
			namespace Cause {
				/**
				 * Triggered by the /summon command.
				 */
				const COMMAND: org.bukkit.event.weather.LightningStrikeEvent.Cause;

				/**
				 * Triggered by a Plugin.
				 */
				const CUSTOM: org.bukkit.event.weather.LightningStrikeEvent.Cause;

				/**
				 * Triggered by a Spawner.
				 */
				const SPAWNER: org.bukkit.event.weather.LightningStrikeEvent.Cause;

				/**
				 * Triggered by an enchanted trident.
				 */
				const TRIDENT: org.bukkit.event.weather.LightningStrikeEvent.Cause;

				/**
				 * Triggered by a skeleton horse trap.
				 */
				const TRAP: org.bukkit.event.weather.LightningStrikeEvent.Cause;

				/**
				 * Triggered by weather.
				 */
				const WEATHER: org.bukkit.event.weather.LightningStrikeEvent.Cause;

				/**
				 * Triggered by an enchantment but not a trident.
				 */
				const ENCHANTMENT: org.bukkit.event.weather.LightningStrikeEvent.Cause;

				/**
				 * Unknown trigger.
				 */
				const UNKNOWN: org.bukkit.event.weather.LightningStrikeEvent.Cause;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.weather.LightningStrikeEvent.Cause;

			}
		}
		interface ThunderChangeEvent extends Modify<org.bukkit.event.weather.WeatherEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the state of thunder that the world is being set to
			 */
			toThunderState(): boolean;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class ThunderChangeEvent {
			constructor(world: org.bukkit.World, to: boolean);

		}
		namespace ThunderChangeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface WeatherChangeEvent extends Modify<org.bukkit.event.weather.WeatherEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			/**
			 * Gets the state of weather that the world is being set to
			 */
			toWeatherState(): boolean;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class WeatherChangeEvent {
			constructor(world: org.bukkit.World, to: boolean);

		}
		namespace WeatherChangeEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface WeatherEvent extends Modify<org.bukkit.event.Event, {
			/**
			 * Returns the World where this event is occurring
			 */
			getWorld(): org.bukkit.World;

		}> {}
		class WeatherEvent {
			constructor(where: org.bukkit.World);

		}
	}
	namespace org.bukkit.plugin.messaging {
		interface ChannelNameTooLongException {
		}
		class ChannelNameTooLongException {
			constructor();

			constructor(channel: string);

		}
		interface ChannelNotRegisteredException {
		}
		class ChannelNotRegisteredException {
			constructor();

			constructor(channel: string);

		}
		interface MessageTooLargeException {
		}
		class MessageTooLargeException {
			constructor();

			constructor(message: any /* byte */[]);

			constructor(length: number);

			constructor(msg: string);

		}
		interface Messenger {
			/**
			 * Checks if the specified channel is a reserved name.
			 * 
			 * All channels within the "minecraft" namespace except for
			 * "minecraft:brand" are reserved.
			 */
			isReservedChannel(channel: string): boolean;

			/**
			 * Registers the specific plugin to the requested outgoing plugin channel,
			 * allowing it to send messages through that channel to any clients.
			 */
			registerOutgoingPluginChannel(plugin: org.bukkit.plugin.Plugin, channel: string): void;

			/**
			 * Unregisters the specific plugin from the requested outgoing plugin
			 * channel, no longer allowing it to send messages through that channel to
			 * any clients.
			 */
			unregisterOutgoingPluginChannel(plugin: org.bukkit.plugin.Plugin, channel: string): void;

			/**
			 * Unregisters the specific plugin from all outgoing plugin channels, no
			 * longer allowing it to send any plugin messages.
			 */
			unregisterOutgoingPluginChannel(plugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Registers the specific plugin for listening on the requested incoming
			 * plugin channel, allowing it to act upon any plugin messages.
			 */
			registerIncomingPluginChannel(plugin: org.bukkit.plugin.Plugin, channel: string, listener: org.bukkit.plugin.messaging.PluginMessageListener): org.bukkit.plugin.messaging.PluginMessageListenerRegistration;

			/**
			 * Unregisters the specific plugin's listener from listening on the
			 * requested incoming plugin channel, no longer allowing it to act upon
			 * any plugin messages.
			 */
			unregisterIncomingPluginChannel(plugin: org.bukkit.plugin.Plugin, channel: string, listener: org.bukkit.plugin.messaging.PluginMessageListener): void;

			/**
			 * Unregisters the specific plugin from listening on the requested
			 * incoming plugin channel, no longer allowing it to act upon any plugin
			 * messages.
			 */
			unregisterIncomingPluginChannel(plugin: org.bukkit.plugin.Plugin, channel: string): void;

			/**
			 * Unregisters the specific plugin from listening on all plugin channels
			 * through all listeners.
			 */
			unregisterIncomingPluginChannel(plugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Gets a set containing all the outgoing plugin channels.
			 */
			getOutgoingChannels(): globalThis.java.util.Set<string>;

			/**
			 * Gets a set containing all the outgoing plugin channels that the
			 * specified plugin is registered to.
			 */
			getOutgoingChannels(plugin: org.bukkit.plugin.Plugin): globalThis.java.util.Set<string>;

			/**
			 * Gets a set containing all the incoming plugin channels.
			 */
			getIncomingChannels(): globalThis.java.util.Set<string>;

			/**
			 * Gets a set containing all the incoming plugin channels that the
			 * specified plugin is registered for.
			 */
			getIncomingChannels(plugin: org.bukkit.plugin.Plugin): globalThis.java.util.Set<string>;

			/**
			 * Gets a set containing all the incoming plugin channel registrations
			 * that the specified plugin has.
			 */
			getIncomingChannelRegistrations(plugin: org.bukkit.plugin.Plugin): globalThis.java.util.Set<org.bukkit.plugin.messaging.PluginMessageListenerRegistration>;

			/**
			 * Gets a set containing all the incoming plugin channel registrations
			 * that are on the requested channel.
			 */
			getIncomingChannelRegistrations(channel: string): globalThis.java.util.Set<org.bukkit.plugin.messaging.PluginMessageListenerRegistration>;

			/**
			 * Gets a set containing all the incoming plugin channel registrations
			 * that the specified plugin has on the requested channel.
			 */
			getIncomingChannelRegistrations(plugin: org.bukkit.plugin.Plugin, channel: string): globalThis.java.util.Set<org.bukkit.plugin.messaging.PluginMessageListenerRegistration>;

			/**
			 * Checks if the specified plugin message listener registration is valid.
			 * 
			 * A registration is considered valid if it has not be unregistered and
			 * that the plugin is still enabled.
			 */
			isRegistrationValid(registration: org.bukkit.plugin.messaging.PluginMessageListenerRegistration): boolean;

			/**
			 * Checks if the specified plugin has registered to receive incoming
			 * messages through the requested channel.
			 */
			isIncomingChannelRegistered(plugin: org.bukkit.plugin.Plugin, channel: string): boolean;

			/**
			 * Checks if the specified plugin has registered to send outgoing messages
			 * through the requested channel.
			 */
			isOutgoingChannelRegistered(plugin: org.bukkit.plugin.Plugin, channel: string): boolean;

			/**
			 * Dispatches the specified incoming message to any registered listeners.
			 */
			dispatchIncomingMessage(source: org.bukkit.entity.Player, channel: string, message: any /* byte */[]): void;

		}
		namespace Messenger {
			/**
			 * Represents the largest size that an individual Plugin Message may be.
			 */
			const MAX_MESSAGE_SIZE: number;

			/**
			 * Represents the largest size that a Plugin Channel may be.
			 */
			const MAX_CHANNEL_SIZE: number;

		}
		interface PluginChannelDirection {}
		namespace PluginChannelDirection {
			/**
			 * The plugin channel is being sent to the server from a client.
			 */
			const INCOMING: org.bukkit.plugin.messaging.PluginChannelDirection;

			/**
			 * The plugin channel is being sent to a client from the server.
			 */
			const OUTGOING: org.bukkit.plugin.messaging.PluginChannelDirection;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.plugin.messaging.PluginChannelDirection;

		}
		interface PluginMessageListener {
			/**
			 * A method that will be thrown when a PluginMessageSource sends a plugin
			 * message on a registered channel.
			 */
			onPluginMessageReceived(channel: string, player: org.bukkit.entity.Player, message: any /* byte */[]): void;

		}
		interface PluginMessageListenerRegistration {
			/**
			 * Gets the plugin channel that this registration is about.
			 */
			getChannel(): string;

			/**
			 * Gets the registered listener described by this registration.
			 */
			getListener(): org.bukkit.plugin.messaging.PluginMessageListener;

			/**
			 * Gets the plugin that this registration is for.
			 */
			getPlugin(): org.bukkit.plugin.Plugin;

			/**
			 * Checks if this registration is still valid.
			 */
			isValid(): boolean;

			equals(obj: any): boolean;

			hashCode(): number;

		}
		class PluginMessageListenerRegistration {
			constructor(messenger: org.bukkit.plugin.messaging.Messenger, plugin: org.bukkit.plugin.Plugin, channel: string, listener: org.bukkit.plugin.messaging.PluginMessageListener);

		}
		interface PluginMessageRecipient {
			/**
			 * Sends this recipient a Plugin Message on the specified outgoing
			 * channel.
			 * 
			 * The message may not be larger than Messenger.MAX_MESSAGE_SIZE
			 * bytes, and the plugin must be registered to send messages on the
			 * specified channel.
			 */
			sendPluginMessage(source: org.bukkit.plugin.Plugin, channel: string, message: any /* byte */[]): void;

			/**
			 * Gets a set containing all the Plugin Channels that this client is
			 * listening on.
			 */
			getListeningPluginChannels(): globalThis.java.util.Set<string>;

		}
		interface ReservedChannelException {
		}
		class ReservedChannelException {
			constructor();

			constructor(name: string);

		}
		interface StandardMessenger {
			/**
			 * Description copied from interface:Â Messenger
			 */
			isReservedChannel(channel: string): boolean;

			/**
			 * Description copied from interface:Â Messenger
			 */
			registerOutgoingPluginChannel(plugin: org.bukkit.plugin.Plugin, channel: string): void;

			/**
			 * Description copied from interface:Â Messenger
			 */
			unregisterOutgoingPluginChannel(plugin: org.bukkit.plugin.Plugin, channel: string): void;

			/**
			 * Description copied from interface:Â Messenger
			 */
			unregisterOutgoingPluginChannel(plugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Description copied from interface:Â Messenger
			 */
			registerIncomingPluginChannel(plugin: org.bukkit.plugin.Plugin, channel: string, listener: org.bukkit.plugin.messaging.PluginMessageListener): org.bukkit.plugin.messaging.PluginMessageListenerRegistration;

			/**
			 * Description copied from interface:Â Messenger
			 */
			unregisterIncomingPluginChannel(plugin: org.bukkit.plugin.Plugin, channel: string, listener: org.bukkit.plugin.messaging.PluginMessageListener): void;

			/**
			 * Description copied from interface:Â Messenger
			 */
			unregisterIncomingPluginChannel(plugin: org.bukkit.plugin.Plugin, channel: string): void;

			/**
			 * Description copied from interface:Â Messenger
			 */
			unregisterIncomingPluginChannel(plugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Description copied from interface:Â Messenger
			 */
			getOutgoingChannels(): globalThis.java.util.Set<string>;

			/**
			 * Description copied from interface:Â Messenger
			 */
			getOutgoingChannels(plugin: org.bukkit.plugin.Plugin): globalThis.java.util.Set<string>;

			/**
			 * Description copied from interface:Â Messenger
			 */
			getIncomingChannels(): globalThis.java.util.Set<string>;

			/**
			 * Description copied from interface:Â Messenger
			 */
			getIncomingChannels(plugin: org.bukkit.plugin.Plugin): globalThis.java.util.Set<string>;

			/**
			 * Description copied from interface:Â Messenger
			 */
			getIncomingChannelRegistrations(plugin: org.bukkit.plugin.Plugin): globalThis.java.util.Set<org.bukkit.plugin.messaging.PluginMessageListenerRegistration>;

			/**
			 * Description copied from interface:Â Messenger
			 */
			getIncomingChannelRegistrations(channel: string): globalThis.java.util.Set<org.bukkit.plugin.messaging.PluginMessageListenerRegistration>;

			/**
			 * Description copied from interface:Â Messenger
			 */
			getIncomingChannelRegistrations(plugin: org.bukkit.plugin.Plugin, channel: string): globalThis.java.util.Set<org.bukkit.plugin.messaging.PluginMessageListenerRegistration>;

			/**
			 * Description copied from interface:Â Messenger
			 */
			isRegistrationValid(registration: org.bukkit.plugin.messaging.PluginMessageListenerRegistration): boolean;

			/**
			 * Description copied from interface:Â Messenger
			 */
			isIncomingChannelRegistered(plugin: org.bukkit.plugin.Plugin, channel: string): boolean;

			/**
			 * Description copied from interface:Â Messenger
			 */
			isOutgoingChannelRegistered(plugin: org.bukkit.plugin.Plugin, channel: string): boolean;

			/**
			 * Description copied from interface:Â Messenger
			 */
			dispatchIncomingMessage(source: org.bukkit.entity.Player, channel: string, message: any /* byte */[]): void;

		}
		class StandardMessenger {
			constructor();

		}
		namespace StandardMessenger {
			/**
			 * Validates a Plugin Channel name.
			 */
			function validateChannel(channel: string): void;

			/**
			 * Validates and corrects a Plugin Channel name. Method is not reentrant / idempotent.
			 */
			function validateAndCorrectChannel(channel: string): string;

			/**
			 * Validates the input of a Plugin Message, ensuring the arguments are all
			 * valid.
			 */
			function validatePluginMessage(messenger: org.bukkit.plugin.messaging.Messenger, source: org.bukkit.plugin.Plugin, channel: string, message: any /* byte */[]): void;

		}
	}
	namespace org.bukkit.map {
		interface MapCanvas {
			/**
			 * Get the map this canvas is attached to.
			 */
			getMapView(): org.bukkit.map.MapView;

			/**
			 * Get the cursor collection associated with this canvas.
			 */
			getCursors(): org.bukkit.map.MapCursorCollection;

			/**
			 * Set the cursor collection associated with this canvas. This does not
			 * usually need to be called since a MapCursorCollection is already
			 * provided.
			 */
			setCursors(cursors: org.bukkit.map.MapCursorCollection): void;

			/**
			 * Draw a pixel to the canvas.
			 * 
			 * The provided color might be converted to another color,
			 * which is in the map color range. This means, that
			 * getPixelColor(int, int) might return another
			 * color than set.
			 * If null is used as color, then the color returned by
			 * getBasePixelColor(int, int) is shown on the map.
			 */
			setPixelColor(x: number, y: number, color: (any /* java.awt.Color */ | null)): void;

			/**
			 * Get a pixel from the canvas.
			 * If no color is set at the given position for this canvas, then null is
			 * returned and the color returned by getBasePixelColor(int, int)
			 * is shown on the map.
			 */
			getPixelColor(x: number, y: number): (any /* java.awt.Color */ | null);

			/**
			 * Get a pixel from the layers below this canvas.
			 */
			getBasePixelColor(x: number, y: number): any /* java.awt.Color */;

			/**
			 * Draw a pixel to the canvas.
			 */
			setPixel(x: number, y: number, color: any /* byte */): void;

			/**
			 * Get a pixel from the canvas.
			 */
			getPixel(x: number, y: number): any /* byte */;

			/**
			 * Get a pixel from the layers below this canvas.
			 */
			getBasePixel(x: number, y: number): any /* byte */;

			/**
			 * Draw an image to the map. The image will be clipped if necessary.
			 */
			drawImage(x: number, y: number, image: any /* java.awt.Image */): void;

			/**
			 * Render text to the map using fancy formatting. Newline (\n) characters
			 * will move down one line and return to the original column, and the text
			 * color can be changed using sequences such as "Â§12;", replacing 12 with
			 * the palette index of the color (see MapPalette).
			 */
			drawText(x: number, y: number, font: org.bukkit.map.MapFont, text: string): void;

		}
		interface MapCursor {
			/**
			 * Get the X position of this cursor.
			 */
			getX(): any /* byte */;

			/**
			 * Get the Y position of this cursor.
			 */
			getY(): any /* byte */;

			/**
			 * Get the direction of this cursor.
			 */
			getDirection(): any /* byte */;

			/**
			 * Get the type of this cursor.
			 */
			getType(): org.bukkit.map.MapCursor.Type;

			/**
			 * Get the type of this cursor.
			 */
			getRawType(): any /* byte */;

			/**
			 * Get the visibility status of this cursor.
			 */
			isVisible(): boolean;

			/**
			 * Set the X position of this cursor.
			 */
			setX(x: any /* byte */): void;

			/**
			 * Set the Y position of this cursor.
			 */
			setY(y: any /* byte */): void;

			/**
			 * Set the direction of this cursor.
			 */
			setDirection(direction: any /* byte */): void;

			/**
			 * Set the type of this cursor.
			 */
			setType(type: org.bukkit.map.MapCursor.Type): void;

			/**
			 * Set the type of this cursor.
			 */
			setRawType(type: any /* byte */): void;

			/**
			 * Set the visibility status of this cursor.
			 */
			setVisible(visible: boolean): void;

			/**
			 * Gets the caption on this cursor.
			 */
			getCaption(): (string | null);

			/**
			 * Sets the caption on this cursor.
			 */
			setCaption(caption: (string | null)): void;

		}
		class MapCursor {
			/**
			 * Initialize the map cursor.
			 */
			constructor(x: any /* byte */, y: any /* byte */, direction: any /* byte */, type: any /* byte */, visible: boolean);

			/**
			 * Initialize the map cursor.
			 */
			constructor(x: any /* byte */, y: any /* byte */, direction: any /* byte */, type: org.bukkit.map.MapCursor.Type, visible: boolean);

			/**
			 * Initialize the map cursor.
			 */
			constructor(x: any /* byte */, y: any /* byte */, direction: any /* byte */, type: any /* byte */, visible: boolean, caption: (string | null));

			/**
			 * Initialize the map cursor.
			 */
			constructor(x: any /* byte */, y: any /* byte */, direction: any /* byte */, type: org.bukkit.map.MapCursor.Type, visible: boolean, caption: (string | null));

		}
		namespace MapCursor {
			interface Type {
				/**
				 * Description copied from interface:Â Keyed
				 */
				getKey(): org.bukkit.NamespacedKey;

				/**
				 * Gets the internal value of the cursor.
				 */
				getValue(): any /* byte */;

			}
			namespace Type {
				const PLAYER: org.bukkit.map.MapCursor.Type;

				const FRAME: org.bukkit.map.MapCursor.Type;

				const RED_MARKER: org.bukkit.map.MapCursor.Type;

				const BLUE_MARKER: org.bukkit.map.MapCursor.Type;

				const TARGET_X: org.bukkit.map.MapCursor.Type;

				const TARGET_POINT: org.bukkit.map.MapCursor.Type;

				const PLAYER_OFF_MAP: org.bukkit.map.MapCursor.Type;

				const PLAYER_OFF_LIMITS: org.bukkit.map.MapCursor.Type;

				const MANSION: org.bukkit.map.MapCursor.Type;

				const MONUMENT: org.bukkit.map.MapCursor.Type;

				const BANNER_WHITE: org.bukkit.map.MapCursor.Type;

				const BANNER_ORANGE: org.bukkit.map.MapCursor.Type;

				const BANNER_MAGENTA: org.bukkit.map.MapCursor.Type;

				const BANNER_LIGHT_BLUE: org.bukkit.map.MapCursor.Type;

				const BANNER_YELLOW: org.bukkit.map.MapCursor.Type;

				const BANNER_LIME: org.bukkit.map.MapCursor.Type;

				const BANNER_PINK: org.bukkit.map.MapCursor.Type;

				const BANNER_GRAY: org.bukkit.map.MapCursor.Type;

				const BANNER_LIGHT_GRAY: org.bukkit.map.MapCursor.Type;

				const BANNER_CYAN: org.bukkit.map.MapCursor.Type;

				const BANNER_PURPLE: org.bukkit.map.MapCursor.Type;

				const BANNER_BLUE: org.bukkit.map.MapCursor.Type;

				const BANNER_BROWN: org.bukkit.map.MapCursor.Type;

				const BANNER_GREEN: org.bukkit.map.MapCursor.Type;

				const BANNER_RED: org.bukkit.map.MapCursor.Type;

				const BANNER_BLACK: org.bukkit.map.MapCursor.Type;

				const RED_X: org.bukkit.map.MapCursor.Type;

				const VILLAGE_DESERT: org.bukkit.map.MapCursor.Type;

				const VILLAGE_PLAINS: org.bukkit.map.MapCursor.Type;

				const VILLAGE_SAVANNA: org.bukkit.map.MapCursor.Type;

				const VILLAGE_SNOWY: org.bukkit.map.MapCursor.Type;

				const VILLAGE_TAIGA: org.bukkit.map.MapCursor.Type;

				const JUNGLE_TEMPLE: org.bukkit.map.MapCursor.Type;

				const SWAMP_HUT: org.bukkit.map.MapCursor.Type;

				const TRIAL_CHAMBERS: org.bukkit.map.MapCursor.Type;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.map.MapCursor.Type;

				/**
				 * Get a cursor by its internal value.
				 */
				function byValue(value: any /* byte */): (org.bukkit.map.MapCursor.Type | null);

			}
		}
		interface MapCursorCollection {
			/**
			 * Get the amount of cursors in this collection.
			 */
			size(): number;

			/**
			 * Get a cursor from this collection.
			 */
			getCursor(index: number): org.bukkit.map.MapCursor;

			/**
			 * Remove a cursor from the collection.
			 */
			removeCursor(cursor: org.bukkit.map.MapCursor): boolean;

			/**
			 * Add a cursor to the collection.
			 */
			addCursor(cursor: org.bukkit.map.MapCursor): org.bukkit.map.MapCursor;

			/**
			 * Add a cursor to the collection.
			 */
			addCursor(x: number, y: number, direction: any /* byte */): org.bukkit.map.MapCursor;

			/**
			 * Add a cursor to the collection.
			 */
			addCursor(x: number, y: number, direction: any /* byte */, type: any /* byte */): org.bukkit.map.MapCursor;

			/**
			 * Add a cursor to the collection.
			 */
			addCursor(x: number, y: number, direction: any /* byte */, type: any /* byte */, visible: boolean): org.bukkit.map.MapCursor;

			/**
			 * Add a cursor to the collection.
			 */
			addCursor(x: number, y: number, direction: any /* byte */, type: any /* byte */, visible: boolean, caption: (string | null)): org.bukkit.map.MapCursor;

		}
		class MapCursorCollection {
			constructor();

		}
		interface MapFont {
			/**
			 * Set the sprite for a given character.
			 */
			setChar(ch: any /* char */, sprite: org.bukkit.map.MapFont.CharacterSprite): void;

			/**
			 * Get the sprite for a given character.
			 */
			getChar(ch: any /* char */): (org.bukkit.map.MapFont.CharacterSprite | null);

			/**
			 * Get the width of the given text as it would be rendered using this
			 * font.
			 */
			getWidth(text: string): number;

			/**
			 * Get the height of this font.
			 */
			getHeight(): number;

			/**
			 * Check whether the given text is valid.
			 */
			isValid(text: string): boolean;

		}
		class MapFont {
			constructor();

		}
		namespace MapFont {
			interface CharacterSprite {
				/**
				 * Get the value of a pixel of the character.
				 */
				get(row: number, col: number): boolean;

				/**
				 * Get the width of the character sprite.
				 */
				getWidth(): number;

				/**
				 * Get the height of the character sprite.
				 */
				getHeight(): number;

			}
			class CharacterSprite {
				constructor(width: number, height: number, data: boolean[]);

			}
		}
		interface MapPalette {}
		namespace MapPalette {
			const TRANSPARENT: any /* byte */;

			const LIGHT_GREEN: any /* byte */;

			const LIGHT_BROWN: any /* byte */;

			const GRAY_1: any /* byte */;

			const RED: any /* byte */;

			const PALE_BLUE: any /* byte */;

			const GRAY_2: any /* byte */;

			const DARK_GREEN: any /* byte */;

			const WHITE: any /* byte */;

			const LIGHT_GRAY: any /* byte */;

			const BROWN: any /* byte */;

			const DARK_GRAY: any /* byte */;

			const BLUE: any /* byte */;

			const DARK_BROWN: any /* byte */;

			/**
			 * Resize an image to 128x128.
			 */
			function resizeImage(image: (any /* java.awt.Image */ | null)): any /* java.awt.image.BufferedImage */;

			/**
			 * Get the index of the closest matching color in the palette to the given
			 * color.
			 */
			function matchColor(r: number, g: number, b: number): any /* byte */;

			/**
			 * Get the index of the closest matching color in the palette to the given
			 * color.
			 */
			function matchColor(color: any /* java.awt.Color */): any /* byte */;

			/**
			 * Get the value of the given color in the palette.
			 */
			function getColor(index: any /* byte */): any /* java.awt.Color */;

			/**
			 * Sets the given MapColorCache.
			 */
			function setMapColorCache(mapColorCache: org.bukkit.map.MapPalette.MapColorCache): void;

		}
		namespace MapPalette {
			interface MapColorCache {
				/**
				 * Returns true if the MapColorCache has values cached, if not it will
				 * return false.
				 * A case where it might return false is when the cache is not build jet.
				 */
				isCached(): boolean;

				/**
				 * Get the cached index of the closest matching color in the palette to the given
				 * color.
				 */
				matchColor(color: any /* java.awt.Color */): any /* byte */;

			}
		}
		interface MapRenderer {
			/**
			 * Get whether the renderer is contextual, i.e. has different canvases for
			 * different players.
			 */
			isContextual(): boolean;

			/**
			 * Initialize this MapRenderer for the given map.
			 */
			initialize(map: org.bukkit.map.MapView): void;

			/**
			 * Render to the given map.
			 */
			render(map: org.bukkit.map.MapView, canvas: org.bukkit.map.MapCanvas, player: org.bukkit.entity.Player): void;

		}
		class MapRenderer {
			/**
			 * Initialize the map renderer base to be non-contextual. See isContextual().
			 */
			constructor();

			/**
			 * Initialize the map renderer base with the given contextual status.
			 */
			constructor(contextual: boolean);

		}
		interface MapView {
			/**
			 * Get the ID of this map item for use with MapMeta.
			 */
			getId(): number;

			/**
			 * Check whether this map is virtual. A map is virtual if its lowermost
			 * MapRenderer is plugin-provided.
			 */
			isVirtual(): boolean;

			/**
			 * Get the scale of this map.
			 */
			getScale(): org.bukkit.map.MapView.Scale;

			/**
			 * Set the scale of this map.
			 */
			setScale(scale: org.bukkit.map.MapView.Scale): void;

			/**
			 * Get the center X position of this map.
			 */
			getCenterX(): number;

			/**
			 * Get the center Z position of this map.
			 */
			getCenterZ(): number;

			/**
			 * Set the center X position of this map.
			 */
			setCenterX(x: number): void;

			/**
			 * Set the center Z position of this map.
			 */
			setCenterZ(z: number): void;

			/**
			 * Get the world that this map is associated with. Primarily used by the
			 * internal renderer, but may be used by external renderers. May return
			 * null if the world the map is associated with is not loaded.
			 */
			getWorld(): (org.bukkit.World | null);

			/**
			 * Set the world that this map is associated with. The world is used by
			 * the internal renderer, and may also be used by external renderers.
			 */
			setWorld(world: org.bukkit.World): void;

			/**
			 * Get a list of MapRenderers currently in effect.
			 */
			getRenderers(): globalThis.java.util.List<org.bukkit.map.MapRenderer>;

			/**
			 * Add a renderer to this map.
			 */
			addRenderer(renderer: org.bukkit.map.MapRenderer): void;

			/**
			 * Remove a renderer from this map.
			 */
			removeRenderer(renderer: (org.bukkit.map.MapRenderer | null)): boolean;

			/**
			 * Gets whether a position cursor should be shown when the map is near its
			 * center.
			 */
			isTrackingPosition(): boolean;

			/**
			 * Sets whether a position cursor should be shown when the map is near its
			 * center.
			 */
			setTrackingPosition(trackingPosition: boolean): void;

			/**
			 * Whether the map will show a smaller position cursor (true), or no
			 * position cursor (false) when cursor is outside of map's range.
			 */
			isUnlimitedTracking(): boolean;

			/**
			 * Whether the map will show a smaller position cursor (true), or no
			 * position cursor (false) when cursor is outside of map's range.
			 */
			setUnlimitedTracking(unlimited: boolean): void;

			/**
			 * Gets whether the map is locked or not.
			 * A locked map may not be explored further.
			 */
			isLocked(): boolean;

			/**
			 * Gets whether the map is locked or not.
			 * A locked map may not be explored further.
			 */
			setLocked(locked: boolean): void;

		}
		namespace MapView {
			interface Scale {
				/**
				 * Get the raw value of this scale level.
				 */
				getValue(): any /* byte */;

			}
			namespace Scale {
				const CLOSEST: org.bukkit.map.MapView.Scale;

				const CLOSE: org.bukkit.map.MapView.Scale;

				const NORMAL: org.bukkit.map.MapView.Scale;

				const FAR: org.bukkit.map.MapView.Scale;

				const FARTHEST: org.bukkit.map.MapView.Scale;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.map.MapView.Scale;

				/**
				 * Get the scale given the raw value.
				 */
				function valueOf(value: any /* byte */): (org.bukkit.map.MapView.Scale | null);

			}
		}
		interface MinecraftFont extends Modify<org.bukkit.map.MapFont, {
		}> {}
		class MinecraftFont {
			/**
			 * Initialize a new MinecraftFont.
			 */
			constructor();

		}
		namespace MinecraftFont {
			/**
			 * A static non-malleable MinecraftFont.
			 */
			const Font: org.bukkit.map.MinecraftFont;

		}
	}
	namespace org.bukkit.entity.minecart {
		interface CommandMinecart extends Modify<org.bukkit.entity.Minecart, {
			/**
			 * Gets the command that this CommandMinecart will run when activated.
			 * This will never return null. If the CommandMinecart does not have a
			 * command, an empty String will be returned instead.
			 */
			getCommand(): string;

			/**
			 * Sets the command that this CommandMinecart will run when activated.
			 * Setting the command to null is the same as setting it to an empty
			 * String.
			 */
			setCommand(command: (string | null)): void;

			/**
			 * Sets the name of this CommandMinecart. The name is used with commands
			 * that this CommandMinecart executes. Setting the name to null is the
			 * same as setting it to "@".
			 */
			setName(name: (string | null)): void;

		}> {}
		interface ExplosiveMinecart extends Modify<org.bukkit.entity.Minecart, {
			/**
			 * Set the fuse ticks of this minecart.
			 * If the fuse ticks are set to a non-zero value, this will ignite the
			 * explosive.
			 */
			setFuseTicks(ticks: number): void;

			/**
			 * Get the fuse ticks of this minecart.
			 * If the fuse ticks reach 0, the minecart will explode.
			 */
			getFuseTicks(): number;

			/**
			 * Ignite this minecart's fuse naturally.
			 */
			ignite(): void;

			/**
			 * Check whether or not this minecart's fuse has been ignited.
			 */
			isIgnited(): boolean;

			/**
			 * Immediately explode this minecart with the power assumed by its current
			 * movement.
			 */
			explode(): void;

			/**
			 * Immediately explode this minecart with the given power.
			 */
			explode(power: number): void;

		}> {}
		interface HopperMinecart extends Modify<org.bukkit.entity.Minecart & org.bukkit.inventory.InventoryHolder & org.bukkit.loot.Lootable, {
			/**
			 * Checks whether or not this Minecart will pick up
			 * items into its inventory.
			 */
			isEnabled(): boolean;

			/**
			 * Sets whether this Minecart will pick up items.
			 */
			setEnabled(enabled: boolean): void;

		}> {}
		interface PoweredMinecart extends Modify<org.bukkit.entity.Minecart, {
			/**
			 * Get the number of ticks until the minecart runs out of fuel.
			 */
			getFuel(): number;

			/**
			 * Set the number of ticks until the minecart runs out of fuel.
			 */
			setFuel(fuel: number): void;

		}> {}
		interface RideableMinecart extends Modify<org.bukkit.entity.Minecart, {}> {}
		interface SpawnerMinecart extends Modify<org.bukkit.entity.Minecart, {}> {}
		interface StorageMinecart extends Modify<org.bukkit.entity.Minecart & org.bukkit.inventory.InventoryHolder & org.bukkit.loot.Lootable, {}> {}
	}
	namespace org.bukkit.packs {
		interface DataPack extends Modify<org.bukkit.Keyed, {
			/**
			 * Gets the title of the data pack.
			 */
			getTitle(): string;

			/**
			 * Gets the description of the data pack.
			 */
			getDescription(): string;

			/**
			 * Gets the pack format.
			 * 
			 * Pack formats are non-standard and unrelated to the version of Minecraft. For
			 * a list of known pack versions, see the
			 * Minecraft Wiki.
			 */
			getPackFormat(): number;

			/**
			 * Gets the minimum supported pack format. If the data pack does not specify a
			 * minimum supported format, getPackFormat() is returned.
			 * 
			 * Pack formats are non-standard and unrelated to the version of Minecraft. For
			 * a list of known pack versions, see the
			 * Minecraft Wiki.
			 */
			getMinSupportedPackFormat(): number;

			/**
			 * Gets the maximum supported pack format. If the data pack does not specify a
			 * maximum supported format, getPackFormat() is returned.
			 * 
			 * Pack formats are non-standard and unrelated to the version of Minecraft. For
			 * a list of known pack versions, see the
			 * Minecraft Wiki.
			 */
			getMaxSupportedPackFormat(): number;

			/**
			 * Gets if the data pack is enabled on the server.
			 */
			isEnabled(): boolean;

			/**
			 * Gets if the data pack is required on the server.
			 */
			isRequired(): boolean;

			/**
			 * Gets the compatibility of this data pack with the server.
			 */
			getCompatibility(): org.bukkit.packs.DataPack.Compatibility;

			/**
			 * Gets a set of features requested by this data pack.
			 */
			getRequestedFeatures(): globalThis.java.util.Set<org.bukkit.FeatureFlag>;

			/**
			 * Gets the source of this data pack.
			 */
			getSource(): org.bukkit.packs.DataPack.Source;

		}> {}
		namespace DataPack {
			interface Compatibility {}
			namespace Compatibility {
				/**
				 * It's newer than the server pack version.
				 */
				const NEW: org.bukkit.packs.DataPack.Compatibility;

				/**
				 * It's older than the server pack version.
				 */
				const OLD: org.bukkit.packs.DataPack.Compatibility;

				/**
				 * Its compatible with the server pack version.
				 */
				const COMPATIBLE: org.bukkit.packs.DataPack.Compatibility;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.packs.DataPack.Compatibility;

			}
		}
		namespace DataPack {
			interface Source {}
			namespace Source {
				const DEFAULT: org.bukkit.packs.DataPack.Source;

				const BUILT_IN: org.bukkit.packs.DataPack.Source;

				const FEATURE: org.bukkit.packs.DataPack.Source;

				const WORLD: org.bukkit.packs.DataPack.Source;

				const SERVER: org.bukkit.packs.DataPack.Source;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.packs.DataPack.Source;

			}
		}
		interface DataPackManager {
			/**
			 * Return all the available DataPacks on the server.
			 */
			getDataPacks(): globalThis.java.util.Collection<org.bukkit.packs.DataPack>;

			/**
			 * Gets a DataPack by its key.
			 */
			getDataPack(dataPackKey: org.bukkit.NamespacedKey): (org.bukkit.packs.DataPack | null);

			/**
			 * Return all the enabled DataPack in the World.
			 */
			getEnabledDataPacks(world: org.bukkit.World): globalThis.java.util.Collection<org.bukkit.packs.DataPack>;

			/**
			 * Return all the disabled DataPack in the World.
			 */
			getDisabledDataPacks(world: org.bukkit.World): globalThis.java.util.Collection<org.bukkit.packs.DataPack>;

			/**
			 * Gets if the Material is enabled for use by the features in World.
			 */
			isEnabledByFeature(material: org.bukkit.Material, world: org.bukkit.World): boolean;

			/**
			 * Gets if the ItemType is enabled for use by the features in World.
			 */
			isEnabledByFeature(itemType: org.bukkit.inventory.ItemType, world: org.bukkit.World): boolean;

			/**
			 * Gets if the BlockType is enabled for use by the features in World.
			 */
			isEnabledByFeature(blockType: org.bukkit.block.BlockType, world: org.bukkit.World): boolean;

			/**
			 * Gets if the EntityType is enabled for use by the Features in World.
			 */
			isEnabledByFeature(entityType: org.bukkit.entity.EntityType, world: org.bukkit.World): boolean;

		}
		interface ResourcePack {
			/**
			 * Gets the id of the resource pack.
			 */
			getId(): globalThis.java.util.UUID;

			/**
			 * Gets the url of the resource pack.
			 */
			getUrl(): string;

			/**
			 * Gets the hash of the resource pack.
			 */
			getHash(): (string | null);

			/**
			 * Gets the prompt to show of the resource pack.
			 */
			getPrompt(): (string | null);

			/**
			 * Gets if the resource pack is required by the server.
			 */
			isRequired(): boolean;

		}
	}
	namespace org.bukkit.configuration {
		interface Configuration extends Modify<org.bukkit.configuration.ConfigurationSection, {
			/**
			 * Sets the default value of the given path as provided.
			 * 
			 * If no source Configuration was provided as a default
			 * collection, then a new MemoryConfiguration will be created to
			 * hold the new default value.
			 * 
			 * If value is null, the value will be removed from the default
			 * Configuration source.
			 */
			addDefault(path: string, value: (any | null)): void;

			/**
			 * Sets the default values of the given paths as provided.
			 * 
			 * If no source Configuration was provided as a default
			 * collection, then a new MemoryConfiguration will be created to
			 * hold the new default values.
			 */
			addDefaults(defaults: globalThis.java.util.Map<string, any>): void;

			/**
			 * Sets the default values of the given paths as provided.
			 * 
			 * If no source Configuration was provided as a default
			 * collection, then a new MemoryConfiguration will be created to
			 * hold the new default value.
			 * 
			 * This method will not hold a reference to the specified Configuration,
			 * nor will it automatically update if that Configuration ever changes. If
			 * you require this, you should set the default source with setDefaults(org.bukkit.configuration.Configuration).
			 */
			addDefaults(defaults: org.bukkit.configuration.Configuration): void;

			/**
			 * Sets the source of all default values for this Configuration.
			 * 
			 * If a previous source was set, or previous default values were defined,
			 * then they will not be copied to the new source.
			 */
			setDefaults(defaults: org.bukkit.configuration.Configuration): void;

			/**
			 * Gets the source Configuration for this configuration.
			 * 
			 * If no configuration source was set, but default values were added, then
			 * a MemoryConfiguration will be returned. If no source was set
			 * and no defaults were set, then this method will return null.
			 */
			getDefaults(): (org.bukkit.configuration.Configuration | null);

			/**
			 * Gets the ConfigurationOptions for this Configuration.
			 * 
			 * All setters through this method are chainable.
			 */
			options(): org.bukkit.configuration.ConfigurationOptions;

		}> {}
		interface ConfigurationOptions {
			/**
			 * Returns the Configuration that this object is responsible for.
			 */
			configuration(): org.bukkit.configuration.Configuration;

			/**
			 * Gets the char that will be used to separate ConfigurationSections
			 * 
			 * This value does not affect how the Configuration is stored,
			 * only in how you access the data. The default value is '.'.
			 */
			pathSeparator(): any /* char */;

			/**
			 * Sets the char that will be used to separate ConfigurationSections
			 * 
			 * This value does not affect how the Configuration is stored,
			 * only in how you access the data. The default value is '.'.
			 */
			pathSeparator(value: any /* char */): org.bukkit.configuration.ConfigurationOptions;

			/**
			 * Checks if the Configuration should copy values from its default
			 * Configuration directly.
			 * 
			 * If this is true, all values in the default Configuration will be
			 * directly copied, making it impossible to distinguish between values
			 * that were set and values that are provided by default. As a result,
			 * ConfigurationSection.contains(java.lang.String) will always
			 * return the same value as ConfigurationSection.isSet(java.lang.String). The default value is
			 * false.
			 */
			copyDefaults(): boolean;

			/**
			 * Sets if the Configuration should copy values from its default
			 * Configuration directly.
			 * 
			 * If this is true, all values in the default Configuration will be
			 * directly copied, making it impossible to distinguish between values
			 * that were set and values that are provided by default. As a result,
			 * ConfigurationSection.contains(java.lang.String) will always
			 * return the same value as ConfigurationSection.isSet(java.lang.String). The default value is
			 * false.
			 */
			copyDefaults(value: boolean): org.bukkit.configuration.ConfigurationOptions;

		}
		interface ConfigurationSection {
			/**
			 * Gets a set containing all keys in this section.
			 * 
			 * If deep is set to true, then this will contain all the keys within any
			 * child ConfigurationSections (and their children, etc). These
			 * will be in a valid path notation for you to use.
			 * 
			 * If deep is set to false, then this will contain only the keys of any
			 * direct children, and not their own children.
			 */
			getKeys(deep: boolean): globalThis.java.util.Set<string>;

			/**
			 * Gets a Map containing all keys and their values for this section.
			 * 
			 * If deep is set to true, then this will contain all the keys and values
			 * within any child ConfigurationSections (and their children,
			 * etc). These keys will be in a valid path notation for you to use.
			 * 
			 * If deep is set to false, then this will contain only the keys and
			 * values of any direct children, and not their own children.
			 */
			getValues(deep: boolean): globalThis.java.util.Map<string, any>;

			/**
			 * Checks if this ConfigurationSection contains the given path.
			 * 
			 * If the value for the requested path does not exist but a default value
			 * has been specified, this will return true.
			 */
			contains(path: string): boolean;

			/**
			 * Checks if this ConfigurationSection contains the given path.
			 * 
			 * If the value for the requested path does not exist, the boolean parameter
			 * of true has been specified, a default value for the path exists, this
			 * will return true.
			 * 
			 * If a boolean parameter of false has been specified, true will only be
			 * returned if there is a set value for the specified path.
			 */
			contains(path: string, ignoreDefault: boolean): boolean;

			/**
			 * Checks if this ConfigurationSection has a value set for the
			 * given path.
			 * 
			 * If the value for the requested path does not exist but a default value
			 * has been specified, this will still return false.
			 */
			isSet(path: string): boolean;

			/**
			 * Gets the path of this ConfigurationSection from its root Configuration
			 * 
			 * For any Configuration themselves, this will return an empty
			 * string.
			 * 
			 * If the section is no longer contained within its root for any reason,
			 * such as being replaced with a different value, this may return null.
			 * 
			 * To retrieve the single name of this section, that is, the final part of
			 * the path returned by this method, you may use getName().
			 */
			getCurrentPath(): (string | null);

			/**
			 * Gets the name of this individual ConfigurationSection, in the
			 * path.
			 * 
			 * This will always be the final part of getCurrentPath(), unless
			 * the section is orphaned.
			 */
			getName(): string;

			/**
			 * Gets the root Configuration that contains this ConfigurationSection
			 * 
			 * For any Configuration themselves, this will return its own
			 * object.
			 * 
			 * If the section is no longer contained within its root for any reason,
			 * such as being replaced with a different value, this may return null.
			 */
			getRoot(): (org.bukkit.configuration.Configuration | null);

			/**
			 * Gets the parent ConfigurationSection that directly contains
			 * this ConfigurationSection.
			 * 
			 * For any Configuration themselves, this will return null.
			 * 
			 * If the section is no longer contained within its parent for any reason,
			 * such as being replaced with a different value, this may return null.
			 */
			getParent(): (org.bukkit.configuration.ConfigurationSection | null);

			/**
			 * Gets the requested Object by path.
			 * 
			 * If the Object does not exist but a default value has been specified,
			 * this will return the default value. If the Object does not exist and no
			 * default value was specified, this will return null.
			 */
			get(path: string): (any | null);

			/**
			 * Gets the requested Object by path, returning a default value if not
			 * found.
			 * 
			 * If the Object does not exist then the specified default value will
			 * returned regardless of if a default has been identified in the root
			 * Configuration.
			 */
			get(path: string, def: (any | null)): (any | null);

			/**
			 * Sets the specified path to the given value.
			 * 
			 * If value is null, the entry will be removed. Any existing entry will be
			 * replaced, regardless of what the new value is.
			 * 
			 * Some implementations may have limitations on what you may store. See
			 * their individual javadocs for details. No implementations should allow
			 * you to store Configurations or ConfigurationSections,
			 * please use createSection(java.lang.String) for that.
			 */
			set(path: string, value: (any | null)): void;

			/**
			 * Creates an empty ConfigurationSection at the specified path.
			 * 
			 * Any value that was previously set at this path will be overwritten. If
			 * the previous value was itself a ConfigurationSection, it will
			 * be orphaned.
			 */
			createSection(path: string): org.bukkit.configuration.ConfigurationSection;

			/**
			 * Creates a ConfigurationSection at the specified path, with
			 * specified values.
			 * 
			 * Any value that was previously set at this path will be overwritten. If
			 * the previous value was itself a ConfigurationSection, it will
			 * be orphaned.
			 */
			createSection(path: string, map: globalThis.java.util.Map): org.bukkit.configuration.ConfigurationSection;

			/**
			 * Gets the requested String by path.
			 * 
			 * If the String does not exist but a default value has been specified,
			 * this will return the default value. If the String does not exist and no
			 * default value was specified, this will return null.
			 */
			getString(path: string): (string | null);

			/**
			 * Gets the requested String by path, returning a default value if not
			 * found.
			 * 
			 * If the String does not exist then the specified default value will
			 * returned regardless of if a default has been identified in the root
			 * Configuration.
			 */
			getString(path: string, def: (string | null)): (string | null);

			/**
			 * Checks if the specified path is a String.
			 * 
			 * If the path exists but is not a String, this will return false. If the
			 * path does not exist, this will return false. If the path does not exist
			 * but a default value has been specified, this will check if that default
			 * value is a String and return appropriately.
			 */
			isString(path: string): boolean;

			/**
			 * Gets the requested int by path.
			 * 
			 * If the int does not exist but a default value has been specified, this
			 * will return the default value. If the int does not exist and no default
			 * value was specified, this will return 0.
			 */
			getInt(path: string): number;

			/**
			 * Gets the requested int by path, returning a default value if not found.
			 * 
			 * If the int does not exist then the specified default value will
			 * returned regardless of if a default has been identified in the root
			 * Configuration.
			 */
			getInt(path: string, def: number): number;

			/**
			 * Checks if the specified path is an int.
			 * 
			 * If the path exists but is not a int, this will return false. If the
			 * path does not exist, this will return false. If the path does not exist
			 * but a default value has been specified, this will check if that default
			 * value is a int and return appropriately.
			 */
			isInt(path: string): boolean;

			/**
			 * Gets the requested boolean by path.
			 * 
			 * If the boolean does not exist but a default value has been specified,
			 * this will return the default value. If the boolean does not exist and
			 * no default value was specified, this will return false.
			 */
			getBoolean(path: string): boolean;

			/**
			 * Gets the requested boolean by path, returning a default value if not
			 * found.
			 * 
			 * If the boolean does not exist then the specified default value will
			 * returned regardless of if a default has been identified in the root
			 * Configuration.
			 */
			getBoolean(path: string, def: boolean): boolean;

			/**
			 * Checks if the specified path is a boolean.
			 * 
			 * If the path exists but is not a boolean, this will return false. If the
			 * path does not exist, this will return false. If the path does not exist
			 * but a default value has been specified, this will check if that default
			 * value is a boolean and return appropriately.
			 */
			isBoolean(path: string): boolean;

			/**
			 * Gets the requested double by path.
			 * 
			 * If the double does not exist but a default value has been specified,
			 * this will return the default value. If the double does not exist and no
			 * default value was specified, this will return 0.
			 */
			getDouble(path: string): number;

			/**
			 * Gets the requested double by path, returning a default value if not
			 * found.
			 * 
			 * If the double does not exist then the specified default value will
			 * returned regardless of if a default has been identified in the root
			 * Configuration.
			 */
			getDouble(path: string, def: number): number;

			/**
			 * Checks if the specified path is a double.
			 * 
			 * If the path exists but is not a double, this will return false. If the
			 * path does not exist, this will return false. If the path does not exist
			 * but a default value has been specified, this will check if that default
			 * value is a double and return appropriately.
			 */
			isDouble(path: string): boolean;

			/**
			 * Gets the requested long by path.
			 * 
			 * If the long does not exist but a default value has been specified, this
			 * will return the default value. If the long does not exist and no
			 * default value was specified, this will return 0.
			 */
			getLong(path: string): number;

			/**
			 * Gets the requested long by path, returning a default value if not
			 * found.
			 * 
			 * If the long does not exist then the specified default value will
			 * returned regardless of if a default has been identified in the root
			 * Configuration.
			 */
			getLong(path: string, def: number): number;

			/**
			 * Checks if the specified path is a long.
			 * 
			 * If the path exists but is not a long, this will return false. If the
			 * path does not exist, this will return false. If the path does not exist
			 * but a default value has been specified, this will check if that default
			 * value is a long and return appropriately.
			 */
			isLong(path: string): boolean;

			/**
			 * Gets the requested List by path.
			 * 
			 * If the List does not exist but a default value has been specified, this
			 * will return the default value. If the List does not exist and no
			 * default value was specified, this will return null.
			 */
			getList(path: string): (globalThis.java.util.List | null);

			/**
			 * Gets the requested List by path, returning a default value if not
			 * found.
			 * 
			 * If the List does not exist then the specified default value will
			 * returned regardless of if a default has been identified in the root
			 * Configuration.
			 */
			getList(path: string, def: (globalThis.java.util.List | null)): (globalThis.java.util.List | null);

			/**
			 * Checks if the specified path is a List.
			 * 
			 * If the path exists but is not a List, this will return false. If the
			 * path does not exist, this will return false. If the path does not exist
			 * but a default value has been specified, this will check if that default
			 * value is a List and return appropriately.
			 */
			isList(path: string): boolean;

			/**
			 * Gets the requested List of String by path.
			 * 
			 * If the List does not exist but a default value has been specified, this
			 * will return the default value. If the List does not exist and no
			 * default value was specified, this will return an empty List.
			 * 
			 * This method will attempt to cast any values into a String if possible,
			 * but may miss any values out if they are not compatible.
			 */
			getStringList(path: string): globalThis.java.util.List<string>;

			/**
			 * Gets the requested List of Integer by path.
			 * 
			 * If the List does not exist but a default value has been specified, this
			 * will return the default value. If the List does not exist and no
			 * default value was specified, this will return an empty List.
			 * 
			 * This method will attempt to cast any values into a Integer if possible,
			 * but may miss any values out if they are not compatible.
			 */
			getIntegerList(path: string): globalThis.java.util.List<number>;

			/**
			 * Gets the requested List of Boolean by path.
			 * 
			 * If the List does not exist but a default value has been specified, this
			 * will return the default value. If the List does not exist and no
			 * default value was specified, this will return an empty List.
			 * 
			 * This method will attempt to cast any values into a Boolean if possible,
			 * but may miss any values out if they are not compatible.
			 */
			getBooleanList(path: string): globalThis.java.util.List<boolean>;

			/**
			 * Gets the requested List of Double by path.
			 * 
			 * If the List does not exist but a default value has been specified, this
			 * will return the default value. If the List does not exist and no
			 * default value was specified, this will return an empty List.
			 * 
			 * This method will attempt to cast any values into a Double if possible,
			 * but may miss any values out if they are not compatible.
			 */
			getDoubleList(path: string): globalThis.java.util.List<number>;

			/**
			 * Gets the requested List of Float by path.
			 * 
			 * If the List does not exist but a default value has been specified, this
			 * will return the default value. If the List does not exist and no
			 * default value was specified, this will return an empty List.
			 * 
			 * This method will attempt to cast any values into a Float if possible,
			 * but may miss any values out if they are not compatible.
			 */
			getFloatList(path: string): globalThis.java.util.List<number>;

			/**
			 * Gets the requested List of Long by path.
			 * 
			 * If the List does not exist but a default value has been specified, this
			 * will return the default value. If the List does not exist and no
			 * default value was specified, this will return an empty List.
			 * 
			 * This method will attempt to cast any values into a Long if possible,
			 * but may miss any values out if they are not compatible.
			 */
			getLongList(path: string): globalThis.java.util.List<number>;

			/**
			 * Gets the requested List of Byte by path.
			 * 
			 * If the List does not exist but a default value has been specified, this
			 * will return the default value. If the List does not exist and no
			 * default value was specified, this will return an empty List.
			 * 
			 * This method will attempt to cast any values into a Byte if possible,
			 * but may miss any values out if they are not compatible.
			 */
			getByteList(path: string): globalThis.java.util.List<number>;

			/**
			 * Gets the requested List of Character by path.
			 * 
			 * If the List does not exist but a default value has been specified, this
			 * will return the default value. If the List does not exist and no
			 * default value was specified, this will return an empty List.
			 * 
			 * This method will attempt to cast any values into a Character if
			 * possible, but may miss any values out if they are not compatible.
			 */
			getCharacterList(path: string): globalThis.java.util.List<string>;

			/**
			 * Gets the requested List of Short by path.
			 * 
			 * If the List does not exist but a default value has been specified, this
			 * will return the default value. If the List does not exist and no
			 * default value was specified, this will return an empty List.
			 * 
			 * This method will attempt to cast any values into a Short if possible,
			 * but may miss any values out if they are not compatible.
			 */
			getShortList(path: string): globalThis.java.util.List<number>;

			/**
			 * Gets the requested List of Maps by path.
			 * 
			 * If the List does not exist but a default value has been specified, this
			 * will return the default value. If the List does not exist and no
			 * default value was specified, this will return an empty List.
			 * 
			 * This method will attempt to cast any values into a Map if possible, but
			 * may miss any values out if they are not compatible.
			 */
			getMapList(path: string): globalThis.java.util.List;

			/**
			 * Gets the requested object at the given path.
			 * If the Object does not exist but a default value has been specified, this
			 * will return the default value. If the Object does not exist and no
			 * default value was specified, this will return null.
			 * Note: For example #getObject(path, String.class) is not
			 * equivalent to #getString(path) because
			 * #getString(path) converts internally all
			 * Objects to Strings. However, #getObject(path, Boolean.class) is
			 * equivalent to #getBoolean(path) for example.
			 */
			getObject<T = any>(path: string, clazz: globalThis.java.lang.Class<T>): (T | null);

			/**
			 * Gets the requested object at the given path, returning a default value if
			 * not found
			 * If the Object does not exist then the specified default value will
			 * returned regardless of if a default has been identified in the root
			 * Configuration.
			 * Note: For example #getObject(path, String.class, def) is
			 * not equivalent to
			 * #getString(path, def) because
			 * #getString(path, def) converts
			 * internally all Objects to Strings. However, #getObject(path,
			 * Boolean.class, def) is equivalent to #getBoolean(path,
			 * def) for example.
			 */
			getObject<T = any>(path: string, clazz: globalThis.java.lang.Class<T>, def: (T | null)): (T | null);

			/**
			 * Gets the requested ConfigurationSerializable object at the given
			 * path.
			 * If the Object does not exist but a default value has been specified, this
			 * will return the default value. If the Object does not exist and no
			 * default value was specified, this will return null.
			 */
			getSerializable<T = any>(path: string, clazz: globalThis.java.lang.Class<T>): (T | null);

			/**
			 * Gets the requested ConfigurationSerializable object at the given
			 * path, returning a default value if not found
			 * If the Object does not exist then the specified default value will
			 * returned regardless of if a default has been identified in the root
			 * Configuration.
			 */
			getSerializable<T = any>(path: string, clazz: globalThis.java.lang.Class<T>, def: (T | null)): (T | null);

			/**
			 * Gets the requested Vector by path.
			 * 
			 * If the Vector does not exist but a default value has been specified,
			 * this will return the default value. If the Vector does not exist and no
			 * default value was specified, this will return null.
			 */
			getVector(path: string): (org.bukkit.util.Vector | null);

			/**
			 * Gets the requested Vector by path, returning a default value if
			 * not found.
			 * 
			 * If the Vector does not exist then the specified default value will
			 * returned regardless of if a default has been identified in the root
			 * Configuration.
			 */
			getVector(path: string, def: (org.bukkit.util.Vector | null)): (org.bukkit.util.Vector | null);

			/**
			 * Checks if the specified path is a Vector.
			 * 
			 * If the path exists but is not a Vector, this will return false. If the
			 * path does not exist, this will return false. If the path does not exist
			 * but a default value has been specified, this will check if that default
			 * value is a Vector and return appropriately.
			 */
			isVector(path: string): boolean;

			/**
			 * Gets the requested OfflinePlayer by path.
			 * 
			 * If the OfflinePlayer does not exist but a default value has been
			 * specified, this will return the default value. If the OfflinePlayer
			 * does not exist and no default value was specified, this will return
			 * null.
			 */
			getOfflinePlayer(path: string): (org.bukkit.OfflinePlayer | null);

			/**
			 * Gets the requested OfflinePlayer by path, returning a default
			 * value if not found.
			 * 
			 * If the OfflinePlayer does not exist then the specified default value
			 * will returned regardless of if a default has been identified in the
			 * root Configuration.
			 */
			getOfflinePlayer(path: string, def: (org.bukkit.OfflinePlayer | null)): (org.bukkit.OfflinePlayer | null);

			/**
			 * Checks if the specified path is an OfflinePlayer.
			 * 
			 * If the path exists but is not a OfflinePlayer, this will return false.
			 * If the path does not exist, this will return false. If the path does
			 * not exist but a default value has been specified, this will check if
			 * that default value is a OfflinePlayer and return appropriately.
			 */
			isOfflinePlayer(path: string): boolean;

			/**
			 * Gets the requested ItemStack by path.
			 * 
			 * If the ItemStack does not exist but a default value has been specified,
			 * this will return the default value. If the ItemStack does not exist and
			 * no default value was specified, this will return null.
			 */
			getItemStack(path: string): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Gets the requested ItemStack by path, returning a default value
			 * if not found.
			 * 
			 * If the ItemStack does not exist then the specified default value will
			 * returned regardless of if a default has been identified in the root
			 * Configuration.
			 */
			getItemStack(path: string, def: (org.bukkit.inventory.ItemStack | null)): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Checks if the specified path is an ItemStack.
			 * 
			 * If the path exists but is not a ItemStack, this will return false. If
			 * the path does not exist, this will return false. If the path does not
			 * exist but a default value has been specified, this will check if that
			 * default value is a ItemStack and return appropriately.
			 */
			isItemStack(path: string): boolean;

			/**
			 * Gets the requested Color by path.
			 * 
			 * If the Color does not exist but a default value has been specified,
			 * this will return the default value. If the Color does not exist and no
			 * default value was specified, this will return null.
			 */
			getColor(path: string): (org.bukkit.Color | null);

			/**
			 * Gets the requested Color by path, returning a default value if
			 * not found.
			 * 
			 * If the Color does not exist then the specified default value will
			 * returned regardless of if a default has been identified in the root
			 * Configuration.
			 */
			getColor(path: string, def: (org.bukkit.Color | null)): (org.bukkit.Color | null);

			/**
			 * Checks if the specified path is a Color.
			 * 
			 * If the path exists but is not a Color, this will return false. If the
			 * path does not exist, this will return false. If the path does not exist
			 * but a default value has been specified, this will check if that default
			 * value is a Color and return appropriately.
			 */
			isColor(path: string): boolean;

			/**
			 * Gets the requested Location by path.
			 * 
			 * If the Location does not exist but a default value has been specified,
			 * this will return the default value. If the Location does not exist and no
			 * default value was specified, this will return null.
			 */
			getLocation(path: string): (org.bukkit.Location | null);

			/**
			 * Gets the requested Location by path, returning a default value if
			 * not found.
			 * 
			 * If the Location does not exist then the specified default value will
			 * returned regardless of if a default has been identified in the root
			 * Configuration.
			 */
			getLocation(path: string, def: (org.bukkit.Location | null)): (org.bukkit.Location | null);

			/**
			 * Checks if the specified path is a Location.
			 * 
			 * If the path exists but is not a Location, this will return false. If the
			 * path does not exist, this will return false. If the path does not exist
			 * but a default value has been specified, this will check if that default
			 * value is a Location and return appropriately.
			 */
			isLocation(path: string): boolean;

			/**
			 * Gets the requested ConfigurationSection by path.
			 * 
			 * If the ConfigurationSection does not exist but a default value has been
			 * specified, this will return the default value. If the
			 * ConfigurationSection does not exist and no default value was specified,
			 * this will return null.
			 */
			getConfigurationSection(path: string): (org.bukkit.configuration.ConfigurationSection | null);

			/**
			 * Checks if the specified path is a ConfigurationSection.
			 * 
			 * If the path exists but is not a ConfigurationSection, this will return
			 * false. If the path does not exist, this will return false. If the path
			 * does not exist but a default value has been specified, this will check
			 * if that default value is a ConfigurationSection and return
			 * appropriately.
			 */
			isConfigurationSection(path: string): boolean;

			/**
			 * Gets the equivalent ConfigurationSection from the default
			 * Configuration defined in getRoot().
			 * 
			 * If the root contains no defaults, or the defaults doesn't contain a
			 * value for this path, or the value at this path is not a ConfigurationSection then this will return null.
			 */
			getDefaultSection(): (org.bukkit.configuration.ConfigurationSection | null);

			/**
			 * Sets the default value in the root at the given path as provided.
			 * 
			 * If no source Configuration was provided as a default
			 * collection, then a new MemoryConfiguration will be created to
			 * hold the new default value.
			 * 
			 * If value is null, the value will be removed from the default
			 * Configuration source.
			 * 
			 * If the value as returned by getDefaultSection() is null, then
			 * this will create a new section at the path, replacing anything that may
			 * have existed there previously.
			 */
			addDefault(path: string, value: (any | null)): void;

			/**
			 * Gets the requested comment list by path.
			 * 
			 * If no comments exist, an empty list will be returned. A null entry
			 * represents an empty line and an empty String represents an empty comment
			 * line.
			 */
			getComments(path: string): globalThis.java.util.List<string>;

			/**
			 * Gets the requested inline comment list by path.
			 * 
			 * If no comments exist, an empty list will be returned. A null entry
			 * represents an empty line and an empty String represents an empty comment
			 * line.
			 */
			getInlineComments(path: string): globalThis.java.util.List<string>;

			/**
			 * Sets the comment list at the specified path.
			 * 
			 * If value is null, the comments will be removed. A null entry is an empty
			 * line and an empty String entry is an empty comment line. If the path does
			 * not exist, no comments will be set. Any existing comments will be
			 * replaced, regardless of what the new comments are.
			 * 
			 * Some implementations may have limitations on what persists. See their
			 * individual javadocs for details.
			 */
			setComments(path: string, comments: (globalThis.java.util.List<string> | null)): void;

			/**
			 * Sets the inline comment list at the specified path.
			 * 
			 * If value is null, the comments will be removed. A null entry is an empty
			 * line and an empty String entry is an empty comment line. If the path does
			 * not exist, no comment will be set. Any existing comments will be
			 * replaced, regardless of what the new comments are.
			 * 
			 * Some implementations may have limitations on what persists. See their
			 * individual javadocs for details.
			 */
			setInlineComments(path: string, comments: (globalThis.java.util.List<string> | null)): void;

		}
		interface InvalidConfigurationException {
		}
		class InvalidConfigurationException {
			/**
			 * Creates a new instance of InvalidConfigurationException without a
			 * message or cause.
			 */
			constructor();

			/**
			 * Constructs an instance of InvalidConfigurationException with the
			 * specified message.
			 */
			constructor(msg: string);

			/**
			 * Constructs an instance of InvalidConfigurationException with the
			 * specified cause.
			 */
			constructor(cause: globalThis.java.lang.Throwable);

			/**
			 * Constructs an instance of InvalidConfigurationException with the
			 * specified message and cause.
			 */
			constructor(msg: string, cause: globalThis.java.lang.Throwable);

		}
		interface MemoryConfiguration extends Modify<org.bukkit.configuration.MemorySection, {
			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			addDefault(path: string, value: (any | null)): void;

			/**
			 * Description copied from interface:Â Configuration
			 */
			addDefaults(defaults: globalThis.java.util.Map<string, any>): void;

			/**
			 * Description copied from interface:Â Configuration
			 */
			addDefaults(defaults: org.bukkit.configuration.Configuration): void;

			/**
			 * Description copied from interface:Â Configuration
			 */
			setDefaults(defaults: org.bukkit.configuration.Configuration): void;

			/**
			 * Description copied from interface:Â Configuration
			 */
			getDefaults(): (org.bukkit.configuration.Configuration | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getParent(): (org.bukkit.configuration.ConfigurationSection | null);

			/**
			 * Description copied from interface:Â Configuration
			 */
			options(): org.bukkit.configuration.MemoryConfigurationOptions;

		}> {}
		class MemoryConfiguration {
			/**
			 * Creates an empty MemoryConfiguration with no default values.
			 */
			constructor();

			/**
			 * Creates an empty MemoryConfiguration using the specified Configuration as a source for all default values.
			 */
			constructor(defaults: (org.bukkit.configuration.Configuration | null));

		}
		interface MemoryConfigurationOptions extends Modify<org.bukkit.configuration.ConfigurationOptions, {
			/**
			 * Description copied from class:Â ConfigurationOptions
			 */
			configuration(): org.bukkit.configuration.MemoryConfiguration;

			/**
			 * Description copied from class:Â ConfigurationOptions
			 */
			copyDefaults(value: boolean): org.bukkit.configuration.MemoryConfigurationOptions;

			/**
			 * Description copied from class:Â ConfigurationOptions
			 */
			pathSeparator(value: any /* char */): org.bukkit.configuration.MemoryConfigurationOptions;

		}> {}
		interface MemorySection {
			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getKeys(deep: boolean): globalThis.java.util.Set<string>;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getValues(deep: boolean): globalThis.java.util.Map<string, any>;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			contains(path: string): boolean;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			contains(path: string, ignoreDefault: boolean): boolean;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			isSet(path: string): boolean;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getCurrentPath(): string;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getName(): string;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getRoot(): (org.bukkit.configuration.Configuration | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getParent(): (org.bukkit.configuration.ConfigurationSection | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			addDefault(path: string, value: (any | null)): void;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getDefaultSection(): (org.bukkit.configuration.ConfigurationSection | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			set(path: string, value: (any | null)): void;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			get(path: string): (any | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			get(path: string, def: (any | null)): (any | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			createSection(path: string): org.bukkit.configuration.ConfigurationSection;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			createSection(path: string, map: globalThis.java.util.Map): org.bukkit.configuration.ConfigurationSection;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getString(path: string): (string | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getString(path: string, def: (string | null)): (string | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			isString(path: string): boolean;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getInt(path: string): number;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getInt(path: string, def: number): number;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			isInt(path: string): boolean;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getBoolean(path: string): boolean;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getBoolean(path: string, def: boolean): boolean;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			isBoolean(path: string): boolean;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getDouble(path: string): number;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getDouble(path: string, def: number): number;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			isDouble(path: string): boolean;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getLong(path: string): number;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getLong(path: string, def: number): number;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			isLong(path: string): boolean;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getList(path: string): (globalThis.java.util.List | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getList(path: string, def: (globalThis.java.util.List | null)): (globalThis.java.util.List | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			isList(path: string): boolean;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getStringList(path: string): globalThis.java.util.List<string>;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getIntegerList(path: string): globalThis.java.util.List<number>;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getBooleanList(path: string): globalThis.java.util.List<boolean>;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getDoubleList(path: string): globalThis.java.util.List<number>;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getFloatList(path: string): globalThis.java.util.List<number>;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getLongList(path: string): globalThis.java.util.List<number>;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getByteList(path: string): globalThis.java.util.List<number>;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getCharacterList(path: string): globalThis.java.util.List<string>;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getShortList(path: string): globalThis.java.util.List<number>;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getMapList(path: string): globalThis.java.util.List;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getObject<T = any>(path: string, clazz: globalThis.java.lang.Class<T>): (T | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getObject<T = any>(path: string, clazz: globalThis.java.lang.Class<T>, def: (T | null)): (T | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getSerializable<T = any>(path: string, clazz: globalThis.java.lang.Class<T>): (T | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getSerializable<T = any>(path: string, clazz: globalThis.java.lang.Class<T>, def: (T | null)): (T | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getVector(path: string): (org.bukkit.util.Vector | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getVector(path: string, def: (org.bukkit.util.Vector | null)): (org.bukkit.util.Vector | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			isVector(path: string): boolean;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getOfflinePlayer(path: string): (org.bukkit.OfflinePlayer | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getOfflinePlayer(path: string, def: (org.bukkit.OfflinePlayer | null)): (org.bukkit.OfflinePlayer | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			isOfflinePlayer(path: string): boolean;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getItemStack(path: string): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getItemStack(path: string, def: (org.bukkit.inventory.ItemStack | null)): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			isItemStack(path: string): boolean;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getColor(path: string): (org.bukkit.Color | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getColor(path: string, def: (org.bukkit.Color | null)): (org.bukkit.Color | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			isColor(path: string): boolean;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getLocation(path: string): (org.bukkit.Location | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getLocation(path: string, def: (org.bukkit.Location | null)): (org.bukkit.Location | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			isLocation(path: string): boolean;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getConfigurationSection(path: string): (org.bukkit.configuration.ConfigurationSection | null);

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			isConfigurationSection(path: string): boolean;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getComments(path: string): globalThis.java.util.List<string>;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			getInlineComments(path: string): globalThis.java.util.List<string>;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			setComments(path: string, comments: (globalThis.java.util.List<string> | null)): void;

			/**
			 * Description copied from interface:Â ConfigurationSection
			 */
			setInlineComments(path: string, comments: (globalThis.java.util.List<string> | null)): void;

			toString(): string;

		}
		namespace MemorySection {
			/**
			 * Creates a full path to the given ConfigurationSection from its
			 * root Configuration.
			 * 
			 * You may use this method for any given ConfigurationSection, not
			 * only MemorySection.
			 */
			function createPath(section: org.bukkit.configuration.ConfigurationSection, key: (string | null)): string;

			/**
			 * Creates a relative path to the given ConfigurationSection from
			 * the given relative section.
			 * 
			 * You may use this method for any given ConfigurationSection, not
			 * only MemorySection.
			 */
			function createPath(section: org.bukkit.configuration.ConfigurationSection, key: (string | null), relativeTo: (org.bukkit.configuration.ConfigurationSection | null)): string;

		}
	}
	namespace org.bukkit.configuration.serialization {
		interface ConfigurationSerializable {
			/**
			 * Creates a Map representation of this class.
			 * 
			 * This class must provide a method to restore this class, as defined in
			 * the ConfigurationSerializable interface javadocs.
			 */
			serialize(): globalThis.java.util.Map<string, any>;

		}
		interface ConfigurationSerialization {
			deserialize(args: globalThis.java.util.Map<string>): (org.bukkit.configuration.serialization.ConfigurationSerializable | null);

		}
		namespace ConfigurationSerialization {
			const SERIALIZED_TYPE_KEY: string;

			/**
			 * Attempts to deserialize the given arguments into a new instance of the
			 * given class.
			 * 
			 * The class must implement ConfigurationSerializable, including
			 * the extra methods as specified in the javadoc of
			 * ConfigurationSerializable.
			 * 
			 * If a new instance could not be made, an example being the class not
			 * fully implementing the interface, null will be returned.
			 */
			function deserializeObject(args: globalThis.java.util.Map<string>, clazz: globalThis.java.lang.Class<org.bukkit.configuration.serialization.ConfigurationSerializable>): (org.bukkit.configuration.serialization.ConfigurationSerializable | null);

			/**
			 * Attempts to deserialize the given arguments into a new instance of the
			 * given class.
			 * 
			 * The class must implement ConfigurationSerializable, including
			 * the extra methods as specified in the javadoc of
			 * ConfigurationSerializable.
			 * 
			 * If a new instance could not be made, an example being the class not
			 * fully implementing the interface, null will be returned.
			 */
			function deserializeObject(args: globalThis.java.util.Map<string>): (org.bukkit.configuration.serialization.ConfigurationSerializable | null);

			/**
			 * Registers the given ConfigurationSerializable class by its
			 * alias
			 */
			function registerClass(clazz: globalThis.java.lang.Class<org.bukkit.configuration.serialization.ConfigurationSerializable>): void;

			/**
			 * Registers the given alias to the specified ConfigurationSerializable class
			 */
			function registerClass(clazz: globalThis.java.lang.Class<org.bukkit.configuration.serialization.ConfigurationSerializable>, alias: string): void;

			/**
			 * Unregisters the specified alias to a ConfigurationSerializable
			 */
			function unregisterClass(alias: string): void;

			/**
			 * Unregisters any aliases for the specified ConfigurationSerializable class
			 */
			function unregisterClass(clazz: globalThis.java.lang.Class<org.bukkit.configuration.serialization.ConfigurationSerializable>): void;

			/**
			 * Attempts to get a registered ConfigurationSerializable class by
			 * its alias
			 */
			function getClassByAlias(alias: string): (globalThis.java.lang.Class<org.bukkit.configuration.serialization.ConfigurationSerializable> | null);

			/**
			 * Gets the correct alias for the given ConfigurationSerializable
			 * class
			 */
			function getAlias(clazz: globalThis.java.lang.Class<org.bukkit.configuration.serialization.ConfigurationSerializable>): string;

		}
		interface DelegateDeserialization {}
		interface SerializableAs {}
	}
	namespace org.bukkit.inventory.recipe {
		interface CookingBookCategory {}
		namespace CookingBookCategory {
			const FOOD: org.bukkit.inventory.recipe.CookingBookCategory;

			const BLOCKS: org.bukkit.inventory.recipe.CookingBookCategory;

			const MISC: org.bukkit.inventory.recipe.CookingBookCategory;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.inventory.recipe.CookingBookCategory;

		}
		interface CraftingBookCategory {}
		namespace CraftingBookCategory {
			const BUILDING: org.bukkit.inventory.recipe.CraftingBookCategory;

			const REDSTONE: org.bukkit.inventory.recipe.CraftingBookCategory;

			const EQUIPMENT: org.bukkit.inventory.recipe.CraftingBookCategory;

			const MISC: org.bukkit.inventory.recipe.CraftingBookCategory;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.inventory.recipe.CraftingBookCategory;

		}
	}
	namespace org.bukkit.scoreboard {
		interface Criteria {
			/**
			 * Get the name of this criteria (its unique id).
			 */
			getName(): string;

			/**
			 * Get whether or not this criteria is read only. If read only, scoreboards with this criteria
			 * cannot have their scores changed.
			 */
			isReadOnly(): boolean;

			/**
			 * Get the RenderType used by default for this criteria.
			 */
			getDefaultRenderType(): org.bukkit.scoreboard.RenderType;

		}
		namespace Criteria {
			/**
			 * The dummy criteria. Not changed by the server.
			 */
			const DUMMY: org.bukkit.scoreboard.Criteria;

			/**
			 * The trigger criteria. Changed when a player runs the /trigger command for an objective.
			 */
			const TRIGGER: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player dies.
			 */
			const DEATH_COUNT: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player kills another player.
			 */
			const PLAYER_KILL_COUNT: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player kills another living entity.
			 */
			const TOTAL_KILL_COUNT: org.bukkit.scoreboard.Criteria;

			/**
			 * Mirrors the player's health points (0 for no health, 20 for maximum default health).
			 */
			const HEALTH: org.bukkit.scoreboard.Criteria;

			/**
			 * Mirrors the player's food points (0 for no food, 20 for maximum food).
			 */
			const FOOD: org.bukkit.scoreboard.Criteria;

			/**
			 * Mirrors the player's air supply (0 for no air, 300 for maximum air).
			 */
			const AIR: org.bukkit.scoreboard.Criteria;

			/**
			 * Mirrors the player's armor points (0 for no armor, 20 for maximum armor).
			 */
			const ARMOR: org.bukkit.scoreboard.Criteria;

			/**
			 * Mirrors the player's experience points.
			 */
			const XP: org.bukkit.scoreboard.Criteria;

			/**
			 * Mirrors the player's experience level.
			 */
			const LEVEL: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player kills another player on the black team.
			 */
			const TEAM_KILL_BLACK: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player kills another player on the dark blue team.
			 */
			const TEAM_KILL_DARK_BLUE: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player kills another player on the dark green team.
			 */
			const TEAM_KILL_DARK_GREEN: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player kills another player on the dark aqua team.
			 */
			const TEAM_KILL_DARK_AQUA: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player kills another player on the dark red team.
			 */
			const TEAM_KILL_DARK_RED: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player kills another player on the dark purple team.
			 */
			const TEAM_KILL_DARK_PURPLE: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player kills another player on the gold team.
			 */
			const TEAM_KILL_GOLD: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player kills another player on the gray team.
			 */
			const TEAM_KILL_GRAY: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player kills another player on the dark gray team.
			 */
			const TEAM_KILL_DARK_GRAY: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player kills another player on the blue team.
			 */
			const TEAM_KILL_BLUE: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player kills another player on the green team.
			 */
			const TEAM_KILL_GREEN: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player kills another player on the aqua team.
			 */
			const TEAM_KILL_AQUA: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player kills another player on the red team.
			 */
			const TEAM_KILL_RED: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player kills another player on the light purple team.
			 */
			const TEAM_KILL_LIGHT_PURPLE: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player kills another player on the yellow team.
			 */
			const TEAM_KILL_YELLOW: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player kills another player on the white team.
			 */
			const TEAM_KILL_WHITE: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player is killed by a player on the black team.
			 */
			const KILLED_BY_TEAM_BLACK: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player is killed by a player on the dark blue team.
			 */
			const KILLED_BY_TEAM_DARK_BLUE: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player is killed by a player on the dark green team.
			 */
			const KILLED_BY_TEAM_DARK_GREEN: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player is killed by a player on the dark aqua team.
			 */
			const KILLED_BY_TEAM_DARK_AQUA: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player is killed by a player on the dark red team.
			 */
			const KILLED_BY_TEAM_DARK_RED: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player is killed by a player on the dark purple team.
			 */
			const KILLED_BY_TEAM_DARK_PURPLE: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player is killed by a player on the gold team.
			 */
			const KILLED_BY_TEAM_GOLD: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player is killed by a player on the gray team.
			 */
			const KILLED_BY_TEAM_GRAY: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player is killed by a player on the dark gray team.
			 */
			const KILLED_BY_TEAM_DARK_GRAY: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player is killed by a player on the blue team.
			 */
			const KILLED_BY_TEAM_BLUE: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player is killed by a player on the green team.
			 */
			const KILLED_BY_TEAM_GREEN: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player is killed by a player on the aqua team.
			 */
			const KILLED_BY_TEAM_AQUA: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player is killed by a player on the red team.
			 */
			const KILLED_BY_TEAM_RED: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player is killed by a player on the light purple team.
			 */
			const KILLED_BY_TEAM_LIGHT_PURPLE: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player is killed by a player on the yellow team.
			 */
			const KILLED_BY_TEAM_YELLOW: org.bukkit.scoreboard.Criteria;

			/**
			 * Increments automatically when a player is killed by a player on the white team.
			 */
			const KILLED_BY_TEAM_WHITE: org.bukkit.scoreboard.Criteria;

			/**
			 * Get a Criteria for the specified statistic pertaining to blocks or items.
			 * 
			 * This method expects a Statistic of Statistic.Type.BLOCK or Statistic.Type.ITEM and the
			 * Material matching said type (e.g. BLOCK statistics require materials where
			 * Material.isBlock() is true). This acts as a convenience to create more complex
			 * compound criteria such as those that increment on block breaks, or item uses. An example
			 * would be Criteria.statistic(Statistic.CRAFT_ITEM, Material.STICK), returning a
			 * Criteria representing "minecraft.crafted:minecraft.stick" which will increment when the
			 * player crafts a stick.
			 * 
			 * If the provided statistic does not require additional data, statistic(Statistic)
			 * is called and returned instead.
			 * 
			 * This method provides no guarantee that any given criteria exists on the vanilla server.
			 */
			function statistic(statistic: org.bukkit.Statistic, material: org.bukkit.Material): org.bukkit.scoreboard.Criteria;

			/**
			 * Get a Criteria for the specified statistic pertaining to an entity type.
			 * 
			 * This method expects a Statistic of Statistic.Type.ENTITY. This acts as a convenience
			 * to create more complex compound criteria such as being killed by a specific entity type.
			 * An example would be Criteria.statistic(Statistic.KILL_ENTITY, EntityType.CREEPER),
			 * returning a Criteria representing "minecraft.killed:minecraft.creeper" which will increment
			 * when the player kills a creepers.
			 * 
			 * If the provided statistic does not require additional data, statistic(Statistic)
			 * is called and returned instead.
			 * 
			 * This method provides no guarantee that any given criteria exists on the vanilla server.
			 */
			function statistic(statistic: org.bukkit.Statistic, entityType: org.bukkit.entity.EntityType): org.bukkit.scoreboard.Criteria;

			/**
			 * Get a Criteria for the specified statistic.
			 * 
			 * An example would be Criteria.statistic(Statistic.FLY_ONE_CM), returning a Criteria
			 * representing "minecraft.custom:minecraft.aviate_one_cm" which will increment when the player
			 * flies with an elytra.
			 * 
			 * This method provides no guarantee that any given criteria exists on the vanilla server. All
			 * statistics are accepted, however some may not operate as expected if additional data is
			 * required. For block/item-related statistics, see statistic(Statistic, Material),
			 * and for entity-related statistics, see statistic(Statistic, EntityType)
			 */
			function statistic(statistic: org.bukkit.Statistic): org.bukkit.scoreboard.Criteria;

			/**
			 * Get (or create) a new Criteria by its name.
			 */
			function create(name: string): org.bukkit.scoreboard.Criteria;

		}
		interface Criterias {}
		namespace Criterias {
			const HEALTH: string;

			const PLAYER_KILLS: string;

			const TOTAL_KILLS: string;

			const DEATHS: string;

		}
		interface DisplaySlot {}
		namespace DisplaySlot {
			const BELOW_NAME: org.bukkit.scoreboard.DisplaySlot;

			const PLAYER_LIST: org.bukkit.scoreboard.DisplaySlot;

			const SIDEBAR: org.bukkit.scoreboard.DisplaySlot;

			const SIDEBAR_BLACK: org.bukkit.scoreboard.DisplaySlot;

			const SIDEBAR_DARK_BLUE: org.bukkit.scoreboard.DisplaySlot;

			const SIDEBAR_DARK_GREEN: org.bukkit.scoreboard.DisplaySlot;

			const SIDEBAR_DARK_AQUA: org.bukkit.scoreboard.DisplaySlot;

			const SIDEBAR_DARK_RED: org.bukkit.scoreboard.DisplaySlot;

			const SIDEBAR_DARK_PURPLE: org.bukkit.scoreboard.DisplaySlot;

			const SIDEBAR_GOLD: org.bukkit.scoreboard.DisplaySlot;

			const SIDEBAR_GRAY: org.bukkit.scoreboard.DisplaySlot;

			const SIDEBAR_DARK_GRAY: org.bukkit.scoreboard.DisplaySlot;

			const SIDEBAR_BLUE: org.bukkit.scoreboard.DisplaySlot;

			const SIDEBAR_GREEN: org.bukkit.scoreboard.DisplaySlot;

			const SIDEBAR_AQUA: org.bukkit.scoreboard.DisplaySlot;

			const SIDEBAR_RED: org.bukkit.scoreboard.DisplaySlot;

			const SIDEBAR_LIGHT_PURPLE: org.bukkit.scoreboard.DisplaySlot;

			const SIDEBAR_YELLOW: org.bukkit.scoreboard.DisplaySlot;

			const SIDEBAR_WHITE: org.bukkit.scoreboard.DisplaySlot;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.scoreboard.DisplaySlot;

		}
		interface NameTagVisibility {}
		namespace NameTagVisibility {
			/**
			 * Always show the player's nametag.
			 */
			const ALWAYS: org.bukkit.scoreboard.NameTagVisibility;

			/**
			 * Never show the player's nametag.
			 */
			const NEVER: org.bukkit.scoreboard.NameTagVisibility;

			/**
			 * Show the player's nametag only to his own team members.
			 */
			const HIDE_FOR_OTHER_TEAMS: org.bukkit.scoreboard.NameTagVisibility;

			/**
			 * Show the player's nametag only to members of other teams.
			 */
			const HIDE_FOR_OWN_TEAM: org.bukkit.scoreboard.NameTagVisibility;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.scoreboard.NameTagVisibility;

		}
		interface Objective {
			/**
			 * Gets the name of this Objective
			 */
			getName(): string;

			/**
			 * Gets the name displayed to players for this objective
			 */
			getDisplayName(): string;

			/**
			 * Sets the name displayed to players for this objective.
			 */
			setDisplayName(displayName: string): void;

			/**
			 * Gets the criteria this objective tracks.
			 */
			getCriteria(): string;

			/**
			 * Gets the criteria this objective tracks.
			 */
			getTrackedCriteria(): org.bukkit.scoreboard.Criteria;

			/**
			 * Gets if the objective's scores can be modified directly by a plugin.
			 */
			isModifiable(): boolean;

			/**
			 * Gets the scoreboard to which this objective is attached.
			 */
			getScoreboard(): (org.bukkit.scoreboard.Scoreboard | null);

			/**
			 * Unregisters this objective from the scoreboard.
			 */
			unregister(): void;

			/**
			 * Sets this objective to display on the specified slot for the
			 * scoreboard, removing it from any other display slot.
			 */
			setDisplaySlot(slot: (org.bukkit.scoreboard.DisplaySlot | null)): void;

			/**
			 * Gets the display slot this objective is displayed at.
			 */
			getDisplaySlot(): (org.bukkit.scoreboard.DisplaySlot | null);

			/**
			 * Sets manner in which this objective will be rendered.
			 */
			setRenderType(renderType: org.bukkit.scoreboard.RenderType): void;

			/**
			 * Sets manner in which this objective will be rendered.
			 */
			getRenderType(): org.bukkit.scoreboard.RenderType;

			/**
			 * Gets a player's Score for an Objective on this Scoreboard
			 */
			getScore(player: org.bukkit.OfflinePlayer): org.bukkit.scoreboard.Score;

			/**
			 * Gets an entry's Score for an Objective on this Scoreboard.
			 */
			getScore(entry: string): org.bukkit.scoreboard.Score;

		}
		interface RenderType {}
		namespace RenderType {
			/**
			 * Display integer value.
			 */
			const INTEGER: org.bukkit.scoreboard.RenderType;

			/**
			 * Display number of hearts corresponding to value.
			 */
			const HEARTS: org.bukkit.scoreboard.RenderType;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.scoreboard.RenderType;

		}
		interface Score {
			/**
			 * Gets the OfflinePlayer being tracked by this Score
			 */
			getPlayer(): org.bukkit.OfflinePlayer;

			/**
			 * Gets the entry being tracked by this Score
			 */
			getEntry(): string;

			/**
			 * Gets the Objective being tracked by this Score
			 */
			getObjective(): org.bukkit.scoreboard.Objective;

			/**
			 * Gets the current score
			 */
			getScore(): number;

			/**
			 * Sets the current score.
			 */
			setScore(score: number): void;

			/**
			 * Shows if this score has been set at any point in time.
			 */
			isScoreSet(): boolean;

			/**
			 * Gets the scoreboard for the associated objective.
			 */
			getScoreboard(): (org.bukkit.scoreboard.Scoreboard | null);

		}
		interface Scoreboard {
			/**
			 * Registers an Objective on this Scoreboard
			 */
			registerNewObjective(name: string, criteria: string): org.bukkit.scoreboard.Objective;

			/**
			 * Registers an Objective on this Scoreboard
			 */
			registerNewObjective(name: string, criteria: string, displayName: string): org.bukkit.scoreboard.Objective;

			/**
			 * Registers an Objective on this Scoreboard
			 */
			registerNewObjective(name: string, criteria: string, displayName: string, renderType: org.bukkit.scoreboard.RenderType): org.bukkit.scoreboard.Objective;

			/**
			 * Registers an Objective on this Scoreboard
			 */
			registerNewObjective(name: string, criteria: org.bukkit.scoreboard.Criteria, displayName: string): org.bukkit.scoreboard.Objective;

			/**
			 * Registers an Objective on this Scoreboard
			 */
			registerNewObjective(name: string, criteria: org.bukkit.scoreboard.Criteria, displayName: string, renderType: org.bukkit.scoreboard.RenderType): org.bukkit.scoreboard.Objective;

			/**
			 * Gets an Objective on this Scoreboard by name
			 */
			getObjective(name: string): (org.bukkit.scoreboard.Objective | null);

			/**
			 * Gets all Objectives of a Criteria on the Scoreboard
			 */
			getObjectivesByCriteria(criteria: string): globalThis.java.util.Set<org.bukkit.scoreboard.Objective>;

			/**
			 * Gets all Objectives of a Criteria on the Scoreboard
			 */
			getObjectivesByCriteria(criteria: org.bukkit.scoreboard.Criteria): globalThis.java.util.Set<org.bukkit.scoreboard.Objective>;

			/**
			 * Gets all Objectives on this Scoreboard
			 */
			getObjectives(): globalThis.java.util.Set<org.bukkit.scoreboard.Objective>;

			/**
			 * Gets the Objective currently displayed in a DisplaySlot on this
			 * Scoreboard
			 */
			getObjective(slot: org.bukkit.scoreboard.DisplaySlot): (org.bukkit.scoreboard.Objective | null);

			/**
			 * Gets all scores for a player on this Scoreboard
			 */
			getScores(player: org.bukkit.OfflinePlayer): globalThis.java.util.Set<org.bukkit.scoreboard.Score>;

			/**
			 * Gets all scores for an entry on this Scoreboard
			 */
			getScores(entry: string): globalThis.java.util.Set<org.bukkit.scoreboard.Score>;

			/**
			 * Removes all scores for a player on this Scoreboard
			 */
			resetScores(player: org.bukkit.OfflinePlayer): void;

			/**
			 * Removes all scores for an entry on this Scoreboard
			 */
			resetScores(entry: string): void;

			/**
			 * Gets a player's Team on this Scoreboard
			 */
			getPlayerTeam(player: org.bukkit.OfflinePlayer): (org.bukkit.scoreboard.Team | null);

			/**
			 * Gets a entries Team on this Scoreboard
			 */
			getEntryTeam(entry: string): (org.bukkit.scoreboard.Team | null);

			/**
			 * Gets a Team by name on this Scoreboard
			 */
			getTeam(teamName: string): (org.bukkit.scoreboard.Team | null);

			/**
			 * Gets all teams on this Scoreboard
			 */
			getTeams(): globalThis.java.util.Set<org.bukkit.scoreboard.Team>;

			/**
			 * Registers a Team on this Scoreboard
			 */
			registerNewTeam(name: string): org.bukkit.scoreboard.Team;

			/**
			 * Gets all players tracked by this Scoreboard
			 */
			getPlayers(): globalThis.java.util.Set<org.bukkit.OfflinePlayer>;

			/**
			 * Gets all entries tracked by this Scoreboard
			 */
			getEntries(): globalThis.java.util.Set<string>;

			/**
			 * Clears any objective in the specified slot.
			 */
			clearSlot(slot: org.bukkit.scoreboard.DisplaySlot): void;

		}
		interface ScoreboardManager {
			/**
			 * Gets the primary Scoreboard controlled by the server.
			 * 
			 * This Scoreboard is saved by the server, is affected by the /scoreboard
			 * command, and is the scoreboard shown by default to players.
			 */
			getMainScoreboard(): org.bukkit.scoreboard.Scoreboard;

			/**
			 * Gets a new Scoreboard to be tracked by the server. This scoreboard will
			 * be tracked as long as a reference is kept, either by a player or by a
			 * plugin.
			 */
			getNewScoreboard(): org.bukkit.scoreboard.Scoreboard;

		}
		interface Team {
			/**
			 * Gets the name of this Team
			 */
			getName(): string;

			/**
			 * Gets the name displayed to entries for this team
			 */
			getDisplayName(): string;

			/**
			 * Sets the name displayed to entries for this team
			 */
			setDisplayName(displayName: string): void;

			/**
			 * Gets the prefix prepended to the display of entries on this team.
			 */
			getPrefix(): string;

			/**
			 * Sets the prefix prepended to the display of entries on this team.
			 */
			setPrefix(prefix: string): void;

			/**
			 * Gets the suffix appended to the display of entries on this team.
			 */
			getSuffix(): string;

			/**
			 * Sets the suffix appended to the display of entries on this team.
			 */
			setSuffix(suffix: string): void;

			/**
			 * Gets the color of the team.
			 * 
			 * This only sets the team outline, other occurrences of colors such as in
			 * names are handled by prefixes / suffixes.
			 */
			getColor(): org.bukkit.ChatColor;

			/**
			 * Sets the color of the team.
			 * 
			 * This only sets the team outline, other occurrences of colors such as in
			 * names are handled by prefixes / suffixes.
			 */
			setColor(color: org.bukkit.ChatColor): void;

			/**
			 * Gets the team friendly fire state
			 */
			allowFriendlyFire(): boolean;

			/**
			 * Sets the team friendly fire state
			 */
			setAllowFriendlyFire(enabled: boolean): void;

			/**
			 * Gets the team's ability to see invisible teammates.
			 */
			canSeeFriendlyInvisibles(): boolean;

			/**
			 * Sets the team's ability to see invisible teammates.
			 */
			setCanSeeFriendlyInvisibles(enabled: boolean): void;

			/**
			 * Gets the team's ability to see name tags
			 */
			getNameTagVisibility(): org.bukkit.scoreboard.NameTagVisibility;

			/**
			 * Set's the team's ability to see name tags
			 */
			setNameTagVisibility(visibility: org.bukkit.scoreboard.NameTagVisibility): void;

			/**
			 * Gets the Set of players on the team
			 */
			getPlayers(): globalThis.java.util.Set<org.bukkit.OfflinePlayer>;

			/**
			 * Gets the Set of entries on the team
			 */
			getEntries(): globalThis.java.util.Set<string>;

			/**
			 * Gets the size of the team
			 */
			getSize(): number;

			/**
			 * Gets the Scoreboard to which this team is attached
			 */
			getScoreboard(): (org.bukkit.scoreboard.Scoreboard | null);

			/**
			 * This puts the specified player onto this team for the scoreboard.
			 * 
			 * This will remove the player from any other team on the scoreboard.
			 */
			addPlayer(player: org.bukkit.OfflinePlayer): void;

			/**
			 * This puts the specified entry onto this team for the scoreboard.
			 * 
			 * This will remove the entry from any other team on the scoreboard.
			 */
			addEntry(entry: string): void;

			/**
			 * Removes the player from this team.
			 */
			removePlayer(player: org.bukkit.OfflinePlayer): boolean;

			/**
			 * Removes the entry from this team.
			 */
			removeEntry(entry: string): boolean;

			/**
			 * Unregisters this team from the Scoreboard
			 */
			unregister(): void;

			/**
			 * Checks to see if the specified player is a member of this team.
			 */
			hasPlayer(player: org.bukkit.OfflinePlayer): boolean;

			/**
			 * Checks to see if the specified entry is a member of this team.
			 */
			hasEntry(entry: string): boolean;

			/**
			 * Get an option for this team
			 */
			getOption(option: org.bukkit.scoreboard.Team.Option): org.bukkit.scoreboard.Team.OptionStatus;

			/**
			 * Set an option for this team
			 */
			setOption(option: org.bukkit.scoreboard.Team.Option, status: org.bukkit.scoreboard.Team.OptionStatus): void;

		}
		namespace Team {
			interface Option {}
			namespace Option {
				/**
				 * How to display the name tags of players on this team.
				 */
				const NAME_TAG_VISIBILITY: org.bukkit.scoreboard.Team.Option;

				/**
				 * How to display the death messages for players on this team.
				 */
				const DEATH_MESSAGE_VISIBILITY: org.bukkit.scoreboard.Team.Option;

				/**
				 * How players of this team collide with others.
				 */
				const COLLISION_RULE: org.bukkit.scoreboard.Team.Option;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.scoreboard.Team.Option;

			}
		}
		namespace Team {
			interface OptionStatus {}
			namespace OptionStatus {
				/**
				 * Apply this option to everyone.
				 */
				const ALWAYS: org.bukkit.scoreboard.Team.OptionStatus;

				/**
				 * Never apply this option.
				 */
				const NEVER: org.bukkit.scoreboard.Team.OptionStatus;

				/**
				 * Apply this option only for opposing teams.
				 */
				const FOR_OTHER_TEAMS: org.bukkit.scoreboard.Team.OptionStatus;

				/**
				 * Apply this option for only team members.
				 */
				const FOR_OWN_TEAM: org.bukkit.scoreboard.Team.OptionStatus;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.scoreboard.Team.OptionStatus;

			}
		}
	}
	namespace org.bukkit.inventory.meta.tags {
		interface CustomItemTagContainer {
			/**
			 * Stores a custom value on the ItemMeta.
			 * This API cannot be used to manipulate minecraft tags, as the values will
			 * be stored using your namespace. This method will override any existing
			 * value the meta may have stored under the provided key.
			 */
			setCustomTag<T = any, Z = any>(key: org.bukkit.NamespacedKey, type: org.bukkit.inventory.meta.tags.ItemTagType<T, Z>, value: Z): void;

			/**
			 * Returns if the item meta has a custom tag registered matching the
			 * provided parameters.
			 * This method will only return if the found value has the same primitive
			 * data type as the provided key.
			 * Storing a value using a custom ItemTagType implementation will
			 * not store the complex data type. Therefore storing a UUID (by storing a
			 * byte[]) will match hasCustomTag("key" , ItemTagType.BYTE_ARRAY).
			 * Likewise a stored byte[] will always match your UUID ItemTagType
			 * even if it is not 16 bytes long.
			 * This method is only usable for custom object keys. Overwriting existing
			 * tags, like the the display name, will not work as the values are stored
			 * using your namespace.
			 */
			hasCustomTag<T = any, Z = any>(key: org.bukkit.NamespacedKey, type: org.bukkit.inventory.meta.tags.ItemTagType<T, Z>): boolean;

			/**
			 * Returns the custom tag's value that is stored on the item.
			 */
			getCustomTag<T = any, Z = any>(key: org.bukkit.NamespacedKey, type: org.bukkit.inventory.meta.tags.ItemTagType<T, Z>): (Z | null);

			/**
			 * Removes a custom key from the item meta.
			 */
			removeCustomTag(key: org.bukkit.NamespacedKey): void;

			/**
			 * Returns if the container instance is empty, therefore has no entries
			 * inside it.
			 */
			isEmpty(): boolean;

			/**
			 * Returns the adapter context this tag container uses.
			 */
			getAdapterContext(): org.bukkit.inventory.meta.tags.ItemTagAdapterContext;

		}
		interface ItemTagAdapterContext {
			/**
			 * Creates a new and empty tag container instance.
			 */
			newTagContainer(): org.bukkit.inventory.meta.tags.CustomItemTagContainer;

		}
		interface ItemTagType<T = any, Z = any> {
			/**
			 * Returns the primitive data type of this tag.
			 */
			getPrimitiveType(): globalThis.java.lang.Class<T>;

			/**
			 * Returns the complex object type the primitive value resembles.
			 */
			getComplexType(): globalThis.java.lang.Class<Z>;

			/**
			 * Returns the primitive data that resembles the complex object passed to
			 * this method.
			 */
			toPrimitive(complex: Z, context: org.bukkit.inventory.meta.tags.ItemTagAdapterContext): T;

			/**
			 * Creates a complex object based of the passed primitive value
			 */
			fromPrimitive(primitive: T, context: org.bukkit.inventory.meta.tags.ItemTagAdapterContext): Z;

		}
		namespace ItemTagType {
			const BYTE: org.bukkit.inventory.meta.tags.ItemTagType<number, number>;

			const SHORT: org.bukkit.inventory.meta.tags.ItemTagType<number, number>;

			const INTEGER: org.bukkit.inventory.meta.tags.ItemTagType<number, number>;

			const LONG: org.bukkit.inventory.meta.tags.ItemTagType<number, number>;

			const FLOAT: org.bukkit.inventory.meta.tags.ItemTagType<number, number>;

			const DOUBLE: org.bukkit.inventory.meta.tags.ItemTagType<number, number>;

			const STRING: org.bukkit.inventory.meta.tags.ItemTagType<string, string>;

			const BYTE_ARRAY: org.bukkit.inventory.meta.tags.ItemTagType;

			const INTEGER_ARRAY: org.bukkit.inventory.meta.tags.ItemTagType;

			const LONG_ARRAY: org.bukkit.inventory.meta.tags.ItemTagType;

			const TAG_CONTAINER: org.bukkit.inventory.meta.tags.ItemTagType<org.bukkit.inventory.meta.tags.CustomItemTagContainer, org.bukkit.inventory.meta.tags.CustomItemTagContainer>;

		}
		namespace ItemTagType {
			interface PrimitiveTagType<T = any> {
				/**
				 * Description copied from interface:Â ItemTagType
				 */
				getPrimitiveType(): globalThis.java.lang.Class<T>;

				/**
				 * Description copied from interface:Â ItemTagType
				 */
				getComplexType(): globalThis.java.lang.Class<T>;

				/**
				 * Description copied from interface:Â ItemTagType
				 */
				toPrimitive(complex: T, context: org.bukkit.inventory.meta.tags.ItemTagAdapterContext): T;

				/**
				 * Description copied from interface:Â ItemTagType
				 */
				fromPrimitive(primitive: T, context: org.bukkit.inventory.meta.tags.ItemTagAdapterContext): T;

			}
		}
	}
	namespace org.bukkit.event.enchantment {
		interface EnchantItemEvent extends Modify<org.bukkit.event.inventory.InventoryEvent, {
			/**
			 * Gets the player enchanting the item
			 */
			getEnchanter(): org.bukkit.entity.Player;

			/**
			 * Gets the block being used to enchant the item
			 */
			getEnchantBlock(): org.bukkit.block.Block;

			/**
			 * Gets the item to be enchanted (can be modified)
			 */
			getItem(): org.bukkit.inventory.ItemStack;

			/**
			 * Gets the cost (minimum level) which is displayed as a number on the right
			 * hand side of the enchantment offer.
			 */
			getExpLevelCost(): number;

			/**
			 * Sets the cost (minimum level) which is displayed as a number on the right
			 * hand side of the enchantment offer.
			 */
			setExpLevelCost(level: number): void;

			/**
			 * Get map of enchantment (levels, keyed by type) to be added to item
			 * (modify map returned to change values). Note: Any enchantments not
			 * allowed for the item will be ignored
			 */
			getEnchantsToAdd(): globalThis.java.util.Map<org.bukkit.enchantments.Enchantment, number>;

			/**
			 * Get the Enchantment that was displayed as a hint to the player
			 * on the selected enchantment offer.
			 */
			getEnchantmentHint(): org.bukkit.enchantments.Enchantment;

			/**
			 * Get the level of the enchantment that was displayed as a hint to the
			 * player on the selected enchantment offer.
			 */
			getLevelHint(): number;

			/**
			 * Which button was pressed to initiate the enchanting.
			 */
			whichButton(): number;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class EnchantItemEvent {
			constructor(enchanter: org.bukkit.entity.Player, view: org.bukkit.inventory.InventoryView, table: org.bukkit.block.Block, item: org.bukkit.inventory.ItemStack, level: number, enchants: globalThis.java.util.Map<org.bukkit.enchantments.Enchantment, number>, enchantmentHint: org.bukkit.enchantments.Enchantment, levelHint: number, i: number);

		}
		namespace EnchantItemEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface PrepareItemEnchantEvent extends Modify<org.bukkit.event.inventory.InventoryEvent, {
			/**
			 * Gets the player enchanting the item
			 */
			getEnchanter(): org.bukkit.entity.Player;

			/**
			 * Gets the block being used to enchant the item
			 */
			getEnchantBlock(): org.bukkit.block.Block;

			/**
			 * Gets the item to be enchanted.
			 */
			getItem(): org.bukkit.inventory.ItemStack;

			/**
			 * Get enchantment bonus in effect - corresponds to number of bookshelves
			 */
			getEnchantmentBonus(): number;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class PrepareItemEnchantEvent {
			constructor(enchanter: org.bukkit.entity.Player, view: org.bukkit.inventory.InventoryView, table: org.bukkit.block.Block, item: org.bukkit.inventory.ItemStack, offers: org.bukkit.enchantments.EnchantmentOffer[], bonus: number);

		}
		namespace PrepareItemEnchantEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
	}
	namespace org.bukkit.enchantments {
		interface Enchantment {
			/**
			 * Gets the unique name of this enchantment
			 */
			getName(): string;

			/**
			 * Gets the maximum level that this Enchantment may become.
			 */
			getMaxLevel(): number;

			/**
			 * Gets the level that this Enchantment should start at
			 */
			getStartLevel(): number;

			/**
			 * Gets the type of ItemStack that may fit this Enchantment.
			 */
			getItemTarget(): org.bukkit.enchantments.EnchantmentTarget;

			/**
			 * Checks if this enchantment is a treasure enchantment.
			 * 
			 * Treasure enchantments can only be received via looting, trading, or
			 * fishing.
			 */
			isTreasure(): boolean;

			/**
			 * Checks if this enchantment is a cursed enchantment
			 * 
			 * Cursed enchantments are found the same way treasure enchantments are
			 */
			isCursed(): boolean;

			/**
			 * Check if this enchantment conflicts with another enchantment.
			 */
			conflictsWith(other: org.bukkit.enchantments.Enchantment): boolean;

			/**
			 * Checks if this Enchantment may be applied to the given ItemStack.
			 * 
			 * This does not check if it conflicts with any enchantments already
			 * applied to the item.
			 */
			canEnchantItem(item: org.bukkit.inventory.ItemStack): boolean;

		}
		class Enchantment {
			constructor();

		}
		namespace Enchantment {
			/**
			 * Provides protection against environmental damage
			 */
			const PROTECTION: org.bukkit.enchantments.Enchantment;

			/**
			 * Provides protection against fire damage
			 */
			const FIRE_PROTECTION: org.bukkit.enchantments.Enchantment;

			/**
			 * Provides protection against fall damage
			 */
			const FEATHER_FALLING: org.bukkit.enchantments.Enchantment;

			/**
			 * Provides protection against explosive damage
			 */
			const BLAST_PROTECTION: org.bukkit.enchantments.Enchantment;

			/**
			 * Provides protection against projectile damage
			 */
			const PROJECTILE_PROTECTION: org.bukkit.enchantments.Enchantment;

			/**
			 * Decreases the rate of air loss whilst underwater
			 */
			const RESPIRATION: org.bukkit.enchantments.Enchantment;

			/**
			 * Increases the speed at which a player may mine underwater
			 */
			const AQUA_AFFINITY: org.bukkit.enchantments.Enchantment;

			/**
			 * Damages the attacker
			 */
			const THORNS: org.bukkit.enchantments.Enchantment;

			/**
			 * Increases walking speed while in water
			 */
			const DEPTH_STRIDER: org.bukkit.enchantments.Enchantment;

			/**
			 * Freezes any still water adjacent to ice / frost which player is walking on
			 */
			const FROST_WALKER: org.bukkit.enchantments.Enchantment;

			/**
			 * Item cannot be removed
			 */
			const BINDING_CURSE: org.bukkit.enchantments.Enchantment;

			/**
			 * Increases damage against all targets
			 */
			const SHARPNESS: org.bukkit.enchantments.Enchantment;

			/**
			 * Increases damage against undead targets
			 */
			const SMITE: org.bukkit.enchantments.Enchantment;

			/**
			 * Increases damage against arthropod targets
			 */
			const BANE_OF_ARTHROPODS: org.bukkit.enchantments.Enchantment;

			/**
			 * All damage to other targets will knock them back when hit
			 */
			const KNOCKBACK: org.bukkit.enchantments.Enchantment;

			/**
			 * When attacking a target, has a chance to set them on fire
			 */
			const FIRE_ASPECT: org.bukkit.enchantments.Enchantment;

			/**
			 * Provides a chance of gaining extra loot when killing monsters
			 */
			const LOOTING: org.bukkit.enchantments.Enchantment;

			/**
			 * Increases damage against targets when using a sweep attack
			 */
			const SWEEPING_EDGE: org.bukkit.enchantments.Enchantment;

			/**
			 * Increases the rate at which you mine/dig
			 */
			const EFFICIENCY: org.bukkit.enchantments.Enchantment;

			/**
			 * Allows blocks to drop themselves instead of fragments (for example,
			 * stone instead of cobblestone)
			 */
			const SILK_TOUCH: org.bukkit.enchantments.Enchantment;

			/**
			 * Decreases the rate at which a tool looses durability
			 */
			const UNBREAKING: org.bukkit.enchantments.Enchantment;

			/**
			 * Provides a chance of gaining extra loot when destroying blocks
			 */
			const FORTUNE: org.bukkit.enchantments.Enchantment;

			/**
			 * Provides extra damage when shooting arrows from bows
			 */
			const POWER: org.bukkit.enchantments.Enchantment;

			/**
			 * Provides a knockback when an entity is hit by an arrow from a bow
			 */
			const PUNCH: org.bukkit.enchantments.Enchantment;

			/**
			 * Sets entities on fire when hit by arrows shot from a bow
			 */
			const FLAME: org.bukkit.enchantments.Enchantment;

			/**
			 * Provides infinite arrows when shooting a bow
			 */
			const INFINITY: org.bukkit.enchantments.Enchantment;

			/**
			 * Decreases odds of catching worthless junk
			 */
			const LUCK_OF_THE_SEA: org.bukkit.enchantments.Enchantment;

			/**
			 * Increases rate of fish biting your hook
			 */
			const LURE: org.bukkit.enchantments.Enchantment;

			/**
			 * Causes a thrown trident to return to the player who threw it
			 */
			const LOYALTY: org.bukkit.enchantments.Enchantment;

			/**
			 * Deals more damage to mobs that live in the ocean
			 */
			const IMPALING: org.bukkit.enchantments.Enchantment;

			/**
			 * When it is rainy, launches the player in the direction their trident is thrown
			 */
			const RIPTIDE: org.bukkit.enchantments.Enchantment;

			/**
			 * Strikes lightning when a mob is hit with a trident if conditions are
			 * stormy
			 */
			const CHANNELING: org.bukkit.enchantments.Enchantment;

			/**
			 * Shoot multiple arrows from crossbows
			 */
			const MULTISHOT: org.bukkit.enchantments.Enchantment;

			/**
			 * Charges crossbows quickly
			 */
			const QUICK_CHARGE: org.bukkit.enchantments.Enchantment;

			/**
			 * Crossbow projectiles pierce entities
			 */
			const PIERCING: org.bukkit.enchantments.Enchantment;

			/**
			 * Increases fall damage of maces
			 */
			const DENSITY: org.bukkit.enchantments.Enchantment;

			/**
			 * Reduces armor effectiveness against maces
			 */
			const BREACH: org.bukkit.enchantments.Enchantment;

			/**
			 * Emits wind burst upon hitting enemy
			 */
			const WIND_BURST: org.bukkit.enchantments.Enchantment;

			/**
			 * Allows mending the item using experience orbs
			 */
			const MENDING: org.bukkit.enchantments.Enchantment;

			/**
			 * Item disappears instead of dropping
			 */
			const VANISHING_CURSE: org.bukkit.enchantments.Enchantment;

			/**
			 * Walk quicker on soul blocks
			 */
			const SOUL_SPEED: org.bukkit.enchantments.Enchantment;

			/**
			 * Walk quicker while sneaking
			 */
			const SWIFT_SNEAK: org.bukkit.enchantments.Enchantment;

			/**
			 * Gets the Enchantment at the specified key
			 */
			function getByKey(key: (org.bukkit.NamespacedKey | null)): (org.bukkit.enchantments.Enchantment | null);

			/**
			 * Gets the Enchantment at the specified name
			 */
			function getByName(name: (string | null)): (org.bukkit.enchantments.Enchantment | null);

		}
		interface EnchantmentOffer {
			/**
			 * Get the type of the enchantment.
			 */
			getEnchantment(): org.bukkit.enchantments.Enchantment;

			/**
			 * Sets the type of the enchantment.
			 */
			setEnchantment(enchantment: org.bukkit.enchantments.Enchantment): void;

			/**
			 * Gets the level of the enchantment.
			 */
			getEnchantmentLevel(): number;

			/**
			 * Sets the level of the enchantment.
			 */
			setEnchantmentLevel(enchantmentLevel: number): void;

			/**
			 * Gets the cost (minimum level) which is displayed as a number on the right
			 * hand side of the enchantment offer.
			 */
			getCost(): number;

			/**
			 * Sets the cost (minimum level) which is displayed as a number on the right
			 * hand side of the enchantment offer.
			 */
			setCost(cost: number): void;

		}
		class EnchantmentOffer {
			constructor(enchantment: org.bukkit.enchantments.Enchantment, enchantmentLevel: number, cost: number);

		}
		interface EnchantmentTarget {
			/**
			 * Check whether this target includes the specified item.
			 */
			includes(item: org.bukkit.Material): boolean;

			/**
			 * Check whether this target includes the specified item.
			 */
			includes(item: org.bukkit.inventory.ItemStack): boolean;

		}
		namespace EnchantmentTarget {
			/**
			 * Allows the Enchantment to be placed on all items
			 */
			const ALL: org.bukkit.enchantments.EnchantmentTarget;

			/**
			 * Allows the Enchantment to be placed on armor
			 */
			const ARMOR: org.bukkit.enchantments.EnchantmentTarget;

			/**
			 * Allows the Enchantment to be placed on feet slot armor
			 */
			const ARMOR_FEET: org.bukkit.enchantments.EnchantmentTarget;

			/**
			 * Allows the Enchantment to be placed on leg slot armor
			 */
			const ARMOR_LEGS: org.bukkit.enchantments.EnchantmentTarget;

			/**
			 * Allows the Enchantment to be placed on torso slot armor
			 */
			const ARMOR_TORSO: org.bukkit.enchantments.EnchantmentTarget;

			/**
			 * Allows the Enchantment to be placed on head slot armor
			 */
			const ARMOR_HEAD: org.bukkit.enchantments.EnchantmentTarget;

			/**
			 * Allows the Enchantment to be placed on weapons (swords)
			 */
			const WEAPON: org.bukkit.enchantments.EnchantmentTarget;

			/**
			 * Allows the Enchantment to be placed on tools (spades, pickaxe, axes)
			 */
			const TOOL: org.bukkit.enchantments.EnchantmentTarget;

			/**
			 * Allows the Enchantment to be placed on bows.
			 */
			const BOW: org.bukkit.enchantments.EnchantmentTarget;

			/**
			 * Allows the Enchantment to be placed on fishing rods.
			 */
			const FISHING_ROD: org.bukkit.enchantments.EnchantmentTarget;

			/**
			 * Allows the enchantment to be placed on items with durability.
			 */
			const BREAKABLE: org.bukkit.enchantments.EnchantmentTarget;

			/**
			 * Allows the enchantment to be placed on wearable items.
			 */
			const WEARABLE: org.bukkit.enchantments.EnchantmentTarget;

			/**
			 * Allow the Enchantment to be placed on tridents.
			 */
			const TRIDENT: org.bukkit.enchantments.EnchantmentTarget;

			/**
			 * Allow the Enchantment to be placed on crossbows.
			 */
			const CROSSBOW: org.bukkit.enchantments.EnchantmentTarget;

			/**
			 * Allow the Enchantment to be placed on vanishing items.
			 */
			const VANISHABLE: org.bukkit.enchantments.EnchantmentTarget;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.enchantments.EnchantmentTarget;

		}
		interface EnchantmentWrapper extends Modify<org.bukkit.enchantments.Enchantment, {
			/**
			 * Gets the enchantment bound to this wrapper
			 */
			getEnchantment(): org.bukkit.enchantments.Enchantment;

		}> {}
	}
	namespace org.bukkit.block.spawner {
		interface SpawnRule {
			/**
			 * Gets the minimum (inclusive) block light required for spawning to
			 * succeed.
			 */
			getMinBlockLight(): number;

			/**
			 * Sets the minimum (inclusive) block light required for spawning to
			 * succeed.
			 */
			setMinBlockLight(minBlockLight: number): void;

			/**
			 * Gets the maximum (inclusive) block light required for spawning to
			 * succeed.
			 */
			getMaxBlockLight(): number;

			/**
			 * Sets the maximum (inclusive) block light required for spawning to
			 * succeed.
			 */
			setMaxBlockLight(maxBlockLight: number): void;

			/**
			 * Gets the minimum (inclusive) sky light required for spawning to succeed.
			 */
			getMinSkyLight(): number;

			/**
			 * Sets the minimum (inclusive) sky light required for spawning to succeed.
			 */
			setMinSkyLight(minSkyLight: number): void;

			/**
			 * Gets the maximum (inclusive) sky light required for spawning to succeed.
			 */
			getMaxSkyLight(): number;

			/**
			 * Sets the maximum (inclusive) sky light required for spawning to succeed.
			 */
			setMaxSkyLight(maxSkyLight: number): void;

			equals(obj: any): boolean;

			hashCode(): number;

			clone(): org.bukkit.block.spawner.SpawnRule;

			/**
			 * Description copied from interface:Â ConfigurationSerializable
			 */
			serialize(): globalThis.java.util.Map<string, any>;

		}
		class SpawnRule {
			/**
			 * Constructs a new SpawnRule.
			 */
			constructor(minBlockLight: number, maxBlockLight: number, minSkyLight: number, maxSkyLight: number);

		}
		namespace SpawnRule {
			function deserialize(args: globalThis.java.util.Map<string, any>): org.bukkit.block.spawner.SpawnRule;

		}
		interface SpawnerEntry {
			/**
			 * Gets the EntitySnapshot for this SpawnerEntry.
			 */
			getSnapshot(): org.bukkit.entity.EntitySnapshot;

			/**
			 * Sets the EntitySnapshot for this SpawnerEntry.
			 */
			setSnapshot(snapshot: org.bukkit.entity.EntitySnapshot): void;

			/**
			 * Gets the weight for this SpawnerEntry, when added to a spawner entries
			 * with higher weight will spawn more often.
			 */
			getSpawnWeight(): number;

			/**
			 * Sets the weight for this SpawnerEntry, when added to a spawner entries
			 * with higher weight will spawn more often.
			 */
			setSpawnWeight(spawnWeight: number): void;

			/**
			 * Gets a copy of the SpawnRule for this SpawnerEntry, or null if
			 * none has been set.
			 */
			getSpawnRule(): (org.bukkit.block.spawner.SpawnRule | null);

			/**
			 * Sets the SpawnRule for this SpawnerEntry, null may be used to
			 * clear the current spawn rule.
			 */
			setSpawnRule(spawnRule: (org.bukkit.block.spawner.SpawnRule | null)): void;

			/**
			 * Gets the equipment which will be applied to the spawned entity.
			 */
			getEquipment(): (org.bukkit.block.spawner.SpawnerEntry.Equipment | null);

			/**
			 * Sets the equipment which will be applied to the spawned entity.
			 */
			setEquipment(equipment: (org.bukkit.block.spawner.SpawnerEntry.Equipment | null)): void;

		}
		class SpawnerEntry {
			constructor(snapshot: org.bukkit.entity.EntitySnapshot, spawnWeight: number, spawnRule: (org.bukkit.block.spawner.SpawnRule | null));

			constructor(snapshot: org.bukkit.entity.EntitySnapshot, spawnWeight: number, spawnRule: (org.bukkit.block.spawner.SpawnRule | null), equipment: (org.bukkit.block.spawner.SpawnerEntry.Equipment | null));

		}
		namespace SpawnerEntry {
			interface Equipment {
				/**
				 * Set the loot table for the entity.
				 * 
				 * To remove a loot table use null. Do not use LootTables.EMPTY
				 * to clear a LootTable.
				 */
				setEquipmentLootTable(table: org.bukkit.loot.LootTable): void;

				/**
				 * Gets the loot table for the entity.
				 * 
				 * If an entity does not have a loot table, this will return null, NOT
				 * an empty loot table.
				 */
				getEquipmentLootTable(): org.bukkit.loot.LootTable;

				/**
				 * Gets a mutable map of the drop chances for each slot of the entity.
				 * If non-null, the entity's drop chances will be overridden with the
				 * given value.
				 */
				getDropChances(): globalThis.java.util.Map<org.bukkit.inventory.EquipmentSlot, number>;

			}
			class Equipment {
				constructor(equipmentLootTable: org.bukkit.loot.LootTable, dropChances: globalThis.java.util.Map<org.bukkit.inventory.EquipmentSlot, number>);

			}
		}
	}
	namespace org.bukkit.configuration.file {
		interface FileConfiguration extends Modify<org.bukkit.configuration.MemoryConfiguration, {
			/**
			 * Saves this FileConfiguration to the specified location.
			 * 
			 * If the file does not exist, it will be created. If already exists, it
			 * will be overwritten. If it cannot be overwritten or created, an
			 * exception will be thrown.
			 * 
			 * This method will save using the system default encoding, or possibly
			 * using UTF8.
			 */
			save(file: any /* java.io.File */): void;

			/**
			 * Saves this FileConfiguration to the specified location.
			 * 
			 * If the file does not exist, it will be created. If already exists, it
			 * will be overwritten. If it cannot be overwritten or created, an
			 * exception will be thrown.
			 * 
			 * This method will save using the system default encoding, or possibly
			 * using UTF8.
			 */
			save(file: string): void;

			/**
			 * Saves this FileConfiguration to a string, and returns it.
			 */
			saveToString(): string;

			/**
			 * Loads this FileConfiguration from the specified location.
			 * 
			 * All the values contained within this configuration will be removed,
			 * leaving only settings and defaults, and the new values will be loaded
			 * from the given file.
			 * 
			 * If the file cannot be loaded for any reason, an exception will be
			 * thrown.
			 */
			load(file: any /* java.io.File */): void;

			/**
			 * Loads this FileConfiguration from the specified reader.
			 * 
			 * All the values contained within this configuration will be removed,
			 * leaving only settings and defaults, and the new values will be loaded
			 * from the given stream.
			 */
			load(reader: any /* java.io.Reader */): void;

			/**
			 * Loads this FileConfiguration from the specified location.
			 * 
			 * All the values contained within this configuration will be removed,
			 * leaving only settings and defaults, and the new values will be loaded
			 * from the given file.
			 * 
			 * If the file cannot be loaded for any reason, an exception will be
			 * thrown.
			 */
			load(file: string): void;

			/**
			 * Loads this FileConfiguration from the specified string, as
			 * opposed to from file.
			 * 
			 * All the values contained within this configuration will be removed,
			 * leaving only settings and defaults, and the new values will be loaded
			 * from the given string.
			 * 
			 * If the string is invalid in any way, an exception will be thrown.
			 */
			loadFromString(contents: string): void;

			/**
			 * Description copied from interface:Â Configuration
			 */
			options(): org.bukkit.configuration.file.FileConfigurationOptions;

		}> {}
		class FileConfiguration {
			/**
			 * Creates an empty FileConfiguration with no default values.
			 */
			constructor();

			/**
			 * Creates an empty FileConfiguration using the specified Configuration as a source for all default values.
			 */
			constructor(defaults: (org.bukkit.configuration.Configuration | null));

		}
		interface FileConfigurationOptions extends Modify<org.bukkit.configuration.MemoryConfigurationOptions, {
			/**
			 * Description copied from class:Â ConfigurationOptions
			 */
			configuration(): org.bukkit.configuration.file.FileConfiguration;

			/**
			 * Description copied from class:Â ConfigurationOptions
			 */
			copyDefaults(value: boolean): org.bukkit.configuration.file.FileConfigurationOptions;

			/**
			 * Description copied from class:Â ConfigurationOptions
			 */
			pathSeparator(value: any /* char */): org.bukkit.configuration.file.FileConfigurationOptions;

			/**
			 * Gets the header that will be applied to the top of the saved output.
			 * 
			 * This header will be commented out and applied directly at the top of
			 * the generated output of the FileConfiguration. It is not
			 * required to include a newline at the end of the header as it will
			 * automatically be applied, but you may include one if you wish for extra
			 * spacing.
			 * 
			 * If no comments exist, an empty list will be returned. A null entry
			 * represents an empty line and an empty String represents an empty comment
			 * line.
			 */
			getHeader(): globalThis.java.util.List<string>;

			header(): string;

			/**
			 * Sets the header that will be applied to the top of the saved output.
			 * 
			 * This header will be commented out and applied directly at the top of
			 * the generated output of the FileConfiguration. It is not
			 * required to include a newline at the end of the header as it will
			 * automatically be applied, but you may include one if you wish for extra
			 * spacing.
			 * 
			 * If no comments exist, an empty list will be returned. A null entry
			 * represents an empty line and an empty String represents an empty comment
			 * line.
			 */
			setHeader(value: (globalThis.java.util.List<string> | null)): org.bukkit.configuration.file.FileConfigurationOptions;

			header(value: (string | null)): org.bukkit.configuration.file.FileConfigurationOptions;

			/**
			 * Gets the footer that will be applied to the bottom of the saved output.
			 * 
			 * This footer will be commented out and applied directly at the bottom of
			 * the generated output of the FileConfiguration. It is not required
			 * to include a newline at the beginning of the footer as it will
			 * automatically be applied, but you may include one if you wish for extra
			 * spacing.
			 * 
			 * If no comments exist, an empty list will be returned. A null entry
			 * represents an empty line and an empty String represents an empty comment
			 * line.
			 */
			getFooter(): globalThis.java.util.List<string>;

			/**
			 * Sets the footer that will be applied to the bottom of the saved output.
			 * 
			 * This footer will be commented out and applied directly at the bottom of
			 * the generated output of the FileConfiguration. It is not required
			 * to include a newline at the beginning of the footer as it will
			 * automatically be applied, but you may include one if you wish for extra
			 * spacing.
			 * 
			 * If no comments exist, an empty list will be returned. A null entry
			 * represents an empty line and an empty String represents an empty comment
			 * line.
			 */
			setFooter(value: (globalThis.java.util.List<string> | null)): org.bukkit.configuration.file.FileConfigurationOptions;

			/**
			 * Gets whether or not comments should be loaded and saved.
			 * 
			 * Defaults to true.
			 */
			parseComments(): boolean;

			/**
			 * Sets whether or not comments should be loaded and saved.
			 * 
			 * Defaults to true.
			 */
			parseComments(value: boolean): org.bukkit.configuration.MemoryConfigurationOptions;

			copyHeader(): boolean;

			copyHeader(value: boolean): org.bukkit.configuration.file.FileConfigurationOptions;

		}> {}
		interface YamlConfiguration extends Modify<org.bukkit.configuration.file.FileConfiguration, {
			/**
			 * Description copied from class:Â FileConfiguration
			 */
			saveToString(): string;

			/**
			 * Description copied from class:Â FileConfiguration
			 */
			loadFromString(contents: string): void;

			/**
			 * Description copied from interface:Â Configuration
			 */
			options(): org.bukkit.configuration.file.YamlConfigurationOptions;

		}> {}
		class YamlConfiguration {
			constructor();

		}
		namespace YamlConfiguration {
			/**
			 * Creates a new YamlConfiguration, loading from the given file.
			 * 
			 * Any errors loading the Configuration will be logged and then ignored.
			 * If the specified input is not a valid config, a blank config will be
			 * returned.
			 * 
			 * The encoding used may follow the system dependent default.
			 */
			function loadConfiguration(file: any /* java.io.File */): org.bukkit.configuration.file.YamlConfiguration;

			/**
			 * Creates a new YamlConfiguration, loading from the given reader.
			 * 
			 * Any errors loading the Configuration will be logged and then ignored.
			 * If the specified input is not a valid config, a blank config will be
			 * returned.
			 */
			function loadConfiguration(reader: any /* java.io.Reader */): org.bukkit.configuration.file.YamlConfiguration;

		}
		interface YamlConfigurationOptions extends Modify<org.bukkit.configuration.file.FileConfigurationOptions, {
			/**
			 * Description copied from class:Â ConfigurationOptions
			 */
			configuration(): org.bukkit.configuration.file.YamlConfiguration;

			/**
			 * Description copied from class:Â ConfigurationOptions
			 */
			copyDefaults(value: boolean): org.bukkit.configuration.file.YamlConfigurationOptions;

			/**
			 * Description copied from class:Â ConfigurationOptions
			 */
			pathSeparator(value: any /* char */): org.bukkit.configuration.file.YamlConfigurationOptions;

			/**
			 * Description copied from class:Â FileConfigurationOptions
			 */
			setHeader(value: (globalThis.java.util.List<string> | null)): org.bukkit.configuration.file.YamlConfigurationOptions;

			header(value: (string | null)): org.bukkit.configuration.file.YamlConfigurationOptions;

			/**
			 * Description copied from class:Â FileConfigurationOptions
			 */
			setFooter(value: (globalThis.java.util.List<string> | null)): org.bukkit.configuration.file.YamlConfigurationOptions;

			/**
			 * Description copied from class:Â FileConfigurationOptions
			 */
			parseComments(value: boolean): org.bukkit.configuration.file.YamlConfigurationOptions;

			copyHeader(value: boolean): org.bukkit.configuration.file.YamlConfigurationOptions;

			/**
			 * Gets how much spaces should be used to indent each line.
			 * 
			 * The minimum value this may be is 2, and the maximum is 9.
			 */
			indent(): number;

			/**
			 * Sets how much spaces should be used to indent each line.
			 * 
			 * The minimum value this may be is 2, and the maximum is 9.
			 */
			indent(value: number): org.bukkit.configuration.file.YamlConfigurationOptions;

			/**
			 * Gets how long a line can be, before it gets split.
			 */
			width(): number;

			/**
			 * Sets how long a line can be, before it gets split.
			 */
			width(value: number): org.bukkit.configuration.file.YamlConfigurationOptions;

		}> {}
		interface YamlConstructor {
			flattenMapping(node: any /* org.yaml.snakeyaml.nodes.MappingNode */): void;

			construct(node: any /* org.yaml.snakeyaml.nodes.Node */): (any | null);

		}
		class YamlConstructor {
			constructor();

			constructor(loaderOptions: any /* org.yaml.snakeyaml.LoaderOptions */);

		}
		interface YamlRepresenter {
			addClassTag(arg0: globalThis.java.lang.Class<any>, arg1: any /* org.yaml.snakeyaml.nodes.Tag */): any /* org.yaml.snakeyaml.nodes.Tag */;

			getTimeZone(): globalThis.java.util.TimeZone;

			setTimeZone(arg0: globalThis.java.util.TimeZone): void;

		}
		class YamlRepresenter {
			constructor();

			constructor(options: any /* org.yaml.snakeyaml.DumperOptions */);

		}
	}
	namespace org.bukkit.inventory.meta.components {
		interface FoodComponent extends Modify<org.bukkit.configuration.serialization.ConfigurationSerializable, {
			/**
			 * Gets the food restored by this item when eaten.
			 */
			getNutrition(): number;

			/**
			 * Sets the food restored by this item when eaten.
			 */
			setNutrition(nutrition: number): void;

			/**
			 * Gets the saturation restored by this item when eaten.
			 */
			getSaturation(): number;

			/**
			 * Sets the saturation restored by this item when eaten.
			 */
			setSaturation(saturation: number): void;

			/**
			 * Gets if this item can be eaten even when not hungry.
			 */
			canAlwaysEat(): boolean;

			/**
			 * Sets if this item can be eaten even when not hungry.
			 */
			setCanAlwaysEat(canAlwaysEat: boolean): void;

			/**
			 * Gets the time in seconds it will take for this item to be eaten.
			 */
			getEatSeconds(): number;

			/**
			 * Sets the time in seconds it will take for this item to be eaten.
			 */
			setEatSeconds(eatSeconds: number): void;

			/**
			 * Gets the item this food will convert to once eaten.
			 */
			getUsingConvertsTo(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Sets the item this food will convert to once eaten.
			 */
			setUsingConvertsTo(item: (org.bukkit.inventory.ItemStack | null)): void;

			/**
			 * Gets the effects which may be applied by this item when eaten.
			 */
			getEffects(): globalThis.java.util.List<org.bukkit.inventory.meta.components.FoodComponent.FoodEffect>;

			/**
			 * Sets the effects which may be applied by this item when eaten.
			 */
			setEffects(effects: globalThis.java.util.List<org.bukkit.inventory.meta.components.FoodComponent.FoodEffect>): void;

			/**
			 * Adds an effect which may be applied by this item when eaten.
			 */
			addEffect(effect: org.bukkit.potion.PotionEffect, probability: number): org.bukkit.inventory.meta.components.FoodComponent.FoodEffect;

		}> {}
		namespace FoodComponent {
			interface FoodEffect extends Modify<org.bukkit.configuration.serialization.ConfigurationSerializable, {
				/**
				 * Gets the effect which may be applied.
				 */
				getEffect(): org.bukkit.potion.PotionEffect;

				/**
				 * Sets the effect which may be applied.
				 */
				setEffect(effect: org.bukkit.potion.PotionEffect): void;

				/**
				 * Gets the probability of this effect being applied.
				 */
				getProbability(): number;

				/**
				 * Sets the probability of this effect being applied.
				 */
				setProbability(probability: number): void;

			}> {}
		}
		interface JukeboxPlayableComponent extends Modify<org.bukkit.configuration.serialization.ConfigurationSerializable, {
			/**
			 * Gets the song assigned to this component.
			 */
			getSong(): (org.bukkit.JukeboxSong | null);

			/**
			 * Gets the key of the song assigned to this component.
			 */
			getSongKey(): org.bukkit.NamespacedKey;

			/**
			 * Sets the song assigned to this component.
			 */
			setSong(song: org.bukkit.JukeboxSong): void;

			/**
			 * Sets the key of the song assigned to this component.
			 */
			setSongKey(song: org.bukkit.NamespacedKey): void;

			/**
			 * Gets if the song will show in the item tooltip.
			 */
			isShowInTooltip(): boolean;

			/**
			 * Sets if the song will show in the item tooltip.
			 */
			setShowInTooltip(show: boolean): void;

		}> {}
		interface ToolComponent extends Modify<org.bukkit.configuration.serialization.ConfigurationSerializable, {
			/**
			 * Get the default mining speed of this tool. This value is used by the tool
			 * if no rule explicitly overrides it. 1.0 is standard mining speed.
			 */
			getDefaultMiningSpeed(): number;

			/**
			 * Set the default mining speed of this tool. This value is used by the tool
			 * if no rule explicitly overrides it. 1.0 is standard mining speed.
			 */
			setDefaultMiningSpeed(speed: number): void;

			/**
			 * Get the amount of durability to be removed from the tool each time a
			 * block is broken.
			 */
			getDamagePerBlock(): number;

			/**
			 * Set the amount of durability to be removed from the tool each time a
			 * block is broken.
			 */
			setDamagePerBlock(damage: number): void;

			/**
			 * Get the list of ToolRules that apply to this tool.
			 */
			getRules(): globalThis.java.util.List<org.bukkit.inventory.meta.components.ToolComponent.ToolRule>;

			/**
			 * Set the list of ToolRules to apply to this tool. This
			 * will remove any existing tool rules.
			 */
			setRules(rules: globalThis.java.util.List<org.bukkit.inventory.meta.components.ToolComponent.ToolRule>): void;

			/**
			 * Add a new rule to this tool component, which provides further information
			 * about a specific block type.
			 */
			addRule(block: org.bukkit.Material, speed: (number | null), correctForDrops: (boolean | null)): org.bukkit.inventory.meta.components.ToolComponent.ToolRule;

			/**
			 * Add a new rule to this tool component, which provides further information
			 * about a collection of block types.
			 */
			addRule(blocks: globalThis.java.util.Collection<org.bukkit.Material>, speed: (number | null), correctForDrops: (boolean | null)): org.bukkit.inventory.meta.components.ToolComponent.ToolRule;

			/**
			 * Add a new rule to this tool component, which provides further information
			 * about a collection of block types represented by a block Tag.
			 */
			addRule(tag: org.bukkit.Tag<org.bukkit.Material>, speed: (number | null), correctForDrops: (boolean | null)): org.bukkit.inventory.meta.components.ToolComponent.ToolRule;

			/**
			 * Remove the given ToolComponent.ToolRule from this tool.
			 */
			removeRule(rule: org.bukkit.inventory.meta.components.ToolComponent.ToolRule): boolean;

		}> {}
		namespace ToolComponent {
			interface ToolRule extends Modify<org.bukkit.configuration.serialization.ConfigurationSerializable, {
				/**
				 * Get a collection of the block types to which this tool rule applies.
				 */
				getBlocks(): globalThis.java.util.Collection<org.bukkit.Material>;

				/**
				 * Set the block type to which this rule applies.
				 */
				setBlocks(block: org.bukkit.Material): void;

				/**
				 * Set the block types to which this rule applies.
				 */
				setBlocks(blocks: globalThis.java.util.Collection<org.bukkit.Material>): void;

				/**
				 * Set the block types (represented as a block Tag) to which
				 * this rule applies.
				 */
				setBlocks(tag: org.bukkit.Tag<org.bukkit.Material>): void;

				/**
				 * Get the mining speed of this rule. If non-null, this speed value is
				 * used in lieu of the default speed value of the tool. 1.0 is standard
				 * mining speed.
				 */
				getSpeed(): (number | null);

				/**
				 * Set the mining speed of this rule. 1.0 is standard mining speed.
				 */
				setSpeed(speed: (number | null)): void;

				/**
				 * Get whether or not this rule is considered the optimal tool for the
				 * blocks listed by this rule and will drop items. If non-null, this
				 * value is used in lieu of the default tool checking behavior defined
				 * by Minecraft.
				 */
				isCorrectForDrops(): (boolean | null);

				/**
				 * Set whether or not this rule is considered the optimal tool for the
				 * blocks listed by this rule and will drop items.
				 */
				setCorrectForDrops(correct: (boolean | null)): void;

			}> {}
		}
	}
	namespace org.bukkit.generator.structure {
		interface GeneratedStructure extends Modify<org.bukkit.persistence.PersistentDataHolder, {
			/**
			 * Gets the bounding box of this placed structure.
			 */
			getBoundingBox(): org.bukkit.util.BoundingBox;

			/**
			 * Gets the structure that this PlacedStructure represents.
			 */
			getStructure(): org.bukkit.generator.structure.Structure;

			/**
			 * Gets all the StructurePiece that make up this PlacedStructure.
			 */
			getPieces(): globalThis.java.util.Collection<org.bukkit.generator.structure.StructurePiece>;

		}> {}
		interface Structure {
			/**
			 * Returns the type of the structure.
			 */
			getStructureType(): org.bukkit.generator.structure.StructureType;

		}
		class Structure {
			constructor();

		}
		namespace Structure {
			const PILLAGER_OUTPOST: org.bukkit.generator.structure.Structure;

			const MINESHAFT: org.bukkit.generator.structure.Structure;

			const MINESHAFT_MESA: org.bukkit.generator.structure.Structure;

			const MANSION: org.bukkit.generator.structure.Structure;

			const JUNGLE_PYRAMID: org.bukkit.generator.structure.Structure;

			const DESERT_PYRAMID: org.bukkit.generator.structure.Structure;

			const IGLOO: org.bukkit.generator.structure.Structure;

			const SHIPWRECK: org.bukkit.generator.structure.Structure;

			const SHIPWRECK_BEACHED: org.bukkit.generator.structure.Structure;

			const SWAMP_HUT: org.bukkit.generator.structure.Structure;

			const STRONGHOLD: org.bukkit.generator.structure.Structure;

			const MONUMENT: org.bukkit.generator.structure.Structure;

			const OCEAN_RUIN_COLD: org.bukkit.generator.structure.Structure;

			const OCEAN_RUIN_WARM: org.bukkit.generator.structure.Structure;

			const FORTRESS: org.bukkit.generator.structure.Structure;

			const NETHER_FOSSIL: org.bukkit.generator.structure.Structure;

			const END_CITY: org.bukkit.generator.structure.Structure;

			const BURIED_TREASURE: org.bukkit.generator.structure.Structure;

			const BASTION_REMNANT: org.bukkit.generator.structure.Structure;

			const VILLAGE_PLAINS: org.bukkit.generator.structure.Structure;

			const VILLAGE_DESERT: org.bukkit.generator.structure.Structure;

			const VILLAGE_SAVANNA: org.bukkit.generator.structure.Structure;

			const VILLAGE_SNOWY: org.bukkit.generator.structure.Structure;

			const VILLAGE_TAIGA: org.bukkit.generator.structure.Structure;

			const RUINED_PORTAL: org.bukkit.generator.structure.Structure;

			const RUINED_PORTAL_DESERT: org.bukkit.generator.structure.Structure;

			const RUINED_PORTAL_JUNGLE: org.bukkit.generator.structure.Structure;

			const RUINED_PORTAL_SWAMP: org.bukkit.generator.structure.Structure;

			const RUINED_PORTAL_MOUNTAIN: org.bukkit.generator.structure.Structure;

			const RUINED_PORTAL_OCEAN: org.bukkit.generator.structure.Structure;

			const RUINED_PORTAL_NETHER: org.bukkit.generator.structure.Structure;

			const ANCIENT_CITY: org.bukkit.generator.structure.Structure;

			const TRAIL_RUINS: org.bukkit.generator.structure.Structure;

			const TRIAL_CHAMBERS: org.bukkit.generator.structure.Structure;

		}
		interface StructurePiece {
			/**
			 * Gets the bounding box of this structure piece.
			 */
			getBoundingBox(): org.bukkit.util.BoundingBox;

		}
		interface StructureType {
		}
		class StructureType {
			constructor();

		}
		namespace StructureType {
			const BURIED_TREASURE: org.bukkit.generator.structure.StructureType;

			const DESERT_PYRAMID: org.bukkit.generator.structure.StructureType;

			const END_CITY: org.bukkit.generator.structure.StructureType;

			const FORTRESS: org.bukkit.generator.structure.StructureType;

			const IGLOO: org.bukkit.generator.structure.StructureType;

			const JIGSAW: org.bukkit.generator.structure.StructureType;

			const JUNGLE_TEMPLE: org.bukkit.generator.structure.StructureType;

			const MINESHAFT: org.bukkit.generator.structure.StructureType;

			const NETHER_FOSSIL: org.bukkit.generator.structure.StructureType;

			const OCEAN_MONUMENT: org.bukkit.generator.structure.StructureType;

			const OCEAN_RUIN: org.bukkit.generator.structure.StructureType;

			const RUINED_PORTAL: org.bukkit.generator.structure.StructureType;

			const SHIPWRECK: org.bukkit.generator.structure.StructureType;

			const STRONGHOLD: org.bukkit.generator.structure.StructureType;

			const SWAMP_HUT: org.bukkit.generator.structure.StructureType;

			const WOODLAND_MANSION: org.bukkit.generator.structure.StructureType;

		}
	}
	namespace org.bukkit.help {
		interface GenericCommandHelpTopic extends Modify<org.bukkit.help.HelpTopic, {
			/**
			 * Description copied from class:Â HelpTopic
			 */
			canSee(sender: org.bukkit.command.CommandSender): boolean;

		}> {}
		class GenericCommandHelpTopic {
			constructor(command: org.bukkit.command.Command);

		}
		interface HelpMap {
			/**
			 * Returns a help topic for a given topic name.
			 */
			getHelpTopic(topicName: string): (org.bukkit.help.HelpTopic | null);

			/**
			 * Returns a collection of all the registered help topics.
			 */
			getHelpTopics(): globalThis.java.util.Collection<org.bukkit.help.HelpTopic>;

			/**
			 * Adds a topic to the server's help index.
			 */
			addTopic(topic: org.bukkit.help.HelpTopic): void;

			/**
			 * Clears out the contents of the help index. Normally called during
			 * server reload.
			 */
			clear(): void;

			/**
			 * Associates a HelpTopicFactory object with given command base
			 * class. Plugins typically call this method during onLoad(). Once
			 * registered, the custom HelpTopicFactory will be used to create a custom
			 * HelpTopic for all commands deriving from the
			 * commandClass base class, or all commands deriving from PluginCommand who's executor derives from
			 * commandClass base class.
			 */
			registerHelpTopicFactory(commandClass: globalThis.java.lang.Class, factory: org.bukkit.help.HelpTopicFactory): void;

			/**
			 * Gets the list of plugins the server administrator has chosen to exclude
			 * from the help index. Plugin authors who choose to directly extend
			 * Command instead of PluginCommand will need to check this collection in
			 * their HelpTopicFactory implementations to ensure they meet the
			 * server administrator's expectations.
			 */
			getIgnoredPlugins(): globalThis.java.util.List<string>;

		}
		interface HelpTopic {
			/**
			 * Determines if a Player is allowed to see this help topic.
			 * 
			 * HelpTopic implementations should take server administrator wishes into
			 * account as set by the amendCanSee(String) function.
			 */
			canSee(player: org.bukkit.command.CommandSender): boolean;

			/**
			 * Allows the server administrator to override the permission required to
			 * see a help topic.
			 * 
			 * HelpTopic implementations should take this into account when
			 * determining topic visibility on the canSee(org.bukkit.command.CommandSender) function.
			 */
			amendCanSee(amendedPermission: (string | null)): void;

			/**
			 * Returns the name of this help topic.
			 */
			getName(): string;

			/**
			 * Returns a brief description that will be displayed in the topic index.
			 */
			getShortText(): string;

			/**
			 * Returns the full description of this help topic that is displayed when
			 * the user requests this topic's details.
			 * 
			 * The result will be paginated to properly fit the user's client.
			 */
			getFullText(forWho: org.bukkit.command.CommandSender): string;

			/**
			 * Allows the server admin (or another plugin) to add or replace the
			 * contents of a help topic.
			 * 
			 * A null in either parameter will leave that part of the topic unchanged.
			 * In either amending parameter, the string <text> is replaced
			 * with the existing contents in the help topic. Use this to append or
			 * prepend additional content into an automatically generated help topic.
			 */
			amendTopic(amendedShortText: (string | null), amendedFullText: (string | null)): void;

		}
		class HelpTopic {
			constructor();

		}
		interface HelpTopicComparator {
			compare(lhs: org.bukkit.help.HelpTopic, rhs: org.bukkit.help.HelpTopic): number;

		}
		namespace HelpTopicComparator {
			function topicNameComparatorInstance(): org.bukkit.help.HelpTopicComparator.TopicNameComparator;

			function helpTopicComparatorInstance(): org.bukkit.help.HelpTopicComparator;

		}
		namespace HelpTopicComparator {
			interface TopicNameComparator {
				compare(lhs: string, rhs: string): number;

			}
		}
		interface HelpTopicFactory<TCommand = any> {
			/**
			 * This method accepts a command deriving from a custom command base class
			 * and constructs a custom HelpTopic for it.
			 */
			createTopic(command: TCommand): (org.bukkit.help.HelpTopic | null);

		}
		interface IndexHelpTopic extends Modify<org.bukkit.help.HelpTopic, {
			/**
			 * Description copied from class:Â HelpTopic
			 */
			canSee(sender: org.bukkit.command.CommandSender): boolean;

			/**
			 * Description copied from class:Â HelpTopic
			 */
			amendCanSee(amendedPermission: (string | null)): void;

			/**
			 * Description copied from class:Â HelpTopic
			 */
			getFullText(sender: org.bukkit.command.CommandSender): string;

		}> {}
		class IndexHelpTopic {
			constructor(name: string, shortText: (string | null), permission: (string | null), topics: globalThis.java.util.Collection<org.bukkit.help.HelpTopic>);

			constructor(name: string, shortText: (string | null), permission: (string | null), topics: globalThis.java.util.Collection<org.bukkit.help.HelpTopic>, preamble: (string | null));

		}
	}
	namespace org.bukkit.event.hanging {
		interface HangingBreakByEntityEvent extends Modify<org.bukkit.event.hanging.HangingBreakEvent, {
			/**
			 * Gets the entity that removed the hanging entity.
			 * May be null, for example when broken by an explosion.
			 */
			getRemover(): (org.bukkit.entity.Entity | null);

		}> {}
		class HangingBreakByEntityEvent {
			constructor(hanging: org.bukkit.entity.Hanging, remover: (org.bukkit.entity.Entity | null));

			constructor(hanging: org.bukkit.entity.Hanging, remover: (org.bukkit.entity.Entity | null), cause: org.bukkit.event.hanging.HangingBreakEvent.RemoveCause);

		}
		interface HangingBreakEvent extends Modify<org.bukkit.event.hanging.HangingEvent, {
			/**
			 * Gets the cause for the hanging entity's removal
			 */
			getCause(): org.bukkit.event.hanging.HangingBreakEvent.RemoveCause;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class HangingBreakEvent {
			constructor(hanging: org.bukkit.entity.Hanging, cause: org.bukkit.event.hanging.HangingBreakEvent.RemoveCause);

		}
		namespace HangingBreakEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace HangingBreakEvent {
			interface RemoveCause {}
			namespace RemoveCause {
				/**
				 * Removed by an entity
				 */
				const ENTITY: org.bukkit.event.hanging.HangingBreakEvent.RemoveCause;

				/**
				 * Removed by an explosion
				 */
				const EXPLOSION: org.bukkit.event.hanging.HangingBreakEvent.RemoveCause;

				/**
				 * Removed by placing a block on it
				 */
				const OBSTRUCTION: org.bukkit.event.hanging.HangingBreakEvent.RemoveCause;

				/**
				 * Removed by destroying the block behind it, etc
				 */
				const PHYSICS: org.bukkit.event.hanging.HangingBreakEvent.RemoveCause;

				/**
				 * Removed by an uncategorised cause
				 */
				const DEFAULT: org.bukkit.event.hanging.HangingBreakEvent.RemoveCause;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.hanging.HangingBreakEvent.RemoveCause;

			}
		}
		interface HangingEvent extends Modify<org.bukkit.event.Event, {
			/**
			 * Gets the hanging entity involved in this event.
			 */
			getEntity(): org.bukkit.entity.Hanging;

		}> {}
		interface HangingPlaceEvent extends Modify<org.bukkit.event.hanging.HangingEvent, {
			/**
			 * Returns the player placing the hanging entity
			 */
			getPlayer(): (org.bukkit.entity.Player | null);

			/**
			 * Returns the block that the hanging entity was placed on
			 */
			getBlock(): org.bukkit.block.Block;

			/**
			 * Returns the face of the block that the hanging entity was placed on
			 */
			getBlockFace(): org.bukkit.block.BlockFace;

			/**
			 * Returns the hand that was used to place the hanging entity, or null
			 * if a player did not place the hanging entity.
			 */
			getHand(): (org.bukkit.inventory.EquipmentSlot | null);

			/**
			 * Gets the item from which the hanging entity originated
			 */
			getItemStack(): (org.bukkit.inventory.ItemStack | null);

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class HangingPlaceEvent {
			constructor(hanging: org.bukkit.entity.Hanging, player: (org.bukkit.entity.Player | null), block: org.bukkit.block.Block, blockFace: org.bukkit.block.BlockFace, hand: (org.bukkit.inventory.EquipmentSlot | null));

			constructor(hanging: org.bukkit.entity.Hanging, player: (org.bukkit.entity.Player | null), block: org.bukkit.block.Block, blockFace: org.bukkit.block.BlockFace, hand: (org.bukkit.inventory.EquipmentSlot | null), itemStack: (org.bukkit.inventory.ItemStack | null));

		}
		namespace HangingPlaceEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
	}
	namespace org.bukkit.potion {
		interface PotionBrewer {
			/**
			 * Creates a PotionEffect from the given PotionEffectType,
			 * applying duration modifiers and checks.
			 */
			createEffect(potion: org.bukkit.potion.PotionEffectType, duration: number, amplifier: number): org.bukkit.potion.PotionEffect;

			/**
			 * Returns a collection of PotionEffect that would be applied from
			 * a potion with the given data value.
			 */
			getEffectsFromDamage(damage: number): globalThis.java.util.Collection<org.bukkit.potion.PotionEffect>;

			/**
			 * Returns a collection of PotionEffect that would be applied from
			 * a potion with the given type.
			 */
			getEffects(type: org.bukkit.potion.PotionType, upgraded: boolean, extended: boolean): globalThis.java.util.Collection<org.bukkit.potion.PotionEffect>;

		}
		interface PotionData {
			/**
			 * Gets the type of the potion, Type matches up with each kind of craftable
			 * potion
			 */
			getType(): org.bukkit.potion.PotionType;

			/**
			 * Checks if the potion is in an upgraded state. This refers to whether or
			 * not the potion is Tier 2, such as Potion of Fire Resistance II.
			 */
			isUpgraded(): boolean;

			/**
			 * Checks if the potion is in an extended state. This refers to the extended
			 * duration potions
			 */
			isExtended(): boolean;

			hashCode(): number;

			equals(obj: any): boolean;

		}
		class PotionData {
			/**
			 * Instantiates a final PotionData object to contain information about a
			 * Potion
			 */
			constructor(type: org.bukkit.potion.PotionType, extended: boolean, upgraded: boolean);

			constructor(type: org.bukkit.potion.PotionType);

		}
		interface PotionEffect {
			/**
			 * Description copied from interface:Â ConfigurationSerializable
			 */
			serialize(): globalThis.java.util.Map<string, any>;

			/**
			 * Attempts to add the effect represented by this object to the given
			 * LivingEntity.
			 */
			apply(entity: org.bukkit.entity.LivingEntity): boolean;

			equals(obj: any): boolean;

			/**
			 * Returns the amplifier of this effect. A higher amplifier means the
			 * potion effect happens more often over its duration and in some cases
			 * has more effect on its target.
			 */
			getAmplifier(): number;

			/**
			 * Returns the duration (in ticks) that this effect will run for when
			 * applied to a LivingEntity.
			 */
			getDuration(): number;

			/**
			 * Returns whether or not this potion effect has an infinite duration. Potion
			 * effects with infinite durations will display an infinite symbol and never
			 * expire unless manually removed.
			 */
			isInfinite(): boolean;

			/**
			 * Returns whether or not this potion effect has a shorter duration than the
			 * provided potion effect.
			 * 
			 * An infinite duration is considered longer than non-infinite durations. If
			 * both potion effects have infinite durations, then neither is shorter than
			 * the other and this method will return false.
			 */
			isShorterThan(other: org.bukkit.potion.PotionEffect): boolean;

			/**
			 * Returns the PotionEffectType of this effect.
			 */
			getType(): org.bukkit.potion.PotionEffectType;

			/**
			 * Makes potion effect produce more, translucent, particles.
			 */
			isAmbient(): boolean;

			hasParticles(): boolean;

			getColor(): (org.bukkit.Color | null);

			hasIcon(): boolean;

			hashCode(): number;

			toString(): string;

		}
		class PotionEffect {
			/**
			 * Creates a potion effect.
			 */
			constructor(type: org.bukkit.potion.PotionEffectType, duration: number, amplifier: number, ambient: boolean, particles: boolean, icon: boolean);

			/**
			 * Creates a potion effect with no defined color.
			 */
			constructor(type: org.bukkit.potion.PotionEffectType, duration: number, amplifier: number, ambient: boolean, particles: boolean);

			/**
			 * Creates a potion effect. Assumes that particles are visible
			 */
			constructor(type: org.bukkit.potion.PotionEffectType, duration: number, amplifier: number, ambient: boolean);

			/**
			 * Creates a potion effect. Assumes ambient is true.
			 */
			constructor(type: org.bukkit.potion.PotionEffectType, duration: number, amplifier: number);

			/**
			 * Constructor for deserialization.
			 */
			constructor(map: globalThis.java.util.Map<string, any>);

		}
		namespace PotionEffect {
			/**
			 * A constant denoting infinite potion duration.
			 */
			const INFINITE_DURATION: number;

		}
		interface PotionEffectType {
			/**
			 * Creates a PotionEffect from this PotionEffectType, applying duration
			 * modifiers and checks.
			 */
			createEffect(duration: number, amplifier: number): org.bukkit.potion.PotionEffect;

			/**
			 * Returns whether the effect of this type happens once, immediately.
			 */
			isInstant(): boolean;

			/**
			 * Returns the category of this effect type.
			 */
			getCategory(): org.bukkit.potion.PotionEffectTypeCategory;

			/**
			 * Returns the color of this effect type.
			 */
			getColor(): org.bukkit.Color;

			/**
			 * Returns the duration modifier applied to effects of this type.
			 */
			getDurationModifier(): number;

			/**
			 * Returns the unique ID of this type.
			 */
			getId(): number;

			/**
			 * Returns the name of this effect type.
			 */
			getName(): string;

		}
		class PotionEffectType {
			constructor();

		}
		namespace PotionEffectType {
			/**
			 * Increases movement speed.
			 */
			const SPEED: org.bukkit.potion.PotionEffectType;

			/**
			 * Decreases movement speed.
			 */
			const SLOWNESS: org.bukkit.potion.PotionEffectType;

			/**
			 * Increases dig speed.
			 */
			const HASTE: org.bukkit.potion.PotionEffectType;

			/**
			 * Decreases dig speed.
			 */
			const MINING_FATIGUE: org.bukkit.potion.PotionEffectType;

			/**
			 * Increases damage dealt.
			 */
			const STRENGTH: org.bukkit.potion.PotionEffectType;

			/**
			 * Heals an entity.
			 */
			const INSTANT_HEALTH: org.bukkit.potion.PotionEffectType;

			/**
			 * Hurts an entity.
			 */
			const INSTANT_DAMAGE: org.bukkit.potion.PotionEffectType;

			/**
			 * Increases jump height.
			 */
			const JUMP_BOOST: org.bukkit.potion.PotionEffectType;

			/**
			 * Warps vision on the client.
			 */
			const NAUSEA: org.bukkit.potion.PotionEffectType;

			/**
			 * Regenerates health.
			 */
			const REGENERATION: org.bukkit.potion.PotionEffectType;

			/**
			 * Decreases damage dealt to an entity.
			 */
			const RESISTANCE: org.bukkit.potion.PotionEffectType;

			/**
			 * Stops fire damage.
			 */
			const FIRE_RESISTANCE: org.bukkit.potion.PotionEffectType;

			/**
			 * Allows breathing underwater.
			 */
			const WATER_BREATHING: org.bukkit.potion.PotionEffectType;

			/**
			 * Grants invisibility.
			 */
			const INVISIBILITY: org.bukkit.potion.PotionEffectType;

			/**
			 * Blinds an entity.
			 */
			const BLINDNESS: org.bukkit.potion.PotionEffectType;

			/**
			 * Allows an entity to see in the dark.
			 */
			const NIGHT_VISION: org.bukkit.potion.PotionEffectType;

			/**
			 * Increases hunger.
			 */
			const HUNGER: org.bukkit.potion.PotionEffectType;

			/**
			 * Decreases damage dealt by an entity.
			 */
			const WEAKNESS: org.bukkit.potion.PotionEffectType;

			/**
			 * Deals damage to an entity over time.
			 */
			const POISON: org.bukkit.potion.PotionEffectType;

			/**
			 * Deals damage to an entity over time and gives the health to the
			 * shooter.
			 */
			const WITHER: org.bukkit.potion.PotionEffectType;

			/**
			 * Increases the maximum health of an entity.
			 */
			const HEALTH_BOOST: org.bukkit.potion.PotionEffectType;

			/**
			 * Increases the maximum health of an entity with health that cannot be
			 * regenerated, but is refilled every 30 seconds.
			 */
			const ABSORPTION: org.bukkit.potion.PotionEffectType;

			/**
			 * Increases the food level of an entity each tick.
			 */
			const SATURATION: org.bukkit.potion.PotionEffectType;

			/**
			 * Outlines the entity so that it can be seen from afar.
			 */
			const GLOWING: org.bukkit.potion.PotionEffectType;

			/**
			 * Causes the entity to float into the air.
			 */
			const LEVITATION: org.bukkit.potion.PotionEffectType;

			/**
			 * Loot table luck.
			 */
			const LUCK: org.bukkit.potion.PotionEffectType;

			/**
			 * Loot table unluck.
			 */
			const UNLUCK: org.bukkit.potion.PotionEffectType;

			/**
			 * Slows entity fall rate.
			 */
			const SLOW_FALLING: org.bukkit.potion.PotionEffectType;

			/**
			 * Effects granted by a nearby conduit. Includes enhanced underwater abilities.
			 */
			const CONDUIT_POWER: org.bukkit.potion.PotionEffectType;

			/**
			 * Increses underwater movement speed.
			 * Squee'ek uh'k kk'kkkk squeek eee'eek.
			 */
			const DOLPHINS_GRACE: org.bukkit.potion.PotionEffectType;

			/**
			 * Triggers an ominous event when the player enters a village or trial chambers.
			 * oof.
			 */
			const BAD_OMEN: org.bukkit.potion.PotionEffectType;

			/**
			 * Reduces the cost of villager trades.
			 * \o/.
			 */
			const HERO_OF_THE_VILLAGE: org.bukkit.potion.PotionEffectType;

			/**
			 * Causes the player's vision to dim occasionally.
			 */
			const DARKNESS: org.bukkit.potion.PotionEffectType;

			/**
			 * Causes trial spawners to become ominous.
			 */
			const TRIAL_OMEN: org.bukkit.potion.PotionEffectType;

			/**
			 * Triggers a raid when a player enters a village.
			 */
			const RAID_OMEN: org.bukkit.potion.PotionEffectType;

			/**
			 * Emits a wind burst upon death.
			 */
			const WIND_CHARGED: org.bukkit.potion.PotionEffectType;

			/**
			 * Creates cobwebs upon death.
			 */
			const WEAVING: org.bukkit.potion.PotionEffectType;

			/**
			 * Causes slimes to spawn upon death.
			 */
			const OOZING: org.bukkit.potion.PotionEffectType;

			/**
			 * Chance of spawning silverfish when hurt.
			 */
			const INFESTED: org.bukkit.potion.PotionEffectType;

			/**
			 * Gets the PotionEffectType at the specified key
			 */
			function getByKey(key: (org.bukkit.NamespacedKey | null)): (org.bukkit.potion.PotionEffectType | null);

			/**
			 * Gets the effect type specified by the unique id.
			 */
			function getById(id: number): (org.bukkit.potion.PotionEffectType | null);

			/**
			 * Gets the effect type specified by the given name.
			 */
			function getByName(name: string): (org.bukkit.potion.PotionEffectType | null);

		}
		interface PotionEffectTypeCategory {}
		namespace PotionEffectTypeCategory {
			/**
			 * Beneficial effects that positively impact an entity, such as Regeneration,
			 * Absorption, or Fire Resistance.
			 */
			const BENEFICIAL: org.bukkit.potion.PotionEffectTypeCategory;

			/**
			 * Harmful effects that negatively impact an entity, such as Blindness, Wither,
			 * or Levitation.
			 */
			const HARMFUL: org.bukkit.potion.PotionEffectTypeCategory;

			/**
			 * Neutral effects that have neither a positive nor negative effect on an
			 * entity, such as Glowing or Bad Omen.
			 */
			const NEUTRAL: org.bukkit.potion.PotionEffectTypeCategory;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.potion.PotionEffectTypeCategory;

		}
		interface PotionEffectTypeWrapper extends Modify<org.bukkit.potion.PotionEffectType, {
			/**
			 * Get the potion type bound to this wrapper.
			 */
			getType(): org.bukkit.potion.PotionEffectType;

		}> {}
		interface PotionType {
			getEffectType(): (org.bukkit.potion.PotionEffectType | null);

			getPotionEffects(): globalThis.java.util.List<org.bukkit.potion.PotionEffect>;

			isInstant(): boolean;

			/**
			 * Checks if the potion type has an upgraded state.
			 * This refers to whether or not the potion type can be Tier 2,
			 * such as Potion of Fire Resistance II.
			 */
			isUpgradeable(): boolean;

			/**
			 * Checks if the potion type has an extended state.
			 * This refers to the extended duration potions
			 */
			isExtendable(): boolean;

			getMaxLevel(): number;

			/**
			 * Description copied from interface:Â Keyed
			 */
			getKey(): org.bukkit.NamespacedKey;

		}
		namespace PotionType {
			const WATER: org.bukkit.potion.PotionType;

			const MUNDANE: org.bukkit.potion.PotionType;

			const THICK: org.bukkit.potion.PotionType;

			const AWKWARD: org.bukkit.potion.PotionType;

			const NIGHT_VISION: org.bukkit.potion.PotionType;

			const LONG_NIGHT_VISION: org.bukkit.potion.PotionType;

			const INVISIBILITY: org.bukkit.potion.PotionType;

			const LONG_INVISIBILITY: org.bukkit.potion.PotionType;

			const LEAPING: org.bukkit.potion.PotionType;

			const LONG_LEAPING: org.bukkit.potion.PotionType;

			const STRONG_LEAPING: org.bukkit.potion.PotionType;

			const FIRE_RESISTANCE: org.bukkit.potion.PotionType;

			const LONG_FIRE_RESISTANCE: org.bukkit.potion.PotionType;

			const SWIFTNESS: org.bukkit.potion.PotionType;

			const LONG_SWIFTNESS: org.bukkit.potion.PotionType;

			const STRONG_SWIFTNESS: org.bukkit.potion.PotionType;

			const SLOWNESS: org.bukkit.potion.PotionType;

			const LONG_SLOWNESS: org.bukkit.potion.PotionType;

			const STRONG_SLOWNESS: org.bukkit.potion.PotionType;

			const WATER_BREATHING: org.bukkit.potion.PotionType;

			const LONG_WATER_BREATHING: org.bukkit.potion.PotionType;

			const HEALING: org.bukkit.potion.PotionType;

			const STRONG_HEALING: org.bukkit.potion.PotionType;

			const HARMING: org.bukkit.potion.PotionType;

			const STRONG_HARMING: org.bukkit.potion.PotionType;

			const POISON: org.bukkit.potion.PotionType;

			const LONG_POISON: org.bukkit.potion.PotionType;

			const STRONG_POISON: org.bukkit.potion.PotionType;

			const REGENERATION: org.bukkit.potion.PotionType;

			const LONG_REGENERATION: org.bukkit.potion.PotionType;

			const STRONG_REGENERATION: org.bukkit.potion.PotionType;

			const STRENGTH: org.bukkit.potion.PotionType;

			const LONG_STRENGTH: org.bukkit.potion.PotionType;

			const STRONG_STRENGTH: org.bukkit.potion.PotionType;

			const WEAKNESS: org.bukkit.potion.PotionType;

			const LONG_WEAKNESS: org.bukkit.potion.PotionType;

			const LUCK: org.bukkit.potion.PotionType;

			const TURTLE_MASTER: org.bukkit.potion.PotionType;

			const LONG_TURTLE_MASTER: org.bukkit.potion.PotionType;

			const STRONG_TURTLE_MASTER: org.bukkit.potion.PotionType;

			const SLOW_FALLING: org.bukkit.potion.PotionType;

			const LONG_SLOW_FALLING: org.bukkit.potion.PotionType;

			const WIND_CHARGED: org.bukkit.potion.PotionType;

			const WEAVING: org.bukkit.potion.PotionType;

			const OOZING: org.bukkit.potion.PotionType;

			const INFESTED: org.bukkit.potion.PotionType;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.potion.PotionType;

			function getByEffect(effectType: (org.bukkit.potion.PotionEffectType | null)): (org.bukkit.potion.PotionType | null);

		}
		namespace PotionType {
			interface InternalPotionData {
				getEffectType(): org.bukkit.potion.PotionEffectType;

				getPotionEffects(): globalThis.java.util.List<org.bukkit.potion.PotionEffect>;

				isInstant(): boolean;

				isUpgradeable(): boolean;

				isExtendable(): boolean;

				getMaxLevel(): number;

			}
		}
	}
	namespace org.bukkit.ban {
		interface IpBanList extends Modify<org.bukkit.BanList<any /* java.net.InetAddress */>, {}> {}
		interface ProfileBanList extends Modify<org.bukkit.BanList<org.bukkit.profile.PlayerProfile>, {
			/**
			 * Adds a ban to this list. If a previous ban exists, this will
			 * update the previous entry.
			 */
			addBan(target: org.bukkit.profile.PlayerProfile, reason: (string | null), expires: (globalThis.java.util.Date | null), source: (string | null)): (org.bukkit.BanEntry<org.bukkit.profile.PlayerProfile> | null);

		}> {}
	}
	namespace org.bukkit.plugin.java {
		interface JavaPlugin extends Modify<org.bukkit.plugin.PluginBase, {
			/**
			 * Returns the folder that the plugin data's files are located in. The
			 * folder may not yet exist.
			 */
			getDataFolder(): any /* java.io.File */;

			/**
			 * Gets the associated PluginLoader responsible for this plugin
			 */
			getPluginLoader(): org.bukkit.plugin.PluginLoader;

			/**
			 * Returns the Server instance currently running this plugin
			 */
			getServer(): org.bukkit.Server;

			/**
			 * Returns a value indicating whether or not this plugin is currently
			 * enabled
			 */
			isEnabled(): boolean;

			/**
			 * Returns the plugin.yaml file containing the details for this plugin
			 */
			getDescription(): org.bukkit.plugin.PluginDescriptionFile;

			/**
			 * Description copied from interface:Â Plugin
			 */
			getConfig(): org.bukkit.configuration.file.FileConfiguration;

			/**
			 * Description copied from interface:Â Plugin
			 */
			reloadConfig(): void;

			/**
			 * Description copied from interface:Â Plugin
			 */
			saveConfig(): void;

			/**
			 * Description copied from interface:Â Plugin
			 */
			saveDefaultConfig(): void;

			/**
			 * Description copied from interface:Â Plugin
			 */
			saveResource(resourcePath: string, replace: boolean): void;

			/**
			 * Description copied from interface:Â Plugin
			 */
			getResource(filename: string): (any /* java.io.InputStream */ | null);

			/**
			 * Executes the given command, returning its success.
			 * 
			 * If false is returned, then the "usage" plugin.yml entry for this command
			 * (if defined) will be sent to the player.
			 */
			onCommand(sender: org.bukkit.command.CommandSender, command: org.bukkit.command.Command, label: string, args: string[]): boolean;

			/**
			 * Requests a list of possible completions for a command argument.
			 */
			onTabComplete(sender: org.bukkit.command.CommandSender, command: org.bukkit.command.Command, alias: string, args: string[]): (globalThis.java.util.List<string> | null);

			/**
			 * Gets the command with the given name, specific to this plugin. Commands
			 * need to be registered in the PluginDescriptionFile to exist at runtime.
			 */
			getCommand(name: string): (org.bukkit.command.PluginCommand | null);

			/**
			 * Description copied from interface:Â Plugin
			 */
			onLoad(): void;

			/**
			 * Description copied from interface:Â Plugin
			 */
			onDisable(): void;

			/**
			 * Description copied from interface:Â Plugin
			 */
			onEnable(): void;

			/**
			 * Description copied from interface:Â Plugin
			 */
			getDefaultWorldGenerator(worldName: string, id: (string | null)): (org.bukkit.generator.ChunkGenerator | null);

			/**
			 * Description copied from interface:Â Plugin
			 */
			getDefaultBiomeProvider(worldName: string, id: (string | null)): (org.bukkit.generator.BiomeProvider | null);

			/**
			 * Description copied from interface:Â Plugin
			 */
			isNaggable(): boolean;

			/**
			 * Description copied from interface:Â Plugin
			 */
			setNaggable(canNag: boolean): void;

			/**
			 * Description copied from interface:Â Plugin
			 */
			getLogger(): globalThis.java.util.logging.Logger;

			toString(): string;

		}> {}
		class JavaPlugin {
			constructor();

		}
		namespace JavaPlugin {
			/**
			 * This method provides fast access to the plugin that has provided the given plugin class, which is
			 * usually the plugin that implemented it.
			 * 
			 * An exception to this would be if plugin's jar that contained the class
			 * does not extend the class, where the intended plugin would have
			 * resided in a different jar / classloader.
			 */
			function getPlugin<T = any>(clazz: globalThis.java.lang.Class<T>): T;

			/**
			 * This method provides fast access to the plugin that has provided the
			 * given class.
			 */
			function getProvidingPlugin(clazz: globalThis.java.lang.Class): org.bukkit.plugin.java.JavaPlugin;

		}
		interface JavaPluginLoader {
			/**
			 * Description copied from interface:Â PluginLoader
			 */
			loadPlugin(file: any /* java.io.File */): org.bukkit.plugin.Plugin;

			/**
			 * Description copied from interface:Â PluginLoader
			 */
			getPluginDescription(file: any /* java.io.File */): org.bukkit.plugin.PluginDescriptionFile;

			/**
			 * Description copied from interface:Â PluginLoader
			 */
			createRegisteredListeners(listener: org.bukkit.event.Listener, plugin: org.bukkit.plugin.Plugin): globalThis.java.util.Map<globalThis.java.lang.Class<org.bukkit.event.Event>, globalThis.java.util.Set<org.bukkit.plugin.RegisteredListener>>;

			/**
			 * Description copied from interface:Â PluginLoader
			 */
			enablePlugin(plugin: org.bukkit.plugin.Plugin): void;

			/**
			 * Description copied from interface:Â PluginLoader
			 */
			disablePlugin(plugin: org.bukkit.plugin.Plugin): void;

		}
		class JavaPluginLoader {
			/**
			 * This class was not meant to be constructed explicitly
			 */
			constructor(instance: org.bukkit.Server);

		}
		namespace JavaPluginLoader {
			const pluginParentTimer: any /* org.spigotmc.CustomTimingsHandler */;

		}
	}
	namespace org.bukkit.entity.memory {
		interface MemoryKey<T = any> {
			/**
			 * Description copied from interface:Â Keyed
			 */
			getKey(): org.bukkit.NamespacedKey;

			/**
			 * Gets the class of values associated with this memory.
			 */
			getMemoryClass(): globalThis.java.lang.Class<T>;

		}
		namespace MemoryKey {
			const HOME: org.bukkit.entity.memory.MemoryKey<org.bukkit.Location>;

			const POTENTIAL_JOB_SITE: org.bukkit.entity.memory.MemoryKey<org.bukkit.Location>;

			const JOB_SITE: org.bukkit.entity.memory.MemoryKey<org.bukkit.Location>;

			const MEETING_POINT: org.bukkit.entity.memory.MemoryKey<org.bukkit.Location>;

			const GOLEM_DETECTED_RECENTLY: org.bukkit.entity.memory.MemoryKey<boolean>;

			const LAST_SLEPT: org.bukkit.entity.memory.MemoryKey<number>;

			const LAST_WOKEN: org.bukkit.entity.memory.MemoryKey<number>;

			const LAST_WORKED_AT_POI: org.bukkit.entity.memory.MemoryKey<number>;

			const UNIVERSAL_ANGER: org.bukkit.entity.memory.MemoryKey<boolean>;

			const ANGRY_AT: org.bukkit.entity.memory.MemoryKey<globalThis.java.util.UUID>;

			const ADMIRING_ITEM: org.bukkit.entity.memory.MemoryKey<boolean>;

			const ADMIRING_DISABLED: org.bukkit.entity.memory.MemoryKey<boolean>;

			const HUNTED_RECENTLY: org.bukkit.entity.memory.MemoryKey<boolean>;

			const PLAY_DEAD_TICKS: org.bukkit.entity.memory.MemoryKey<number>;

			const TEMPTATION_COOLDOWN_TICKS: org.bukkit.entity.memory.MemoryKey<number>;

			const IS_TEMPTED: org.bukkit.entity.memory.MemoryKey<boolean>;

			const LONG_JUMP_COOLING_DOWN: org.bukkit.entity.memory.MemoryKey<number>;

			const HAS_HUNTING_COOLDOWN: org.bukkit.entity.memory.MemoryKey<boolean>;

			const RAM_COOLDOWN_TICKS: org.bukkit.entity.memory.MemoryKey<number>;

			const LIKED_PLAYER: org.bukkit.entity.memory.MemoryKey<globalThis.java.util.UUID>;

			const LIKED_NOTEBLOCK_POSITION: org.bukkit.entity.memory.MemoryKey<org.bukkit.Location>;

			const LIKED_NOTEBLOCK_COOLDOWN_TICKS: org.bukkit.entity.memory.MemoryKey<number>;

			const ITEM_PICKUP_COOLDOWN_TICKS: org.bukkit.entity.memory.MemoryKey<number>;

			const SNIFFER_EXPLORED_POSITIONS: org.bukkit.entity.memory.MemoryKey<org.bukkit.Location>;

			/**
			 * Returns a MemoryKey by a NamespacedKey.
			 */
			function getByKey(namespacedKey: org.bukkit.NamespacedKey): (org.bukkit.entity.memory.MemoryKey | null);

			/**
			 * Returns the set of all MemoryKeys.
			 */
			function values(): globalThis.java.util.Set<org.bukkit.entity.memory.MemoryKey>;

		}
	}
	namespace org.bukkit.block.structure {
		interface Mirror {}
		namespace Mirror {
			/**
			 * No mirroring.
			 * 
			 * Positive X to Positive Z
			 */
			const NONE: org.bukkit.block.structure.Mirror;

			/**
			 * Structure is mirrored left to right.
			 * 
			 * Similar to looking in a mirror. Positive X to Negative Z
			 */
			const LEFT_RIGHT: org.bukkit.block.structure.Mirror;

			/**
			 * Structure is mirrored front to back.
			 * 
			 * Positive Z to Negative X
			 */
			const FRONT_BACK: org.bukkit.block.structure.Mirror;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.block.structure.Mirror;

		}
		interface StructureRotation {}
		namespace StructureRotation {
			/**
			 * No rotation.
			 */
			const NONE: org.bukkit.block.structure.StructureRotation;

			/**
			 * Rotated clockwise 90 degrees.
			 */
			const CLOCKWISE_90: org.bukkit.block.structure.StructureRotation;

			/**
			 * Rotated clockwise 180 degrees.
			 */
			const CLOCKWISE_180: org.bukkit.block.structure.StructureRotation;

			/**
			 * Rotated counter clockwise 90 degrees.
			 * 
			 * Equivalent to rotating clockwise 270 degrees.
			 */
			const COUNTERCLOCKWISE_90: org.bukkit.block.structure.StructureRotation;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.block.structure.StructureRotation;

		}
		interface UsageMode {}
		namespace UsageMode {
			/**
			 * The mode used when saving a structure.
			 */
			const SAVE: org.bukkit.block.structure.UsageMode;

			/**
			 * The mode used when loading a structure.
			 */
			const LOAD: org.bukkit.block.structure.UsageMode;

			/**
			 * Used when saving a structure for easy size calculation. When using this
			 * mode, the Structure name MUST match the name in the second Structure
			 * block that is in SAVE.
			 */
			const CORNER: org.bukkit.block.structure.UsageMode;

			/**
			 * Used to run specific custom functions, which can only be used for certain
			 * Structures. The structure block is removed after this function completes.
			 * The data tags (functions) can be found on the
			 * wiki.
			 */
			const DATA: org.bukkit.block.structure.UsageMode;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.block.structure.UsageMode;

		}
	}
	namespace org.bukkit.material.types {
		interface MushroomBlockTexture {
			/**
			 * Gets the associated data value representing this mushroom block face.
			 */
			getData(): any /* byte */;

			/**
			 * Gets the face that has cap texture.
			 */
			getCapFace(): (org.bukkit.block.BlockFace | null);

		}
		namespace MushroomBlockTexture {
			/**
			 * Pores on all faces.
			 */
			const ALL_PORES: org.bukkit.material.types.MushroomBlockTexture;

			/**
			 * Cap texture on the top, north and west faces, pores on remaining sides.
			 */
			const CAP_NORTH_WEST: org.bukkit.material.types.MushroomBlockTexture;

			/**
			 * Cap texture on the top and north faces, pores on remaining sides.
			 */
			const CAP_NORTH: org.bukkit.material.types.MushroomBlockTexture;

			/**
			 * Cap texture on the top, north and east faces, pores on remaining sides.
			 */
			const CAP_NORTH_EAST: org.bukkit.material.types.MushroomBlockTexture;

			/**
			 * Cap texture on the top and west faces, pores on remaining sides.
			 */
			const CAP_WEST: org.bukkit.material.types.MushroomBlockTexture;

			/**
			 * Cap texture on the top face, pores on remaining sides.
			 */
			const CAP_TOP: org.bukkit.material.types.MushroomBlockTexture;

			/**
			 * Cap texture on the top and east faces, pores on remaining sides.
			 */
			const CAP_EAST: org.bukkit.material.types.MushroomBlockTexture;

			/**
			 * Cap texture on the top, south and west faces, pores on remaining sides.
			 */
			const CAP_SOUTH_WEST: org.bukkit.material.types.MushroomBlockTexture;

			/**
			 * Cap texture on the top and south faces, pores on remaining sides.
			 */
			const CAP_SOUTH: org.bukkit.material.types.MushroomBlockTexture;

			/**
			 * Cap texture on the top, south and east faces, pores on remaining sides.
			 */
			const CAP_SOUTH_EAST: org.bukkit.material.types.MushroomBlockTexture;

			/**
			 * Stem texture on the north, east, south and west faces, pores on top and
			 * bottom.
			 */
			const STEM_SIDES: org.bukkit.material.types.MushroomBlockTexture;

			/**
			 * Cap texture on all faces.
			 */
			const ALL_CAP: org.bukkit.material.types.MushroomBlockTexture;

			/**
			 * Stem texture on all faces.
			 */
			const ALL_STEM: org.bukkit.material.types.MushroomBlockTexture;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.material.types.MushroomBlockTexture;

			/**
			 * Gets the MushroomBlockType with the given data value.
			 */
			function getByData(data: any /* byte */): (org.bukkit.material.types.MushroomBlockTexture | null);

			/**
			 * Gets the MushroomBlockType with cap texture on the given block face.
			 */
			function getCapByFace(face: (org.bukkit.block.BlockFace | null)): (org.bukkit.material.types.MushroomBlockTexture | null);

		}
	}
	namespace org.bukkit.util.noise {
		interface NoiseGenerator {
			/**
			 * Computes and returns the 1D noise for the given coordinate in 1D space
			 */
			noise(x: number): number;

			/**
			 * Computes and returns the 2D noise for the given coordinates in 2D space
			 */
			noise(x: number, y: number): number;

			/**
			 * Computes and returns the 3D noise for the given coordinates in 3D space
			 */
			noise(x: number, y: number, z: number): number;

			/**
			 * Generates noise for the 1D coordinates using the specified number of
			 * octaves and parameters
			 */
			noise(x: number, octaves: number, frequency: number, amplitude: number): number;

			/**
			 * Generates noise for the 1D coordinates using the specified number of
			 * octaves and parameters
			 */
			noise(x: number, octaves: number, frequency: number, amplitude: number, normalized: boolean): number;

			/**
			 * Generates noise for the 2D coordinates using the specified number of
			 * octaves and parameters
			 */
			noise(x: number, y: number, octaves: number, frequency: number, amplitude: number): number;

			/**
			 * Generates noise for the 2D coordinates using the specified number of
			 * octaves and parameters
			 */
			noise(x: number, y: number, octaves: number, frequency: number, amplitude: number, normalized: boolean): number;

			/**
			 * Generates noise for the 3D coordinates using the specified number of
			 * octaves and parameters
			 */
			noise(x: number, y: number, z: number, octaves: number, frequency: number, amplitude: number): number;

			/**
			 * Generates noise for the 3D coordinates using the specified number of
			 * octaves and parameters
			 */
			noise(x: number, y: number, z: number, octaves: number, frequency: number, amplitude: number, normalized: boolean): number;

		}
		class NoiseGenerator {
			constructor();

		}
		namespace NoiseGenerator {
			/**
			 * Speedy floor, faster than (int)Math.floor(x)
			 */
			function floor(x: number): number;

		}
		interface OctaveGenerator {
			/**
			 * Sets the scale used for all coordinates passed to this generator.
			 * 
			 * This is the equivalent to setting each coordinate to the specified
			 * value.
			 */
			setScale(scale: number): void;

			/**
			 * Gets the scale used for each X-coordinates passed
			 */
			getXScale(): number;

			/**
			 * Sets the scale used for each X-coordinates passed
			 */
			setXScale(scale: number): void;

			/**
			 * Gets the scale used for each Y-coordinates passed
			 */
			getYScale(): number;

			/**
			 * Sets the scale used for each Y-coordinates passed
			 */
			setYScale(scale: number): void;

			/**
			 * Gets the scale used for each Z-coordinates passed
			 */
			getZScale(): number;

			/**
			 * Sets the scale used for each Z-coordinates passed
			 */
			setZScale(scale: number): void;

			/**
			 * Generates noise for the 1D coordinates using the specified number of
			 * octaves and parameters
			 */
			noise(x: number, frequency: number, amplitude: number): number;

			/**
			 * Generates noise for the 1D coordinates using the specified number of
			 * octaves and parameters
			 */
			noise(x: number, frequency: number, amplitude: number, normalized: boolean): number;

			/**
			 * Generates noise for the 2D coordinates using the specified number of
			 * octaves and parameters
			 */
			noise(x: number, y: number, frequency: number, amplitude: number): number;

			/**
			 * Generates noise for the 2D coordinates using the specified number of
			 * octaves and parameters
			 */
			noise(x: number, y: number, frequency: number, amplitude: number, normalized: boolean): number;

			/**
			 * Generates noise for the 3D coordinates using the specified number of
			 * octaves and parameters
			 */
			noise(x: number, y: number, z: number, frequency: number, amplitude: number): number;

			/**
			 * Generates noise for the 3D coordinates using the specified number of
			 * octaves and parameters
			 */
			noise(x: number, y: number, z: number, frequency: number, amplitude: number, normalized: boolean): number;

		}
		interface PerlinNoiseGenerator extends Modify<org.bukkit.util.noise.NoiseGenerator, {
			/**
			 * Description copied from class:Â NoiseGenerator
			 */
			noise(x: number, y: number, z: number): number;

		}> {}
		class PerlinNoiseGenerator {
			/**
			 * Creates a seeded perlin noise generator for the given world
			 */
			constructor(world: org.bukkit.World);

			/**
			 * Creates a seeded perlin noise generator for the given seed
			 */
			constructor(seed: number);

			/**
			 * Creates a seeded perlin noise generator with the given Random
			 */
			constructor(rand: globalThis.java.util.Random);

		}
		namespace PerlinNoiseGenerator {
			/**
			 * Computes and returns the 1D unseeded perlin noise for the given
			 * coordinates in 1D space
			 */
			function getNoise(x: number): number;

			/**
			 * Computes and returns the 2D unseeded perlin noise for the given
			 * coordinates in 2D space
			 */
			function getNoise(x: number, y: number): number;

			/**
			 * Computes and returns the 3D unseeded perlin noise for the given
			 * coordinates in 3D space
			 */
			function getNoise(x: number, y: number, z: number): number;

			/**
			 * Gets the singleton unseeded instance of this generator
			 */
			function getInstance(): org.bukkit.util.noise.PerlinNoiseGenerator;

			/**
			 * Generates noise for the 1D coordinates using the specified number of
			 * octaves and parameters
			 */
			function getNoise(x: number, octaves: number, frequency: number, amplitude: number): number;

			/**
			 * Generates noise for the 2D coordinates using the specified number of
			 * octaves and parameters
			 */
			function getNoise(x: number, y: number, octaves: number, frequency: number, amplitude: number): number;

			/**
			 * Generates noise for the 3D coordinates using the specified number of
			 * octaves and parameters
			 */
			function getNoise(x: number, y: number, z: number, octaves: number, frequency: number, amplitude: number): number;

		}
		interface PerlinOctaveGenerator extends Modify<org.bukkit.util.noise.OctaveGenerator, {
		}> {}
		class PerlinOctaveGenerator {
			/**
			 * Creates a perlin octave generator for the given world
			 */
			constructor(world: org.bukkit.World, octaves: number);

			/**
			 * Creates a perlin octave generator for the given world
			 */
			constructor(seed: number, octaves: number);

			/**
			 * Creates a perlin octave generator for the given Random
			 */
			constructor(rand: globalThis.java.util.Random, octaves: number);

		}
		interface SimplexNoiseGenerator extends Modify<org.bukkit.util.noise.PerlinNoiseGenerator, {
			/**
			 * Description copied from class:Â NoiseGenerator
			 */
			noise(xin: number, yin: number, zin: number): number;

			/**
			 * Description copied from class:Â NoiseGenerator
			 */
			noise(xin: number, yin: number): number;

			/**
			 * Computes and returns the 4D simplex noise for the given coordinates in
			 * 4D space
			 */
			noise(x: number, y: number, z: number, w: number): number;

		}> {}
		class SimplexNoiseGenerator {
			/**
			 * Creates a seeded simplex noise generator for the given world
			 */
			constructor(world: org.bukkit.World);

			/**
			 * Creates a seeded simplex noise generator for the given seed
			 */
			constructor(seed: number);

			/**
			 * Creates a seeded simplex noise generator with the given Random
			 */
			constructor(rand: globalThis.java.util.Random);

		}
		namespace SimplexNoiseGenerator {
			/**
			 * Computes and returns the 1D unseeded simplex noise for the given
			 * coordinates in 1D space
			 */
			function getNoise(xin: number): number;

			/**
			 * Computes and returns the 2D unseeded simplex noise for the given
			 * coordinates in 2D space
			 */
			function getNoise(xin: number, yin: number): number;

			/**
			 * Computes and returns the 3D unseeded simplex noise for the given
			 * coordinates in 3D space
			 */
			function getNoise(xin: number, yin: number, zin: number): number;

			/**
			 * Computes and returns the 4D simplex noise for the given coordinates in
			 * 4D space
			 */
			function getNoise(x: number, y: number, z: number, w: number): number;

			/**
			 * Gets the singleton unseeded instance of this generator
			 */
			function getInstance(): org.bukkit.util.noise.SimplexNoiseGenerator;

		}
		interface SimplexOctaveGenerator extends Modify<org.bukkit.util.noise.OctaveGenerator, {
			/**
			 * Description copied from class:Â OctaveGenerator
			 */
			setScale(scale: number): void;

			/**
			 * Gets the scale used for each W-coordinates passed
			 */
			getWScale(): number;

			/**
			 * Sets the scale used for each W-coordinates passed
			 */
			setWScale(scale: number): void;

			/**
			 * Generates noise for the 3D coordinates using the specified number of
			 * octaves and parameters
			 */
			noise(x: number, y: number, z: number, w: number, frequency: number, amplitude: number): number;

			/**
			 * Generates noise for the 3D coordinates using the specified number of
			 * octaves and parameters
			 */
			noise(x: number, y: number, z: number, w: number, frequency: number, amplitude: number, normalized: boolean): number;

		}> {}
		class SimplexOctaveGenerator {
			/**
			 * Creates a simplex octave generator for the given world
			 */
			constructor(world: org.bukkit.World, octaves: number);

			/**
			 * Creates a simplex octave generator for the given world
			 */
			constructor(seed: number, octaves: number);

			/**
			 * Creates a simplex octave generator for the given Random
			 */
			constructor(rand: globalThis.java.util.Random, octaves: number);

		}
	}
	namespace org.bukkit.structure {
		interface Palette {
			/**
			 * Gets a copy of the blocks this Palette is made of.
			 * The positions of the returned block
			 * states are offsets relative to the structure's position that is provided
			 * once the structure is placed into the world.
			 */
			getBlocks(): globalThis.java.util.List<org.bukkit.block.BlockState>;

			/**
			 * Gets the number of blocks stored in this palette.
			 */
			getBlockCount(): number;

		}
		interface Structure extends Modify<org.bukkit.persistence.PersistentDataHolder, {
			/**
			 * Gets the current size of the structure.
			 * 
			 * The size of the structure may not be fixed.
			 */
			getSize(): org.bukkit.util.BlockVector;

			/**
			 * Gets a list of available block palettes.
			 */
			getPalettes(): globalThis.java.util.List<org.bukkit.structure.Palette>;

			/**
			 * Gets the number of palettes in this structure.
			 */
			getPaletteCount(): number;

			/**
			 * Gets a list of entities that have been included in the Structure.
			 * The entity positions are offsets relative to the structure's position
			 * that is provided once the structure is placed into the world.
			 */
			getEntities(): globalThis.java.util.List<org.bukkit.entity.Entity>;

			/**
			 * Gets the number of entities in this structure.
			 */
			getEntityCount(): number;

			/**
			 * Place a structure in the world.
			 */
			place(location: org.bukkit.Location, includeEntities: boolean, structureRotation: org.bukkit.block.structure.StructureRotation, mirror: org.bukkit.block.structure.Mirror, palette: number, integrity: number, random: globalThis.java.util.Random): void;

			/**
			 * Place a structure in the world.
			 */
			place(location: org.bukkit.Location, includeEntities: boolean, structureRotation: org.bukkit.block.structure.StructureRotation, mirror: org.bukkit.block.structure.Mirror, palette: number, integrity: number, random: globalThis.java.util.Random, blockTransformers: globalThis.java.util.Collection<org.bukkit.util.BlockTransformer>, entityTransformers: globalThis.java.util.Collection<org.bukkit.util.EntityTransformer>): void;

			/**
			 * Place a structure in the world.
			 */
			place(regionAccessor: org.bukkit.RegionAccessor, location: org.bukkit.util.BlockVector, includeEntities: boolean, structureRotation: org.bukkit.block.structure.StructureRotation, mirror: org.bukkit.block.structure.Mirror, palette: number, integrity: number, random: globalThis.java.util.Random): void;

			/**
			 * Place a structure in the world.
			 */
			place(regionAccessor: org.bukkit.RegionAccessor, location: org.bukkit.util.BlockVector, includeEntities: boolean, structureRotation: org.bukkit.block.structure.StructureRotation, mirror: org.bukkit.block.structure.Mirror, palette: number, integrity: number, random: globalThis.java.util.Random, blockTransformers: globalThis.java.util.Collection<org.bukkit.util.BlockTransformer>, entityTransformers: globalThis.java.util.Collection<org.bukkit.util.EntityTransformer>): void;

			/**
			 * Fills the structure from an area in a world. The origin and size will be
			 * calculated automatically from the two corners provided.
			 * 
			 * Be careful as this will override the current data of the structure.
			 * 
			 * Be aware that this method allows for creating structures larger than the
			 * 48x48x48 size that Minecraft's Structure blocks support. Any structures
			 * saved this way can not be loaded by using a structure block. Using the
			 * API however will still work.
			 */
			fill(corner1: org.bukkit.Location, corner2: org.bukkit.Location, includeEntities: boolean): void;

			/**
			 * Fills the Structure from an area in a world, starting at the specified
			 * origin and extending in each axis according to the specified size vector.
			 * 
			 * Be careful as this will override the current data of the structure.
			 * 
			 * Be aware that this method allows for saving structures larger than the
			 * 48x48x48 size that Minecraft's Structure blocks support. Any structures
			 * saved this way can not be loaded by using a structure block. Using the
			 * API however will still work.
			 */
			fill(origin: org.bukkit.Location, size: org.bukkit.util.BlockVector, includeEntities: boolean): void;

		}> {}
		interface StructureManager {
			/**
			 * Gets the currently registered structures.
			 * 
			 * These are the currently loaded structures that the StructureManager is
			 * aware of. When a structure block refers to a structure, these structures
			 * are checked first. If the specified structure is not found among the
			 * currently registered structures, the StructureManager may dynamically
			 * read the structure from the primary world folder, DataPacks, or the
			 * server's own resources. Structures can be registered via registerStructure(NamespacedKey, Structure)
			 */
			getStructures(): globalThis.java.util.Map<org.bukkit.NamespacedKey, org.bukkit.structure.Structure>;

			/**
			 * Gets a registered Structure.
			 */
			getStructure(structureKey: org.bukkit.NamespacedKey): (org.bukkit.structure.Structure | null);

			/**
			 * Registers the given structure. See getStructures().
			 */
			registerStructure(structureKey: org.bukkit.NamespacedKey, structure: org.bukkit.structure.Structure): (org.bukkit.structure.Structure | null);

			/**
			 * Unregisters a structure. Unregisters the specified structure. If the
			 * structure still exists in the primary world folder, a DataPack, or is
			 * part of the server's own resources, it may be loaded and registered again
			 * when it is requested by a plugin or the server itself.
			 */
			unregisterStructure(structureKey: org.bukkit.NamespacedKey): (org.bukkit.structure.Structure | null);

			/**
			 * Loads a structure for the specified key and optionally registers it.
			 * 
			 * This will first check the already loaded registered structures, and otherwise load the structure from the primary
			 * world folder, DataPacks, and the server's own resources (in this order).
			 * 
			 * When loading the structure from the primary world folder, the given key
			 * is translated to a file as specified by
			 * getStructureFile(NamespacedKey).
			 */
			loadStructure(structureKey: org.bukkit.NamespacedKey, register: boolean): (org.bukkit.structure.Structure | null);

			/**
			 * Loads the structure for the specified key and automatically registers it.
			 * See loadStructure(NamespacedKey, boolean).
			 */
			loadStructure(structureKey: org.bukkit.NamespacedKey): (org.bukkit.structure.Structure | null);

			/**
			 * Saves the currently registered structure for the
			 * specified key to the primary world folder as
			 * specified by {#getStructureFile(NamespacedKey}.
			 */
			saveStructure(structureKey: org.bukkit.NamespacedKey): void;

			/**
			 * Saves a structure with a given key to the primary world folder.
			 */
			saveStructure(structureKey: org.bukkit.NamespacedKey, structure: org.bukkit.structure.Structure): void;

			/**
			 * Unregisters the specified structure and deletes its structure file from the primary world
			 * folder. Note that this method cannot be used to delete vanilla Minecraft
			 * structures, or structures from DataPacks. Unregistering these structures
			 * will however work fine.
			 */
			deleteStructure(structureKey: org.bukkit.NamespacedKey): void;

			/**
			 * Deletes the structure file for
			 * the specified structure from the primary world folder. Note that this
			 * method cannot be used to delete vanilla Minecraft structures, or
			 * structures from DataPacks. Unregistering these structures will however
			 * work fine.
			 */
			deleteStructure(structureKey: org.bukkit.NamespacedKey, unregister: boolean): void;

			/**
			 * Gets the location where a structure file would exist in the primary world
			 * directory based on the NamespacedKey using the format
			 * world/generated/{NAMESPACE}/structures/{KEY}.nbt. This method will always
			 * return a file, even if none exists at the moment.
			 */
			getStructureFile(structureKey: org.bukkit.NamespacedKey): any /* java.io.File */;

			/**
			 * Reads a Structure from disk.
			 */
			loadStructure(file: any /* java.io.File */): org.bukkit.structure.Structure;

			/**
			 * Reads a Structure from a stream.
			 */
			loadStructure(inputStream: any /* java.io.InputStream */): org.bukkit.structure.Structure;

			/**
			 * Save a structure to a file. This will overwrite a file if it already
			 * exists.
			 */
			saveStructure(file: any /* java.io.File */, structure: org.bukkit.structure.Structure): void;

			/**
			 * Save a structure to a stream.
			 */
			saveStructure(outputStream: any /* java.io.OutputStream */, structure: org.bukkit.structure.Structure): void;

			/**
			 * Creates a new empty structure.
			 */
			createStructure(): org.bukkit.structure.Structure;

			/**
			 * Creates a copy of this structure.
			 */
			copy(structure: org.bukkit.structure.Structure): org.bukkit.structure.Structure;

		}
	}
	namespace org.bukkit.block.banner {
		interface Pattern {
			/**
			 * Description copied from interface:Â ConfigurationSerializable
			 */
			serialize(): globalThis.java.util.Map<string, any>;

			/**
			 * Returns the color of the pattern
			 */
			getColor(): org.bukkit.DyeColor;

			/**
			 * Returns the type of pattern
			 */
			getPattern(): org.bukkit.block.banner.PatternType;

			hashCode(): number;

			equals(obj: any): boolean;

		}
		class Pattern {
			/**
			 * Creates a new pattern from the specified color and
			 * pattern type
			 */
			constructor(color: org.bukkit.DyeColor, pattern: org.bukkit.block.banner.PatternType);

			/**
			 * Constructor for deserialization.
			 */
			constructor(map: globalThis.java.util.Map<string, any>);

		}
		interface PatternType {
			/**
			 * Description copied from interface:Â Keyed
			 */
			getKey(): org.bukkit.NamespacedKey;

			/**
			 * Returns the identifier used to represent
			 * this pattern type
			 */
			getIdentifier(): string;

		}
		namespace PatternType {
			const BASE: org.bukkit.block.banner.PatternType;

			const SQUARE_BOTTOM_LEFT: org.bukkit.block.banner.PatternType;

			const SQUARE_BOTTOM_RIGHT: org.bukkit.block.banner.PatternType;

			const SQUARE_TOP_LEFT: org.bukkit.block.banner.PatternType;

			const SQUARE_TOP_RIGHT: org.bukkit.block.banner.PatternType;

			const STRIPE_BOTTOM: org.bukkit.block.banner.PatternType;

			const STRIPE_TOP: org.bukkit.block.banner.PatternType;

			const STRIPE_LEFT: org.bukkit.block.banner.PatternType;

			const STRIPE_RIGHT: org.bukkit.block.banner.PatternType;

			const STRIPE_CENTER: org.bukkit.block.banner.PatternType;

			const STRIPE_MIDDLE: org.bukkit.block.banner.PatternType;

			const STRIPE_DOWNRIGHT: org.bukkit.block.banner.PatternType;

			const STRIPE_DOWNLEFT: org.bukkit.block.banner.PatternType;

			const SMALL_STRIPES: org.bukkit.block.banner.PatternType;

			const CROSS: org.bukkit.block.banner.PatternType;

			const STRAIGHT_CROSS: org.bukkit.block.banner.PatternType;

			const TRIANGLE_BOTTOM: org.bukkit.block.banner.PatternType;

			const TRIANGLE_TOP: org.bukkit.block.banner.PatternType;

			const TRIANGLES_BOTTOM: org.bukkit.block.banner.PatternType;

			const TRIANGLES_TOP: org.bukkit.block.banner.PatternType;

			const DIAGONAL_LEFT: org.bukkit.block.banner.PatternType;

			const DIAGONAL_UP_RIGHT: org.bukkit.block.banner.PatternType;

			const DIAGONAL_UP_LEFT: org.bukkit.block.banner.PatternType;

			const DIAGONAL_RIGHT: org.bukkit.block.banner.PatternType;

			const CIRCLE: org.bukkit.block.banner.PatternType;

			const RHOMBUS: org.bukkit.block.banner.PatternType;

			const HALF_VERTICAL: org.bukkit.block.banner.PatternType;

			const HALF_HORIZONTAL: org.bukkit.block.banner.PatternType;

			const HALF_VERTICAL_RIGHT: org.bukkit.block.banner.PatternType;

			const HALF_HORIZONTAL_BOTTOM: org.bukkit.block.banner.PatternType;

			const BORDER: org.bukkit.block.banner.PatternType;

			const CURLY_BORDER: org.bukkit.block.banner.PatternType;

			const CREEPER: org.bukkit.block.banner.PatternType;

			const GRADIENT: org.bukkit.block.banner.PatternType;

			const GRADIENT_UP: org.bukkit.block.banner.PatternType;

			const BRICKS: org.bukkit.block.banner.PatternType;

			const SKULL: org.bukkit.block.banner.PatternType;

			const FLOWER: org.bukkit.block.banner.PatternType;

			const MOJANG: org.bukkit.block.banner.PatternType;

			const GLOBE: org.bukkit.block.banner.PatternType;

			const PIGLIN: org.bukkit.block.banner.PatternType;

			const FLOW: org.bukkit.block.banner.PatternType;

			const GUSTER: org.bukkit.block.banner.PatternType;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.block.banner.PatternType;

			/**
			 * Returns the pattern type which matches the passed
			 * identifier or null if no matches are found
			 */
			function getByIdentifier(identifier: (string | null)): (org.bukkit.block.banner.PatternType | null);

		}
	}
	namespace org.bukkit.permissions {
		interface Permissible extends Modify<org.bukkit.permissions.ServerOperator, {
			/**
			 * Checks if this object contains an override for the specified
			 * permission, by fully qualified name
			 */
			isPermissionSet(name: string): boolean;

			/**
			 * Checks if this object contains an override for the specified Permission
			 */
			isPermissionSet(perm: org.bukkit.permissions.Permission): boolean;

			/**
			 * Gets the value of the specified permission, if set.
			 * 
			 * If a permission override is not set on this object, the default value
			 * of the permission will be returned.
			 */
			hasPermission(name: string): boolean;

			/**
			 * Gets the value of the specified permission, if set.
			 * 
			 * If a permission override is not set on this object, the default value
			 * of the permission will be returned
			 */
			hasPermission(perm: org.bukkit.permissions.Permission): boolean;

			/**
			 * Adds a new PermissionAttachment with a single permission by
			 * name and value
			 */
			addAttachment(plugin: org.bukkit.plugin.Plugin, name: string, value: boolean): org.bukkit.permissions.PermissionAttachment;

			/**
			 * Adds a new empty PermissionAttachment to this object
			 */
			addAttachment(plugin: org.bukkit.plugin.Plugin): org.bukkit.permissions.PermissionAttachment;

			/**
			 * Temporarily adds a new PermissionAttachment with a single
			 * permission by name and value
			 */
			addAttachment(plugin: org.bukkit.plugin.Plugin, name: string, value: boolean, ticks: number): (org.bukkit.permissions.PermissionAttachment | null);

			/**
			 * Temporarily adds a new empty PermissionAttachment to this
			 * object
			 */
			addAttachment(plugin: org.bukkit.plugin.Plugin, ticks: number): (org.bukkit.permissions.PermissionAttachment | null);

			/**
			 * Removes the given PermissionAttachment from this object
			 */
			removeAttachment(attachment: org.bukkit.permissions.PermissionAttachment): void;

			/**
			 * Recalculates the permissions for this object, if the attachments have
			 * changed values.
			 * 
			 * This should very rarely need to be called from a plugin.
			 */
			recalculatePermissions(): void;

			/**
			 * Gets a set containing all of the permissions currently in effect by
			 * this object
			 */
			getEffectivePermissions(): globalThis.java.util.Set<org.bukkit.permissions.PermissionAttachmentInfo>;

		}> {}
		interface PermissibleBase {
			/**
			 * Description copied from interface:Â ServerOperator
			 */
			isOp(): boolean;

			/**
			 * Description copied from interface:Â ServerOperator
			 */
			setOp(value: boolean): void;

			/**
			 * Description copied from interface:Â Permissible
			 */
			isPermissionSet(name: string): boolean;

			/**
			 * Description copied from interface:Â Permissible
			 */
			isPermissionSet(perm: org.bukkit.permissions.Permission): boolean;

			/**
			 * Description copied from interface:Â Permissible
			 */
			hasPermission(inName: string): boolean;

			/**
			 * Description copied from interface:Â Permissible
			 */
			hasPermission(perm: org.bukkit.permissions.Permission): boolean;

			/**
			 * Description copied from interface:Â Permissible
			 */
			addAttachment(plugin: org.bukkit.plugin.Plugin, name: string, value: boolean): org.bukkit.permissions.PermissionAttachment;

			/**
			 * Description copied from interface:Â Permissible
			 */
			addAttachment(plugin: org.bukkit.plugin.Plugin): org.bukkit.permissions.PermissionAttachment;

			/**
			 * Description copied from interface:Â Permissible
			 */
			removeAttachment(attachment: org.bukkit.permissions.PermissionAttachment): void;

			/**
			 * Description copied from interface:Â Permissible
			 */
			recalculatePermissions(): void;

			clearPermissions(): void;

			/**
			 * Description copied from interface:Â Permissible
			 */
			addAttachment(plugin: org.bukkit.plugin.Plugin, name: string, value: boolean, ticks: number): (org.bukkit.permissions.PermissionAttachment | null);

			/**
			 * Description copied from interface:Â Permissible
			 */
			addAttachment(plugin: org.bukkit.plugin.Plugin, ticks: number): (org.bukkit.permissions.PermissionAttachment | null);

			/**
			 * Description copied from interface:Â Permissible
			 */
			getEffectivePermissions(): globalThis.java.util.Set<org.bukkit.permissions.PermissionAttachmentInfo>;

		}
		class PermissibleBase {
			constructor(opable: (org.bukkit.permissions.ServerOperator | null));

		}
		interface Permission {
			/**
			 * Returns the unique fully qualified name of this Permission
			 */
			getName(): string;

			/**
			 * Gets the children of this permission.
			 * 
			 * If you change this map in any form, you must call recalculatePermissibles() to recalculate all Permissibles
			 */
			getChildren(): globalThis.java.util.Map<string, boolean>;

			/**
			 * Gets the default value of this permission.
			 */
			getDefault(): org.bukkit.permissions.PermissionDefault;

			/**
			 * Sets the default value of this permission.
			 * 
			 * This will not be saved to disk, and is a temporary operation until the
			 * server reloads permissions. Changing this default will cause all Permissibles that contain this permission to recalculate their
			 * permissions
			 */
			setDefault(value: org.bukkit.permissions.PermissionDefault): void;

			/**
			 * Gets a brief description of this permission, may be empty
			 */
			getDescription(): string;

			/**
			 * Sets the description of this permission.
			 * 
			 * This will not be saved to disk, and is a temporary operation until the
			 * server reloads permissions.
			 */
			setDescription(value: (string | null)): void;

			/**
			 * Gets a set containing every Permissible that has this
			 * permission.
			 * 
			 * This set cannot be modified.
			 */
			getPermissibles(): globalThis.java.util.Set<org.bukkit.permissions.Permissible>;

			/**
			 * Recalculates all Permissibles that contain this permission.
			 * 
			 * This should be called after modifying the children, and is
			 * automatically called after modifying the default value
			 */
			recalculatePermissibles(): void;

			/**
			 * Adds this permission to the specified parent permission.
			 * 
			 * If the parent permission does not exist, it will be created and
			 * registered.
			 */
			addParent(name: string, value: boolean): org.bukkit.permissions.Permission;

			/**
			 * Adds this permission to the specified parent permission.
			 */
			addParent(perm: org.bukkit.permissions.Permission, value: boolean): void;

		}
		class Permission {
			constructor(name: string);

			constructor(name: string, description: (string | null));

			constructor(name: string, defaultValue: (org.bukkit.permissions.PermissionDefault | null));

			constructor(name: string, description: (string | null), defaultValue: (org.bukkit.permissions.PermissionDefault | null));

			constructor(name: string, children: (globalThis.java.util.Map<string, boolean> | null));

			constructor(name: string, description: (string | null), children: (globalThis.java.util.Map<string, boolean> | null));

			constructor(name: string, defaultValue: (org.bukkit.permissions.PermissionDefault | null), children: (globalThis.java.util.Map<string, boolean> | null));

			constructor(name: string, description: (string | null), defaultValue: (org.bukkit.permissions.PermissionDefault | null), children: (globalThis.java.util.Map<string, boolean> | null));

		}
		namespace Permission {
			const DEFAULT_PERMISSION: org.bukkit.permissions.PermissionDefault;

			/**
			 * Loads a list of Permissions from a map of data, usually used from
			 * retrieval from a yaml file.
			 * 
			 * The data may contain a list of name:data, where the data contains the
			 * following keys:
			 * 
			 * default: Boolean true or false. If not specified, false.
			 * children: Map<String, Boolean> of child permissions. If not
			 * specified, empty list.
			 * description: Short string containing a very small description of
			 * this description. If not specified, empty string.
			 * 
			 */
			function loadPermissions(data: globalThis.java.util.Map, error: string, def: (org.bukkit.permissions.PermissionDefault | null)): globalThis.java.util.List<org.bukkit.permissions.Permission>;

			/**
			 * Loads a Permission from a map of data, usually used from retrieval from
			 * a yaml file.
			 * 
			 * The data may contain the following keys:
			 * 
			 * default: Boolean true or false. If not specified, false.
			 * children: Map<String, Boolean> of child permissions. If not
			 * specified, empty list.
			 * description: Short string containing a very small description of
			 * this description. If not specified, empty string.
			 * 
			 */
			function loadPermission(name: string, data: globalThis.java.util.Map<string, any>): org.bukkit.permissions.Permission;

			/**
			 * Loads a Permission from a map of data, usually used from retrieval from
			 * a yaml file.
			 * 
			 * The data may contain the following keys:
			 * 
			 * default: Boolean true or false. If not specified, false.
			 * children: Map<String, Boolean> of child permissions. If not
			 * specified, empty list.
			 * description: Short string containing a very small description of
			 * this description. If not specified, empty string.
			 * 
			 */
			function loadPermission(name: string, data: globalThis.java.util.Map, def: (org.bukkit.permissions.PermissionDefault | null), output: (globalThis.java.util.List<org.bukkit.permissions.Permission> | null)): org.bukkit.permissions.Permission;

		}
		interface PermissionAttachment {
			/**
			 * Gets the plugin responsible for this attachment
			 */
			getPlugin(): org.bukkit.plugin.Plugin;

			/**
			 * Sets an object to be called for when this attachment is removed from a
			 * Permissible. May be null.
			 */
			setRemovalCallback(ex: (org.bukkit.permissions.PermissionRemovedExecutor | null)): void;

			/**
			 * Gets the class that was previously set to be called when this
			 * attachment was removed from a Permissible. May be null.
			 */
			getRemovalCallback(): (org.bukkit.permissions.PermissionRemovedExecutor | null);

			/**
			 * Gets the Permissible that this is attached to
			 */
			getPermissible(): org.bukkit.permissions.Permissible;

			/**
			 * Gets a copy of all set permissions and values contained within this
			 * attachment.
			 * 
			 * This map may be modified but will not affect the attachment, as it is a
			 * copy.
			 */
			getPermissions(): globalThis.java.util.Map<string, boolean>;

			/**
			 * Sets a permission to the given value, by its fully qualified name
			 */
			setPermission(name: string, value: boolean): void;

			/**
			 * Sets a permission to the given value
			 */
			setPermission(perm: org.bukkit.permissions.Permission, value: boolean): void;

			/**
			 * Removes the specified permission from this attachment.
			 * 
			 * If the permission does not exist in this attachment, nothing will
			 * happen.
			 */
			unsetPermission(name: string): void;

			/**
			 * Removes the specified permission from this attachment.
			 * 
			 * If the permission does not exist in this attachment, nothing will
			 * happen.
			 */
			unsetPermission(perm: org.bukkit.permissions.Permission): void;

			/**
			 * Removes this attachment from its registered Permissible
			 */
			remove(): boolean;

		}
		class PermissionAttachment {
			constructor(plugin: org.bukkit.plugin.Plugin, permissible: org.bukkit.permissions.Permissible);

		}
		interface PermissionAttachmentInfo {
			/**
			 * Gets the permissible this is attached to
			 */
			getPermissible(): org.bukkit.permissions.Permissible;

			/**
			 * Gets the permission being set
			 */
			getPermission(): string;

			/**
			 * Gets the attachment providing this permission. This may be null for
			 * default permissions (usually parent permissions).
			 */
			getAttachment(): (org.bukkit.permissions.PermissionAttachment | null);

			/**
			 * Gets the value of this permission
			 */
			getValue(): boolean;

		}
		class PermissionAttachmentInfo {
			constructor(permissible: org.bukkit.permissions.Permissible, permission: string, attachment: (org.bukkit.permissions.PermissionAttachment | null), value: boolean);

		}
		interface PermissionDefault {
			/**
			 * Calculates the value of this PermissionDefault for the given operator
			 * value
			 */
			getValue(op: boolean): boolean;

			toString(): string;

		}
		namespace PermissionDefault {
			const TRUE: org.bukkit.permissions.PermissionDefault;

			const FALSE: org.bukkit.permissions.PermissionDefault;

			const OP: org.bukkit.permissions.PermissionDefault;

			const NOT_OP: org.bukkit.permissions.PermissionDefault;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.permissions.PermissionDefault;

			/**
			 * Looks up a PermissionDefault by name
			 */
			function getByName(name: string): (org.bukkit.permissions.PermissionDefault | null);

		}
		interface PermissionRemovedExecutor {
			/**
			 * Called when a PermissionAttachment is removed from a Permissible
			 */
			attachmentRemoved(attachment: org.bukkit.permissions.PermissionAttachment): void;

		}
		interface ServerOperator {
			/**
			 * Checks if this object is a server operator
			 */
			isOp(): boolean;

			/**
			 * Sets the operator status of this object
			 */
			setOp(value: boolean): void;

		}
	}
	namespace org.bukkit.profile {
		interface PlayerProfile extends Modify<org.bukkit.configuration.serialization.ConfigurationSerializable, {
			/**
			 * Gets the player's unique id.
			 */
			getUniqueId(): (globalThis.java.util.UUID | null);

			/**
			 * Gets the player name.
			 */
			getName(): (string | null);

			/**
			 * Gets the PlayerTextures of this profile.
			 */
			getTextures(): org.bukkit.profile.PlayerTextures;

			/**
			 * Copies the given textures.
			 */
			setTextures(textures: (org.bukkit.profile.PlayerTextures | null)): void;

			/**
			 * Checks whether this profile is complete.
			 * 
			 * A profile is currently considered complete if it has a name, a unique id,
			 * and textures.
			 */
			isComplete(): boolean;

			/**
			 * Produces an updated player profile based on this profile.
			 * 
			 * This tries to produce a completed profile by filling in missing
			 * properties (name, unique id, textures, etc.), and updates existing
			 * properties (e.g. name, textures, etc.) to their official and up-to-date
			 * values. This operation does not alter the current profile, but produces a
			 * new updated PlayerProfile.
			 * 
			 * If no player exists for the unique id or name of this profile, this
			 * operation yields a profile that is equal to the current profile, which
			 * might not be complete.
			 * 
			 * This is an asynchronous operation: Updating the profile can result in an
			 * outgoing connection in another thread in order to fetch the latest
			 * profile properties. The returned CompletableFuture will be
			 * completed once the updated profile is available. In order to not block
			 * the server's main thread, you should not wait for the result of the
			 * returned CompletableFuture on the server's main thread. Instead, if you
			 * want to do something with the updated player profile on the server's main
			 * thread once it is available, you could do something like this:
			 * profile.update().thenAcceptAsync(updatedProfile -> {
			 * // Do something with the updated profile:
			 * // ...
			 * }, runnable -> Bukkit.getScheduler().runTask(plugin, runnable));
			 * 
			 */
			update(): globalThis.java.util.concurrent.CompletableFuture<org.bukkit.profile.PlayerProfile>;

			clone(): org.bukkit.profile.PlayerProfile;

		}> {}
		interface PlayerTextures {
			/**
			 * Checks if the profile stores no textures.
			 */
			isEmpty(): boolean;

			/**
			 * Clears the textures.
			 */
			clear(): void;

			/**
			 * Gets the URL that points to the player's skin.
			 */
			getSkin(): (any /* java.net.URL */ | null);

			/**
			 * Sets the player's skin to the specified URL, and the skin model to
			 * PlayerTextures.SkinModel.CLASSIC.
			 * 
			 * The URL must point to the Minecraft texture server. Example URL:
			 * http://textures.minecraft.net/texture/b3fbd454b599df593f57101bfca34e67d292a8861213d2202bb575da7fd091ac
			 * 
			 */
			setSkin(skinUrl: (any /* java.net.URL */ | null)): void;

			/**
			 * Sets the player's skin and PlayerTextures.SkinModel.
			 * 
			 * The URL must point to the Minecraft texture server. Example URL:
			 * http://textures.minecraft.net/texture/b3fbd454b599df593f57101bfca34e67d292a8861213d2202bb575da7fd091ac
			 * 
			 * 
			 * A skin model of null results in PlayerTextures.SkinModel.CLASSIC to
			 * be used.
			 */
			setSkin(skinUrl: (any /* java.net.URL */ | null), skinModel: (org.bukkit.profile.PlayerTextures.SkinModel | null)): void;

			/**
			 * Gets the model of the player's skin.
			 * 
			 * This returns PlayerTextures.SkinModel.CLASSIC if no skin is set.
			 */
			getSkinModel(): org.bukkit.profile.PlayerTextures.SkinModel;

			/**
			 * Gets the URL that points to the player's cape.
			 */
			getCape(): (any /* java.net.URL */ | null);

			/**
			 * Sets the URL that points to the player's cape.
			 * 
			 * The URL must point to the Minecraft texture server. Example URL:
			 * http://textures.minecraft.net/texture/2340c0e03dd24a11b15a8b33c2a7e9e32abb2051b2481d0ba7defd635ca7a933
			 * 
			 */
			setCape(capeUrl: (any /* java.net.URL */ | null)): void;

			/**
			 * Gets the timestamp at which the profile was last updated.
			 */
			getTimestamp(): number;

			/**
			 * Checks if the textures are signed and the signature is valid.
			 */
			isSigned(): boolean;

		}
		namespace PlayerTextures {
			interface SkinModel {}
			namespace SkinModel {
				/**
				 * The classic Minecraft skin model.
				 */
				const CLASSIC: org.bukkit.profile.PlayerTextures.SkinModel;

				/**
				 * The slim model has slimmer arms than the classic model.
				 */
				const SLIM: org.bukkit.profile.PlayerTextures.SkinModel;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.profile.PlayerTextures.SkinModel;

			}
		}
	}
	namespace org.bukkit.event.raid {
		interface RaidEvent extends Modify<org.bukkit.event.world.WorldEvent, {
			/**
			 * Returns the raid involved with this event.
			 */
			getRaid(): org.bukkit.Raid;

		}> {}
		interface RaidFinishEvent extends Modify<org.bukkit.event.raid.RaidEvent, {
			/**
			 * Returns an immutable list contains all winners.
			 * 
			 * Note: Players who are considered as heroes but were not online at the
			 * end would not be included in this list.
			 */
			getWinners(): globalThis.java.util.List<org.bukkit.entity.Player>;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class RaidFinishEvent {
			constructor(raid: org.bukkit.Raid, world: org.bukkit.World, winners: globalThis.java.util.List<org.bukkit.entity.Player>);

		}
		namespace RaidFinishEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface RaidSpawnWaveEvent extends Modify<org.bukkit.event.raid.RaidEvent, {
			/**
			 * Returns the patrol leader.
			 */
			getPatrolLeader(): (org.bukkit.entity.Raider | null);

			/**
			 * Returns all Raider that spawned in this wave.
			 */
			getRaiders(): globalThis.java.util.List<org.bukkit.entity.Raider>;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class RaidSpawnWaveEvent {
			constructor(raid: org.bukkit.Raid, world: org.bukkit.World, leader: (org.bukkit.entity.Raider | null), raiders: globalThis.java.util.List<org.bukkit.entity.Raider>);

		}
		namespace RaidSpawnWaveEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface RaidStopEvent extends Modify<org.bukkit.event.raid.RaidEvent, {
			/**
			 * Returns the stop reason.
			 */
			getReason(): org.bukkit.event.raid.RaidStopEvent.Reason;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class RaidStopEvent {
			constructor(raid: org.bukkit.Raid, world: org.bukkit.World, reason: org.bukkit.event.raid.RaidStopEvent.Reason);

		}
		namespace RaidStopEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		namespace RaidStopEvent {
			interface Reason {}
			namespace Reason {
				/**
				 * Because the difficulty has been changed to peaceful.
				 */
				const PEACE: org.bukkit.event.raid.RaidStopEvent.Reason;

				/**
				 * The raid took a long time without a final result.
				 */
				const TIMEOUT: org.bukkit.event.raid.RaidStopEvent.Reason;

				/**
				 * Finished the raid.
				 */
				const FINISHED: org.bukkit.event.raid.RaidStopEvent.Reason;

				/**
				 * Couldn't find a suitable place to spawn raiders.
				 */
				const UNSPAWNABLE: org.bukkit.event.raid.RaidStopEvent.Reason;

				/**
				 * The place where the raid occurs no longer be a village.
				 */
				const NOT_IN_VILLAGE: org.bukkit.event.raid.RaidStopEvent.Reason;

				/**
				 * Returns the enum constant of this class with the specified name.
				 * The string must match exactly an identifier used to declare an
				 * enum constant in this class. (Extraneous whitespace characters are
				 * not permitted.)
				 */
				function valueOf(name: string): org.bukkit.event.raid.RaidStopEvent.Reason;

			}
		}
		interface RaidTriggerEvent extends Modify<org.bukkit.event.raid.RaidEvent, {
			/**
			 * Returns the player who triggered the raid.
			 */
			getPlayer(): org.bukkit.entity.Player;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class RaidTriggerEvent {
			constructor(raid: org.bukkit.Raid, world: org.bukkit.World, player: org.bukkit.entity.Player);

		}
		namespace RaidTriggerEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
	}
	namespace org.bukkit.block.sign {
		interface Side {}
		namespace Side {
			const FRONT: org.bukkit.block.sign.Side;

			const BACK: org.bukkit.block.sign.Side;

			/**
			 * Returns the enum constant of this class with the specified name.
			 * The string must match exactly an identifier used to declare an
			 * enum constant in this class. (Extraneous whitespace characters are
			 * not permitted.)
			 */
			function valueOf(name: string): org.bukkit.block.sign.Side;

		}
		interface SignSide extends Modify<org.bukkit.material.Colorable, {
			/**
			 * Gets the line of text at the specified index on this side of the sign.
			 * 
			 * For example, getLine(0) will return the first line of text.
			 */
			getLine(index: number): string;

			/**
			 * Sets the line of text at the specified index on this side of the sign.
			 * 
			 * For example, setLine(0, "Line One") will set the first line of text to
			 * "Line One".
			 */
			setLine(index: number, line: string): void;

			/**
			 * Gets whether this side of the sign has glowing text.
			 */
			isGlowingText(): boolean;

			/**
			 * Sets whether this side of the sign has glowing text.
			 */
			setGlowingText(glowing: boolean): void;

		}> {}
	}
	namespace org.bukkit.event.vehicle {
		interface VehicleBlockCollisionEvent extends Modify<org.bukkit.event.vehicle.VehicleCollisionEvent, {
			/**
			 * Gets the block the vehicle collided with
			 */
			getBlock(): org.bukkit.block.Block;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class VehicleBlockCollisionEvent {
			constructor(vehicle: org.bukkit.entity.Vehicle, block: org.bukkit.block.Block);

		}
		namespace VehicleBlockCollisionEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface VehicleCollisionEvent extends Modify<org.bukkit.event.vehicle.VehicleEvent, {
		}> {}
		class VehicleCollisionEvent {
			constructor(vehicle: org.bukkit.entity.Vehicle);

		}
		interface VehicleCreateEvent extends Modify<org.bukkit.event.vehicle.VehicleEvent, {
			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancelled: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class VehicleCreateEvent {
			constructor(vehicle: org.bukkit.entity.Vehicle);

		}
		namespace VehicleCreateEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface VehicleDamageEvent extends Modify<org.bukkit.event.vehicle.VehicleEvent, {
			/**
			 * Gets the Entity that is attacking the vehicle
			 */
			getAttacker(): (org.bukkit.entity.Entity | null);

			/**
			 * Gets the damage done to the vehicle
			 */
			getDamage(): number;

			/**
			 * Sets the damage done to the vehicle
			 */
			setDamage(damage: number): void;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class VehicleDamageEvent {
			constructor(vehicle: org.bukkit.entity.Vehicle, attacker: (org.bukkit.entity.Entity | null), damage: number);

		}
		namespace VehicleDamageEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface VehicleDestroyEvent extends Modify<org.bukkit.event.vehicle.VehicleEvent, {
			/**
			 * Gets the Entity that has destroyed the vehicle, potentially null
			 */
			getAttacker(): (org.bukkit.entity.Entity | null);

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class VehicleDestroyEvent {
			constructor(vehicle: org.bukkit.entity.Vehicle, attacker: (org.bukkit.entity.Entity | null));

		}
		namespace VehicleDestroyEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface VehicleEnterEvent extends Modify<org.bukkit.event.vehicle.VehicleEvent, {
			/**
			 * Gets the Entity that entered the vehicle.
			 */
			getEntered(): org.bukkit.entity.Entity;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class VehicleEnterEvent {
			constructor(vehicle: org.bukkit.entity.Vehicle, entered: org.bukkit.entity.Entity);

		}
		namespace VehicleEnterEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface VehicleEntityCollisionEvent extends Modify<org.bukkit.event.vehicle.VehicleCollisionEvent, {
			getEntity(): org.bukkit.entity.Entity;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			isPickupCancelled(): boolean;

			setPickupCancelled(cancel: boolean): void;

			isCollisionCancelled(): boolean;

			setCollisionCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class VehicleEntityCollisionEvent {
			constructor(vehicle: org.bukkit.entity.Vehicle, entity: org.bukkit.entity.Entity);

		}
		namespace VehicleEntityCollisionEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface VehicleEvent extends Modify<org.bukkit.event.Event, {
			/**
			 * Get the vehicle.
			 */
			getVehicle(): org.bukkit.entity.Vehicle;

		}> {}
		class VehicleEvent {
			constructor(vehicle: org.bukkit.entity.Vehicle);

		}
		interface VehicleExitEvent extends Modify<org.bukkit.event.vehicle.VehicleEvent, {
			/**
			 * Get the living entity that exited the vehicle.
			 */
			getExited(): org.bukkit.entity.LivingEntity;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			isCancelled(): boolean;

			/**
			 * Description copied from interface:Â Cancellable
			 */
			setCancelled(cancel: boolean): void;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class VehicleExitEvent {
			constructor(vehicle: org.bukkit.entity.Vehicle, exited: org.bukkit.entity.LivingEntity);

		}
		namespace VehicleExitEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface VehicleMoveEvent extends Modify<org.bukkit.event.vehicle.VehicleEvent, {
			/**
			 * Get the previous position.
			 */
			getFrom(): org.bukkit.Location;

			/**
			 * Get the next position.
			 */
			getTo(): org.bukkit.Location;

			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class VehicleMoveEvent {
			constructor(vehicle: org.bukkit.entity.Vehicle, from: org.bukkit.Location, to: org.bukkit.Location);

		}
		namespace VehicleMoveEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
		interface VehicleUpdateEvent extends Modify<org.bukkit.event.vehicle.VehicleEvent, {
			getHandlers(): org.bukkit.event.HandlerList;

		}> {}
		class VehicleUpdateEvent {
			constructor(vehicle: org.bukkit.entity.Vehicle);

		}
		namespace VehicleUpdateEvent {
			function getHandlerList(): org.bukkit.event.HandlerList;

		}
	}
}